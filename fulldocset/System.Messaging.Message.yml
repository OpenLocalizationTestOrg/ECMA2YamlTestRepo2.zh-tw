### YamlMime:ManagedReference
items:
- uid: System.Messaging.Message
  id: Message
  children:
  - System.Messaging.Message.#ctor
  - System.Messaging.Message.#ctor(System.Object)
  - System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  - System.Messaging.Message.AcknowledgeType
  - System.Messaging.Message.Acknowledgment
  - System.Messaging.Message.AdministrationQueue
  - System.Messaging.Message.AppSpecific
  - System.Messaging.Message.ArrivedTime
  - System.Messaging.Message.AttachSenderId
  - System.Messaging.Message.Authenticated
  - System.Messaging.Message.AuthenticationProviderName
  - System.Messaging.Message.AuthenticationProviderType
  - System.Messaging.Message.Body
  - System.Messaging.Message.BodyStream
  - System.Messaging.Message.BodyType
  - System.Messaging.Message.ConnectorType
  - System.Messaging.Message.CorrelationId
  - System.Messaging.Message.DestinationQueue
  - System.Messaging.Message.DestinationSymmetricKey
  - System.Messaging.Message.DigitalSignature
  - System.Messaging.Message.EncryptionAlgorithm
  - System.Messaging.Message.Extension
  - System.Messaging.Message.Formatter
  - System.Messaging.Message.HashAlgorithm
  - System.Messaging.Message.Id
  - System.Messaging.Message.InfiniteTimeout
  - System.Messaging.Message.IsFirstInTransaction
  - System.Messaging.Message.IsLastInTransaction
  - System.Messaging.Message.Label
  - System.Messaging.Message.LookupId
  - System.Messaging.Message.MessageType
  - System.Messaging.Message.Priority
  - System.Messaging.Message.Recoverable
  - System.Messaging.Message.ResponseQueue
  - System.Messaging.Message.SecurityContext
  - System.Messaging.Message.SenderCertificate
  - System.Messaging.Message.SenderId
  - System.Messaging.Message.SenderVersion
  - System.Messaging.Message.SentTime
  - System.Messaging.Message.SourceMachine
  - System.Messaging.Message.TimeToBeReceived
  - System.Messaging.Message.TimeToReachQueue
  - System.Messaging.Message.TransactionId
  - System.Messaging.Message.TransactionStatusQueue
  - System.Messaging.Message.UseAuthentication
  - System.Messaging.Message.UseDeadLetterQueue
  - System.Messaging.Message.UseEncryption
  - System.Messaging.Message.UseJournalQueue
  - System.Messaging.Message.UseTracing
  langs:
  - csharp
  name: Message
  nameWithType: Message
  fullName: System.Messaging.Message
  type: Class
  summary: "提供定義訊息佇列的訊息所需的屬性存取。"
  remarks: "要查看，或從佇列接收訊息或訊息屬性的良好控制傳送至佇列的訊息時，請使用 Message 類別。       <xref:System.Messaging.MessageQueue>使用 Message 類別查看，或從佇列接收訊息時因為同時<xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=fullName>和<xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=fullName>方法建立的訊息類別的新執行個體，並設定執行個體的屬性。</xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=fullName> </xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=fullName></xref:System.Messaging.MessageQueue> 訊息類別的唯讀屬性會套用至從佇列擷取訊息，而讀取/寫入屬性套用至傳送和擷取訊息。 當<xref:System.Messaging.MessageQueue>查看或接收訊息佇列中，從其<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>屬性決定訊息的屬性擷取。</xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> </xref:System.Messaging.MessageQueue>       <xref:System.Messaging.MessageQueue>類別的<xref:System.Messaging.MessageQueue.Send%2A>方法可讓您指定任何物件型別，正在傳送至該佇列的訊息。</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.MessageQueue> 您可以使用<xref:System.Messaging.MessageQueue>執行個體的<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性可指定泛型訊息傳送至佇列的設定。</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> </xref:System.Messaging.MessageQueue> 類型的設定包含格式子、 標籤、 加密及驗證。 您也可以指定適當的值<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>協調訊息的應用程式認可和報告訊息至回應的成員。</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> 使用將訊息傳送至佇列的訊息執行個體可讓您彈性地存取和修改其中許多屬性 — 針對單一訊息或訊息的訊息為基礎。 訊息屬性的優先順序高於<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>       訊息資料儲存在<xref:System.Messaging.Message.Body%2A>屬性以及較小的範圍<xref:System.Messaging.Message.AppSpecific%2A>和<xref:System.Messaging.Message.Extension%2A>屬性。</xref:System.Messaging.Message.Extension%2A> </xref:System.Messaging.Message.AppSpecific%2A> </xref:System.Messaging.Message.Body%2A> 當加密、 序列化，或還原序列化的內容訊息資料<xref:System.Messaging.Message.Body%2A>屬性會受到影響。</xref:System.Messaging.Message.Body%2A>       內容<xref:System.Messaging.Message.Body%2A>傳送訊息，使用時，屬性會序列化<xref:System.Messaging.Message.Formatter%2A>您指定的屬性。</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A> 序列化的內容存在於<xref:System.Messaging.Message.BodyStream%2A>屬性。</xref:System.Messaging.Message.BodyStream%2A> 您也可以設定<xref:System.Messaging.Message.BodyStream%2A>屬性直接管理，例如，若要將檔案傳送為訊息的資料內容。</xref:System.Messaging.Message.BodyStream%2A> 您可以變更<xref:System.Messaging.Message.Body%2A>，或<xref:System.Messaging.Message.Formatter%2A>當您呼叫<xref:System.Messaging.MessageQueue.Send%2A>.</xref:System.Messaging.MessageQueue.Send%2A>隨時傳送訊息，以及資料的屬性也會適當地序列化</xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Body%2A>       所定義之屬性<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=fullName>屬性僅適用於不是型別訊息的訊息。</xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=fullName> 如果您指定<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>屬性<xref:System.Messaging.MessageQueue>，傳送至該佇列的訊息執行個體中同名的屬性會導致這些預設屬性，以略過。</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>       如需訊息執行個體的初始屬性值的清單，請參閱<xref:System.Messaging.Message.%23ctor%2A>建構函式。</xref:System.Messaging.Message.%23ctor%2A>"
  example:
  - "The following code example demonstrates formatting a message body using <xref:System.Messaging.BinaryMessageFormatter>.  \n  \n [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/t-system.messaging.message_1.cpp)]\n [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/t-system.messaging.message_1.cs)]\n [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/t-system.messaging.message_1.vb)]  \n  \n The following code example demonstrates formatting a message body using <xref:System.Messaging.XmlMessageFormatter>.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/t-system.messaging.message_2.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/t-system.messaging.message_2.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/t-system.messaging.message_2.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      public class Message : System.ComponentModel.Component
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements: []
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Dispose(System.Boolean)
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Messaging.Message.#ctor
  id: '#ctor'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message()
  nameWithType: Message.Message()
  fullName: System.Messaging.Message.Message()
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "初始化的新執行個體<xref href=&quot;System.Messaging.Message&quot;></xref>帶有空本文的類別。"
  remarks: "若要建立的新執行個體使用此多載<xref:System.Messaging.Message>具有空白主體的類別。</xref:System.Messaging.Message>       指定<xref:System.Messaging.Message.Body%2A>屬性或<xref:System.Messaging.Message.BodyStream%2A>屬性，才能傳送<xref:System.Messaging.Message>物件。</xref:System.Messaging.Message> </xref:System.Messaging.Message.BodyStream%2A> </xref:System.Messaging.Message.Body%2A> <xref:System.Messaging.Message.Body%2A>屬性可以是任何可序列化，例如文字字串的物件、 結構物件、 類別執行個體或內嵌的物件。</xref:System.Messaging.Message.Body%2A>       除非您直接寫入訊息的內容<xref:System.Messaging.Message.BodyStream%2A>屬性，將<xref:System.Messaging.Message.Formatter%2A>之前傳送訊息的屬性。</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.BodyStream%2A> 使用序列化本文<xref:System.Messaging.Message.Formatter%2A>屬性的值時<xref:System.Messaging.MessageQueue.Send%2A>上呼叫方法<xref:System.Messaging.MessageQueue>執行個體。</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A>       <xref:System.Messaging.XmlMessageFormatter>鬆散偶合，如此就不需要有相同的物件時使用此格式輸入上的寄件者和接收者。</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>將資料序列化為二進位表示法。</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>傳送或接收的 COM 元件時使用。</xref:System.Messaging.ActiveXMessageFormatter>       下表顯示<xref:System.Messaging.Message>.</xref:System.Messaging.Message>的執行個體的初始屬性值      |屬性 |初始值 |  |--------------|-------------------|  |<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  |<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  |<xref:System.Messaging.Message.AppSpecific%2A>|0|  |<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  |<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版 |  |<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  |<xref:System.Messaging.Message.Body%2A>|`null`|  |<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  |<xref:System.Messaging.Message.BodyType%2A>|0|  |<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  |<xref:System.Messaging.Message.CorrelationId%2A>|空字串 (&quot;&quot;) |  |<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|為零長度的位元組的陣列 |  |<xref:System.Messaging.Message.DigitalSignature%2A>|為零長度的位元組的陣列 |  |<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  |<xref:System.Messaging.Message.Extension%2A>|為零長度的位元組的陣列 |  |<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  |<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  |<xref:System.Messaging.Message.Label%2A>|空字串 (&quot;&quot;) |  |<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  |<xref:System.Messaging.Message.Recoverable%2A>|`false`|  |<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  |<xref:System.Messaging.Message.SenderCertificate%2A>|為零長度的位元組的陣列 |  |<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  |<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  |<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  |<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  |<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  |<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  |<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  |<xref:System.Messaging.Message.UseTracing%2A>|`false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/m-system.messaging.messa_16_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/m-system.messaging.messa_16_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/m-system.messaging.messa_16_1.cs)]"
  syntax:
    content: public Message ();
    parameters: []
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.#ctor(System.Object)
  id: '#ctor(System.Object)'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message(Object)
  nameWithType: Message.Message(Object)
  fullName: System.Messaging.Message.Message(Object)
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "初始化的新執行個體<xref href=&quot;System.Messaging.Message&quot;></xref>類別，使用<xref href=&quot;System.Messaging.XmlMessageFormatter&quot;></xref>將指定的物件序列化成訊息的本文。"
  remarks: "若要建立的新執行個體使用此多載<xref:System.Messaging.Message>類別，其中包含<xref:System.Messaging.Message.Body%2A>所指定`body`參數。</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message> `body`參數可以是任何可序列化，例如字串、 結構物件、 類別執行個體或內嵌的物件的物件。 使用序列化本文<xref:System.Messaging.XmlMessageFormatter>除非您變更<xref:System.Messaging.Message.Formatter%2A>屬性之後再<xref:System.Messaging.Message>傳送。</xref:System.Messaging.Message> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.XmlMessageFormatter> 如果您變更<xref:System.Messaging.Message.Body%2A>或<xref:System.Messaging.Message.Formatter%2A>屬性在任何時間，然後再呼叫<xref:System.Messaging.MessageQueue.Send%2A>，訊息將根據新的屬性值來序列化。</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A>       <xref:System.Messaging.XmlMessageFormatter>鬆散偶合，如此就不需要有相同的物件時使用此格式輸入上的寄件者和接收者。</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>將資料序列化為二進位表示法。</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>傳送或接收的 COM 元件時使用。</xref:System.Messaging.ActiveXMessageFormatter>       下表顯示<xref:System.Messaging.Message>.</xref:System.Messaging.Message>的執行個體的初始屬性值      |屬性 |初始值 |  |--------------|-------------------|  |<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  |<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  |<xref:System.Messaging.Message.AppSpecific%2A>|0|  |<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  |<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版 |  |<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  |<xref:System.Messaging.Message.Body%2A>|`body`參數。 |  |<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  |<xref:System.Messaging.Message.BodyType%2A>|0|  |<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  |<xref:System.Messaging.Message.CorrelationId%2A>|空字串 (&quot;&quot;) |  |<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|為零長度的位元組的陣列 |  |<xref:System.Messaging.Message.DigitalSignature%2A>|為零長度的位元組的陣列 |  |<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  |<xref:System.Messaging.Message.Extension%2A>|為零長度的位元組的陣列 |  |<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  |<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  |<xref:System.Messaging.Message.Label%2A>|空字串 (&quot;&quot;) |  |<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  |<xref:System.Messaging.Message.Recoverable%2A>|`false`|  |<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  |<xref:System.Messaging.Message.SenderCertificate%2A>|為零長度的位元組的陣列 |  |<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  |<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  |<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  |<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  |<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  |<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  |<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  |<xref:System.Messaging.Message.UseTracing%2A>|`false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example creates a new queue, sends a message that contains an order to it, and then retrieves it.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/m-system.messaging.messa_33_1.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/m-system.messaging.messa_33_1.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/m-system.messaging.messa_33_1.vb)]"
  syntax:
    content: public Message (object body);
    parameters:
    - id: body
      type: System.Object
      description: "要序列化成訊息的本文物件。"
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  id: '#ctor(System.Object,System.Messaging.IMessageFormatter)'
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Message(Object,IMessageFormatter)
  nameWithType: Message.Message(Object,IMessageFormatter)
  fullName: System.Messaging.Message.Message(Object,IMessageFormatter)
  type: Constructor
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "初始化的新執行個體<xref href=&quot;System.Messaging.Message&quot;></xref>類別使用指定的格式器將指定的物件序列化成訊息的本文。"
  remarks: "若要建立的新執行個體使用此多載<xref:System.Messaging.Message>類別，其中包含<xref:System.Messaging.Message.Body%2A>所指定`body`參數，以及使用任何有效的格式器序列化內文。</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message> `body`參數是可序列化，例如字串、 結構物件、 類別執行個體或內嵌的物件的任何物件。 如果您變更<xref:System.Messaging.Message.Body%2A>或<xref:System.Messaging.Message.Formatter%2A>屬性在任何時間，然後再呼叫<xref:System.Messaging.MessageQueue.Send%2A>，訊息將根據新的屬性值來序列化。</xref:System.Messaging.MessageQueue.Send%2A> </xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.Body%2A>       <xref:System.Messaging.XmlMessageFormatter>鬆散偶合，如此就不需要有相同的物件時使用此格式輸入上的寄件者和接收者。</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>將資料序列化為二進位表示法。</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>傳送或接收的 COM 元件時使用。</xref:System.Messaging.ActiveXMessageFormatter>       下表顯示<xref:System.Messaging.Message>.</xref:System.Messaging.Message>的執行個體的初始屬性值      |屬性 |初始值 |  |--------------|-------------------|  |<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  |<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  |<xref:System.Messaging.Message.AppSpecific%2A>|0|  |<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  |<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider 1.0 版 |  |<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  |<xref:System.Messaging.Message.Body%2A>|`body`參數。 |  |<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  |<xref:System.Messaging.Message.BodyType%2A>|0|  |<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  |<xref:System.Messaging.Message.CorrelationId%2A>|空字串 (&quot;&quot;) |  |<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|為零長度的位元組的陣列 |  |<xref:System.Messaging.Message.DigitalSignature%2A>|為零長度的位元組的陣列 |  |<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  |<xref:System.Messaging.Message.Extension%2A>|為零長度的位元組的陣列 |  |<xref:System.Messaging.Message.Formatter%2A>|`formatter`參數。 |  |<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  |<xref:System.Messaging.Message.Label%2A>|空字串 (&quot;&quot;) |  |<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  |<xref:System.Messaging.Message.Recoverable%2A>|`false`|  |<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  |<xref:System.Messaging.Message.SenderCertificate%2A>|為零長度的位元組的陣列 |  |<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  |<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  |<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  |<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  |<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  |<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  |<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  |<xref:System.Messaging.Message.UseTracing%2A>|`false`|</xref:System.Messaging.Message.UseTracing%2A></xref:System.Messaging.Message.UseJournalQueue%2A></xref:System.Messaging.Message.UseEncryption%2A></xref:System.Messaging.Message.UseDeadLetterQueue%2A></xref:System.Messaging.Message.UseAuthentication%2A></xref:System.Messaging.Message.TransactionStatusQueue%2A></xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A></xref:System.Messaging.Message.SenderCertificate%2A></xref:System.Messaging.Message.ResponseQueue%2A></xref:System.Messaging.Message.Recoverable%2A></xref:System.Messaging.Message.Priority%2A></xref:System.Messaging.Message.Label%2A></xref:System.Messaging.Message.HashAlgorithm%2A></xref:System.Messaging.Message.Formatter%2A></xref:System.Messaging.Message.Extension%2A></xref:System.Messaging.Message.EncryptionAlgorithm%2A></xref:System.Messaging.Message.DigitalSignature%2A></xref:System.Messaging.Message.DestinationSymmetricKey%2A></xref:System.Messaging.Message.CorrelationId%2A></xref:System.Messaging.Message.ConnectorType%2A></xref:System.Messaging.Message.BodyType%2A></xref:System.Messaging.Message.BodyStream%2A></xref:System.Messaging.Message.Body%2A></xref:System.Messaging.Message.AuthenticationProviderType%2A></xref:System.Messaging.Message.AuthenticationProviderName%2A></xref:System.Messaging.Message.AttachSenderId%2A></xref:System.Messaging.Message.AppSpecific%2A></xref:System.Messaging.Message.AdministrationQueue%2A></xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - >-
    [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/6734a59e-0a86-49d1-96b9-_1.cpp)]
     [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/6734a59e-0a86-49d1-96b9-_1.cs)]
     [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/6734a59e-0a86-49d1-96b9-_1.vb)]
  syntax:
    content: public Message (object body, System.Messaging.IMessageFormatter formatter);
    parameters:
    - id: body
      type: System.Object
      description: "要序列化成訊息的本文物件。"
    - id: formatter
      type: System.Messaging.IMessageFormatter
      description: "A <xref href=&quot;System.Messaging.IMessageFormatter&quot;> </xref> ，指定用來序列化訊息主體的格式器。"
  overload: System.Messaging.Message.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.AcknowledgeType
  id: AcknowledgeType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
  fullName: System.Messaging.Message.AcknowledgeType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定要傳回給傳送應用程式的認可訊息類型。"
  remarks: "AcknowledgeType 屬性會指定傳送應用程式所要求的認可訊息的類型。 傳送訊息，以要求通知的特定項目之前，先設定 AcknowledgeType 屬性 — 比方說，訊息到達目的地佇列、 已擷取訊息或防止到達或正在從目的地佇列擷取訊息的逾時。       訊息佇列會通知傳回傳送通知訊息至<xref:System.Messaging.Message.AdministrationQueue%2A>原始訊息所指定的屬性。</xref:System.Messaging.Message.AdministrationQueue%2A> 認可訊息的<xref:System.Messaging.Message.Acknowledgment%2A>屬性會指出認可所代表的類型。</xref:System.Messaging.Message.Acknowledgment%2A> 例如，如果已傳送通知訊息，因為郵件無法送達目的地之前<xref:System.Messaging.Message.TimeToReachQueue%2A>間隔到期，<xref:System.Messaging.Message.Acknowledgment%2A>的認可訊息的屬性會包含值`ReachQueueTimeout`。</xref:System.Messaging.Message.Acknowledgment%2A> </xref:System.Messaging.Message.TimeToReachQueue%2A>"
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_11_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_11_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_11_1.vb)]"
  syntax:
    content: public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }
    return:
      type: System.Messaging.AcknowledgeTypes
      description: "其中一個<xref href=&quot;System.Messaging.AcknowledgeTypes&quot;></xref>代表系統中的管理佇列以及通知會傳回給傳送應用程式的條件所張貼的認可訊息類型的值。 預設值是<xref uid=&quot;langword_csharp_None&quot; name=&quot;None&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.AcknowledgeType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息經過篩選，忽略 AcknowledgeType 屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.Acknowledgment
  id: Acknowledgment
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
  fullName: System.Messaging.Message.Acknowledgment
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得表示此訊息表示通知的分類。"
  remarks: "當您收到來自管理佇列的訊息時，讀取認可屬性來驗證原始訊息的狀態。       當訊息傳送至其目的地佇列時，訊息佇列可以要求張貼通知訊息。 比方說，這類訊息可能表示訊息已到達，且指定的逾時內已擷取還是有可能表示發生了什麼錯誤在傳遞失敗。 目的地佇列傳回通知訊息，並將它們公佈到原始訊息中指定的管理佇列<xref:System.Messaging.Message.AdministrationQueue%2A>屬性。</xref:System.Messaging.Message.AdministrationQueue%2A> <xref:System.Messaging.Message.Id%2A>的認可訊息的屬性會識別的通知訊息，而不是在原始訊息。</xref:System.Messaging.Message.Id%2A> 您可以在通知中找到的原始訊息的識別項<xref:System.Messaging.Message>執行個體的<xref:System.Messaging.Message.CorrelationId%2A>屬性。</xref:System.Messaging.Message.CorrelationId%2A> </xref:System.Messaging.Message>       如果這個<xref:System.Messaging.Message>的執行個體表示的通知訊息，通知屬性指定類型的通知。</xref:System.Messaging.Message> 否則，[通知] 屬性包含值`Normal`。       使用<xref:System.Messaging.Message.AcknowledgeType%2A>指定情況下會傳回認可原始訊息的屬性。</xref:System.Messaging.Message.AcknowledgeType%2A>"
  syntax:
    content: public System.Messaging.Acknowledgment Acknowledgment { get; }
    return:
      type: System.Messaging.Acknowledgment
      description: "其中一個<xref href=&quot;System.Messaging.Acknowledgment&quot;></xref>列舉值。"
  overload: System.Messaging.Message.Acknowledgment*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或-訊息佇列會經過篩選，忽略<xref:System.Messaging.MessagePropertyFilter.Acknowledgment*>屬性。</xref:System.Messaging.MessagePropertyFilter.Acknowledgment*>"
  platform:
  - net462
- uid: System.Messaging.Message.AdministrationQueue
  id: AdministrationQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
  fullName: System.Messaging.Message.AdministrationQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定接收的訊息佇列產生的認可訊息的佇列。"
  remarks: "AdministrationQueue 屬性中指定的佇列可以是任何非交易式佇列。 傳送至管理佇列的認可訊息可以指示原始訊息是否已抵達其目的端佇列，以及是否已從佇列中移除。       當<xref:System.Messaging.Message.AcknowledgeType%2A>屬性有任何值以外`None`，傳送應用程式必須指定要做為管理佇列的佇列。</xref:System.Messaging.Message.AcknowledgeType%2A>"
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_47_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_47_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_47_1.vb)]"
  syntax:
    content: public System.Messaging.MessageQueue AdministrationQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "<xref href=&quot;System.Messaging.MessageQueue&quot;> </xref> ，指定系統產生的通知訊息時使用的管理佇列。 預設值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.AdministrationQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 AdministrationQueue 屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.AppSpecific
  id: AppSpecific
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AppSpecific
  nameWithType: Message.AppSpecific
  fullName: System.Messaging.Message.AppSpecific
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定其他的應用程式特定資訊。"
  remarks: "AppSpecific 屬性包含應用程式特有的資訊，您可以用來組織不同類型的訊息。 例如，您可以使用應用程式特有的索引。 它負責解譯 AppSpecific 屬性資訊的應用程式。       可能的話，您應該包含的訊息，而不是 AppSpecific 屬性主體中的訊息資料。       當使用外部佇列，使用<xref:System.Messaging.Message.Extension%2A>屬性來指定訊息佇列中的訊息屬性不存在。</xref:System.Messaging.Message.Extension%2A> AppSpecific 屬性中，它是要了解的內容的應用程式的責任<xref:System.Messaging.Message.Extension%2A>屬性。</xref:System.Messaging.Message.Extension%2A>"
  syntax:
    content: public int AppSpecific { get; set; }
    return:
      type: System.Int32
      description: "應用程式特有的資訊。 預設值是零。"
  overload: System.Messaging.Message.AppSpecific*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 AppSpecific 屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.ArrivedTime
  id: ArrivedTime
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
  fullName: System.Messaging.Message.ArrivedTime
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得訊息抵達目的端佇列的時間。"
  remarks: "訊息的<xref:System.Messaging.Message.TimeToBeReceived%2A>屬性會指出速度必須從目的地佇列接收訊息。</xref:System.Messaging.Message.TimeToBeReceived%2A> <xref:System.Messaging.Message.TimeToBeReceived%2A>屬性計時器啟動時傳送訊息，不會在訊息送達佇列中。</xref:System.Messaging.Message.TimeToBeReceived%2A>"
  example:
  - "The following code example displays the value of a message's ArrivedTime property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public DateTime ArrivedTime { get; }
    return:
      type: System.DateTime
      description: "A<xref:System.DateTime>表示目的端佇列的訊息抵達時間。</xref:System.DateTime> 目的地佇列所在之電腦的本機時間，時間會調整 gmt。"
  overload: System.Messaging.Message.ArrivedTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或者-訊息佇列會經過篩選，忽略 ArrivedTime 屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.AttachSenderId
  id: AttachSenderId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
  fullName: System.Messaging.Message.AttachSenderId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定值，指出是否應該傳送者識別碼附加至訊息。"
  remarks: "<xref:System.Messaging.Message.SenderId%2A>屬性是位元組陣列，代表傳送使用者的識別項。</xref:System.Messaging.Message.SenderId%2A> 寄件者識別碼由訊息佇列設定，並由接收佇列管理員用來驗證寄件者是否有佇列的存取權限。       如果沒有寄件者識別碼會指出傳送應用程式的訊息佇列應該不驗證訊息的寄件者，也驗證寄件者的存取權限到接收佇列。 <xref:System.Messaging.Message.SenderId%2A>是值得信任，只有當訊息已驗證到達目的地佇列。</xref:System.Messaging.Message.SenderId%2A> 如果佇列接受已驗證的訊息，然後到達目的地佇列時，會拒絕訊息<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>或<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>屬性是`false`。</xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> </xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>      > [!CAUTION] > 拒絕訊息時，如果它是 傳送到寄不出信件佇列 (如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`true`)，或忽略它。</xref:System.Messaging.Message.UseDeadLetterQueue%2A> 當訊息無法抵達佇列時，您可以要求通知。 否則，當<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`訊息可能會遺失，而不發出警告。</xref:System.Messaging.Message.UseDeadLetterQueue%2A>"
  example:
  - "The following code example gets and sets the value of a message's AttachSenderId property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool AttachSenderId { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Messaging.Message.SenderId*>應該附加至訊息; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Messaging.Message.SenderId*> 預設值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.AttachSenderId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 AttachSenderId 屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.Authenticated
  id: Authenticated
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Authenticated
  nameWithType: Message.Authenticated
  fullName: System.Messaging.Message.Authenticated
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得值，指出是否已驗證訊息。"
  remarks: "已驗證屬性會使用只將應用程式，而它是與訊息互動，並嘗試判斷驗證是否已要求。 如果訊息在佇列中，已驗證訊息。 相反地，如果已驗證屬性是`true`，它收到該訊息時，接收佇列管理員會驗證訊息。       您無法判斷是否訊息無法通過驗證它的內容。 訊息佇列會捨棄驗證失敗之前傳送至佇列的訊息。 不過，您可以要求會傳送通知訊息，如果傳遞失敗可防止訊息到達佇列。"
  example:
  - "The following code example displays the value of a message's Authenticated property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool Authenticated { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果訊息已經要求驗證，當其輸入佇列中;，否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.Authenticated*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或者-訊息佇列會經過篩選，忽略驗證屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.AuthenticationProviderName
  id: AuthenticationProviderName
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
  fullName: System.Messaging.Message.AuthenticationProviderName
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定用來產生訊息的數位簽章的密碼編譯提供者的名稱。"
  remarks: "使用外部佇列時，通常會使用 AuthenticationProviderName。 訊息佇列將要求的驗證提供者名稱和密碼編譯提供者 （驗證提供者），來驗證訊息傳送至外部佇列以及從外部佇列傳遞至訊息佇列訊息的數位簽章驗證提供者類型。       傳送郵件時，一定會設定 AuthenticationProviderName 和<xref:System.Messaging.Message.ConnectorType%2A>屬性放在一起。</xref:System.Messaging.Message.ConnectorType%2A> 當傳送訊息時，訊息佇列會忽略驗證提供者名稱如果也沒有設定連接器類型。       AuthenticationProviderName 屬性不可以是`null`，但它可以是空字串 (&quot;&quot;)。"
  syntax:
    content: public string AuthenticationProviderName { get; set; }
    return:
      type: System.String
      description: "用來產生訊息的數位簽章的密碼編譯提供者名稱。 預設為 Microsoft Base Cryptographic Provider 1.0 版。"
  overload: System.Messaging.Message.AuthenticationProviderName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法設定 AuthenticationProviderName 屬性。       -或者-訊息佇列會經過篩選，忽略 AuthenticationProviderName 屬性。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "AuthenticationProviderName 已設為<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Messaging.Message.AuthenticationProviderType
  id: AuthenticationProviderType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
  fullName: System.Messaging.Message.AuthenticationProviderType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定用來產生訊息的數位簽章的密碼編譯提供者的類型。"
  remarks: "您通常使用 AuthenticationProviderType 屬性使用外部佇列時指定的密碼編譯服務提供者是與訊息相關聯。 訊息佇列將要求的驗證提供者名稱和密碼編譯提供者 （驗證提供者），來驗證訊息傳送至外部佇列以及從外部佇列傳遞至訊息佇列訊息的數位簽章驗證提供者類型。       只有`RsaFull`用來搭配訊息。       傳送郵件時，一定會設定 AuthenticationProviderType 和<xref:System.Messaging.Message.ConnectorType%2A>屬性放在一起。</xref:System.Messaging.Message.ConnectorType%2A> 當傳送訊息時，訊息佇列會忽略驗證提供者類型如果也沒有設定連接器類型。"
  syntax:
    content: public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }
    return:
      type: System.Messaging.CryptographicProviderType
      description: "其中一個<xref href=&quot;System.Messaging.CryptographicProviderType&quot;></xref>值。 預設值是<xref uid=&quot;langword_csharp_RSA_FULL&quot; name=&quot;RSA_FULL&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.AuthenticationProviderType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法設定 AuthenticationProviderType 屬性。       -或者-訊息佇列會經過篩選，忽略 AuthenticationProviderType 屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.Body
  id: Body
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Body
  nameWithType: Message.Body
  fullName: System.Messaging.Message.Body
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定訊息的內容。"
  remarks: "訊息的本文屬性通常會包含與訊息相關聯的資料。 雖然您也可以傳送應用程式特定資料<xref:System.Messaging.Message.AppSpecific%2A>和<xref:System.Messaging.Message.Extension%2A>屬性，您應該盡可能訊息的本文中包含訊息資料。</xref:System.Messaging.Message.Extension%2A> </xref:System.Messaging.Message.AppSpecific%2A> 只將主體屬性內容已序列化或加密。       Body 屬性可包含任何物件，其大小不超過 4 MB。 如果您使用<xref:System.Messaging.MessageQueue.Send%2A?displayProperty=fullName>的是不屬於型別<xref:System.Messaging.Message><xref:System.Messaging.MessageQueue>，該物件會位於的 Body 屬性<xref:System.Messaging.Message><xref:System.Messaging.MessageQueue.Peek%2A>或<xref:System.Messaging.MessageQueue.Receive%2A>.</xref:System.Messaging.MessageQueue.Receive%2A></xref:System.Messaging.MessageQueue.Peek%2A>所傳回的執行個體</xref:System.Messaging.Message>的</xref:System.Messaging.MessageQueue></xref:System.Messaging.Message>任何物件傳送至</xref:System.Messaging.MessageQueue.Send%2A?displayProperty=fullName>       中的字串引數`MessageQueue.Send(&quot;hello.&quot;)`是一般物件的範例。       <xref:System.Messaging.Message.BodyType%2A>屬性表示訊息本文中所儲存的資訊類型。</xref:System.Messaging.Message.BodyType%2A> 訊息佇列會使用這項資訊來識別內容屬性的型別。       指定 [內容] 屬性或<xref:System.Messaging.Message.BodyStream%2A>屬性，才能傳送<xref:System.Messaging.Message>物件。</xref:System.Messaging.Message> </xref:System.Messaging.Message.BodyStream%2A> Body 屬性可以是任何可序列化的物件，例如文字字串、 物件結構、 類別執行個體或內嵌的物件。       除非您直接寫入訊息的內容<xref:System.Messaging.Message.BodyStream%2A>屬性，將<xref:System.Messaging.Message.Formatter%2A>之前傳送訊息的屬性。</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.Message.BodyStream%2A> 當<xref:System.Messaging.MessageQueue.Send%2A>上呼叫方法<xref:System.Messaging.MessageQueue>使用包含在這個格式器序列化執行個體，本文<xref:System.Messaging.Message.Formatter%2A>屬性。</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> 如果您未指定的值<xref:System.Messaging.Message.Formatter%2A>屬性，則格式器會預設為<xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter></xref:System.Messaging.Message.Formatter%2A>傳送訊息      > [!NOTE] > 嘗試設定的訊息本文<xref:System.Decimal.MaxValue>會導致<xref:System.OverflowException>時`Send`方法<xref:System.Messaging.MessageQueue>類別稱為和<xref:System.Messaging.ActiveXMessageFormatter>用。</xref:System.Messaging.ActiveXMessageFormatter> </xref:System.Messaging.MessageQueue> </xref:System.OverflowException> </xref:System.Decimal.MaxValue>"
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/p-system.messaging.messa_13_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_13_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/p-system.messaging.messa_13_1.cs)]"
  syntax:
    content: public object Body { get; set; }
    return:
      type: System.Object
      description: "指定訊息內容的物件。 物件可以是字串、 日期、 貨幣、 數字、 位元組陣列或任何 managed 的物件。"
  overload: System.Messaging.Message.Body*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Messaging.Message.Formatter*>屬性是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。</xref:System.Messaging.Message.Formatter*>       -或者-訊息佇列會經過篩選，忽略 Body 屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.BodyStream
  id: BodyStream
  parent: System.Messaging.Message
  langs:
  - csharp
  name: BodyStream
  nameWithType: Message.BodyStream
  fullName: System.Messaging.Message.BodyStream
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定訊息的本文中的資訊。"
  remarks: "訊息的主體可以包含的任何類型的資訊，例如字串、 日期、 貨幣、 數字、 位元組陣列或任何 managed 的物件。 這項資訊會序列化為<xref:System.IO.Stream>傳遞至佇列。</xref:System.IO.Stream>       指定<xref:System.Messaging.Message.Body%2A>屬性或 BodyStream 屬性傳送之前<xref:System.Messaging.Message>物件。</xref:System.Messaging.Message> </xref:System.Messaging.Message.Body%2A> 如果您設定<xref:System.Messaging.Message.Body%2A>屬性，內容序列化成 BodyStream 屬性。</xref:System.Messaging.Message.Body%2A> 不過，您可以選擇直接寫入 BodyStream 屬性。 例如，當您想要開啟的檔案連接，並做為您的訊息主體資料流內容，這十分有用。       除非您直接將 BodyStream 屬性寫入訊息的內容，設定<xref:System.Messaging.Message.Formatter%2A>之前傳送訊息的屬性。</xref:System.Messaging.Message.Formatter%2A> 當<xref:System.Messaging.MessageQueue.Send%2A>上呼叫方法<xref:System.Messaging.MessageQueue>使用包含在這個格式器序列化執行個體，本文<xref:System.Messaging.Message.Formatter%2A>屬性。</xref:System.Messaging.Message.Formatter%2A> </xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> 如果您未指定的值<xref:System.Messaging.Message.Formatter%2A>屬性，則格式器會預設為<xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter></xref:System.Messaging.Message.Formatter%2A>傳送訊息       如果您設定<xref:System.Messaging.Message.UseEncryption%2A>屬性`true`針對此訊息的本文，將會加密訊息傳送時，不會在您設定<xref:System.Messaging.Message.Body%2A>屬性。</xref:System.Messaging.Message.Body%2A> </xref:System.Messaging.Message.UseEncryption%2A> 因此，永遠不會加密 BodyStream 屬性。"
  syntax:
    content: public System.IO.Stream BodyStream { get; set; }
    return:
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>包含中包含的序列化的資訊<xref:System.Messaging.Message.Body*>的訊息。</xref:System.Messaging.Message.Body*> </xref:System.IO.Stream>"
  overload: System.Messaging.Message.BodyStream*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會經過篩選，忽略<xref:System.Messaging.Message.Body*>屬性。</xref:System.Messaging.Message.Body*>"
  platform:
  - net462
- uid: System.Messaging.Message.BodyType
  id: BodyType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: BodyType
  nameWithType: Message.BodyType
  fullName: System.Messaging.Message.BodyType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定訊息本文包含的資料類型。"
  remarks: "訊息佇列會辨識本文內容，做為物件或序列化資料流。 BodyType 屬性指出內的物件類型<xref:System.Messaging.Message.Body%2A>訊息屬性。</xref:System.Messaging.Message.Body%2A>       <xref:System.Messaging.XmlMessageFormatter>訊息本文中會執行原生類型與物件之間的繫結。</xref:System.Messaging.XmlMessageFormatter> 如果您使用<xref:System.Messaging.XmlMessageFormatter>，格式器會為您設定 BodyType 屬性。</xref:System.Messaging.XmlMessageFormatter>       其他格式子可繫結功能也，如下列 C# 程式碼所示。      ```   message.Formatter = new ActiveXMessageFormatter();   object myObject message.Body;   if (myObject is string) {   }   if (myObject is int) {   }   if (myObject is float) {   }   ```"
  example:
  - "The following code example displays the value of a message's BodyType property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public int BodyType { get; set; }
    return:
      type: System.Int32
      description: "訊息本文，則為 true 類型，例如字串、 日期、 貨幣或數值。"
  overload: System.Messaging.Message.BodyType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會經過篩選，忽略<xref:System.Messaging.Message.Body*>屬性。</xref:System.Messaging.Message.Body*>"
  platform:
  - net462
- uid: System.Messaging.Message.ConnectorType
  id: ConnectorType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ConnectorType
  nameWithType: Message.ConnectorType
  fullName: System.Messaging.Message.ConnectorType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定值，指出傳送應用程式已設定通常會設定由訊息佇列的訊息內容。"
  remarks: "訊息佇列需要 ConnectorType 屬性設定每當應用程式設定通常設定由訊息佇列的訊息屬性。 應用程式通常使用下列兩種情況下 ConnectorType:-每當連接器應用程式將訊息傳遞。 ConnectorType 告知傳送和接收的應用程式如何解譯訊息的安全性與認可屬性。      -每當傳送應用程式，而不是訊息佇列時，會加密訊息。 ConnectorType 告知訊息佇列 」 使用<xref:System.Messaging.Message.DestinationSymmetricKey%2A>來解密訊息的屬性值。</xref:System.Messaging.Message.DestinationSymmetricKey%2A>       如果您設定了任何下列的屬性，您必須設定 ConnectorType 屬性 （否則佇列會忽略這些屬性將訊息傳送時）:- <xref:System.Messaging.Message.AuthenticationProviderName%2A>- <xref:System.Messaging.Message.AuthenticationProviderType%2A>- <xref:System.Messaging.Message.DestinationSymmetricKey%2A>- <xref:System.Messaging.Message.DigitalSignature%2A>- <xref:System.Messaging.Message.MessageType%2A>- <xref:System.Messaging.Message.SenderId%2A></xref:System.Messaging.Message.SenderId%2A> </xref:System.Messaging.Message.MessageType%2A> </xref:System.Messaging.Message.DigitalSignature%2A> </xref:System.Messaging.Message.DestinationSymmetricKey%2A> </xref:System.Messaging.Message.AuthenticationProviderType%2A> </xref:System.Messaging.Message.AuthenticationProviderName%2A>"
  syntax:
    content: public Guid ConnectorType { get; set; }
    return:
      type: System.Guid
      description: "A<xref:System.Guid>應用程式定義並與連接器應用程式或訊息加密搭配使用。</xref:System.Guid> 這<xref:System.Guid>可讓接收應用程式來解譯所傳送的應用程式設定的但，通常由訊息佇列設定的訊息屬性。</xref:System.Guid>"
  overload: System.Messaging.Message.ConnectorType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 ConnectorType 屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.CorrelationId
  id: CorrelationId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: CorrelationId
  nameWithType: Message.CorrelationId
  fullName: System.Messaging.Message.CorrelationId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定認可、 報告和回應訊息用來參考原始訊息的訊息識別項。"
  remarks: "當訊息佇列產生認可或報告訊息時，它會使用相互關聯識別項屬性，來指定原始訊息的訊息識別項。 如此一來，在相互關聯識別項將報告或認可訊息連結到原始訊息。       傳送應用程式可以再比對通知或報表與原始訊息使用來識別原始訊息的 CorrelationId 屬性<xref:System.Messaging.Message.Id%2A>屬性。</xref:System.Messaging.Message.Id%2A>       連接器應用程式也必須設認可和報告訊息的 CorrelationId 屬性的原始訊息的訊息識別項。       當您的應用程式會將回應訊息傳送至傳送應用程式時，您可以設定回應訊息的 CorrelationId 屬性至原始訊息的訊息識別項。 傳送應用程式則可以符合您的回應訊息已傳送的訊息。"
  example:
  - "The following code example sends and receives a message that contains an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_95_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_95_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_95_1.vb)]"
  syntax:
    content: public string CorrelationId { get; set; }
    return:
      type: System.String
      description: "所指定的訊息識別項<xref:System.Messaging.Message.Id*>原始訊息的屬性。</xref:System.Messaging.Message.Id*> 產生回應訊息時，訊息佇列時就會產生認可或報告訊息，以及應用程式使用相互關聯識別項。"
  overload: System.Messaging.Message.CorrelationId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會略過的 CorrelationId 屬性篩選。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "CorrelationId 是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Messaging.Message.DestinationQueue
  id: DestinationQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
  fullName: System.Messaging.Message.DestinationQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得訊息的目的的端佇列。"
  remarks: "目的地佇列屬性最常用來判斷訊息已到達日誌或寄不出的信件佇列中的原始目的端。 通常，您不需要檢查這個屬性，因為您通常會從其目的地佇列擷取訊息。"
  example:
  - "The following code example displays the value of a message's DestinationQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue DestinationQueue { get; }
    return:
      type: System.Messaging.MessageQueue
      description: "A <xref href=&quot;System.Messaging.MessageQueue&quot;> </xref> ，指定訊息的目的的端佇列。"
  overload: System.Messaging.Message.DestinationQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或者-訊息佇列會經過篩選，會忽略此目的地佇列的屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.DestinationSymmetricKey
  id: DestinationSymmetricKey
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
  fullName: System.Messaging.Message.DestinationSymmetricKey
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定對稱金鑰，用來加密應用程式加密的訊息或傳送至外部佇列的訊息。"
  remarks: "兩個案例會要求您使用 DestinationSymmetricKey 屬性。 首先，當您的應用程式，而不是訊息佇列，加密訊息。 第二個是加密的訊息傳送至以外訊息佇列的佇列系統時。       設定此屬性之前，您必須加密對稱金鑰與接收佇列管理員的公開金鑰。 當您傳送應用程式加密的訊息時，接收佇列管理員會使用對稱金鑰來解密訊息，再將它傳送到其目的地佇列。       如果您將訊息傳送至外部佇列時，使用適當的連接器應用程式，將加密的訊息轉送以附加的對稱金鑰至接收應用程式第一次接收訊息。 就接收的應用程式來解密訊息使用對稱金鑰的責任。       當您設定 DestinationSymmetricKey 屬性時，您也必須設定<xref:System.Messaging.Message.ConnectorType%2A>屬性。</xref:System.Messaging.Message.ConnectorType%2A> 當傳送訊息時，訊息佇列會忽略 DestinationSymmetricKey 屬性如果<xref:System.Messaging.Message.ConnectorType%2A>也未設定屬性。</xref:System.Messaging.Message.ConnectorType%2A>       DestinationSymmetricKey 屬性有最大陣列大小為 256。"
  syntax:
    content: public byte[] DestinationSymmetricKey { get; set; }
    return:
      type: System.Byte[]
      description: "指定用來加密訊息的目的地對稱金鑰的位元組值陣列。 預設為零長度陣列。"
  overload: System.Messaging.Message.DestinationSymmetricKey*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 DestinationSymmetricKey 屬性篩選。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "DestinationSymmetricKey 是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Messaging.Message.DigitalSignature
  id: DigitalSignature
  parent: System.Messaging.Message
  langs:
  - csharp
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
  fullName: System.Messaging.Message.DigitalSignature
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定訊息佇列用來驗證訊息的數位簽章。"
  remarks: "驗證所送出訊息佇列版本 1.0 的訊息時，訊息佇列會使用數位簽章。 在大部分情況下，訊息佇列會產生並傳送應用程式要求驗證時設定 DigitalSignature 屬性。 接收應用程式會使用這個屬性來擷取附加至訊息的數位簽章。       執行 Message Queuing 2.0 版時，您只能使用 DigitalSignature 屬性。 要求驗證時，傳送應用程式必須指定 Message Queuing 1.0 版簽章。 如果傳送應用程式傳送的訊息佇列版本 2.0 簽章，此屬性會包含四個位元組，每個包含零的緩衝區。       DigitalSignature 屬性搭配<xref:System.Messaging.Message.SenderCertificate%2A>屬性，也會使用連接器應用程式傳送訊息時。</xref:System.Messaging.Message.SenderCertificate%2A> 在此案例中，連接器應用程式，而不是訊息佇列，會產生數位簽章，它會根據使用者傳送訊息的憑證。       DigitalSignature 屬性有最大陣列大小為 256。       當您設定 DigitalSignature 屬性時，您也必須設定<xref:System.Messaging.Message.ConnectorType%2A>屬性。</xref:System.Messaging.Message.ConnectorType%2A> 當傳送訊息時，訊息佇列會忽略 DigitalSignature 屬性如果<xref:System.Messaging.Message.ConnectorType%2A>也未設定屬性。</xref:System.Messaging.Message.ConnectorType%2A>"
  syntax:
    content: public byte[] DigitalSignature { get; set; }
    return:
      type: System.Byte[]
      description: "指定用來驗證訊息的 Message Queuing 1.0 數位簽章的位元組值陣列。 預設為零長度陣列。"
  overload: System.Messaging.Message.DigitalSignature*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 DigitalSignature 屬性篩選。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "DigitalSignature 屬性是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Messaging.Message.EncryptionAlgorithm
  id: EncryptionAlgorithm
  parent: System.Messaging.Message
  langs:
  - csharp
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
  fullName: System.Messaging.Message.EncryptionAlgorithm
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定用來加密私用訊息主體的加密演算法。"
  remarks: "如果訊息是私用 （加密），它會加密再傳送並接收時加以解密。 EncryptionAlgorithm 屬性會指定用來加密私用訊息的訊息本文的演算法。       佇列可以要求傳入訊息加密。 如果應用程式傳送未加密的 （非私用） 訊息到佇列僅接受之私用訊息，或是如果它傳送至佇列的私用訊息，只接受非私用訊息，佇列會拒絕訊息。 傳送應用程式可以要求在此情況下，傳回負值通知訊息。"
  syntax:
    content: public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }
    return:
      type: System.Messaging.EncryptionAlgorithm
      description: "其中一個<xref href=&quot;System.Messaging.EncryptionAlgorithm&quot;></xref>列舉值。 預設值是<xref uid=&quot;langword_csharp_RC2&quot; name=&quot;RC2&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.EncryptionAlgorithm*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 EncryptionAlgorithm 屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.Extension
  id: Extension
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Extension
  nameWithType: Message.Extension
  fullName: System.Messaging.Message.Extension
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定與訊息相關聯的其他的應用程式定義資訊。"
  remarks: "應用程式定義的資訊，例如大型二進位物件，與訊息相關聯的延伸模組屬性提供。 負責接收的應用程式轉譯延伸模組屬性的內容。       如果可行，您應該包含在訊息資料<xref:System.Messaging.Message.Body%2A>訊息，而非延伸模組屬性的屬性。</xref:System.Messaging.Message.Body%2A>       當使用外部佇列，使用擴充功能屬性來指定訊息屬性不存在於訊息佇列中。       非 Microsoft Message Queuing 的佇列系統中存在的外部索引的佇列。 訊息佇列會與透過連接器應用程式的這類佇列通訊。"
  syntax:
    content: public byte[] Extension { get; set; }
    return:
      type: System.Byte[]
      description: "提供與訊息相關聯的應用程式定義資訊的位元組值陣列。 預設為零長度陣列。"
  overload: System.Messaging.Message.Extension*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會篩選忽略擴充屬性。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "擴充功能屬性是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Messaging.Message.Formatter
  id: Formatter
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Formatter
  nameWithType: Message.Formatter
  fullName: System.Messaging.Message.Formatter
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定用來序列化物件或還原序列化的物件，從訊息主體的格式器。"
  remarks: "使用讀取和寫入訊息時，此格式器屬性。 當訊息傳送至佇列時，格式器序列化<xref:System.Messaging.Message.Body%2A>成可以傳送至訊息佇列的資料流的屬性。</xref:System.Messaging.Message.Body%2A> 格式器時從佇列讀取時，會將訊息資料還原序列化<xref:System.Messaging.Message.Body%2A>屬性。</xref:System.Messaging.Message.Body%2A>       除非您直接寫入訊息的內容<xref:System.Messaging.Message.BodyStream%2A>屬性，格式器之前設定屬性，傳送訊息。</xref:System.Messaging.Message.BodyStream%2A> 當<xref:System.Messaging.MessageQueue.Send%2A>上呼叫方法<xref:System.Messaging.MessageQueue>使用格式器內容中包含的格式器序列化執行個體，主體。</xref:System.Messaging.MessageQueue> </xref:System.Messaging.MessageQueue.Send%2A> 如果您傳送訊息但不指定格式器屬性的值，這個格式器就會預設為<xref:System.Messaging.XmlMessageFormatter>.</xref:System.Messaging.XmlMessageFormatter>       <xref:System.Messaging.XmlMessageFormatter>鬆散偶合，如此就不需要有相同的物件時使用此格式輸入上的寄件者和接收者。</xref:System.Messaging.XmlMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>和<xref:System.Messaging.BinaryMessageFormatter>將資料序列化為二進位表示法。</xref:System.Messaging.BinaryMessageFormatter> </xref:System.Messaging.ActiveXMessageFormatter> <xref:System.Messaging.ActiveXMessageFormatter>傳送或接收的 COM 元件時使用。</xref:System.Messaging.ActiveXMessageFormatter>"
  example:
  - "The following code example demonstrates formatting a message body using <xref:System.Messaging.BinaryMessageFormatter>.  \n  \n [!code-cpp[MessagingBinaryFormatter#1](~/add/codesnippet/cpp/p-system.messaging.messa_5_1.cpp)]\n [!code-cs[MessagingBinaryFormatter#1](~/add/codesnippet/csharp/p-system.messaging.messa_5_1.cs)]\n [!code-vb[MessagingBinaryFormatter#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_5_1.vb)]  \n  \n The following code example demonstrates formatting a message body using <xref:System.Messaging.XmlMessageFormatter>.  \n  \n [!code-cpp[Message.Body#1](~/add/codesnippet/cpp/p-system.messaging.messa_5_2.cpp)]\n [!code-cs[Message.Body#1](~/add/codesnippet/csharp/p-system.messaging.messa_5_2.cs)]\n [!code-vb[Message.Body#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_5_2.vb)]"
  syntax:
    content: public System.Messaging.IMessageFormatter Formatter { get; set; }
    return:
      type: System.Messaging.IMessageFormatter
      description: "<xref href=&quot;System.Messaging.IMessageFormatter&quot;> </xref>產生到可寫入或讀取的訊息本文的資料流。 預設值是<xref href=&quot;System.Messaging.XmlMessageFormatter&quot;> </xref>。"
  overload: System.Messaging.Message.Formatter*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "格式器屬性是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Messaging.Message.HashAlgorithm
  id: HashAlgorithm
  parent: System.Messaging.Message
  langs:
  - csharp
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
  fullName: System.Messaging.Message.HashAlgorithm
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定雜湊演算法，驗證訊息時，訊息佇列使用或建立一則訊息的數位簽章。"
  remarks: "來源電腦上，訊息佇列會使用雜湊演算法建立一則訊息的數位簽章時。 目標佇列管理員再使用相同的雜湊演算法，來驗證訊息接收時。"
  syntax:
    content: public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }
    return:
      type: System.Messaging.HashAlgorithm
      description: "其中一個<xref href=&quot;System.Messaging.HashAlgorithm&quot;></xref>列舉值。 Windows XP 的預設值是<xref uid=&quot;langword_csharp_SHA&quot; name=&quot;SHA&quot; href=&quot;&quot;> </xref>。 否則，預設值是<xref uid=&quot;langword_csharp_MD5&quot; name=&quot;MD5&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.HashAlgorithm*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 HashAlgorithm 屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.Id
  id: Id
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Id
  nameWithType: Message.Id
  fullName: System.Messaging.Message.Id
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得訊息的識別項。"
  remarks: "訊息佇列在傳送訊息時，會產生訊息識別項。 識別項是 20 個位元組所組成，並且包含兩個項目︰ 電腦<xref:System.Guid>傳送端電腦的電腦上訊息的唯一識別碼。</xref:System.Guid> 兩個項目合併起來產生網路是唯一的訊息識別項。       訊息佇列會產生所有訊息的訊息識別項，包括認可和報告訊息。 由訊息佇列的抵達或失敗的原始、 已傳送的訊息通常傳送通知訊息。 您可以找到 Id 屬性的值中的原始訊息<xref:System.Messaging.Message.CorrelationId%2A>的認可訊息的屬性。</xref:System.Messaging.Message.CorrelationId%2A>       將回應訊息傳送至回應佇列時，您也可以使用的 Id 屬性。 若要在回應訊息中包含原始訊息的識別項，設定<xref:System.Messaging.Message.CorrelationId%2A>原始訊息的 Id 屬性的回應訊息的屬性。</xref:System.Messaging.Message.CorrelationId%2A> 讀取回應訊息的應用程式然後可以使用回應訊息的相互關聯識別碼來識別原始訊息。"
  example:
  - "The following code example sends and receives a message containing an order to and from a queue. It specifically requests a positive acknowledgment when the original message reaches or is retrieved from the queue.  \n  \n [!code-cs[Message.Acknowledgment#1](~/add/codesnippet/csharp/p-system.messaging.messa_19_1.cs)]\n [!code-cpp[Message.Acknowledgment#1](~/add/codesnippet/cpp/p-system.messaging.messa_19_1.cpp)]\n [!code-vb[Message.Acknowledgment#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_19_1.vb)]"
  syntax:
    content: public string Id { get; }
    return:
      type: System.String
      description: "訊息的唯一識別碼，這由訊息佇列所產生。"
  overload: System.Messaging.Message.Id*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或者-訊息佇列會經過篩選，略過的 Id 屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.InfiniteTimeout
  id: InfiniteTimeout
  parent: System.Messaging.Message
  langs:
  - csharp
  name: InfiniteTimeout
  nameWithType: Message.InfiniteTimeout
  fullName: System.Messaging.Message.InfiniteTimeout
  type: Field
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "指定沒有逾時。"
  remarks: "<xref:System.Messaging.Message.TimeToBeReceived%2A>和<xref:System.Messaging.Message.TimeToReachQueue%2A>需要值，指定的逾時。</xref:System.Messaging.Message.TimeToReachQueue%2A></xref:System.Messaging.Message.TimeToBeReceived%2A> 先前的逾時是從佇列接收訊息所允許的最長時間。 對於後者，逾時是訊息到達佇列所允許的時間。 在這兩種情況下，您可以指定逾時秒數為或 InfiniteTimeout 表示沒有逾時。"
  example:
  - "The following code example demonstrates the use of the InfiniteTimeout field.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public static readonly TimeSpan InfiniteTimeout;
    return:
      type: System.TimeSpan
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.IsFirstInTransaction
  id: IsFirstInTransaction
  parent: System.Messaging.Message
  langs:
  - csharp
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
  fullName: System.Messaging.Message.IsFirstInTransaction
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得值，指出訊息是在交易中傳送的第一個訊息。"
  remarks: "接收應用程式使用 IsFirstInTransaction 屬性來確認某訊息傳送到單一佇列在單一交易中的第一個訊息。       這個屬性是只能搭配訊息佇列版本 2.0 和更新版本。       若要確認交易界限，您可以使用 IsFirstInTransaction 屬性一起使用，其他兩個屬性︰<xref:System.Messaging.Message.IsLastInTransaction%2A>和<xref:System.Messaging.Message.TransactionId%2A>。</xref:System.Messaging.Message.TransactionId%2A> </xref:System.Messaging.Message.IsLastInTransaction%2A> 使用先前檢查訊息是否已在交易中，傳送的最後一個訊息並使用後者來擷取交易的識別碼。       如果只在交易中，IsFirstInTransaction 傳送一個訊息和<xref:System.Messaging.Message.IsLastInTransaction%2A>屬性都設定為`true`。</xref:System.Messaging.Message.IsLastInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's IsFirstInTransaction property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool IsFirstInTransaction { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果訊息已傳送交易; 中的第一個訊息否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.IsFirstInTransaction*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或者-訊息佇列會經過篩選，忽略 IsFirstInTransaction 屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.IsLastInTransaction
  id: IsLastInTransaction
  parent: System.Messaging.Message
  langs:
  - csharp
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
  fullName: System.Messaging.Message.IsLastInTransaction
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得值，指出訊息是在交易中傳送的最後一個訊息。"
  remarks: "接收應用程式使用 IsLastInTransaction 屬性來確認某訊息傳送到單一佇列在單一交易中的最後一個訊息。       這個屬性是只能搭配訊息佇列版本 2.0 和更新版本。       若要確認交易界限，您可以使用 IsLastInTransaction 屬性一起使用，其他兩個屬性︰<xref:System.Messaging.Message.IsFirstInTransaction%2A>和<xref:System.Messaging.Message.TransactionId%2A>。</xref:System.Messaging.Message.TransactionId%2A> </xref:System.Messaging.Message.IsFirstInTransaction%2A> 使用先前檢查訊息是否已在交易中，傳送的第一個訊息並使用後者來擷取交易的識別碼。       如果只在交易中，傳送一個訊息<xref:System.Messaging.Message.IsFirstInTransaction%2A>和 IsLastInTransaction 屬性都設定為`true`。</xref:System.Messaging.Message.IsFirstInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's IsLastInTransaction property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool IsLastInTransaction { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果訊息已傳送單一的交易; 中的最後一個訊息否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.IsLastInTransaction*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或者-訊息佇列會經過篩選，忽略 IsLastInTransaction 屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.Label
  id: Label
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Label
  nameWithType: Message.Label
  fullName: System.Messaging.Message.Label
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定應用程式定義的 Unicode 字串，描述訊息。"
  remarks: "有許多用途，您可以使用訊息標籤。 例如，您可以使用它針對顯示用途，或選擇性根據標籤值對訊息的處理。 標籤並不需要是唯一的訊息。       訊息佇列和訊息標籤表示應用程式定義的值，可協助識別佇列或訊息中人類看得懂的條款。 它負責解譯標籤內容，其不具有實質意義至訊息佇列應用程式的應用程式。"
  example:
  - "The following code example gets and sets the value of a message's Label property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string Label { get; set; }
    return:
      type: System.String
      description: "訊息的標籤。 預設為空字串 (&quot;&quot;)。"
  overload: System.Messaging.Message.Label*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會略過的 Label 屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.LookupId
  id: LookupId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: LookupId
  nameWithType: Message.LookupId
  fullName: System.Messaging.Message.LookupId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "MSMQ 3.0 中引進。 取得訊息的查閱識別項。"
  remarks: "LookupId 內容來提供唯讀存取訊息的查閱識別項。 在 MSMQ 3.0 中引進的查閱識別項是 64 位元識別碼是由訊息佇列產生並指派給每個訊息時訊息放置在佇列中。 查閱識別項不會傳送訊息時產生的訊息識別項相同。       訊息佇列會產生為所有的連接器，以及傳出佇列會放在任何佇列，包括應用程式產生的目的、 管理和報告佇列，以及由系統產生筆記本中，寄不出的信件訊息的查閱識別項。 換句話說，這包括這兩個傳送由傳送應用程式和訊息佇列的訊息。 查閱識別項是唯一至佇列，並在佇列外不具意義。       如果將訊息傳送至數個目的地佇列，或是如果訊息的複本儲存在電腦日誌或佇列日誌中，每個訊息的複本將有它自己的查詢識別時它會放在其各自的佇列。       只能讀取 LookupId 內容來從佇列擷取的訊息。       查閱識別項用來讀取佇列中的特定訊息。 一旦知道訊息的查閱識別項，接收應用程式可以呼叫<xref:System.Messaging.MessageQueue.PeekByLookupId%2A>或<xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A>直接移至該訊息並查看或抓取佇列中與資料指標必須在佇列前端開始和結束時佇列的瀏覽不同的是函式中，取得佇列中訊息的查閱識別項是應用程式的責任。</xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> </xref:System.Messaging.MessageQueue.PeekByLookupId%2A> 取得查詢的識別項的一種可能的方式是建立快取的每個訊息的識別項，因為它們被放在佇列中的元件會叫用的目的地佇列的觸發程序。"
  syntax:
    content: public long LookupId { get; }
    return:
      type: System.Int64
      description: "訊息的查閱識別項，這由訊息佇列產生，而且是專用的佇列訊息的所在位置。"
  overload: System.Messaging.Message.LookupId*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "未安裝 MSMQ 3.0。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或者-忽略 LookupId 內容來篩選訊息佇列。"
  platform:
  - net462
- uid: System.Messaging.Message.MessageType
  id: MessageType
  parent: System.Messaging.Message
  langs:
  - csharp
  name: MessageType
  nameWithType: Message.MessageType
  fullName: System.Messaging.Message.MessageType
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: 'Gets the message type: <xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Acknowledgment&quot; name=&quot;Acknowledgment&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Report&quot; name=&quot;Report&quot; href=&quot;&quot;></xref>.'
  remarks: "訊息佇列傳送訊息時，通常設定這個屬性。 訊息佇列訊息可以是下列類型之一:- `Normal`，這一般訊息從傳送至佇列，應用程式，或回應訊息傳回給傳送應用程式。      - `Acknowledgement`，由訊息佇列產生每當傳送應用程式要求。 例如，訊息佇列可以產生正或負訊息，以表示原始訊息已抵達或已讀取。 訊息佇列會將適當的認可訊息傳回給傳送應用程式所指定的管理佇列。      - `Report`，每當報告佇列在來源佇列管理員定義訊息佇列會產生。 當啟用追蹤時，訊息佇列傳送報告訊息至訊息佇列報告佇列每次原始訊息進入或離開訊息佇列伺服器。"
  example:
  - "The following code example displays the value of a message's MessageType property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageType MessageType { get; }
    return:
      type: System.Messaging.MessageType
      description: "MessageType 值的其中一個。"
  overload: System.Messaging.Message.MessageType*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或者-訊息佇列會經過篩選，會忽略此訊息類型屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.Priority
  id: Priority
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Priority
  nameWithType: Message.Priority
  fullName: System.Messaging.Message.Priority
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定訊息的優先權，用來決定放置訊息佇列的位置。"
  remarks: "Priority 屬性會影響訊息佇列處理的方式將訊息同時路由時，以及當它到達其目的地。 較高優先權的訊息是在路由期間給予喜好設定，並且插入目的端佇列的前端。 具有相同優先順序的訊息會根據抵達時間在佇列中放置。       您可以設定只針對非交易式訊息的有意義的優先權。 訊息佇列會自動設定交易式訊息的優先權`Lowest`，因而導致交易式訊息的優先權會被忽略。"
  example:
  - "The following code example sends two messages of different priorities to the queue, and retrieves them subsequently.  \n  \n [!code-cpp[Message.DefaultPropertiesToSend#1](~/add/codesnippet/cpp/p-system.messaging.messa_87_1.cpp)]\n [!code-vb[Message.DefaultPropertiesToSend#1](~/add/codesnippet/visualbasic/p-system.messaging.messa_87_1.vb)]\n [!code-cs[Message.DefaultPropertiesToSend#1](~/add/codesnippet/csharp/p-system.messaging.messa_87_1.cs)]"
  syntax:
    content: public System.Messaging.MessagePriority Priority { get; set; }
    return:
      type: System.Messaging.MessagePriority
      description: "其中一個<xref href=&quot;System.Messaging.MessagePriority&quot;></xref>代表非交易式訊息的優先權等級的值。 預設值是<xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.Priority*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會略過的優先權屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.Recoverable
  id: Recoverable
  parent: System.Messaging.Message
  langs:
  - csharp
  name: Recoverable
  nameWithType: Message.Recoverable
  fullName: System.Messaging.Message.Recoverable
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定值，指出是否保證訊息傳遞發生電腦故障或網路問題時。"
  remarks: "可復原的屬性會指出是否保證訊息傳遞，即使目的地佇列來路由訊息時電腦當機。       如果訊息的傳遞保證，訊息儲存在本機的路由中的每一個步驟，直到訊息成功轉送至下一部電腦。 可復原的屬性設定為`true`可能會影響輸送量。       如果訊息是交易式，會自動訊息佇列將訊息視為可復原，可修復屬性的值為何。"
  example:
  - "The following code example gets and sets the value of a message's Recoverable property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool Recoverable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果訊息的傳遞保證 （透過將訊息儲存在磁碟路由）。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果不保證傳遞。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.Recoverable*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會略過的可修復屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.ResponseQueue
  id: ResponseQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
  fullName: System.Messaging.Message.ResponseQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定接收應用程式產生的回應訊息的佇列。"
  remarks: "ResponseQueue 屬性會識別接收應用程式所產生的回應訊息，以便接收應用程式傳回給傳送應用程式的佇列。 應用程式傳送其訊息時，傳送應用程式指定回應佇列。 任何可用的佇列都可以指定為回應佇列。       傳回至回應佇列的訊息是特定應用程式。 應用程式必須定義訊息，以及動作接收的訊息時要採取的內容。"
  example:
  - "The following code example gets and sets the value of a message's ResponseQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue ResponseQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "<xref href=&quot;System.Messaging.MessageQueue&quot;> </xref>至哪些應用程式所產生的回應會傳回訊息。 預設值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.ResponseQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 ResponseQueue 屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.SecurityContext
  id: SecurityContext
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SecurityContext
  nameWithType: Message.SecurityContext
  fullName: System.Messaging.Message.SecurityContext
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定訊息的安全性內容。"
  syntax:
    content: public System.Messaging.SecurityContext SecurityContext { get; set; }
    return:
      type: System.Messaging.SecurityContext
      description: "A <xref href=&quot;System.Messaging.SecurityContext&quot;> </xref>包含訊息的安全性內容，如果先前已設定之屬性的物件; 否則為 NULL。"
  overload: System.Messaging.Message.SecurityContext*
  exceptions: []
  platform:
  - net462
- uid: System.Messaging.Message.SenderCertificate
  id: SenderCertificate
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
  fullName: System.Messaging.Message.SenderCertificate
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定用來驗證訊息的安全性憑證。"
  remarks: "當訊息包含外部安全性憑證時，接收應用程式會使用 SenderCertificate 屬性。       訊息佇列可以驗證訊息的內部或外部的安全性憑證。 訊息佇列會提供用來驗證訊息完整性的內部憑證。 憑證授權單位提供的外部憑證，您可以透過訊息 SenderCertificate 屬性存取。 除了讓訊息佇列來驗證訊息、 外部憑證可讓接收應用程式進一步驗證寄件者。 發生內部憑證已經沒有可用的值，可接收的應用程式。       必須以目錄服務的訊息佇列系統註冊的外部憑證。 外部憑證包含憑證授權單位、 憑證使用者、 憑證的有效期、 公開金鑰憑證的使用者和憑證授權單位的簽章的相關資訊。"
  syntax:
    content: public byte[] SenderCertificate { get; set; }
    return:
      type: System.Byte[]
      description: "代表安全性憑證，以確認訊息傳送者訊息佇列使用的位元組值陣列。 預設為零長度陣列。"
  overload: System.Messaging.Message.SenderCertificate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 SenderCertificate 屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.SenderId
  id: SenderId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderId
  nameWithType: Message.SenderId
  fullName: System.Messaging.Message.SenderId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得傳送使用者的識別項。"
  remarks: "如果<xref:System.Messaging.Message.AttachSenderId%2A>屬性是`false`，寄件者識別碼 屬性中指定的寄件者識別項未附加至訊息傳送時。</xref:System.Messaging.Message.AttachSenderId%2A> 這表示訊息佇列將訊息傳送到目的地佇列時，不應該驗證寄件者。 如果<xref:System.Messaging.Message.AttachSenderId%2A>屬性是`true`，SenderId 屬性值是訊息已驗證時，才可信任。</xref:System.Messaging.Message.AttachSenderId%2A> 使用<xref:System.Messaging.Message.Authenticated%2A>屬性搭配使用具有 SenderId 屬性來驗證寄件者的存取權限。</xref:System.Messaging.Message.Authenticated%2A>       連接器應用程式是使用連接器伺服器以提供訊息佇列和其他佇列的系統之間的通訊的應用程式。 訊息佇列會要求連接器應用程式提供寄件者識別。 您必須設定<xref:System.Messaging.Message.ConnectorType%2A>當連接器應用程式透過傳送訊息的屬性。</xref:System.Messaging.Message.ConnectorType%2A>"
  syntax:
    content: public byte[] SenderId { get; }
    return:
      type: System.Byte[]
      description: "識別寄件者的位元組值陣列。 接收佇列管理員會使用識別碼時，它會驗證來驗證寄件者訊息和佇列的寄件者的存取權限的訊息。"
  overload: System.Messaging.Message.SenderId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或者-訊息佇列會經過篩選，忽略 SenderId 屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.SenderVersion
  id: SenderVersion
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SenderVersion
  nameWithType: Message.SenderVersion
  fullName: System.Messaging.Message.SenderVersion
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得用來傳送訊息的訊息佇列的版本。"
  remarks: "SenderVersion 屬性是很重要的特定功能。 例如，只要 Message Queuing 2.0 和更新版本，支援交易處理和數位簽章可用來驗證 MSMQ 1.0 所傳送的訊息。       傳送佇列管理員在傳送訊息時設定 SenderVersion 屬性。"
  example:
  - "The following code example displays the value of a message's SenderVersion property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public long SenderVersion { get; }
    return:
      type: System.Int64
      description: "用來傳送訊息的訊息佇列版本。"
  overload: System.Messaging.Message.SenderVersion*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或者-訊息佇列會經過篩選，忽略 SenderVersion 屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.SentTime
  id: SentTime
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SentTime
  nameWithType: Message.SentTime
  fullName: System.Messaging.Message.SentTime
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得來源佇列管理員傳送訊息時傳送電腦上的日期和時間。"
  remarks: "SentTime 屬性會為此電腦的本機時間調整的執行個體<xref:System.Messaging.Message>類別會建立。</xref:System.Messaging.Message> 這個時區可以不同於來源和目的地佇列。"
  example:
  - "The following code example displays the value of a message's SentTime property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public DateTime SentTime { get; }
    return:
      type: System.DateTime
      description: "A<xref:System.DateTime>表示傳送訊息的時間。</xref:System.DateTime>"
  overload: System.Messaging.Message.SentTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或者-訊息佇列會經過篩選，忽略 SentTime 屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.SourceMachine
  id: SourceMachine
  parent: System.Messaging.Message
  langs:
  - csharp
  name: SourceMachine
  nameWithType: Message.SourceMachine
  fullName: System.Messaging.Message.SourceMachine
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得產生訊息的電腦。"
  remarks: "以 SourceMachine 屬性的格式不包含上述兩個正斜線 (\\\\\\\\)。 例如，`myServer`是有效的 SourceMachine。"
  example:
  - "The following code example displays the value of a message's SourceMachine property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string SourceMachine { get; }
    return:
      type: System.String
      description: "傳送訊息之電腦的名稱。"
  overload: System.Messaging.Message.SourceMachine*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或者-訊息佇列會經過篩選，忽略以 SourceMachine 屬性。"
  - type: System.Messaging.MessageQueueException
    commentId: T:System.Messaging.MessageQueueException
    description: "無法存取電腦資訊 」 或 「 目錄服務。"
  platform:
  - net462
- uid: System.Messaging.Message.TimeToBeReceived
  id: TimeToBeReceived
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
  fullName: System.Messaging.Message.TimeToBeReceived
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定從目的地佇列等候接收訊息的時間的最大數量。"
  remarks: "TimeToBeReceived 屬性會指定傳送訊息從目的地佇列等候接收的總時間。 時間限制包括花在到達目的地佇列以及之前接收到訊息佇列中等待的時間花費的時間。      > [!CAUTION] > 時使用依存性用戶端電腦，必須與執行訊息佇列伺服器的時鐘同步處理用戶端電腦上的時鐘。 否則，無法預期的行為可能會造成當傳送訊息的 TimeToBeReceived 屬性不是<xref:System.Messaging.Message.InfiniteTimeout>.</xref:System.Messaging.Message.InfiniteTimeout>       如果 TimeToBeReceived 屬性所指定的間隔到期之前從佇列移除訊息，訊息佇列捨棄的訊息中有兩種。 如果訊息的<xref:System.Messaging.Message.UseDeadLetterQueue%2A>屬性是`true`，訊息傳送至寄不出信件佇列。</xref:System.Messaging.Message.UseDeadLetterQueue%2A> 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`，會忽略該訊息。</xref:System.Messaging.Message.UseDeadLetterQueue%2A>       您可以設定訊息的<xref:System.Messaging.Message.AcknowledgeType%2A>屬性來要求的訊息佇列傳送負認可訊息傳回傳送應用程式計時器終止之前，不會擷取訊息。</xref:System.Messaging.Message.AcknowledgeType%2A>       如果 TimeToBeReceived 屬性所指定的值所指定的值少於<xref:System.Messaging.Message.TimeToReachQueue%2A>屬性，TimeToBeReceived 會優先。</xref:System.Messaging.Message.TimeToReachQueue%2A>       在單一交易中傳送的數個訊息，訊息佇列會使用第一個訊息的 TimeToBeReceived 屬性。"
  example:
  - "The following code example gets and sets the value of a message's TimeToBeReceived property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public TimeSpan TimeToBeReceived { get; set; }
    return:
      type: System.TimeSpan
      description: "傳送的訊息，從目的地佇列等候接收的總時間。 預設值是<xref href=&quot;System.Messaging.Message.InfiniteTimeout&quot;> </xref>。"
  overload: System.Messaging.Message.TimeToBeReceived*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 TimeToBeReceived 屬性篩選。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定給 TimeToBeReceived 無效的值。"
  platform:
  - net462
- uid: System.Messaging.Message.TimeToReachQueue
  id: TimeToReachQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
  fullName: System.Messaging.Message.TimeToReachQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定訊息抵達佇列的時間的最大數量。"
  remarks: "如果訊息抵達其目的端之前到期，TimeToReachQueue 屬性所指定的間隔，訊息佇列就會捨棄中有兩種訊息。 如果訊息的<xref:System.Messaging.Message.UseDeadLetterQueue%2A>屬性是`true`，訊息傳送至寄不出信件佇列。</xref:System.Messaging.Message.UseDeadLetterQueue%2A> 如果<xref:System.Messaging.Message.UseDeadLetterQueue%2A>是`false`，會忽略該訊息，您可以設定他訊息<xref:System.Messaging.Message.AcknowledgeType%2A>屬性來要求的訊息佇列傳送負認可訊息傳回傳送應用程式在計時器逾時前未到達的訊息。</xref:System.Messaging.Message.AcknowledgeType%2A> </xref:System.Messaging.Message.UseDeadLetterQueue%2A>       如果 TimeToReachQueue 屬性設定為 0 秒，訊息佇列會嘗試一次訊息傳送至其目的地 — 如果佇列等待訊息。 如果本機佇列，訊息永遠會到達。       TimeToReachQueue 屬性所指定的值是否大於所指定的值<xref:System.Messaging.Message.TimeToBeReceived%2A>屬性，<xref:System.Messaging.Message.TimeToBeReceived%2A>優先。</xref:System.Messaging.Message.TimeToBeReceived%2A> </xref:System.Messaging.Message.TimeToBeReceived%2A>       當在單一交易中傳送數個訊息時，訊息佇列會使用第一個訊息的 TimeToReachQueue 屬性。"
  example:
  - "The following code example gets and sets the value of a message's TimeToReachQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public TimeSpan TimeToReachQueue { get; set; }
    return:
      type: System.TimeSpan
      description: "訊息抵達目的端佇列的時間限制，開始時間的訊息會傳送。 預設值是<xref href=&quot;System.Messaging.Message.InfiniteTimeout&quot;> </xref>。"
  overload: System.Messaging.Message.TimeToReachQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 TimeToReachQueue 屬性篩選。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "TimeToReachQueue 為指定的值無效。 它可能表示負數。"
  platform:
  - net462
- uid: System.Messaging.Message.TransactionId
  id: TransactionId
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TransactionId
  nameWithType: Message.TransactionId
  fullName: System.Messaging.Message.TransactionId
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得的交易的訊息是組件的識別項。"
  remarks: "接收應用程式會使用 TransactionId 屬性，確認已為特定交易的一部分傳送一則訊息。 交易識別項包含傳送端電腦 （第一個 16 位元），後面接著一個 4 位元組交易序號識別的項。       這個屬性是僅供訊息佇列版本 2.0 和更新版本。       交易識別項不保證是唯一的因為交易序號不持續性，而且它們重新啟動一段 2 <sup>20</sup>。 訊息佇列僅保證，後續的交易都會都有不同的交易序號。       您可以使用之 TransactionId 屬性連同<xref:System.Messaging.Message.IsFirstInTransaction%2A>和<xref:System.Messaging.Message.IsLastInTransaction%2A>屬性，以驗證交易界限。</xref:System.Messaging.Message.IsLastInTransaction%2A> </xref:System.Messaging.Message.IsFirstInTransaction%2A>"
  example:
  - "The following code example displays the value of a message's TransactionId property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public string TransactionId { get; }
    return:
      type: System.String
      description: "與訊息相關聯的交易識別碼。"
  overload: System.Messaging.Message.TransactionId*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或者-訊息佇列會經過篩選，忽略 TransactionId 屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.TransactionStatusQueue
  id: TransactionStatusQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
  fullName: System.Messaging.Message.TransactionStatusQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "在來源電腦上取得交易狀態佇列。"
  remarks: "TransactionStatusQueue 屬性會識別讀取回條認可接收連接器應用程式的來源電腦上的交易式佇列。 訊息佇列設定屬性，並擷取交易式訊息傳送至外部佇列時，連接器應用程式會使用屬性。       非 Microsoft Message Queuing 的佇列系統中存在的外部索引的佇列。 訊息佇列會與透過連接器應用程式的這類佇列通訊。       連接器應用程式可以傳送認可訊息傳回給傳送應用程式使用的交易狀態佇列。 即使傳送應用程式不會要求其他認可的交易狀態應該會收到這些通知。"
  example:
  - "The following code example displays the value of a message's TransactionStatusQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }
    return:
      type: System.Messaging.MessageQueue
      description: "交易狀態的來源電腦上，用來傳送認可訊息傳回給傳送應用程式。 預設值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.TransactionStatusQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息尚未傳送。 這個屬性只可以讀取佇列中擷取的訊息。       -或者-訊息佇列會經過篩選，忽略 TransactionStatusQueue 屬性。"
  platform:
  - net462
- uid: System.Messaging.Message.UseAuthentication
  id: UseAuthentication
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
  fullName: System.Messaging.Message.UseAuthentication
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定值，指出是否訊息 （或必須） 驗證之前傳送。"
  remarks: "UseAuthentication 屬性會指定是否需要驗證訊息。 如果傳送應用程式要求驗證，訊息佇列的數位簽章，並使用它來簽署訊息在傳送和接收時，驗證訊息。       如果是 UseAuthentication`false`和訊息已傳送至只接受已驗證的訊息佇列、 到達佇列時，將會拒絕訊息。       您無法判斷是否訊息無法通過驗證它的內容。 傳送至佇列之前，訊息佇列就會捨棄這類訊息。 不過，您可以要求會傳送通知訊息，如果傳遞失敗可防止訊息到達佇列。"
  syntax:
    content: public bool UseAuthentication { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果傳送應用程式要求驗證的訊息。，否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.UseAuthentication*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 UseAuthentication 屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.UseDeadLetterQueue
  id: UseDeadLetterQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
  fullName: System.Messaging.Message.UseDeadLetterQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定值，指出無法傳遞訊息的複本是否應該傳送到寄不出信件佇列。"
  remarks: "<xref:System.Messaging.Message.UseJournalQueue%2A>和 UseDeadLetterQueue 屬性會指定如何追蹤訊息佇列訊息。</xref:System.Messaging.Message.UseJournalQueue%2A> 如果是 UseDeadLetterQueue `true`，傳遞失敗 （非交易式訊息），導致傳送至非交易式寄不出信件佇列無法傳送訊息的電腦上的訊息。 傳遞失敗可能被因郵件計時器過期，例如。       在交易式訊息的傳遞失敗，訊息佇列傳送訊息至交易式寄不出信件佇列中所有負數且不確定的情況下在來源電腦上。       當您將訊息儲存在寄不出信件佇列時，則應清除定期以移除不再需要的訊息佇列。 計算儲存在寄不出信件佇列對佇列所在的電腦的大小配額的訊息。 電腦配額由系統管理員所設定，並指的是配置來儲存訊息的整個電腦上，不只是在單一佇列的大小。       您不會建立日誌或寄不出的信件佇列。 這些是訊息佇列會產生這兩個系統佇列。"
  example:
  - "The following code example gets and sets the value of a message's UseDeadLetterQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseDeadLetterQueue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果訊息傳遞失敗會導致傳送到寄不出的信件佇列訊息的複本，否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.UseDeadLetterQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 UseDeadLetterQueue 屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.UseEncryption
  id: UseEncryption
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseEncryption
  nameWithType: Message.UseEncryption
  fullName: System.Messaging.Message.UseEncryption
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定值，指出是否要建立私用訊息。"
  remarks: "如果訊息是私人的其主體已加密，然後再傳送和接收時解密。 若要傳送的私用訊息，傳送應用程式必須指定用於加密和 （選擇性） 的加密演算法。       傳送私用的訊息時，您的應用程式不必執行訊息加密。 訊息佇列可以為您加密訊息本文，如果您的應用程式傳送 Microsoft Windows 2000 的企業、 可存取目錄服務中的訊息。 接收私用的訊息時，接收佇列管理員一律會解密訊息內文。"
  example:
  - "The following code example gets and sets the value of a message's UseEncryption property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseEncryption { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要求訊息佇列來加密訊息。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.UseEncryption*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 UseEncryption 屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.UseJournalQueue
  id: UseJournalQueue
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
  fullName: System.Messaging.Message.UseJournalQueue
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定值，指出是否應該在原始電腦上電腦日誌中保留訊息的複本。"
  remarks: "UseJournalQueue 和<xref:System.Messaging.Message.UseDeadLetterQueue%2A>屬性會指定如何追蹤訊息佇列訊息。</xref:System.Messaging.Message.UseDeadLetterQueue%2A> 如果是 UseJournalQueue `true`，然後複本就會保留在訊息已傳送的每個步驟的起始電腦上電腦日誌中。       如果目的地佇列是在遠端電腦上傳送的訊息只會複製到日誌佇列。 如果目的地是本機電腦上，訊息會直接傳送至佇列。沒有任何需要日誌的中間步驟。       當您將訊息儲存在日誌佇列中時，清除佇列，定期以移除不再需要的訊息。 計算儲存在日誌佇列的佇列所在的電腦配額的訊息。 （由系統管理員會設定電腦配額）。     您不會建立日誌或寄不出的信件佇列。 這些是訊息佇列會產生這兩個系統佇列。"
  example:
  - "The following code example gets and sets the value of a message's UseJournalQueue property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseJournalQueue { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要求在原始電腦的電腦日誌中保留一份訊息，訊息之後，將已成功傳輸 （從來源到下一部伺服器電腦）;否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.UseJournalQueue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 UseJournalQueue 屬性篩選。"
  platform:
  - net462
- uid: System.Messaging.Message.UseTracing
  id: UseTracing
  parent: System.Messaging.Message
  langs:
  - csharp
  name: UseTracing
  nameWithType: Message.UseTracing
  fullName: System.Messaging.Message.UseTracing
  type: Property
  assemblies:
  - System.Messaging
  namespace: System.Messaging
  summary: "取得或設定值，指出是否要向其目的地佇列為時加以追蹤訊息。"
  remarks: "UseTracing 屬性會指定是否要向其目的地佇列為時加以追蹤訊息的路由。 如果`true`，的每當訊息通過訊息佇列路由伺服器傳送 （由訊息佇列產生） 報告訊息至報告佇列。 來源佇列管理員所指定的報告佇列。 報告佇列都不限於報告訊息產生的訊息佇列。您應用程式所產生的訊息也可以傳送至報告佇列。       使用追蹤牽涉到設定 Active Directory，並指定訊息佇列企業報告佇列。 系統管理員設定這些設定。"
  example:
  - "The following code example gets and sets the value of a message's UseTracing property.  \n  \n [!code-cs[XpsCreate#XpsCreateAddPkgContent](~/add/codesnippet/csharp/XpsCreate/XpsCreate.cs#xpscreateaddpkgcontent)]"
  syntax:
    content: public bool UseTracing { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果每個由原始訊息路由至目的地佇列的中繼步驟產生的報表傳送給系統的報告佇列。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Messaging.Message.UseTracing*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "訊息佇列會忽略 UseTracing 屬性篩選。"
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.Messaging.MessageQueueException
  parent: System.Messaging
  isExternal: false
  name: MessageQueueException
  nameWithType: MessageQueueException
  fullName: System.Messaging.MessageQueueException
- uid: System.Messaging.Message.#ctor
  parent: System.Messaging.Message
  isExternal: false
  name: Message()
  nameWithType: Message.Message()
  fullName: System.Messaging.Message.Message()
- uid: System.Messaging.Message.#ctor(System.Object)
  parent: System.Messaging.Message
  isExternal: false
  name: Message(Object)
  nameWithType: Message.Message(Object)
  fullName: System.Messaging.Message.Message(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)
  parent: System.Messaging.Message
  isExternal: false
  name: Message(Object,IMessageFormatter)
  nameWithType: Message.Message(Object,IMessageFormatter)
  fullName: System.Messaging.Message.Message(Object,IMessageFormatter)
- uid: System.Messaging.IMessageFormatter
  parent: System.Messaging
  isExternal: false
  name: IMessageFormatter
  nameWithType: IMessageFormatter
  fullName: System.Messaging.IMessageFormatter
- uid: System.Messaging.Message.AcknowledgeType
  parent: System.Messaging.Message
  isExternal: false
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
  fullName: System.Messaging.Message.AcknowledgeType
- uid: System.Messaging.AcknowledgeTypes
  parent: System.Messaging
  isExternal: false
  name: AcknowledgeTypes
  nameWithType: AcknowledgeTypes
  fullName: System.Messaging.AcknowledgeTypes
- uid: System.Messaging.Message.Acknowledgment
  parent: System.Messaging.Message
  isExternal: false
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
  fullName: System.Messaging.Message.Acknowledgment
- uid: System.Messaging.Acknowledgment
  parent: System.Messaging
  isExternal: false
  name: Acknowledgment
  nameWithType: Acknowledgment
  fullName: System.Messaging.Acknowledgment
- uid: System.Messaging.Message.AdministrationQueue
  parent: System.Messaging.Message
  isExternal: false
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
  fullName: System.Messaging.Message.AdministrationQueue
- uid: System.Messaging.MessageQueue
  parent: System.Messaging
  isExternal: false
  name: MessageQueue
  nameWithType: MessageQueue
  fullName: System.Messaging.MessageQueue
- uid: System.Messaging.Message.AppSpecific
  parent: System.Messaging.Message
  isExternal: false
  name: AppSpecific
  nameWithType: Message.AppSpecific
  fullName: System.Messaging.Message.AppSpecific
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Messaging.Message.ArrivedTime
  parent: System.Messaging.Message
  isExternal: false
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
  fullName: System.Messaging.Message.ArrivedTime
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Messaging.Message.AttachSenderId
  parent: System.Messaging.Message
  isExternal: false
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
  fullName: System.Messaging.Message.AttachSenderId
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Messaging.Message.Authenticated
  parent: System.Messaging.Message
  isExternal: false
  name: Authenticated
  nameWithType: Message.Authenticated
  fullName: System.Messaging.Message.Authenticated
- uid: System.Messaging.Message.AuthenticationProviderName
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
  fullName: System.Messaging.Message.AuthenticationProviderName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Messaging.Message.AuthenticationProviderType
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
  fullName: System.Messaging.Message.AuthenticationProviderType
- uid: System.Messaging.CryptographicProviderType
  parent: System.Messaging
  isExternal: false
  name: CryptographicProviderType
  nameWithType: CryptographicProviderType
  fullName: System.Messaging.CryptographicProviderType
- uid: System.Messaging.Message.Body
  parent: System.Messaging.Message
  isExternal: false
  name: Body
  nameWithType: Message.Body
  fullName: System.Messaging.Message.Body
- uid: System.Messaging.Message.BodyStream
  parent: System.Messaging.Message
  isExternal: false
  name: BodyStream
  nameWithType: Message.BodyStream
  fullName: System.Messaging.Message.BodyStream
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.Messaging.Message.BodyType
  parent: System.Messaging.Message
  isExternal: false
  name: BodyType
  nameWithType: Message.BodyType
  fullName: System.Messaging.Message.BodyType
- uid: System.Messaging.Message.ConnectorType
  parent: System.Messaging.Message
  isExternal: false
  name: ConnectorType
  nameWithType: Message.ConnectorType
  fullName: System.Messaging.Message.ConnectorType
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.Messaging.Message.CorrelationId
  parent: System.Messaging.Message
  isExternal: false
  name: CorrelationId
  nameWithType: Message.CorrelationId
  fullName: System.Messaging.Message.CorrelationId
- uid: System.Messaging.Message.DestinationQueue
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
  fullName: System.Messaging.Message.DestinationQueue
- uid: System.Messaging.Message.DestinationSymmetricKey
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
  fullName: System.Messaging.Message.DestinationSymmetricKey
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Messaging.Message.DigitalSignature
  parent: System.Messaging.Message
  isExternal: false
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
  fullName: System.Messaging.Message.DigitalSignature
- uid: System.Messaging.Message.EncryptionAlgorithm
  parent: System.Messaging.Message
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
  fullName: System.Messaging.Message.EncryptionAlgorithm
- uid: System.Messaging.EncryptionAlgorithm
  parent: System.Messaging
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: EncryptionAlgorithm
  fullName: System.Messaging.EncryptionAlgorithm
- uid: System.Messaging.Message.Extension
  parent: System.Messaging.Message
  isExternal: false
  name: Extension
  nameWithType: Message.Extension
  fullName: System.Messaging.Message.Extension
- uid: System.Messaging.Message.Formatter
  parent: System.Messaging.Message
  isExternal: false
  name: Formatter
  nameWithType: Message.Formatter
  fullName: System.Messaging.Message.Formatter
- uid: System.Messaging.Message.HashAlgorithm
  parent: System.Messaging.Message
  isExternal: false
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
  fullName: System.Messaging.Message.HashAlgorithm
- uid: System.Messaging.HashAlgorithm
  parent: System.Messaging
  isExternal: false
  name: HashAlgorithm
  nameWithType: HashAlgorithm
  fullName: System.Messaging.HashAlgorithm
- uid: System.Messaging.Message.Id
  parent: System.Messaging.Message
  isExternal: false
  name: Id
  nameWithType: Message.Id
  fullName: System.Messaging.Message.Id
- uid: System.Messaging.Message.InfiniteTimeout
  parent: System.Messaging.Message
  isExternal: false
  name: InfiniteTimeout
  nameWithType: Message.InfiniteTimeout
  fullName: System.Messaging.Message.InfiniteTimeout
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Messaging.Message.IsFirstInTransaction
  parent: System.Messaging.Message
  isExternal: false
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
  fullName: System.Messaging.Message.IsFirstInTransaction
- uid: System.Messaging.Message.IsLastInTransaction
  parent: System.Messaging.Message
  isExternal: false
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
  fullName: System.Messaging.Message.IsLastInTransaction
- uid: System.Messaging.Message.Label
  parent: System.Messaging.Message
  isExternal: false
  name: Label
  nameWithType: Message.Label
  fullName: System.Messaging.Message.Label
- uid: System.Messaging.Message.LookupId
  parent: System.Messaging.Message
  isExternal: false
  name: LookupId
  nameWithType: Message.LookupId
  fullName: System.Messaging.Message.LookupId
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Messaging.Message.MessageType
  parent: System.Messaging.Message
  isExternal: false
  name: MessageType
  nameWithType: Message.MessageType
  fullName: System.Messaging.Message.MessageType
- uid: System.Messaging.MessageType
  parent: System.Messaging
  isExternal: false
  name: MessageType
  nameWithType: MessageType
  fullName: System.Messaging.MessageType
- uid: System.Messaging.Message.Priority
  parent: System.Messaging.Message
  isExternal: false
  name: Priority
  nameWithType: Message.Priority
  fullName: System.Messaging.Message.Priority
- uid: System.Messaging.MessagePriority
  parent: System.Messaging
  isExternal: false
  name: MessagePriority
  nameWithType: MessagePriority
  fullName: System.Messaging.MessagePriority
- uid: System.Messaging.Message.Recoverable
  parent: System.Messaging.Message
  isExternal: false
  name: Recoverable
  nameWithType: Message.Recoverable
  fullName: System.Messaging.Message.Recoverable
- uid: System.Messaging.Message.ResponseQueue
  parent: System.Messaging.Message
  isExternal: false
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
  fullName: System.Messaging.Message.ResponseQueue
- uid: System.Messaging.Message.SecurityContext
  parent: System.Messaging.Message
  isExternal: false
  name: SecurityContext
  nameWithType: Message.SecurityContext
  fullName: System.Messaging.Message.SecurityContext
- uid: System.Messaging.SecurityContext
  parent: System.Messaging
  isExternal: false
  name: SecurityContext
  nameWithType: SecurityContext
  fullName: System.Messaging.SecurityContext
- uid: System.Messaging.Message.SenderCertificate
  parent: System.Messaging.Message
  isExternal: false
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
  fullName: System.Messaging.Message.SenderCertificate
- uid: System.Messaging.Message.SenderId
  parent: System.Messaging.Message
  isExternal: false
  name: SenderId
  nameWithType: Message.SenderId
  fullName: System.Messaging.Message.SenderId
- uid: System.Messaging.Message.SenderVersion
  parent: System.Messaging.Message
  isExternal: false
  name: SenderVersion
  nameWithType: Message.SenderVersion
  fullName: System.Messaging.Message.SenderVersion
- uid: System.Messaging.Message.SentTime
  parent: System.Messaging.Message
  isExternal: false
  name: SentTime
  nameWithType: Message.SentTime
  fullName: System.Messaging.Message.SentTime
- uid: System.Messaging.Message.SourceMachine
  parent: System.Messaging.Message
  isExternal: false
  name: SourceMachine
  nameWithType: Message.SourceMachine
  fullName: System.Messaging.Message.SourceMachine
- uid: System.Messaging.Message.TimeToBeReceived
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
  fullName: System.Messaging.Message.TimeToBeReceived
- uid: System.Messaging.Message.TimeToReachQueue
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
  fullName: System.Messaging.Message.TimeToReachQueue
- uid: System.Messaging.Message.TransactionId
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionId
  nameWithType: Message.TransactionId
  fullName: System.Messaging.Message.TransactionId
- uid: System.Messaging.Message.TransactionStatusQueue
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
  fullName: System.Messaging.Message.TransactionStatusQueue
- uid: System.Messaging.Message.UseAuthentication
  parent: System.Messaging.Message
  isExternal: false
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
  fullName: System.Messaging.Message.UseAuthentication
- uid: System.Messaging.Message.UseDeadLetterQueue
  parent: System.Messaging.Message
  isExternal: false
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
  fullName: System.Messaging.Message.UseDeadLetterQueue
- uid: System.Messaging.Message.UseEncryption
  parent: System.Messaging.Message
  isExternal: false
  name: UseEncryption
  nameWithType: Message.UseEncryption
  fullName: System.Messaging.Message.UseEncryption
- uid: System.Messaging.Message.UseJournalQueue
  parent: System.Messaging.Message
  isExternal: false
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
  fullName: System.Messaging.Message.UseJournalQueue
- uid: System.Messaging.Message.UseTracing
  parent: System.Messaging.Message
  isExternal: false
  name: UseTracing
  nameWithType: Message.UseTracing
  fullName: System.Messaging.Message.UseTracing
- uid: System.Messaging.Message.#ctor*
  parent: System.Messaging.Message
  isExternal: false
  name: Message
  nameWithType: Message.Message
- uid: System.Messaging.Message.AcknowledgeType*
  parent: System.Messaging.Message
  isExternal: false
  name: AcknowledgeType
  nameWithType: Message.AcknowledgeType
- uid: System.Messaging.Message.Acknowledgment*
  parent: System.Messaging.Message
  isExternal: false
  name: Acknowledgment
  nameWithType: Message.Acknowledgment
- uid: System.Messaging.Message.AdministrationQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: AdministrationQueue
  nameWithType: Message.AdministrationQueue
- uid: System.Messaging.Message.AppSpecific*
  parent: System.Messaging.Message
  isExternal: false
  name: AppSpecific
  nameWithType: Message.AppSpecific
- uid: System.Messaging.Message.ArrivedTime*
  parent: System.Messaging.Message
  isExternal: false
  name: ArrivedTime
  nameWithType: Message.ArrivedTime
- uid: System.Messaging.Message.AttachSenderId*
  parent: System.Messaging.Message
  isExternal: false
  name: AttachSenderId
  nameWithType: Message.AttachSenderId
- uid: System.Messaging.Message.Authenticated*
  parent: System.Messaging.Message
  isExternal: false
  name: Authenticated
  nameWithType: Message.Authenticated
- uid: System.Messaging.Message.AuthenticationProviderName*
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderName
  nameWithType: Message.AuthenticationProviderName
- uid: System.Messaging.Message.AuthenticationProviderType*
  parent: System.Messaging.Message
  isExternal: false
  name: AuthenticationProviderType
  nameWithType: Message.AuthenticationProviderType
- uid: System.Messaging.Message.Body*
  parent: System.Messaging.Message
  isExternal: false
  name: Body
  nameWithType: Message.Body
- uid: System.Messaging.Message.BodyStream*
  parent: System.Messaging.Message
  isExternal: false
  name: BodyStream
  nameWithType: Message.BodyStream
- uid: System.Messaging.Message.BodyType*
  parent: System.Messaging.Message
  isExternal: false
  name: BodyType
  nameWithType: Message.BodyType
- uid: System.Messaging.Message.ConnectorType*
  parent: System.Messaging.Message
  isExternal: false
  name: ConnectorType
  nameWithType: Message.ConnectorType
- uid: System.Messaging.Message.CorrelationId*
  parent: System.Messaging.Message
  isExternal: false
  name: CorrelationId
  nameWithType: Message.CorrelationId
- uid: System.Messaging.Message.DestinationQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationQueue
  nameWithType: Message.DestinationQueue
- uid: System.Messaging.Message.DestinationSymmetricKey*
  parent: System.Messaging.Message
  isExternal: false
  name: DestinationSymmetricKey
  nameWithType: Message.DestinationSymmetricKey
- uid: System.Messaging.Message.DigitalSignature*
  parent: System.Messaging.Message
  isExternal: false
  name: DigitalSignature
  nameWithType: Message.DigitalSignature
- uid: System.Messaging.Message.EncryptionAlgorithm*
  parent: System.Messaging.Message
  isExternal: false
  name: EncryptionAlgorithm
  nameWithType: Message.EncryptionAlgorithm
- uid: System.Messaging.Message.Extension*
  parent: System.Messaging.Message
  isExternal: false
  name: Extension
  nameWithType: Message.Extension
- uid: System.Messaging.Message.Formatter*
  parent: System.Messaging.Message
  isExternal: false
  name: Formatter
  nameWithType: Message.Formatter
- uid: System.Messaging.Message.HashAlgorithm*
  parent: System.Messaging.Message
  isExternal: false
  name: HashAlgorithm
  nameWithType: Message.HashAlgorithm
- uid: System.Messaging.Message.Id*
  parent: System.Messaging.Message
  isExternal: false
  name: Id
  nameWithType: Message.Id
- uid: System.Messaging.Message.IsFirstInTransaction*
  parent: System.Messaging.Message
  isExternal: false
  name: IsFirstInTransaction
  nameWithType: Message.IsFirstInTransaction
- uid: System.Messaging.Message.IsLastInTransaction*
  parent: System.Messaging.Message
  isExternal: false
  name: IsLastInTransaction
  nameWithType: Message.IsLastInTransaction
- uid: System.Messaging.Message.Label*
  parent: System.Messaging.Message
  isExternal: false
  name: Label
  nameWithType: Message.Label
- uid: System.Messaging.Message.LookupId*
  parent: System.Messaging.Message
  isExternal: false
  name: LookupId
  nameWithType: Message.LookupId
- uid: System.Messaging.Message.MessageType*
  parent: System.Messaging.Message
  isExternal: false
  name: MessageType
  nameWithType: Message.MessageType
- uid: System.Messaging.Message.Priority*
  parent: System.Messaging.Message
  isExternal: false
  name: Priority
  nameWithType: Message.Priority
- uid: System.Messaging.Message.Recoverable*
  parent: System.Messaging.Message
  isExternal: false
  name: Recoverable
  nameWithType: Message.Recoverable
- uid: System.Messaging.Message.ResponseQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: ResponseQueue
  nameWithType: Message.ResponseQueue
- uid: System.Messaging.Message.SecurityContext*
  parent: System.Messaging.Message
  isExternal: false
  name: SecurityContext
  nameWithType: Message.SecurityContext
- uid: System.Messaging.Message.SenderCertificate*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderCertificate
  nameWithType: Message.SenderCertificate
- uid: System.Messaging.Message.SenderId*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderId
  nameWithType: Message.SenderId
- uid: System.Messaging.Message.SenderVersion*
  parent: System.Messaging.Message
  isExternal: false
  name: SenderVersion
  nameWithType: Message.SenderVersion
- uid: System.Messaging.Message.SentTime*
  parent: System.Messaging.Message
  isExternal: false
  name: SentTime
  nameWithType: Message.SentTime
- uid: System.Messaging.Message.SourceMachine*
  parent: System.Messaging.Message
  isExternal: false
  name: SourceMachine
  nameWithType: Message.SourceMachine
- uid: System.Messaging.Message.TimeToBeReceived*
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToBeReceived
  nameWithType: Message.TimeToBeReceived
- uid: System.Messaging.Message.TimeToReachQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: TimeToReachQueue
  nameWithType: Message.TimeToReachQueue
- uid: System.Messaging.Message.TransactionId*
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionId
  nameWithType: Message.TransactionId
- uid: System.Messaging.Message.TransactionStatusQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: TransactionStatusQueue
  nameWithType: Message.TransactionStatusQueue
- uid: System.Messaging.Message.UseAuthentication*
  parent: System.Messaging.Message
  isExternal: false
  name: UseAuthentication
  nameWithType: Message.UseAuthentication
- uid: System.Messaging.Message.UseDeadLetterQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: UseDeadLetterQueue
  nameWithType: Message.UseDeadLetterQueue
- uid: System.Messaging.Message.UseEncryption*
  parent: System.Messaging.Message
  isExternal: false
  name: UseEncryption
  nameWithType: Message.UseEncryption
- uid: System.Messaging.Message.UseJournalQueue*
  parent: System.Messaging.Message
  isExternal: false
  name: UseJournalQueue
  nameWithType: Message.UseJournalQueue
- uid: System.Messaging.Message.UseTracing*
  parent: System.Messaging.Message
  isExternal: false
  name: UseTracing
  nameWithType: Message.UseTracing
