### YamlMime:ManagedReference
items:
- uid: System.Threading.Thread
  id: Thread
  children:
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  - System.Threading.Thread.Abort
  - System.Threading.Thread.Abort(System.Object)
  - System.Threading.Thread.AllocateDataSlot
  - System.Threading.Thread.AllocateNamedDataSlot(System.String)
  - System.Threading.Thread.ApartmentState
  - System.Threading.Thread.BeginCriticalRegion
  - System.Threading.Thread.BeginThreadAffinity
  - System.Threading.Thread.CurrentContext
  - System.Threading.Thread.CurrentCulture
  - System.Threading.Thread.CurrentPrincipal
  - System.Threading.Thread.CurrentThread
  - System.Threading.Thread.CurrentUICulture
  - System.Threading.Thread.DisableComObjectEagerCleanup
  - System.Threading.Thread.EndCriticalRegion
  - System.Threading.Thread.EndThreadAffinity
  - System.Threading.Thread.ExecutionContext
  - System.Threading.Thread.Finalize
  - System.Threading.Thread.FreeNamedDataSlot(System.String)
  - System.Threading.Thread.GetApartmentState
  - System.Threading.Thread.GetCompressedStack
  - System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  - System.Threading.Thread.GetDomain
  - System.Threading.Thread.GetDomainID
  - System.Threading.Thread.GetHashCode
  - System.Threading.Thread.GetNamedDataSlot(System.String)
  - System.Threading.Thread.Interrupt
  - System.Threading.Thread.IsAlive
  - System.Threading.Thread.IsBackground
  - System.Threading.Thread.IsThreadPoolThread
  - System.Threading.Thread.Join
  - System.Threading.Thread.Join(System.Int32)
  - System.Threading.Thread.Join(System.TimeSpan)
  - System.Threading.Thread.ManagedThreadId
  - System.Threading.Thread.MemoryBarrier
  - System.Threading.Thread.Name
  - System.Threading.Thread.Priority
  - System.Threading.Thread.ResetAbort
  - System.Threading.Thread.Resume
  - System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  - System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  - System.Threading.Thread.Sleep(System.Int32)
  - System.Threading.Thread.Sleep(System.TimeSpan)
  - System.Threading.Thread.SpinWait(System.Int32)
  - System.Threading.Thread.Start
  - System.Threading.Thread.Start(System.Object)
  - System.Threading.Thread.Suspend
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  - System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.Threading.Thread.ThreadState
  - System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  - System.Threading.Thread.VolatileRead(System.Byte@)
  - System.Threading.Thread.VolatileRead(System.Double@)
  - System.Threading.Thread.VolatileRead(System.Int16@)
  - System.Threading.Thread.VolatileRead(System.Int32@)
  - System.Threading.Thread.VolatileRead(System.Int64@)
  - System.Threading.Thread.VolatileRead(System.IntPtr@)
  - System.Threading.Thread.VolatileRead(System.Object@)
  - System.Threading.Thread.VolatileRead(System.SByte@)
  - System.Threading.Thread.VolatileRead(System.Single@)
  - System.Threading.Thread.VolatileRead(System.UInt16@)
  - System.Threading.Thread.VolatileRead(System.UInt32@)
  - System.Threading.Thread.VolatileRead(System.UInt64@)
  - System.Threading.Thread.VolatileRead(System.UIntPtr@)
  - System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  - System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  - System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  - System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  - System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  - System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  - System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  - System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  - System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  - System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  - System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  - System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  - System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  - System.Threading.Thread.Yield
  langs:
  - csharp
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
  type: Class
  summary: "建立和控制執行緒，設定其優先權，並取得其狀態。"
  remarks: "當處理程序啟動時，common language runtime 會自動建立單一前景執行緒來執行應用程式程式碼。 這個主要前景執行緒，以及處理序可建立一或多個執行緒來執行此程序相關聯的程式碼的一部分。 這些執行緒可以執行在前景或背景。 此外，您可以使用<xref:System.Threading.ThreadPool>common language runtime 所管理的背景工作執行緒上執行程式碼的類別。</xref:System.Threading.ThreadPool>       本章節內容[啟動執行緒](#Starting)[擷取執行緒物件](#Retrieving)[前景和背景執行緒](#Foreground)[文化特性和執行緒](#Culture)[取得的資訊關於和控制執行緒](#Properties)[存取執行緒類別的原始程式碼](#Source)<a name=&quot;Starting&quot;> </a> # # 啟動執行緒藉由提供委派，表示要在其類別建構函式中執行執行緒的方法啟動執行緒。                                然後呼叫<xref:System.Threading.Thread.Start%2A>方法開始執行。</xref:System.Threading.Thread.Start%2A>       執行緒建構函式可以採用兩個委派類型，根據是否將引數傳遞至方法，以執行其中一項:-如果方法沒有引數，傳遞<xref:System.Threading.ThreadStart>委派建構函式。</xref:System.Threading.ThreadStart> 簽章︰ ```c#       public delegate void ThreadStart()       ``` ```vb       Public Delegate Sub ThreadStart()       ```下列範例會建立並開始執行的執行緒`ExecuteInForeground`方法。           方法會顯示一些執行緒屬性的相關資訊，然後執行的迴圈，它會暫停半秒並會顯示經過的秒數。 當執行緒已執行至少五秒時，則迴圈結束，且在執行緒結束執行。           [!code-cs[System.Threading.Thread#1](~/add/codesnippet/csharp/t-system.threading.thread_1.cs)][!code-vb[System.Threading.Thread#1](~/add/codesnippet/visualbasic/t-system.threading.thread_1.vb) ] -如果方法沒有引數，傳遞<xref:System.Threading.ParameterizedThreadStart>委派建構函式。</xref:System.Threading.ParameterizedThreadStart>       簽章︰ ```c#       public delegate void ParameterizedThreadStart(object obj)       ``` ```vb       Public Delegate Sub ParameterizedThreadStart(obj As Object)       ```委派所執行的方法可以再轉型 （C# 中） 或 （在 Visual Basic) 參數轉換成適當的型別。                     下列範例等同於前一個，不同之處在於它會呼叫<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>建構函式。</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 這個版本的`ExecuteInForeground`方法具有單一參數來表示近似的迴圈是執行的毫秒數。           [!code-cs[System.Threading.Thread#2](~/add/codesnippet/csharp/t-system.threading.thread_2.cs)][!code-vb[System.Threading.Thread#2](~/add/codesnippet/visualbasic/t-system.threading.thread_2.vb) ]則不需要保留執行緒物件的參考，一旦您已經啟動執行緒。       執行緒會繼續執行直到完成為止，執行緒程序。      <a name=&quot;Retrieving&quot;></a># # 您可以使用靜態擷取執行緒物件 (`Shared`在 Visual Basic 中)<xref:System.Threading.Thread.CurrentThread%2A>屬性，以擷取目前執行中執行緒的執行緒正在執行的程式碼中的參考。</xref:System.Threading.Thread.CurrentThread%2A> 下列範例會使用<xref:System.Threading.Thread.CurrentThread%2A>屬性來顯示主應用程式執行緒、 另一個前景執行緒，背景執行緒和執行緒集區執行緒的相關資訊。</xref:System.Threading.Thread.CurrentThread%2A>       [!code-cs[System.Threading.Thread#4](~/add/codesnippet/csharp/t-system.threading.thread_3.cs)][!code-vb[System.Threading.Thread#4](~/add/codesnippet/visualbasic/t-system.threading.thread_3.vb) ] <a name=&quot;Foreground&quot;> </a> # # 前景和背景執行緒的執行緒類別的執行個體代表前景執行緒或背景執行緒。         背景執行緒會與相同前景執行緒有一個例外狀況︰ 背景執行緒不會保存執行的處理序，如果所有的前景執行緒已經終止。 一旦所有的前景執行緒都已停止，執行階段會停止所有的背景執行緒，並關閉。       依預設，下列的執行緒執行在前景:-主應用程式執行緒。      的藉由呼叫執行緒類別建構函式建立所有執行緒。       下列執行緒在背景執行預設:-執行緒集區執行緒，也就是由執行階段所維護的背景工作執行緒集區。  您可以在執行緒集區執行緒上設定執行緒集區和排程工作，使用<xref:System.Threading.ThreadPool>類別。</xref:System.Threading.ThreadPool>          > [!NOTE] > 在執行緒集區執行緒上自動執行工作為基礎的非同步作業。 以工作為基礎的非同步作業會使用<xref:System.Threading.Tasks.Task>和<xref:System.Threading.Tasks.Task%601>類別以實作[工作架構非同步模式](~/add/includes/ajax-current-ext-md.md)。</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      -所有執行緒從 unmanaged 程式碼進入 managed 的執行環境。       您可以變更執行緒在背景中執行，藉由設定<xref:System.Threading.Thread.IsBackground%2A>隨時屬性。</xref:System.Threading.Thread.IsBackground%2A>  背景執行緒可用於任何作業，應該只要應用程式正在執行，但應該不會防止應用程式終止，例如監視檔案系統變更或連入通訊端連線。       下列範例說明前景和背景執行緒之間的差異。 就像中的第一個範例[啟動執行緒](#Starting)區段中，不同之處在於它會設定執行緒在背景執行前啟動它。 如輸出所示，它會執行五秒前中斷迴圈。       [!code-cs[System.Threading.Thread#3](~/add/codesnippet/csharp/t-system.threading.thread_4.cs)][!code-vb[System.Threading.Thread#3](~/add/codesnippet/visualbasic/t-system.threading.thread_4.vb) ] <a name=&quot;Culture&quot;> </a> # # 每個執行緒的文化特性和執行緒有所代表的文化特性，<xref:System.Threading.Thread.CurrentCulture%2A>屬性和 UI 文化特性所表示<xref:System.Threading.Thread.CurrentUICulture%2A>屬性。</xref:System.Threading.Thread.CurrentUICulture%2A> </xref:System.Threading.Thread.CurrentCulture%2A>          目前的文化特性支援剖析和格式、 字串比較和排序，這類區分文化特性的作業，而且也會控制執行緒使用的行事曆與書寫系統。 目前 UI 文化特性提供區分文化特性擷取資源檔中的資源。       新的執行緒會具現化，其文化特性和 UI 文化特性定義的目前系統文化特性和 UI 文化特性，而不是文化特性和 UI 文化特性建立新的執行緒的執行緒。 這表示，例如，如果目前的系統文化特性是英文 （美國） 和主要的應用程式執行緒的目前文化特性為法文 （法國），藉由呼叫建立新執行緒的文化特性<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>建構函式從主執行緒是英文 （美國） 和法文 （法國）。</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 如需詳細資訊，請參閱 < 文化特性和執行緒 」 一節<xref:System.Globalization.CultureInfo>類別主題。</xref:System.Globalization.CultureInfo>      > [!IMPORTANT] > 這不是執行非同步作業的應用程式為目標的執行緒，則為 true[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]和更新版本中的，在此情況下，文化特性和 UI 文化特性是非同步作業的內容的一部分，則為預設非同步作業所執行的執行緒繼承的文化特性和 UI 文化特性的非同步作業已啟動執行緒。 如需詳細資訊，請參閱&quot;文化特性和以工作為基礎的非同步作業 > 一節<xref:System.Globalization.CultureInfo>類別主題。</xref:System.Globalization.CultureInfo>       您可以執行下列動作，以確保所有的執行緒執行的應用程式中共用相同的文化特性和 UI 文化特性:-您可以傳遞<xref:System.Globalization.CultureInfo>物件，代表該文化特性<xref:System.Threading.ParameterizedThreadStart>委派或<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName>方法。</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=fullName> </xref:System.Threading.ParameterizedThreadStart> </xref:System.Globalization.CultureInfo>      -若為應用程式上執行[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]和更新版本中，您可以定義的文化特性和 UI 文化特性所要指派給所設定的值建立應用程式定義域中的所有執行緒<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName>和<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName>屬性。</xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=fullName> </xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=fullName> 請注意，這是每個應用程式網域設定。       如需詳細資訊與範例，請參閱 < 文化特性和執行緒 > 一節<xref:System.Globalization.CultureInfo>類別主題。</xref:System.Globalization.CultureInfo>      <a name=&quot;Properties&quot;></a># # 取得相關資訊和控制執行緒，您可以擷取提供執行緒的相關資訊的屬性值的數目。 在某些情況下，您也可以設定這些屬性值來控制執行緒的作業。 這些執行緒屬性包括:-名稱。 <xref:System.Threading.Thread.Name%2A>會寫入-一次可用來識別在執行緒中的屬性。</xref:System.Threading.Thread.Name%2A>  預設值是`null`。      -A 雜湊碼，您可以藉由呼叫擷取<xref:System.Threading.Thread.GetHashCode%2A>方法。</xref:System.Threading.Thread.GetHashCode%2A> 雜湊程式碼可以用來唯一識別執行緒;在執行緒的存留期間，其雜湊程式碼不會與任何其他執行緒，不論應用程式定義域取得此值的值相衝突。      -執行緒識別碼。 唯讀值<xref:System.Threading.Thread.ManagedThreadId%2A>屬性由執行階段所指派，並且唯一地識別其處理程序中的執行緒。</xref:System.Threading.Thread.ManagedThreadId%2A>          > [!NOTE] > 作業系統[ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx)有沒有固定的關係，managed 執行緒，因為受管理的主機可控制 managed 和 unmanaged 執行緒之間的關聯性。 具體來說，精密的主機可以使用[CLR 裝載 API](https://msdn.microsoft.com/library/ms404385.aspx)排程許多 managed 的執行緒，對相同的作業系統執行緒，或是不同的作業系統執行緒之間移動 managed 的執行緒。      -執行緒的目前狀態。 它的存在時間，執行緒一律是在一或多個定義的狀態<xref:System.Threading.ThreadState>屬性。</xref:System.Threading.ThreadState>      的所定義排程優先權等級<xref:System.Threading.ThreadPriority>屬性。</xref:System.Threading.ThreadPriority> 雖然您可以設定此值，以要求執行緒的優先權，其不一定適用於作業系統。      -唯讀<xref:System.Threading.Thread.IsThreadPoolThread%2A>屬性，指出執行緒是否是在執行緒集區執行緒。</xref:System.Threading.Thread.IsThreadPoolThread%2A>      -<xref:System.Threading.Thread.IsBackground%2A>屬性。</xref:System.Threading.Thread.IsBackground%2A> 如需詳細資訊，請參閱[前景和背景執行緒](#Foreground)> 一節。      <a name=&quot;Source&quot;></a># # 存取要檢視執行緒類別的.NET Framework 原始碼的執行緒類別的原始程式碼請參閱[參考來源](http://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96)。 您可以瀏覽原始碼、 下載的參考，離線檢視，並逐步執行原始程式碼 （包含修補程式和更新），在偵錯;請參閱[指示](http://referencesource.microsoft.com/)。"
  example:
  - "The following example demonstrates simple threading functionality.  \n  \n [!code-cpp[Classic Thread Example#1](~/add/codesnippet/cpp/t-system.threading.thread_5.cpp)]\n [!code-vb[Classic Thread Example#1](~/add/codesnippet/visualbasic/t-system.threading.thread_5.vb)]\n [!code-cs[Classic Thread Example#1](~/add/codesnippet/csharp/t-system.threading.thread_5.cs)]  \n  \n This code produces output similar to the following:  \n  \n```  \n[VB, C++, C#]  \nMain thread: Start a second thread.  \nMain thread: Do some work.  \nThreadProc: 0  \nMain thread: Do some work.  \nThreadProc: 1  \nMain thread: Do some work.  \nThreadProc: 2  \nMain thread: Do some work.  \nThreadProc: 3  \nMain thread: Call Join(), to wait until ThreadProc ends.  \nThreadProc: 4  \nThreadProc: 5  \nThreadProc: 6  \nThreadProc: 7  \nThreadProc: 8  \nThreadProc: 9  \nMain thread: ThreadProc.Join has returned.  Press Enter to end program.  \n```"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread
  inheritance:
  - System.Object
  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  implements:
  - System.Runtime.InteropServices._Thread
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  id: '#ctor(System.Threading.ParameterizedThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "初始化的新執行個體<xref href=&quot;System.Threading.Thread&quot;></xref>類別，指定委派，讓物件可以在執行緒啟動時傳遞到執行緒。"
  remarks: "執行緒不會開始執行時建立。 若要排程執行的執行緒，呼叫<xref:System.Threading.Thread.Start%2A>方法。</xref:System.Threading.Thread.Start%2A> 若要將資料物件傳遞到執行緒，使用<xref:System.Threading.Thread.Start%28System.Object%29>方法多載。</xref:System.Threading.Thread.Start%28System.Object%29>      > [!NOTE] > 可以省略 Visual Basic 使用者<xref:System.Threading.ThreadStart>建構函式建立執行緒時。</xref:System.Threading.ThreadStart> 使用`AddressOf`運算子時傳遞您的方法，例如`Dim t As New Thread(AddressOf ThreadProc)`。 Visual Basic 會自動呼叫<xref:System.Threading.ThreadStart>建構函式。</xref:System.Threading.ThreadStart>"
  example:
  - "The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_19_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_19_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_19_1.cs)]"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "委派，表示這個執行緒開始執行時要叫用的方法。"
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  id: '#ctor(System.Threading.ThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "初始化的新執行個體<xref href=&quot;System.Threading.Thread&quot;></xref>類別。"
  remarks: "執行緒不會開始執行時建立。 若要排程執行的執行緒，呼叫<xref:System.Threading.Thread.Start%2A>方法。</xref:System.Threading.Thread.Start%2A>      > [!NOTE] > 可以省略 Visual Basic 使用者<xref:System.Threading.ThreadStart>建構函式建立執行緒時。</xref:System.Threading.ThreadStart> 使用`AddressOf`運算子，例如傳遞方法時`Dim t As New Thread(AddressOf ThreadProc)`。 Visual Basic 會自動呼叫<xref:System.Threading.ThreadStart>建構函式。</xref:System.Threading.ThreadStart>"
  example:
  - "The following code example shows how to create a thread that executes a static method.  \n  \n [!code-cpp[System.Threading.Thread.ctor#1](~/add/codesnippet/cpp/m-system.threading.threa_18_1.cpp)]\n [!code-vb[System.Threading.Thread.ctor#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_1.vb)]\n [!code-cs[System.Threading.Thread.ctor#1](~/add/codesnippet/csharp/m-system.threading.threa_18_1.cs)]  \n  \n The following code example shows how to create a thread that executes an instance method.  \n  \n [!code-cs[System.Threading.Thread.ctor2#1](~/add/codesnippet/csharp/m-system.threading.threa_18_2.cs)]\n [!code-vb[System.Threading.Thread.ctor2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_18_2.vb)]\n [!code-cpp[System.Threading.Thread.ctor2#1](~/add/codesnippet/cpp/m-system.threading.threa_18_2.cpp)]"
  syntax:
    content: public Thread (System.Threading.ThreadStart start);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "A <xref href=&quot;System.Threading.ThreadStart&quot;> </xref>委派，表示這個執行緒開始執行時要叫用的方法。"
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>start</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  id: '#ctor(System.Threading.ParameterizedThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "初始化的新執行個體<xref href=&quot;System.Threading.Thread&quot;></xref>類別，指定委派，讓物件可以在執行緒啟動時傳遞到執行緒，並指定執行緒的最大堆疊大小。"
  remarks: "請避免使用這個建構函式多載。 所使用的預設堆疊大小<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>建構函式多載是建議的堆疊大小執行緒。</xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> 如果執行緒有記憶體問題，最可能的原因程式設計錯誤，例如無限遞迴。      > [!IMPORTANT] > 開頭[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]、 只有完全受信任的程式碼可以設定`maxStackSize`大於預設堆疊大小 (1 mb) 的值。 如果指定較大的值`maxStackSize`以部分信任，請在執行程式碼時`maxStackSize`會被忽略，而且是預設堆疊大小。 擲不回任何例外狀況。 任何信任層級的程式碼可以設定`maxStackSize`小於預設堆疊大小的值。      > [!NOTE] > 如果您正在開發完全受信任的程式庫，供部分信任的程式碼，且您要啟動的執行緒需要大型堆疊、 您必須先建立執行緒，判斷提示完全信任或將使用預設堆疊大小。 不要這樣除非您完全控制的執行緒執行的程式碼。       如果`maxStackSize`小於最小的堆疊大小，使用最小的堆疊大小。 如果`maxStackSize`不多的頁面大小會四捨五入為下一個較大頁面大小的倍數。 例如，如果您在 Windows Vista 上使用.NET Framework 2.0 版，256 KB （262144 位元組） 是最小的堆疊大小，和頁面大小是 64 KB （65536 個位元組）。      > [!NOTE] > 上的 Microsoft Windows Windows XP 和 Windows Server 2003 之前, 的版本`maxStackSize`會被忽略，而且是可執行檔的標頭中指定的堆疊大小。       如果您指定非常小的堆疊大小，您可能需要停用堆疊探查。 在堆疊嚴重受限，探查可以本身可能會造成堆疊溢位。 若要停用堆疊探查，加入下列應用程式組態檔。      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "A <xref href=&quot;System.Threading.ParameterizedThreadStart&quot;> </xref>委派，表示這個執行緒開始執行時要叫用的方法。"
    - id: maxStackSize
      type: System.Int32
      description: "最大堆疊大小，以位元組為單位，執行緒，或是 0 用於使用可執行檔標頭中指定的預設最大堆疊大小。       重要資訊︰ 對於部分信任程式碼，`maxStackSize`會被忽略，如果大於預設堆疊大小。 擲不回任何例外狀況。"
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>小於零。"
  platform:
  - net462
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  id: '#ctor(System.Threading.ThreadStart,System.Int32)'
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "初始化的新執行個體<xref href=&quot;System.Threading.Thread&quot;></xref>類別，並指定執行緒的最大堆疊大小。"
  remarks: "請避免使用這個建構函式多載。 所使用的預設堆疊大小<xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>建構函式多載是建議的堆疊大小執行緒。</xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> 如果執行緒有記憶體問題，最可能的原因程式設計錯誤，例如無限遞迴。      > [!IMPORTANT] > 開頭[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]、 只有完全受信任的程式碼可以設定`maxStackSize`大於預設堆疊大小 (1 mb) 的值。 如果指定較大的值`maxStackSize`以部分信任，請在執行程式碼時`maxStackSize`會被忽略，而且是預設堆疊大小。 擲不回任何例外狀況。 任何信任層級的程式碼可以設定`maxStackSize`小於預設堆疊大小的值。      > [!NOTE] > 如果您正在開發完全受信任的程式庫，供部分信任的程式碼，且您要啟動的執行緒需要大型堆疊、 您必須先建立執行緒，判斷提示完全信任或將使用預設堆疊大小。 不要這樣除非您完全控制的執行緒執行的程式碼。       如果`maxStackSize`小於最小的堆疊大小，使用最小的堆疊大小。 如果`maxStackSize`不多的頁面大小會四捨五入為下一個較大頁面大小的倍數。 例如，如果您在 Windows Vista 上使用.NET Framework 2.0 版，256 KB （262144 位元組） 是最小的堆疊大小，和頁面大小是 64 KB （65536 個位元組）。      > [!NOTE] > 上的 Microsoft Windows Windows XP 和 Windows Server 2003 之前, 的版本`maxStackSize`會被忽略，而且是可執行檔的標頭中指定的堆疊大小。       如果您指定非常小的堆疊大小，您可能需要停用堆疊探查。 在堆疊嚴重受限，探查可以本身可能會造成堆疊溢位。 若要停用堆疊探查，加入下列應用程式組態檔。      ```   <configuration>     <runtime>       <disableStackOverflowProbing enabled=&quot;true&quot;/>     </runtime>   </configuration>   ```"
  syntax:
    content: public Thread (System.Threading.ThreadStart start, int maxStackSize);
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "A <xref href=&quot;System.Threading.ThreadStart&quot;> </xref>委派，表示這個執行緒開始執行時要叫用的方法。"
    - id: maxStackSize
      type: System.Int32
      description: "最大堆疊大小，以位元組為單位，執行緒，或是 0 用於使用可執行檔標頭中指定的預設最大堆疊大小。       重要資訊︰ 對於部分信任程式碼，`maxStackSize`會被忽略，如果大於預設堆疊大小。 擲不回任何例外狀況。"
  overload: System.Threading.Thread.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>start</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>maxStackSize</code>小於零。"
  platform:
  - net462
- uid: System.Threading.Thread.Abort
  id: Abort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "引發<xref href=&quot;System.Threading.ThreadAbortException&quot;></xref>執行緒被叫用，開始結束執行緒的程序中。 呼叫這個方法通常會結束執行緒。"
  remarks: "在執行緒上叫用這個方法時，系統會<xref:System.Threading.ThreadAbortException>中止該執行緒中</xref:System.Threading.ThreadAbortException>擲回 `ThreadAbortException`是特殊的例外狀況可以攔截的應用程式程式碼，但是會重新擲回的結尾`catch`封鎖除非<xref:System.Threading.Thread.ResetAbort%2A>稱為。</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`取消要求中止，並防止`ThreadAbortException`終止執行緒。 未執行`finally`區塊會執行已中止的執行緒之前。      > [!NOTE] > 當一個執行緒呼叫`Abort`效果是類似於擲回例外狀況; 本身，<xref:System.Threading.ThreadAbortException>時會立即，且結果為可預測。</xref:System.Threading.ThreadAbortException> 不過，如果一個執行緒呼叫`Abort`，另一個執行緒上中斷執行任何程式碼中止。 此外，也可能已中止的靜態建構函式有機會。 在罕見的情況下，這可能導致無法建立應用程式定義域中的類別的執行個體。 在.NET framework 1.0 和 1.1 版中，的可能會無法中止執行緒時`finally`執行的區塊，在此情況下`finally`區塊就會中止。       執行緒中止立即，或完全不保證。 如果執行緒沒有無限量的空間中的計算，可能會發生這種情況下`finally`稱為中止程序，藉此無限延遲中止的區塊。 若要等候，直到執行緒已中止，您可以呼叫<xref:System.Threading.Thread.Join%2A>方法之後呼叫中止之方法的執行緒上但不保證將會結束等待。</xref:System.Threading.Thread.Join%2A>      > [!NOTE] > 呼叫中止執行緒可能封鎖，是否要中止的執行緒中受保護的區域，程式碼，例如`catch`區塊，`finally`區塊或限制的執行區域。 如果呼叫中止的執行緒掌握已中止的執行緒要求的鎖定，便會發生死結。       如果`Abort`稱為上尚未啟動的執行緒，執行緒將會中止時<xref:System.Threading.Thread.Start%2A>稱為。</xref:System.Threading.Thread.Start%2A> 如果`Abort`呼叫執行緒時遭到封鎖或睡眠中的執行緒上中斷，並再中止。       如果`Abort`已暫停的執行緒上呼叫<xref:System.Threading.ThreadStateException>呼叫的執行緒中擲回<xref:System.Threading.Thread.Abort%2A>，和<xref:System.Threading.ThreadState>加入至<xref:System.Threading.Thread.ThreadState%2A>正在中止的執行緒屬性。</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> A<xref:System.Threading.ThreadAbortException>才會擲回在暫停的執行緒，直到<xref:System.Threading.Thread.Resume%2A>稱為。</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       如果`Abort`執行 unmanaged 程式碼時，在 managed 執行緒上呼叫`ThreadAbortException`傳回給 managed 程式碼的執行緒之前不會擲回。       如果兩個呼叫會以`Abort`出現在相同的時間，它是一個設定的狀態資訊的呼叫和其他執行的呼叫可能`Abort`。 不過，應用程式無法偵測這種情況。       之後`Abort`叫用執行緒上、 執行緒的狀態包括<xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> 執行緒已經終止由於成功呼叫之後`Abort`，執行緒的狀態變更為<xref:System.Threading.ThreadState>。</xref:System.Threading.ThreadState> 具有足夠的權限的執行緒，做為目標的`Abort`可以取消中止使用`ResetAbort`方法。 如需範例，示範如何呼叫`ResetAbort`方法，請參閱`ThreadAbortException`類別。"
  syntax:
    content: public void Abort ();
    parameters: []
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "正在中止的執行緒目前已暫停。"
  platform:
  - net462
- uid: System.Threading.Thread.Abort(System.Object)
  id: Abort(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "引發<xref href=&quot;System.Threading.ThreadAbortException&quot;></xref>執行緒被叫用，開始結束執行緒，同時也提供有關執行緒終止的例外狀況資訊的程序中。 呼叫這個方法通常會結束執行緒。"
  remarks: "在執行緒上叫用這個方法時，系統會<xref:System.Threading.ThreadAbortException>中止該執行緒中</xref:System.Threading.ThreadAbortException>擲回 `ThreadAbortException`是特殊的例外狀況可以攔截的應用程式程式碼，但是會重新擲回的結尾`catch`封鎖除非<xref:System.Threading.Thread.ResetAbort%2A>稱為。</xref:System.Threading.Thread.ResetAbort%2A> `ResetAbort`取消要求中止，並防止`ThreadAbortException`終止執行緒。 未執行`finally`區塊會執行已中止的執行緒之前。      > [!NOTE] > 當一個執行緒呼叫`Abort`效果是類似於擲回例外狀況; 本身，<xref:System.Threading.ThreadAbortException>時會立即，且結果為可預測。</xref:System.Threading.ThreadAbortException> 不過，如果一個執行緒呼叫`Abort`，另一個執行緒上中斷執行任何程式碼中止。 沒有靜態建構函式可能會中止的機率。 在罕見的情況下，這可能導致無法建立應用程式定義域中的類別的執行個體。 在.NET framework 1.0 和 1.1 版中，的可能會無法中止執行緒時`finally`執行的區塊，在此情況下`finally`區塊就會中止。       執行緒中止立即，或完全不保證。 如果執行緒沒有無限量的空間中的計算，可能會發生這種情況下`finally`稱為中止程序，藉此無限延遲中止的區塊。 若要等候，直到執行緒已中止，您可以呼叫<xref:System.Threading.Thread.Join%2A>方法之後呼叫中止之方法的執行緒上但不保證會結束等待。</xref:System.Threading.Thread.Join%2A>      > [!NOTE] > 呼叫的執行緒<xref:System.Threading.Thread.Abort%2A>是否要中止的執行緒中受保護的區域，程式碼，例如，可能會封鎖`catch`區塊，`finally`區塊或限制的執行區域。</xref:System.Threading.Thread.Abort%2A> 如果執行緒呼叫<xref:System.Threading.Thread.Abort%2A>鎖定要求已中止的執行緒，便會發生死結。</xref:System.Threading.Thread.Abort%2A>       如果`Abort`稱為上尚未啟動的執行緒，執行緒將會中止時<xref:System.Threading.Thread.Start%2A>稱為。</xref:System.Threading.Thread.Start%2A> 如果`Abort`呼叫執行緒時遭到封鎖或睡眠中的執行緒上中斷，並再中止。       如果`Abort`已暫停的執行緒上呼叫<xref:System.Threading.ThreadStateException>呼叫的執行緒中擲回<xref:System.Threading.Thread.Abort%2A>，和<xref:System.Threading.ThreadState>加入至<xref:System.Threading.Thread.ThreadState%2A>正在中止的執行緒屬性。</xref:System.Threading.Thread.ThreadState%2A> </xref:System.Threading.ThreadState> </xref:System.Threading.Thread.Abort%2A> </xref:System.Threading.ThreadStateException> A<xref:System.Threading.ThreadAbortException>才會擲回在暫停的執行緒，直到<xref:System.Threading.Thread.Resume%2A>稱為。</xref:System.Threading.Thread.Resume%2A> </xref:System.Threading.ThreadAbortException>       如果`Abort`執行 unmanaged 程式碼時，在 managed 執行緒上呼叫`ThreadAbortException`傳回給 managed 程式碼的執行緒之前不會擲回。       如果兩個呼叫會以`Abort`出現在相同的時間，它是一個設定的狀態資訊的呼叫和其他執行的呼叫可能`Abort`。 不過，應用程式無法偵測這種情況。       之後`Abort`叫用執行緒上、 執行緒的狀態包括<xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState> 執行緒已經終止由於成功呼叫之後`Abort`，執行緒的狀態變更為<xref:System.Threading.ThreadState>。</xref:System.Threading.ThreadState> 具有足夠的權限的執行緒，做為目標的`Abort`可以取消中止使用`ResetAbort`方法。 如需範例，示範如何呼叫`ResetAbort`方法，請參閱`ThreadAbortException`類別。"
  example:
  - "The following code example shows how to pass information to a thread that is being aborted.  \n  \n [!code-cs[System.Threading.Thread.Abort2#1](~/add/codesnippet/csharp/m-system.threading.threa_12_1.cs)]\n [!code-cpp[System.Threading.Thread.Abort2#1](~/add/codesnippet/cpp/m-system.threading.threa_12_1.cpp)]\n [!code-vb[System.Threading.Thread.Abort2#1](~/add/codesnippet/visualbasic/m-system.threading.threa_12_1.vb)]"
  syntax:
    content: public void Abort (object stateInfo);
    parameters:
    - id: stateInfo
      type: System.Object
      description: "物件，包含應用程式特定資訊，例如可供正在中止的執行緒的狀態。"
  overload: System.Threading.Thread.Abort*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "正在中止的執行緒目前已暫停。"
  platform:
  - net462
- uid: System.Threading.Thread.AllocateDataSlot
  id: AllocateDataSlot
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "配置所有執行緒上未命名的資料位置。 為提升效能，使用與標示的欄位<xref:System.ThreadStaticAttribute>屬性，屬性。</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework 提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</xref:System.ThreadStaticAttribute> 提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。 如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區︰ 執行緒相關的靜態欄位和資料位置](~/add/includes/ajax-current-ext-md.md)。       在所有執行緒上配置的位置。       執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。 建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。 執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。 資料位置是每個執行緒的唯一的。 沒有其他執行緒 （甚至子執行緒） 可以取得該資料。"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_16_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_16_1.cpp)]  \n  \n **Second Example**  \n  \n The following code example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_16_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_16_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_16_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateDataSlot ();
    parameters: []
    return:
      type: System.LocalDataStoreSlot
      description: "已配置的具名資料位置，所有執行緒上。"
  overload: System.Threading.Thread.AllocateDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  id: AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "配置所有執行緒上的具名的資料位置。 為提升效能，使用與標示的欄位<xref:System.ThreadStaticAttribute>屬性，屬性。</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework 提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</xref:System.ThreadStaticAttribute> 提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。 如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區︰ 執行緒相關的靜態欄位和資料位置](~/add/includes/ajax-current-ext-md.md)。       執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。 建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。 執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。 資料位置是每個執行緒的唯一的。 沒有其他執行緒 （甚至子執行緒） 可以取得該資料。       不需要使用 AllocateNamedDataSlot 方法配置的具名的資料位置，因為<xref:System.Threading.Thread.GetNamedDataSlot%2A>方法配置位置，如果它不已配置。</xref:System.Threading.Thread.GetNamedDataSlot%2A>      > [!NOTE] > AllocateNamedDataSlot 方法使用時，如果它中應該呼叫主執行緒在程式啟動時，因為它會擲回例外狀況，如果已配置具有指定名稱的位置。 沒有任何方法來測試是否已配置的位置。       以這個方法所配置的位置必須釋放與<xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</xref:System.Threading.Thread.FreeNamedDataSlot%2A>"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_7_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_7_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n> [!NOTE]\n>  The example code does not use the AllocateNamedDataSlot method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated. If the AllocateNamedDataSlot method is used, it should be called in the main thread at program startup.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_7_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_7_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_7_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot AllocateNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "要配置之資料插槽的名稱。"
    return:
      type: System.LocalDataStoreSlot
      description: "已配置的具名資料位置，所有執行緒上。"
  overload: System.Threading.Thread.AllocateNamedDataSlot*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "具有指定名稱的具名的資料位置已存在。"
  platform:
  - net462
- uid: System.Threading.Thread.ApartmentState
  id: ApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得或設定這個執行緒的 apartment 狀態。"
  remarks: "**ApartmentState 屬性已經過時。**  非過時的替代方式為<xref:System.Threading.Thread.GetApartmentState%2A>方法來擷取的 apartment 狀態和<xref:System.Threading.Thread.SetApartmentState%2A>方法，以設定 apartment 狀態。</xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>       在.NET framework 1.0 和 1.1 版，`ApartmentState`屬性標記，表示它會在單一執行緒或多執行緒 apartment 中執行的執行緒。 可以設定這個屬性，當執行緒處於`Unstarted`或`Running`執行緒狀態; 不過，它可以只能設定一次的執行緒。 如果尚未設定屬性，它會傳回`Unknown`。       嘗試使用 ApartmentState 屬性來設定其 apartment 狀態已設定執行緒的 apartment 狀態會被忽略。 不過，<xref:System.Threading.Thread.SetApartmentState%2A>方法會擲回<xref:System.InvalidOperationException>在此情況下。</xref:System.InvalidOperationException> </xref:System.Threading.Thread.SetApartmentState%2A>      > [!IMPORTANT] > In the.NET Framework 2.0 版，新的執行緒都會初始化成<xref:System.Threading.ApartmentState?displayProperty=fullName>如果其 apartment 狀態尚未設定之前啟動。</xref:System.Threading.ApartmentState?displayProperty=fullName> 主應用程式執行緒會初始化為<xref:System.Threading.ApartmentState?displayProperty=fullName>預設。</xref:System.Threading.ApartmentState?displayProperty=fullName> 您可以不再將設定主應用程式執行緒<xref:System.Threading.ApartmentState?displayProperty=fullName>藉由設定<xref:System.Threading.ApartmentState?displayProperty=fullName>第一行程式碼上的屬性。</xref:System.Threading.ApartmentState?displayProperty=fullName> </xref:System.Threading.ApartmentState?displayProperty=fullName> 使用<xref:System.STAThreadAttribute>改用。</xref:System.STAThreadAttribute>       在.NET Framework 2.0 版中，您可以指定的 COM 執行緒模型為 c + + 應用程式使用[/CLRTHREADATTRIBUTE （設定 CLR 執行緒屬性）](~/add/includes/ajax-current-ext-md.md)連結器選項。"
  example:
  - "The following code example demonstrates how to set the apartment state of a thread.  \n  \n [!code-cs[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/csharp/p-system.threading.threa_8_1.cs)]\n [!code-cpp[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/cpp/p-system.threading.threa_8_1.cpp)]\n [!code-vb[System.Threading.Thread.ApartmentState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_8_1.vb)]"
  syntax:
    content: public System.Threading.ApartmentState ApartmentState { get; set; }
    return:
      type: System.Threading.ApartmentState
      description: "其中一個<xref href=&quot;System.Threading.ApartmentState&quot;></xref>值。 初始值是<xref uid=&quot;langword_csharp_Unknown&quot; name=&quot;Unknown&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.Thread.ApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "嘗試將此屬性設為無效 apartment 狀態的狀態 (單一執行緒 apartment 以外的狀態 (<xref uid=&quot;langword_csharp_STA&quot; name=&quot;STA&quot; href=&quot;&quot;></xref>) 或多執行緒的 apartment (<xref uid=&quot;langword_csharp_MTA&quot; name=&quot;MTA&quot; href=&quot;&quot;></xref>))。"
  platform:
  - net462
- uid: System.Threading.Thread.BeginCriticalRegion
  id: BeginCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "通知主機在即將執行的程式碼中，執行緒中止或未處理例外狀況的影響可能危及應用程式定義域中的其他工作的區域。"
  remarks: "主控件，例如 Microsoft SQL Server 2005，common language runtime (CLR)，可以建立不同的原則中的程式碼的重大和非關鍵區域的失敗。 在其中執行緒中止或未處理的例外狀況的影響可能不是目前的工作是關鍵區域。 相反地，中止或非關鍵的程式碼區域中的失敗會影響只有工作發生錯誤。       例如，假設有嘗試配置記憶體時保留鎖定工作。 如果記憶體配置失敗，正在中止目前的工作並不足以確保穩定性<xref:System.AppDomain>，因為在等候相同的鎖定網域中可以有其他工作。</xref:System.AppDomain> 如果目前的工作已中止，其他工作可能發生死結。       發生失敗時的關鍵區域中，主機可能會決定卸載整個<xref:System.AppDomain>而不需要繼續執行，可能會不穩定的狀態中的風險。</xref:System.AppDomain> 若要通知您的程式碼正在進入關鍵區域的主機，呼叫 BeginCriticalRegion。 呼叫<xref:System.Threading.Thread.EndCriticalRegion%2A>當執行會傳回非關鍵的程式碼區域。</xref:System.Threading.Thread.EndCriticalRegion%2A>       SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。"
  example:
  - "The following example demonstrates the use of the BeginCriticalRegion and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_5_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_5_1.vb)]"
  syntax:
    content: public static void BeginCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.BeginCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.BeginThreadAffinity
  id: BeginThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "通知主機 managed 程式碼即將執行指令，取決於目前實體作業系統執行緒的識別。"
  remarks: "某些主機的 common language runtime，例如 Microsoft SQL Server 2005，提供它們自己的執行緒管理。 提供它自己的執行緒管理的主機執行的工作從一個實體作業系統執行緒之間移動在任何時間。 大部分的工作不會受到這個切換。 不過，某些工作執行緒相似性，也就是相依實體作業系統執行緒的識別。 這些工作必須通知主應用程式時執行程式碼，不會切換。       比方說，如果您的應用程式呼叫系統 API 來取得作業系統鎖定具有執行緒相似性，例如 Win32 CRITICAL_SECTION，您必須呼叫 BeginThreadAffinity 之前取得鎖定，以及<xref:System.Threading.Thread.EndThreadAffinity%2A>之後釋放鎖定。</xref:System.Threading.Thread.EndThreadAffinity%2A>       SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。"
  example:
  - "The following example demonstrates the use of the BeginThreadAffinity and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_0_1.vb)]"
  syntax:
    content: public static void BeginThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.BeginThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.Threading.Thread.CurrentContext
  id: CurrentContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得目前執行緒正在執行的內容。"
  syntax:
    content: public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }
    return:
      type: System.Runtime.Remoting.Contexts.Context
      description: "A <xref href=&quot;System.Runtime.Remoting.Contexts.Context&quot;> </xref>代表目前的執行緒內容。"
  overload: System.Threading.Thread.CurrentContext*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.Threading.Thread.CurrentCulture
  id: CurrentCulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得或設定目前執行緒的文化特性。"
  remarks: "<xref:System.Globalization.CultureInfo>物件，這個屬性，以及其相關聯的物件，就會傳回判斷預設格式的日期、 時間、 數字、 貨幣值，排序順序的文字、 大小寫慣例，以及字串比較。</xref:System.Globalization.CultureInfo> 請參閱<xref:System.Globalization.CultureInfo>類別若要了解有關的文化特性名稱和識別碼，而異，中性和特定文化特性之間的差異，以及方法的文化特性資訊影響執行緒和應用程式定義域。</xref:System.Globalization.CultureInfo> 請參閱<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>屬性若要了解如何決定執行緒的預設文化特性，以及使用者如何設定電腦的文化特性資訊。</xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName>       開頭為[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]，您可以將中性文化特性中的 CurrentCulture 屬性。 這是因為的行為<xref:System.Globalization.CultureInfo>類別已變更︰ 當它代表中性文化特性，其屬性值 (特別是， <xref:System.Globalization.CultureInfo.Calendar%2A>， <xref:System.Globalization.CultureInfo.CompareInfo%2A>， <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>， <xref:System.Globalization.CultureInfo.NumberFormat%2A>，和<xref:System.Globalization.CultureInfo.TextInfo%2A>屬性) 現在反映中性文化特性相關聯的特定文化特性。</xref:System.Globalization.CultureInfo.TextInfo%2A> </xref:System.Globalization.CultureInfo.NumberFormat%2A> </xref:System.Globalization.CultureInfo.DateTimeFormat%2A> </xref:System.Globalization.CultureInfo.CompareInfo%2A> </xref:System.Globalization.CultureInfo.Calendar%2A> </xref:System.Globalization.CultureInfo> 在舊版的.NET Framework 中的 CurrentCulture 屬性擲回<xref:System.NotSupportedException>時中性文化特性已指派的例外狀況。</xref:System.NotSupportedException>"
  example:
  - "The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_3_1.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentCulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "物件，代表目前執行緒的文化特性。"
  overload: System.Threading.Thread.CurrentCulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "屬性設定為<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Threading.Thread.CurrentPrincipal
  id: CurrentPrincipal
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得或設定執行緒目前的原則 （適用於角色型安全性）。"
  remarks: ''
  example:
  - "The following code example shows how to set and retrieve the principal of a thread.  \n  \n [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/cpp/p-system.threading.threa_11_1.cpp)]\n [!code-cs[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/csharp/p-system.threading.threa_11_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/add/codesnippet/visualbasic/p-system.threading.threa_11_1.vb)]"
  syntax:
    content: public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }
    return:
      type: System.Security.Principal.IPrincipal
      description: "<xref:System.Security.Principal.IPrincipal>值，代表安全性內容。</xref:System.Security.Principal.IPrincipal>"
  overload: System.Threading.Thread.CurrentPrincipal*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要使用權限設定主體。"
  platform:
  - net462
- uid: System.Threading.Thread.CurrentThread
  id: CurrentThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得目前執行的執行緒。"
  remarks: ''
  example:
  - "The following example creates a task that in turn creates 20 child tasks. The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the CurrentThread property  to display information about the thread on which it is running.  \n  \n [!code-vb[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_1_1.vb)]\n [!code-cs[System.Threading.Thread.CurrentThread#1](~/add/codesnippet/csharp/p-system.threading.threa_1_1.cs)]  \n  \n Each child task generates 1 million random numbers between 1 and 1 million and returns their mean. The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.  \n  \n Note that while the application runs on a foreground thread, each task runs on a thread pool thread."
  syntax:
    content: public static System.Threading.Thread CurrentThread { get; }
    return:
      type: System.Threading.Thread
      description: "A <xref href=&quot;System.Threading.Thread&quot;> </xref>也就是在目前執行之執行緒的表示法。"
  overload: System.Threading.Thread.CurrentThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.CurrentUICulture
  id: CurrentUICulture
  parent: System.Threading.Thread
  langs:
  - csharp
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得或設定資源管理員用來在執行階段查詢特定文化特性資源的目前文化特性。"
  remarks: "The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture. See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains. See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=fullName> property to learn how a thread's default UI culture is determined.  \n  \n The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture. Neutral cultures should not be used with formatting methods such as [String.Format(IFormatProvider, String, Object\\[\\])](assetId:///M:System.String.Format(System.IFormatProvider,System.String,System.Object[])?qualifyHint=True&autoUpgrade=False), <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=fullName>. Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.  \n  \n> [!NOTE]\n>  The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=fullName> method throws <xref:System.ArgumentException> for the neutral cultures \"zh-Hant\" (\"zh-CHT\") and \"zh-Hans\" (\"zh-CHS\")."
  example:
  - "The following example determines whether the language of the current thread's UI culture is French. If it is not, it sets the UI culture of the current thread to English (United States).  \n  \n [!code-cs[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_1.cs)]\n [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_1.vb)]  \n  \n The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel. Additional code is needed.  \n  \n [!code-cpp[System.Threading.Thread.Culture#1](~/add/codesnippet/cpp/p-system.threading.threa_2_2.cpp)]\n [!code-cs[System.Threading.Thread.Culture#1](~/add/codesnippet/csharp/p-system.threading.threa_2_2.cs)]\n [!code-vb[System.Threading.Thread.Culture#1](~/add/codesnippet/visualbasic/p-system.threading.threa_2_2.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo CurrentUICulture { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "物件，代表目前的文化特性。"
  overload: System.Threading.Thread.CurrentUICulture*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "屬性設定為<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "屬性設定為無法用來尋找資源檔的文化特性名稱。 資源檔名稱必須包含字母、 數字、 連字號或底線。"
  platform:
  - net462
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  id: DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  langs:
  - csharp
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "關閉自動清除之執行階段可呼叫包裝函式 (RCW) 目前的執行緒。"
  remarks: "根據預設，common language runtime (CLR) 會清除執行階段可呼叫包裝函式自動。 CLR 激發訊息期間清除作業，可能會造成一些符合下列準則不尋常的應用程式的重新進入問題:-應用程式會自己訊息幫浦作業。      -應用程式需要訊息幫浦作業發生時，精確地控制。       這類應用程式可用來防止 CLR 執行的執行階段可呼叫包裝函式自動回收 DisableComObjectEagerCleanup 方法。       如果在執行緒上呼叫此方法，就無法重新啟用該執行緒自動清除。 您的應用程式準備好要清除執行階段可呼叫包裝函式時，請使用<xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName>方法，以指示清除所有執行階段可呼叫包裝函式在目前內容中執行階段。</xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=fullName> 當方法執行時，就會發生訊息幫浦作業。"
  syntax:
    content: public void DisableComObjectEagerCleanup ();
    parameters: []
  overload: System.Threading.Thread.DisableComObjectEagerCleanup*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndCriticalRegion
  id: EndCriticalRegion
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "通知主機在即將執行的程式碼中的執行緒中止或未處理例外狀況的影響限於目前的工作區域。"
  remarks: "主控件，例如 Microsoft SQL Server 2005，common language runtime (CLR)，可以建立不同的原則中的程式碼的重大和非關鍵區域的失敗。 在其中執行緒中止或未處理的例外狀況的影響可能不是目前的工作是關鍵區域。 相反地，中止或非關鍵的程式碼區域中的失敗會影響只有工作發生錯誤。       例如，假設有嘗試配置記憶體時保留鎖定工作。 如果記憶體配置失敗，正在中止目前的工作並不足以確保穩定性<xref:System.AppDomain>，因為在等候相同的鎖定網域中可以有其他工作。</xref:System.AppDomain> 如果目前的工作已中止，其他工作可能發生死結。       發生失敗時的關鍵區域中，主機可能會決定卸載整個<xref:System.AppDomain>而不需要繼續執行，可能會不穩定的狀態中的風險。</xref:System.AppDomain> 若要通知主機程式碼會進入重大的區域，呼叫<xref:System.Threading.Thread.BeginCriticalRegion%2A>.</xref:System.Threading.Thread.BeginCriticalRegion%2A> 當執行會傳回非關鍵的程式碼區域，請呼叫 EndCriticalRegion。       SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。"
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and EndCriticalRegion methods to divide a block of code into critical and non-critical regions.  \n  \n [!code-cs[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/csharp/m-system.threading.threa_1_1.cs)]\n [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/cpp/m-system.threading.threa_1_1.cpp)]\n [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/add/codesnippet/visualbasic/m-system.threading.threa_1_1.vb)]"
  syntax:
    content: public static void EndCriticalRegion ();
    parameters: []
  overload: System.Threading.Thread.EndCriticalRegion*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.EndThreadAffinity
  id: EndThreadAffinity
  parent: System.Threading.Thread
  langs:
  - csharp
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "通知主機 managed 程式碼已完成執行這些指令相依於目前實體作業系統執行緒的識別。"
  remarks: "某些主機的 common language runtime，例如 Microsoft SQL Server 2005，提供它們自己的執行緒管理。 提供它自己的執行緒管理的主機執行的工作從一個實體作業系統執行緒之間移動在任何時間。 大部分的工作不會受到這個切換。 不過，某些工作執行緒相似性，也就是相依實體作業系統執行緒的識別。 這些工作必須通知主應用程式時執行程式碼，不會切換。       例如，如果您的應用程式呼叫系統 API，以取得作業系統鎖定具有執行緒相似性，例如 Win32 CRITICAL_SECTION，您必須呼叫<xref:System.Threading.Thread.BeginThreadAffinity%2A>之前取得的鎖定和 EndThreadAffinity 之後釋放鎖定。</xref:System.Threading.Thread.BeginThreadAffinity%2A>       SQL Server 2005 底下執行的程式碼中使用這個方法需要最高的主機保護層級執行的程式碼。"
  example:
  - "The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and EndThreadAffinity methods to notify a host that a block of code depends on the identity of a physical operating system thread.  \n  \n [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/cpp/m-system.threading.threa_3_1.cpp)]\n [!code-cs[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/csharp/m-system.threading.threa_3_1.cs)]\n [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/add/codesnippet/visualbasic/m-system.threading.threa_3_1.vb)]"
  syntax:
    content: public static void EndThreadAffinity ();
    parameters: []
  overload: System.Threading.Thread.EndThreadAffinity*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.Threading.Thread.ExecutionContext
  id: ExecutionContext
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得<xref:System.Threading.ExecutionContext>物件，其中包含目前執行緒各種內容的相關資訊。</xref:System.Threading.ExecutionContext>"
  remarks: "<xref:System.Threading.ExecutionContext>類別會提供所有的相關資訊的邏輯執行緒執行的單一容器。</xref:System.Threading.ExecutionContext> 這包括安全性內容中，呼叫內容、 同步處理內容、 當地語系化內容和交易內容。"
  syntax:
    content: public System.Threading.ExecutionContext ExecutionContext { get; }
    return:
      type: System.Threading.ExecutionContext
      description: "<xref:System.Threading.ExecutionContext>物件，合併目前執行緒的內容資訊。</xref:System.Threading.ExecutionContext>"
  overload: System.Threading.Thread.ExecutionContext*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Finalize
  id: Finalize
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "確認釋出資源，並在記憶體回收行程回收時執行其他清除作業<xref href=&quot;System.Threading.Thread&quot;></xref>物件。"
  remarks: "記憶體回收行程呼叫 Finalize 準備最終處理而目前的物件時。"
  syntax:
    content: ~Thread ();
    parameters: []
  overload: System.Threading.Thread.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  id: FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "排除的名稱和位置，在程序中的所有執行緒之間的關聯。 為提升效能，使用與標示的欄位<xref:System.ThreadStaticAttribute>屬性，屬性。</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework 提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</xref:System.ThreadStaticAttribute> 提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。 如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區︰ 執行緒相關的靜態欄位和資料位置](~/add/includes/ajax-current-ext-md.md)。       任何執行緒呼叫之後`FreeNamedDataSlot`，呼叫的其他任何執行緒<xref:System.Threading.Thread.GetNamedDataSlot%2A>相同的名稱就會配置新的位置與名稱相關聯。</xref:System.Threading.Thread.GetNamedDataSlot%2A> 後續呼叫`GetNamedDataSlot`任何執行緒會傳回新的位置。 不過，任何執行緒，仍有<xref:System.LocalDataStoreSlot?displayProperty=fullName>先前呼叫所傳回的`GetNamedDataSlot`可以繼續使用舊的位置。</xref:System.LocalDataStoreSlot?displayProperty=fullName>       釋放與名稱關聯的位置時，才每`LocalDataStoreSlot`之前呼叫取得`FreeNamedDataSlot`已釋放及回收。       執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。 建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。 執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。 資料位置是每個執行緒的唯一的。 沒有其他執行緒 （甚至子執行緒） 可以取得該資料。"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_9_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_9_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_9_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_9_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_9_2.vb)]"
  syntax:
    content: public static void FreeNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "要釋放之資料插槽的名稱。"
  overload: System.Threading.Thread.FreeNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetApartmentState
  id: GetApartmentState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "傳回<xref href=&quot;System.Threading.ApartmentState&quot;></xref>表示 apartment 狀態的值。"
  remarks: "這個方法中，連同<xref:System.Threading.Thread.SetApartmentState%2A>方法和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法，會取代<xref:System.Threading.Thread.ApartmentState%2A>屬性。</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A>"
  example:
  - "The following code example demonstrates the GetApartmentState, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, GetApartmentState displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_11_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_11_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_11_1.cs)]"
  syntax:
    content: public System.Threading.ApartmentState GetApartmentState ();
    parameters: []
    return:
      type: System.Threading.ApartmentState
      description: "其中一個<xref href=&quot;System.Threading.ApartmentState&quot;></xref>值，指出 managed 執行緒的 apartment 狀態。 預設值是<xref href=&quot;System.Threading.ApartmentState&quot;> </xref>。"
  overload: System.Threading.Thread.GetApartmentState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetCompressedStack
  id: GetCompressedStack
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "傳回<xref href=&quot;System.Threading.CompressedStack&quot;></xref>可以用於擷取目前執行緒的堆疊物件。"
  remarks: "不再支援這個方法。"
  syntax:
    content: public System.Threading.CompressedStack GetCompressedStack ();
    parameters: []
    return:
      type: System.Threading.CompressedStack
      description: "無。"
  overload: System.Threading.Thread.GetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "在所有情況下。"
  platform:
  - net462
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  id: GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "擷取從目前執行緒上、 目前執行緒的目前網域內的指定位置的值。 為提升效能，使用與標示的欄位<xref:System.ThreadStaticAttribute>屬性，屬性。</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework 提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</xref:System.ThreadStaticAttribute> 提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。 如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區︰ 執行緒相關的靜態欄位和資料位置](~/add/includes/ajax-current-ext-md.md)。       執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。 建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。 執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。 資料位置是每個執行緒的唯一的。 沒有其他執行緒 （甚至子執行緒） 可以取得該資料。      > [!NOTE] > GetData 是`Shared`一律適用於目前執行中執行緒，即使您使用的變數，指的是另一個執行緒呼叫的方法。 為了避免混淆，類別名稱呼叫時，使用`Shared`方法︰ `Dim test As Object = Thread.GetData(testSlot)`。"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_27_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_27_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.DataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_27_2.cs)]\n [!code-cpp[System.Threading.Thread.DataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_27_2.cpp)]\n [!code-vb[System.Threading.Thread.DataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_27_2.vb)]"
  syntax:
    content: public static object GetData (LocalDataStoreSlot slot);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "<xref href=&quot;System.LocalDataStoreSlot&quot;> </xref>要從中取得的值。"
    return:
      type: System.Object
      description: "擷取的數值。"
  overload: System.Threading.Thread.GetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomain
  id: GetDomain
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "傳回目前執行緒正在其中執行的目前定義域。"
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_29_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_29_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_29_1.cpp)]"
  syntax:
    content: public static AppDomain GetDomain ();
    parameters: []
    return:
      type: System.AppDomain
      description: "<xref href=&quot;System.AppDomain&quot;> </xref>代表執行中的執行緒目前的應用程式定義域。"
  overload: System.Threading.Thread.GetDomain*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetDomainID
  id: GetDomainID
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "傳回唯一的應用程式定義域識別項。"
  remarks: ''
  example:
  - "The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.  \n  \n [!code-cs[System.Threading.Thread.Domain#1](~/add/codesnippet/csharp/m-system.threading.threa_17_1.cs)]\n [!code-vb[System.Threading.Thread.Domain#1](~/add/codesnippet/visualbasic/m-system.threading.threa_17_1.vb)]\n [!code-cpp[System.Threading.Thread.Domain#1](~/add/codesnippet/cpp/m-system.threading.threa_17_1.cpp)]"
  syntax:
    content: public static int GetDomainID ();
    parameters: []
    return:
      type: System.Int32
      description: "32 位元帶正負號的整數，用來唯一識別應用程式定義域。"
  overload: System.Threading.Thread.GetDomainID*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetHashCode
  id: GetHashCode
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "傳回目前執行緒的雜湊碼。"
  remarks: "不保證是唯一的雜湊碼。 使用<xref:System.Threading.Thread.ManagedThreadId%2A>屬性，如果您需要 managed 執行緒的唯一識別碼。</xref:System.Threading.Thread.ManagedThreadId%2A>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "整數雜湊碼值。"
  overload: System.Threading.Thread.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  id: GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "尋找具名的資料位置。 為提升效能，使用與標示的欄位<xref:System.ThreadStaticAttribute>屬性，屬性。</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework 提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</xref:System.ThreadStaticAttribute> 提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。 如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區︰ 執行緒相關的靜態欄位和資料位置](~/add/includes/ajax-current-ext-md.md)。       執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。 建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。 執行緒用來配置資料存放區中的資料位置、 儲存和擷取資料值插槽中，並釋放以供重複使用的位置之後在執行緒逾時。 資料位置是每個執行緒的唯一的。 沒有其他執行緒 （甚至子執行緒） 可以取得該資料。       如果具名的位置不存在，則會配置新的位置。 具名的資料位置是公用的任何人都可以管理。"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_13_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_13_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_13_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_13_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_13_2.vb)]"
  syntax:
    content: public static LocalDataStoreSlot GetNamedDataSlot (string name);
    parameters:
    - id: name
      type: System.String
      description: "本機資料位置的名稱。"
    return:
      type: System.LocalDataStoreSlot
      description: "A <xref href=&quot;System.LocalDataStoreSlot&quot;> </xref>這個執行緒配置。"
  overload: System.Threading.Thread.GetNamedDataSlot*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Interrupt
  id: Interrupt
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "中斷處於執行緒<xref uid=&quot;langword_csharp_WaitSleepJoin&quot; name=&quot;WaitSleepJoin&quot; href=&quot;&quot;></xref>執行緒狀態。"
  remarks: "如果這個執行緒目前未遭到封鎖在等候、 睡眠或聯結狀態，它將會中斷接下來開始封鎖時。       <xref:System.Threading.ThreadInterruptedException>在中斷之執行緒，但直到則執行緒會封鎖，就會擲回。</xref:System.Threading.ThreadInterruptedException> 如果執行緒永不封鎖，永遠不會擲回例外狀況，並因此執行緒可能會完成，而任何中斷。"
  example:
  - "The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.  \n  \n [!code-cpp[System.Threading.Thread.Interrupt#1](~/add/codesnippet/cpp/m-system.threading.threa_21_1.cpp)]\n [!code-vb[System.Threading.Thread.Interrupt#1](~/add/codesnippet/visualbasic/m-system.threading.threa_21_1.vb)]\n [!code-cs[System.Threading.Thread.Interrupt#1](~/add/codesnippet/csharp/m-system.threading.threa_21_1.cs)]"
  syntax:
    content: public void Interrupt ();
    parameters: []
  overload: System.Threading.Thread.Interrupt*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有適當<xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>。"
  platform:
  - net462
- uid: System.Threading.Thread.IsAlive
  id: IsAlive
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得值，指出目前執行緒的執行狀態。"
  syntax:
    content: public bool IsAlive { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個執行緒已經啟動但還沒有正常終止或中止。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.Thread.IsAlive*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.IsBackground
  id: IsBackground
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得或設定值，指出執行緒背景執行緒。"
  remarks: "執行緒是背景執行緒或前景執行緒。 背景執行緒就前景執行緒相同，不同之處在於背景執行緒不會防止處理序終止。 一旦處理程序所屬的所有前景執行緒已經都終止，common language runtime 會結束處理程序。 任何剩餘的背景執行緒已停止，並不會完成。       依預設，下列執行緒則是在前景執行 (也就是其 IsBackground 屬性會傳回`false`):-主執行緒 （或主應用程式執行緒）。      的藉由呼叫建立所有執行緒<xref:System.Threading.Thread>類別建構函式。</xref:System.Threading.Thread>       依預設，下列執行緒則是在背景中執行 (也就是其 IsBackground 屬性會傳回`true`):-執行緒集區執行緒，也就是由執行階段所維護的背景工作執行緒集區。 您可以在執行緒集區執行緒上設定執行緒集區和排程工作，使用<xref:System.Threading.ThreadPool>類別。</xref:System.Threading.ThreadPool>          > [!NOTE] > 在執行緒集區執行緒上自動執行工作為基礎的非同步作業。      -所有執行緒從 unmanaged 程式碼進入 managed 的執行環境。"
  example:
  - "The following example contrasts the behavior of foreground and background threads. It creates a foreground thread and a background thread. The foreground thread keeps the process running until completes its `for` loop and terminates. However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.  \n  \n [!code-cs[System.Threading.Thread.IsBackground#1](~/add/codesnippet/csharp/p-system.threading.threa_7_1.cs)]\n [!code-cpp[System.Threading.Thread.IsBackground#1](~/add/codesnippet/cpp/p-system.threading.threa_7_1.cpp)]\n [!code-vb[System.Threading.Thread.IsBackground#1](~/add/codesnippet/visualbasic/p-system.threading.threa_7_1.vb)]"
  syntax:
    content: public bool IsBackground { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個執行緒是的或者會成為背景執行緒，否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.Thread.IsBackground*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "執行緒已無作用。"
  platform:
  - net462
- uid: System.Threading.Thread.IsThreadPoolThread
  id: IsThreadPoolThread
  parent: System.Threading.Thread
  langs:
  - csharp
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得值，指出屬於 managed 的執行緒集區的執行緒。"
  remarks: "如需詳細資訊，請參閱[Managed 執行緒集區](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example shows how to determine whether a thread is from the thread pool.  \n  \n [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/cpp/p-system.threading.threa_0_1.cpp)]\n [!code-cs[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/csharp/p-system.threading.threa_0_1.cs)]\n [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/add/codesnippet/visualbasic/p-system.threading.threa_0_1.vb)]"
  syntax:
    content: public bool IsThreadPoolThread { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個執行緒屬於 managed 的執行緒集區中。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.Thread.IsThreadPoolThread*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Join
  id: Join
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "封鎖呼叫執行緒，直到這個執行個體所表示的執行緒結束，但仍繼續執行標準的 COM 和<xref uid=&quot;langword_csharp_SendMessage&quot; name=&quot;SendMessage&quot; href=&quot;&quot;></xref>幫浦作業。"
  remarks: "聯結是同步處理方法會封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到完成呼叫方法的聯結執行緒。 使用這個方法，以確保執行緒已終止。 如果執行緒不會終止，將會無限期地封鎖呼叫端。 在下列範例中，`Thread1`執行緒呼叫的聯結方法`Thread2`，這會導致`Thread1`區塊，直到`Thread2`已完成。       [!code-cs[System.Threading.Thread.Join#1](~/add/codesnippet/csharp/m-system.threading.threa_24_1.cs)][!code-vb[System.Threading.Thread.Join#1](~/add/codesnippet/visualbasic/m-system.threading.threa_24_1.vb) ]如果執行緒已經終止時有<xref:System.Threading.Thread.Join%2A>呼叫時，此方法會立即傳回。</xref:System.Threading.Thread.Join%2A>        > [!WARNING] > 您應該永遠不會呼叫的聯結方法<xref:System.Threading.Thread>物件，代表目前執行緒從目前的執行緒。</xref:System.Threading.Thread> 這會導致您的應用程式停止回應，因為目前的執行緒本身會永遠等候，這個方法會變更来包含<xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName>呼叫執行緒的狀態 無法叫用`Join`中的執行緒上<xref:System.Threading.ThreadState?displayProperty=fullName>狀態。</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public void Join ();
    parameters: []
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "呼叫端嘗試聯結處於執行緒<xref href=&quot;System.Threading.ThreadState&quot;></xref>狀態。"
  - type: System.Threading.ThreadInterruptedException
    commentId: T:System.Threading.ThreadInterruptedException
    description: "執行緒在等待時中斷。"
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.Int32)
  id: Join(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "封鎖呼叫執行緒，直到此執行個體所表示的執行緒終止為止或指定的時間超過，但仍繼續執行標準的 COM 與 SendMessage 幫浦作業。"
  remarks: "聯結會封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到其中一個執行緒的同步處理方法的<xref:System.Threading.Thread.Join%2A>方法呼叫已完成或經過逾時間隔。</xref:System.Threading.Thread.Join%2A> 在下列範例中，`Thread1`執行緒呼叫<xref:System.Threading.Thread.Join>方法`Thread2`，這會導致`Thread1`封鎖直到 `Thread2`已完成或經過 2 秒。</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#2](~/add/codesnippet/csharp/m-system.threading.threa_8_1.cs)][!code-vb[System.Threading.Thread.Join#2](~/add/codesnippet/visualbasic/m-system.threading.threa_8_1.vb) ]如果<xref:System.Threading.Timeout.Infinite?displayProperty=fullName>指定`millisecondsTimeout`參數，此方法的行為即會相同與<xref:System.Threading.Thread.Join>方法多載，除了傳回的值。</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         如果執行緒已經終止時有<xref:System.Threading.Thread.Join%2A>呼叫時，此方法會立即傳回。</xref:System.Threading.Thread.Join%2A>       這個方法會變更要包含<xref:System.Threading.ThreadState?displayProperty=fullName>.</xref:System.Threading.ThreadState?displayProperty=fullName>呼叫執行緒的狀態 無法叫用`Join`中的執行緒上<xref:System.Threading.ThreadState?displayProperty=fullName>狀態。</xref:System.Threading.ThreadState?displayProperty=fullName>"
  syntax:
    content: public bool Join (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "等候執行緒終止的毫秒數。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果執行緒已經終止;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>執行緒還沒有終止指定的時間量之後<code> millisecondsTimeout </code>參數。"
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "值<code> millisecondsTimeout </code>為負數且不等於&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;以毫秒為單位。"
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "無法啟動執行緒。"
  platform:
  - net462
- uid: System.Threading.Thread.Join(System.TimeSpan)
  id: Join(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "封鎖呼叫執行緒，直到此執行個體所表示的執行緒終止為止或指定的時間超過，但仍繼續執行標準的 COM 與 SendMessage 幫浦作業。"
  remarks: "聯結會封鎖呼叫執行緒 （也就是呼叫方法的執行緒），直到其中一個執行緒的同步處理方法的<xref:System.Threading.Thread.Join%2A>方法呼叫已完成或經過逾時間隔。</xref:System.Threading.Thread.Join%2A> 在下列範例中，`Thread1`執行緒呼叫<xref:System.Threading.Thread.Join>方法`Thread2`，這會導致`Thread1`封鎖直到 `Thread2`已完成或經過 2 秒。</xref:System.Threading.Thread.Join>       [!code-cs[System.Threading.Thread.Join#3](~/add/codesnippet/csharp/m-system.threading.threa_28_1.cs)][!code-vb[System.Threading.Thread.Join#3](~/add/codesnippet/visualbasic/m-system.threading.threa_28_1.vb) ]如果<xref:System.Threading.Timeout.Infinite?displayProperty=fullName>指定`timeout`，此方法的行為即會相同與<xref:System.Threading.Thread.Join>方法多載，除了傳回的值。</xref:System.Threading.Thread.Join> </xref:System.Threading.Timeout.Infinite?displayProperty=fullName>         如果執行緒已經終止時有<xref:System.Threading.Thread.Join%2A>呼叫時，此方法會立即傳回。</xref:System.Threading.Thread.Join%2A>       這個方法會變更目前的執行緒可包括<xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState>的狀態 無法叫用`Join`中的執行緒上<xref:System.Threading.ThreadState?displayProperty=fullName>狀態。</xref:System.Threading.ThreadState?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.  \n  \n [!code-cpp[System.Threading.Thread.Timespan#1](~/add/codesnippet/cpp/m-system.threading.threa_28_2.cpp)]\n [!code-cs[System.Threading.Thread.Timespan#1](~/add/codesnippet/csharp/m-system.threading.threa_28_2.cs)]\n [!code-vb[System.Threading.Thread.Timespan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_28_2.vb)]"
  syntax:
    content: public bool Join (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "A<xref:System.TimeSpan>設等候執行緒終止的時間量。</xref:System.TimeSpan>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果執行緒終止;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>執行緒還沒有終止指定的時間量之後<code> timeout </code>參數。"
  overload: System.Threading.Thread.Join*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "值<code> timeout </code>為負數且不等於&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;以毫秒為單位，或大於&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;毫秒為單位。"
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "呼叫端嘗試聯結處於執行緒<xref href=&quot;System.Threading.ThreadState&quot;></xref>狀態。"
  platform:
  - net462
- uid: System.Threading.Thread.ManagedThreadId
  id: ManagedThreadId
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得目前 managed 執行緒的唯一識別碼。"
  remarks: "執行緒的 ManagedThreadId 屬性值是用來唯一識別其處理程序中的執行緒。       ManagedThreadId 屬性的值不會變化經過一段時間，即使裝載 common language runtime 的 unmanaged 程式碼實作在 fiber 的執行緒。"
  syntax:
    content: public int ManagedThreadId { get; }
    return:
      type: System.Int32
      description: "整數，表示這個 managed 執行緒的唯一識別碼。"
  overload: System.Threading.Thread.ManagedThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.MemoryBarrier
  id: MemoryBarrier
  parent: System.Threading.Thread
  langs:
  - csharp
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: '同步處理記憶體存取，如下所示︰ 執行目前執行緒的處理器無法重新排列指示，例如後呼叫 MemoryBarrier 記憶體存取之後執行之前呼叫 MemoryBarrier 記憶體存取的方式。'
  remarks: "只在多處理器系統上需要 MemoryBarrier 弱式排序 （例如，採用多個將 Intel Itanium 處理器的系統） 的記憶體。       大部分的用途而言，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，或<xref:System.Threading.Monitor>類別提供簡單的方式同步處理資料。</xref:System.Threading.Monitor>"
  syntax:
    content: public static void MemoryBarrier ();
    parameters: []
  overload: System.Threading.Thread.MemoryBarrier*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Name
  id: Name
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得或設定執行緒的名稱。"
  remarks: "這個屬性是寫入-之後。 因為執行緒的名稱屬性的預設值是`null`，您可以判斷是否已明確指派名稱給執行緒藉由比較它與`null`。       指派給名稱屬性的字串可以包含任何 Unicode 字元。"
  example:
  - "The following example shows how to name a thread.  \n  \n [!code-cs[System.Threading.Thread.Name#1](~/add/codesnippet/csharp/p-system.threading.threa_4_1.cs)]\n [!code-cpp[System.Threading.Thread.Name#1](~/add/codesnippet/cpp/p-system.threading.threa_4_1.cpp)]\n [!code-vb[System.Threading.Thread.Name#1](~/add/codesnippet/visualbasic/p-system.threading.threa_4_1.vb)]"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "字串，包含執行緒的名稱或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果沒有設定名稱。"
  overload: System.Threading.Thread.Name*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已要求一組作業，但<xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref>屬性已設定。"
  platform:
  - net462
- uid: System.Threading.Thread.Priority
  id: Priority
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得或設定值，指出執行緒的排程優先權。"
  remarks: "下列優先順序的任何一個可以指派一個執行緒<xref:System.Threading.ThreadPriority>值:- `Highest`       -    `AboveNormal`       -    `Normal`       -    `BelowNormal`       -    `Lowest`作業系統不需要接受執行緒的優先權。</xref:System.Threading.ThreadPriority>"
  example:
  - "The following example shows the result of changing the priority of a thread. Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>, and the priority of a second is set to <xref:System.Threading.ThreadPriority?displayProperty=fullName>. Each thread increments a variable in a `while` loop and runs for a set time.  \n  \n [!code-cs[System.Threading.ThreadPriority#1](~/add/codesnippet/csharp/p-system.threading.threa_6_1.cs)]\n [!code-vb[System.Threading.ThreadPriority#1](~/add/codesnippet/visualbasic/p-system.threading.threa_6_1.vb)]"
  syntax:
    content: public System.Threading.ThreadPriority Priority { get; set; }
    return:
      type: System.Threading.ThreadPriority
      description: "其中一個<xref href=&quot;System.Threading.ThreadPriority&quot;></xref>值。 預設值是<xref href=&quot;System.Threading.ThreadPriority&quot;> </xref>。"
  overload: System.Threading.Thread.Priority*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "此執行緒已達到最終狀態，例如<xref href=&quot;System.Threading.ThreadState&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定給 set 作業不是有效的值<xref href=&quot;System.Threading.ThreadPriority&quot;></xref>值。"
  platform:
  - net462
- uid: System.Threading.Thread.ResetAbort
  id: ResetAbort
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取消<xref:System.Threading.Thread.Abort*>目前執行緒要求。</xref:System.Threading.Thread.Abort*>"
  remarks: "只使用適當的權限的程式碼可以呼叫這個方法。       進行呼叫以`Abort`來終止執行緒，系統會擲回<xref:System.Threading.ThreadAbortException>.</xref:System.Threading.ThreadAbortException> `ThreadAbortException`是特殊的例外狀況，應用程式程式碼可以攔截但重新擲回的 catch 區塊的結尾除非`ResetAbort`呼叫。 `ResetAbort`取消要求中止，並防止`ThreadAbortException`終止執行緒。       請參閱<xref:System.Threading.ThreadAbortException>的範例，示範如何呼叫`ResetAbort`方法。</xref:System.Threading.ThreadAbortException>"
  syntax:
    content: public static void ResetAbort ();
    parameters: []
  overload: System.Threading.Thread.ResetAbort*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "<xref uid=&quot;langword_csharp_Abort&quot; name=&quot;Abort&quot; href=&quot;&quot;></xref>不在目前的執行緒上叫用。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的安全性權限目前的執行緒。"
  platform:
  - net462
- uid: System.Threading.Thread.Resume
  id: Resume
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "繼續已暫止的執行緒。"
  remarks: >-
    > [!CAUTION]

    >  Do not use the <xref:System.Threading.Thread.Suspend%2A> and Resume methods to synchronize the activities of threads. You have no way of knowing what code a thread is executing when you suspend it. If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked. If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked. Deadlocks can occur very easily.
  syntax:
    content: public void Resume ();
    parameters: []
  overload: System.Threading.Thread.Resume*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "執行緒未啟動、 已無作用，或不是處於暫停狀態。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有適當<xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>。"
  platform:
  - net462
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  id: SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "它會啟動之前，請設定執行緒的 apartment 狀態。"
  remarks: "新的執行緒都會初始化成<xref:System.Threading.ApartmentState?displayProperty=fullName>如果其 apartment 狀態尚未設定之前啟動。</xref:System.Threading.ApartmentState?displayProperty=fullName> 在執行緒啟動之前，必須設定 apartment 狀態。      > [!NOTE] > 主應用程式執行緒會初始化為<xref:System.Threading.ApartmentState?displayProperty=fullName>預設。</xref:System.Threading.ApartmentState?displayProperty=fullName> 若要設定主應用程式執行緒的 apartment 狀態的唯一方式<xref:System.Threading.ApartmentState?displayProperty=fullName>是套用<xref:System.STAThreadAttribute>屬性設定為進入點方法。</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       SetApartmentState 方法中，連同<xref:System.Threading.Thread.GetApartmentState%2A>方法和<xref:System.Threading.Thread.TrySetApartmentState%2A>方法，會取代<xref:System.Threading.Thread.ApartmentState%2A>屬性。</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.TrySetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, SetApartmentState, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and SetApartmentState changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with SetApartmentState, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_6_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_6_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_6_1.cs)]"
  syntax:
    content: public void SetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "新的 apartment 狀態。"
  overload: System.Threading.Thread.SetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>不是有效的 apartment 狀態。"
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "已啟動執行緒。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "Apartment 狀態已經初始化。"
  platform:
  - net462
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  id: SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "適用於擷取<xref href=&quot;System.Threading.CompressedStack&quot;></xref>到目前的執行緒。"
  remarks: "不再支援這個方法。"
  syntax:
    content: public void SetCompressedStack (System.Threading.CompressedStack stack);
    parameters:
    - id: stack
      type: System.Threading.CompressedStack
      description: "<xref href=&quot;System.Threading.CompressedStack&quot;> </xref>来套用至目前執行緒的物件。"
  overload: System.Threading.Thread.SetCompressedStack*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "在所有情況下。"
  platform:
  - net462
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  id: SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "目前執行的執行緒，該執行緒的目前網域的指定位置中設定資料。 以提升效能、 使用以標示的欄位<xref:System.ThreadStaticAttribute>屬性，屬性。</xref:System.ThreadStaticAttribute>"
  remarks: "> [!IMPORTANT]>.NET Framework 提供兩種機制來使用執行緒區域儲存區 (TLS): 執行緒相關的靜態欄位 (也就是使用標示的欄位<xref:System.ThreadStaticAttribute>屬性) 和資料位置。</xref:System.ThreadStaticAttribute> 提供較佳的效能比資料的位置，並編譯時間類型檢查執行緒相關的靜態欄位。 如需有關如何使用 TLS 的詳細資訊，請參閱[執行緒區域儲存區︰ 執行緒相關的靜態欄位和資料位置](~/add/includes/ajax-current-ext-md.md)。       執行緒會使用本機存放區的記憶體機制，以儲存執行緒特定資料。 建立時，common language runtime 會配置每個處理序的多位置資料存放區陣列。 執行緒用來配置資料存放區中的資料位置，儲存和擷取資料值插槽中並在執行緒程序結束之後釋放重複使用的位置和<xref:System.Threading.Thread>已經由記憶體回收回收物件。</xref:System.Threading.Thread> 資料位置是每個執行緒的唯一的。 沒有其他執行緒 （甚至子執行緒） 可以取得該資料。      > [!NOTE] > SetData 是`Shared`一律適用於目前執行中執行緒，即使您使用的變數，指的是另一個執行緒呼叫的方法。 為了避免混淆，類別名稱呼叫時，使用`Shared`方法︰ `Thread.SetData(testSlot, &quot;test data&quot;)`。"
  example:
  - "This section contains two code examples. The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information. The second example shows how to use a data slot to do the same thing.  \n  \n **First Example**  \n  \n The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information. This technique provides better performance than the technique that is shown in the second example.  \n  \n [!code-cs[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/csharp/m-system.threading.threa_4_1.cs)]\n [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_1.vb)]\n [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/add/codesnippet/cpp/m-system.threading.threa_4_1.cpp)]  \n  \n **Second Example**  \n  \n The following example demonstrates how to use a named data slot to store thread-specific information.  \n  \n [!code-cs[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/csharp/m-system.threading.threa_4_2.cs)]\n [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/cpp/m-system.threading.threa_4_2.cpp)]\n [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/add/codesnippet/visualbasic/m-system.threading.threa_4_2.vb)]"
  syntax:
    content: public static void SetData (LocalDataStoreSlot slot, object data);
    parameters:
    - id: slot
      type: System.LocalDataStoreSlot
      description: "<xref href=&quot;System.LocalDataStoreSlot&quot;> </xref>要設定的值。"
    - id: data
      type: System.Object
      description: "要設定的值。"
  overload: System.Threading.Thread.SetData*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.Int32)
  id: Sleep(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "暫止指定的毫秒數目前的執行緒。"
  remarks: "執行緒不會執行由作業系統在指定的時間排程。 這個方法會變更要包含<xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState>執行緒的狀態       您可以指定<xref:System.Threading.Timeout.Infinite?displayProperty=fullName>如`millisecondsTimeout`無限期地暫止執行緒的參數。</xref:System.Threading.Timeout.Infinite?displayProperty=fullName> 不過，我們建議您使用其他<xref:System.Threading?displayProperty=fullName>之類的類別<xref:System.Threading.Mutex>， <xref:System.Threading.Monitor>， <xref:System.Threading.EventWaitHandle>，或<xref:System.Threading.Semaphore>改為還執行緒或管理資源。</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       在特定速率的系統時鐘刻度呼叫時鐘的解析度。 實際逾時可能不完全指定的逾時，因為指定的逾時將會調整，讓時鐘刻度一致。 如需有關時鐘的解析度和等候時間的詳細資訊，請參閱[睡眠函式](http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)主題。 這個方法會呼叫[睡眠函式](http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx)Windows 系統應用程式開發介面。       這個方法不會執行標準的 COM 與 SendMessage 幫浦作業。      > [!NOTE] > 如果您需要進入睡眠狀態已在執行緒上<xref:System.STAThreadAttribute>，但您想要執行標準的 COM 與 SendMessage 幫浦作業，請考慮使用其中一個多載的<xref:System.Threading.Thread.Join%2A>方法所指定的逾時間隔。</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method to block the application's main thread.  \n  \n [!code-cs[Thread.Sleep#1](~/add/codesnippet/csharp/m-system.threading.threa_2_1.cs)]\n [!code-vb[Thread.Sleep#1](~/add/codesnippet/visualbasic/m-system.threading.threa_2_1.vb)]\n [!code-cpp[Thread.Sleep#1](~/add/codesnippet/cpp/m-system.threading.threa_2_1.cpp)]"
  syntax:
    content: public static void Sleep (int millisecondsTimeout);
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "執行緒暫止的毫秒數。 如果值`millisecondsTimeout`引數是&0;，執行緒會佔用剩餘的任何準備好要執行的同等優先權執行緒的時間配量。 如果有任何其他的同等優先權執行緒，準備好要執行，則目前執行緒的執行不會暫停。"
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "逾時值為負數且不等於<xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  id: Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "指定的時間量內暫止目前的執行緒。"
  remarks: "執行緒不會執行由作業系統在指定的時間排程。 這個方法會變更要包含<xref:System.Threading.ThreadState>.</xref:System.Threading.ThreadState>執行緒的狀態       您可以指定<xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName>如`timeout`無限期地暫止執行緒的參數。</xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=fullName> 不過，我們建議您使用其他<xref:System.Threading?displayProperty=fullName>之類的類別<xref:System.Threading.Mutex>， <xref:System.Threading.Monitor>， <xref:System.Threading.EventWaitHandle>，或<xref:System.Threading.Semaphore>改為還執行緒或管理資源。</xref:System.Threading.Semaphore> </xref:System.Threading.EventWaitHandle> </xref:System.Threading.Monitor> </xref:System.Threading.Mutex> </xref:System.Threading?displayProperty=fullName>       這個多載<xref:System.Threading.Thread.Sleep%2A>使用中的整數毫秒總數`timeout`。</xref:System.Threading.Thread.Sleep%2A> 小數的毫秒都會被捨棄。       這個方法不會執行標準的 COM 與 SendMessage 幫浦作業。      > [!NOTE] > 如果您需要進入睡眠狀態已在執行緒上<xref:System.STAThreadAttribute>，但您想要執行標準的 COM 與 SendMessage 幫浦作業，請考慮使用其中一個多載的<xref:System.Threading.Thread.Join%2A>方法所指定的逾時間隔。</xref:System.Threading.Thread.Join%2A> </xref:System.STAThreadAttribute>"
  example:
  - "The following example uses the Sleep method overload to block the application's main thread five times, for two seconds each time.  \n  \n [!code-cpp[Thread.Sleep_TimeSpan#1](~/add/codesnippet/cpp/m-system.threading.threa_31_1.cpp)]\n [!code-cs[Thread.Sleep_TimeSpan#1](~/add/codesnippet/csharp/m-system.threading.threa_31_1.cs)]\n [!code-vb[Thread.Sleep_TimeSpan#1](~/add/codesnippet/visualbasic/m-system.threading.threa_31_1.vb)]"
  syntax:
    content: public static void Sleep (TimeSpan timeout);
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "執行緒暫止的時間量。 如果值`millisecondsTimeout`引數是&lt;xref:System.TimeSpan?displayProperty=fullName&gt;，執行緒會佔用剩餘的任何準備好要執行的同等優先權執行緒的時間配量。 如果有任何其他的同等優先權執行緒，準備好要執行，則目前執行緒的執行不會暫停。"
  overload: System.Threading.Thread.Sleep*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "值<code> timeout </code>為負數且不等於&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;以毫秒為單位，或大於&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;毫秒為單位。"
  platform:
  - net462
- uid: System.Threading.Thread.SpinWait(System.Int32)
  id: SpinWait(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "造成等候的次數所定義的執行緒<code> iterations </code>參數。"
  remarks: "SpinWait 方法可用於實作鎖定。 類別在.NET Framework 中，例如<xref:System.Threading.Monitor>和<xref:System.Threading.ReaderWriterLock>，這個方法會在內部使用。</xref:System.Threading.ReaderWriterLock> </xref:System.Threading.Monitor> SpinWait 基本上放處理器非常緊密迴圈中，與所指定的迴圈計數`iterations`參數。 等候的持續時間因此取決於處理器的速度。       與<xref:System.Threading.Thread.Sleep%2A>方法。</xref:System.Threading.Thread.Sleep%2A> 呼叫的執行緒<xref:System.Threading.Thread.Sleep%2A>會產生其目前的配量的處理器時間的其餘部分，即使指定的時間間隔為零。</xref:System.Threading.Thread.Sleep%2A> 指定非零間隔<xref:System.Threading.Thread.Sleep%2A>經過的時間間隔之前，由執行緒排程器將不考慮移除執行緒。</xref:System.Threading.Thread.Sleep%2A>       SpinWait 不通常適用於一般的應用程式。 在大部分情況下，您應該使用.NET Framework; 所提供的同步處理類別例如，呼叫<xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>或陳述式包裝<xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>(`lock`在 C# 或`SyncLock`在 Visual Basic 中)。</xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> </xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>      > [!CAUTION] > 的少數情況下，其中的好處是，若要避免將內容切換，例如當您知道狀態變更已即將發生，請 SpinWait 方法的呼叫在迴圈中。 SpinWait 執行的程式碼被為了防止具有多個處理器的電腦上可能發生的問題。 比方說，在電腦上具有多個採用超執行緒技術的 Intel 處理器，SpinWait 可防止在某些情況下的處理器資源用盡。"
  syntax:
    content: public static void SpinWait (int iterations);
    parameters:
    - id: iterations
      type: System.Int32
      description: "32 位元帶正負號的整數，定義執行緒的時間等候。"
  overload: System.Threading.Thread.SpinWait*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Start
  id: Start
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "造成作業系統將目前的執行個體的狀態變更為<xref href=&quot;System.Threading.ThreadState&quot;> </xref>。"
  remarks: "一旦執行緒處於<xref:System.Threading.ThreadState?displayProperty=fullName>狀態時，系統可以將它排程執行。</xref:System.Threading.ThreadState?displayProperty=fullName> 在執行緒開始執行所表示之方法的第一行<xref:System.Threading.ThreadStart>或<xref:System.Threading.ParameterizedThreadStart>委派提供給執行緒的建構函式。</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> 請注意，開始呼叫不會封鎖呼叫執行緒。      > [!NOTE] > 這個多載會搭配使用所建立的執行緒<xref:System.Threading.ParameterizedThreadStart>委派，`null`傳遞至由執行緒執行的方法。</xref:System.Threading.ParameterizedThreadStart>       一旦在執行緒結束，無法將它重新啟動與另一個呼叫`Start`。"
  example:
  - "The following example creates and starts a thread.  \n  \n [!code-cpp[ThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_25_1.cpp)]\n [!code-cs[ThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_25_1.cs)]\n [!code-vb[ThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_25_1.vb)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "已啟動執行緒。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可用來啟動這個執行緒。"
  platform:
  - net462
- uid: System.Threading.Thread.Start(System.Object)
  id: Start(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "造成作業系統將目前的執行個體的狀態變更為<xref href=&quot;System.Threading.ThreadState&quot;> </xref>，並選擇性地提供物件，其中包含要由執行緒執行的方法所使用的資料。"
  remarks: "一旦執行緒處於<xref:System.Threading.ThreadState?displayProperty=fullName>狀態時，系統可以將它排程執行。</xref:System.Threading.ThreadState?displayProperty=fullName> 在執行緒開始執行所表示之方法的第一行<xref:System.Threading.ThreadStart>或<xref:System.Threading.ParameterizedThreadStart>委派提供給執行緒的建構函式。</xref:System.Threading.ParameterizedThreadStart> </xref:System.Threading.ThreadStart> 請注意，開始呼叫不會封鎖呼叫執行緒。       一旦在執行緒結束，無法將它重新啟動與另一個呼叫`Start`。       這個多載而<xref:System.Threading.ParameterizedThreadStart>委派即可輕易地將資料傳遞給執行緒的程序，但方法不是類型安全因為任何物件可以傳遞給這個多載。</xref:System.Threading.ParameterizedThreadStart> 將執行緒的程序與資料欄位放入背景工作物件是更穩固的方式，將資料傳遞給執行緒的程序。 如需詳細資訊，請參閱[建立執行緒和開始時間傳遞資料](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.  \n  \n [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/cpp/m-system.threading.threa_15_1.cpp)]\n [!code-vb[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/visualbasic/m-system.threading.threa_15_1.vb)]\n [!code-cs[System.Threading.ParameterizedThreadStart#1](~/add/codesnippet/csharp/m-system.threading.threa_15_1.cs)]"
  syntax:
    content: public void Start (object parameter);
    parameters:
    - id: parameter
      type: System.Object
      description: "物件，其中包含資料的方法所使用的執行緒執行。"
  overload: System.Threading.Thread.Start*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "已啟動執行緒。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可用來啟動這個執行緒。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "這個執行緒使用建立<xref href=&quot;System.Threading.ThreadStart&quot;></xref>而不是委派<xref href=&quot;System.Threading.ParameterizedThreadStart&quot;></xref>委派。"
  platform:
  - net462
- uid: System.Threading.Thread.Suspend
  id: Suspend
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "暫止的執行緒，或者如果執行緒已經暫止，則沒有影響。"
  remarks: "如果執行緒已經暫止，這個方法沒有任何作用。      > [!CAUTION] > 不使用暫停並<xref:System.Threading.Thread.Resume%2A>方法來同步處理執行緒活動。</xref:System.Threading.Thread.Resume%2A> 您有無從得知哪些程式碼的執行緒正在執行，當您暫停它。 如果您暫停執行緒，而安全性權限評估期間保留鎖定，其他執行緒中<xref:System.AppDomain>可能封鎖。</xref:System.AppDomain> 如果類別建構函式執行時，您可以暫停執行緒，其他執行緒中<xref:System.AppDomain>，嘗試使用封鎖的類別。</xref:System.AppDomain> 很容易發生死結。"
  syntax:
    content: public void Suspend ();
    parameters: []
  overload: System.Threading.Thread.Suspend*
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "執行緒未啟動，或已無作用。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有適當<xref href=&quot;System.Security.Permissions.SecurityPermission&quot;> </xref>。"
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將一組名稱對應至一組對應的分派識別項。"
  remarks: "這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。"
  syntax:
    content: void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "保留供將來使用。 必須是 IID_NULL。"
    - id: rgszNames
      type: System.IntPtr
      description: "傳入的對應名稱的陣列。"
    - id: cNames
      type: System.UInt32
      description: "要對應的名稱計數。"
    - id: lcid
      type: System.UInt32
      description: "地區設定內容，用於解譯名稱。"
    - id: rgDispId
      type: System.IntPtr
      description: "呼叫端配置的陣列，用於接收對應於名稱的 Id。"
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "使用 COM 的晚期繫結存取`IDispatch`不支援的介面。"
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "擷取的類型資訊物件，然後可以用來取得介面的型別資訊。"
  remarks: "這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetTypeInfo`，請參閱 MSDN Library。"
  syntax:
    content: void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "要傳回的類型資訊。"
    - id: lcid
      type: System.UInt32
      description: "型別資訊的地區設定識別項。"
    - id: ppTInfo
      type: System.IntPtr
      description: "接收到要求的類型資訊物件的指標。"
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "使用 COM 的晚期繫結存取`IDispatch`不支援的介面。"
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  id: System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "擷取物件提供 （0 或 1） 的類型資訊介面數目。"
  remarks: "這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。"
  syntax:
    content: void _Thread.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "指向接收物件提供的類型資訊介面數目的位置。"
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "使用 COM 的晚期繫結存取`IDispatch`不支援的介面。"
  platform:
  - net462
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.Threading.Thread
  langs:
  - csharp
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "提供屬性和物件所公開的方法存取權。"
  remarks: "這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::Invoke`，請參閱 MSDN Library。"
  syntax:
    content: void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "辨識成員。"
    - id: riid
      type: System.Guid
      description: "保留供將來使用。 必須是 IID_NULL。"
    - id: lcid
      type: System.UInt32
      description: "地區設定內容，用於解譯引數。"
    - id: wFlags
      type: System.Int16
      description: "描述呼叫之內容的旗標。"
    - id: pDispParams
      type: System.IntPtr
      description: "此結構包含引數陣列，為具名引數，以及陣列中的項目數目的計數的引數 Dispid 陣列指標。"
    - id: pVarResult
      type: System.IntPtr
      description: "儲存結果之位置的指標。"
    - id: pExcepInfo
      type: System.IntPtr
      description: "包含例外狀況資訊的結構指標。"
    - id: puArgErr
      type: System.IntPtr
      description: "發生錯誤的第一個引數索引。"
  overload: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "使用 COM 的晚期繫結存取`IDispatch`不支援的介面。"
  platform:
  - net462
- uid: System.Threading.Thread.ThreadState
  id: ThreadState
  parent: System.Threading.Thread
  langs:
  - csharp
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "取得值，其中包含目前執行緒的狀態。"
  remarks: "ThreadState 屬性提供更具體的資訊比<xref:System.Threading.Thread.IsAlive%2A>屬性。</xref:System.Threading.Thread.IsAlive%2A>      > [!IMPORTANT] > 執行緒狀態只有時才想要偵錯案例。 您的程式碼永遠不應該使用執行緒狀態來同步處理執行緒活動。"
  example:
  - "The following code example demonstrates accessing the `ThreadState` of a thread.  \n  \n [!code-cs[System.Threading.Thread.ThreadState#1](~/add/codesnippet/csharp/p-system.threading.threa_5_1.cs)]\n [!code-vb[System.Threading.Thread.ThreadState#1](~/add/codesnippet/visualbasic/p-system.threading.threa_5_1.vb)]\n [!code-cpp[System.Threading.Thread.ThreadState#1](~/add/codesnippet/cpp/p-system.threading.threa_5_1.cpp)]"
  syntax:
    content: public System.Threading.ThreadState ThreadState { get; }
    return:
      type: System.Threading.ThreadState
      description: "其中一個<xref href=&quot;System.Threading.ThreadState&quot;></xref>值，表示目前執行緒的狀態。 初始值是<xref uid=&quot;langword_csharp_Unstarted&quot; name=&quot;Unstarted&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.Thread.ThreadState*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  id: TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "它會啟動之前，請設定執行緒的 apartment 狀態。"
  remarks: "新的執行緒都會初始化成<xref:System.Threading.ApartmentState?displayProperty=fullName>如果其 apartment 狀態尚未設定之前啟動。</xref:System.Threading.ApartmentState?displayProperty=fullName> 在執行緒啟動之前，必須設定 apartment 狀態。      > [!NOTE] > 主應用程式執行緒會初始化為<xref:System.Threading.ApartmentState?displayProperty=fullName>預設。</xref:System.Threading.ApartmentState?displayProperty=fullName> 若要設定主應用程式執行緒的 apartment 狀態的唯一方式<xref:System.Threading.ApartmentState?displayProperty=fullName>是套用<xref:System.STAThreadAttribute>屬性設定為進入點方法。</xref:System.STAThreadAttribute> </xref:System.Threading.ApartmentState?displayProperty=fullName>       TrySetApartmentState 方法中，連同<xref:System.Threading.Thread.GetApartmentState%2A>方法和<xref:System.Threading.Thread.SetApartmentState%2A>方法，會取代<xref:System.Threading.Thread.ApartmentState%2A>屬性。</xref:System.Threading.Thread.ApartmentState%2A> </xref:System.Threading.Thread.SetApartmentState%2A> </xref:System.Threading.Thread.GetApartmentState%2A>"
  example:
  - "The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and TrySetApartmentState methods. The code example creates a thread. Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState?displayProperty=fullName> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState?displayProperty=fullName>. The TrySetApartmentState method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState?displayProperty=fullName> because the apartment state is already set. If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.  \n  \n After the thread is started, the TrySetApartmentState method is used again. This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.  \n  \n [!code-vb[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/visualbasic/m-system.threading.threa_26_1.vb)]\n [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/cpp/m-system.threading.threa_26_1.cpp)]\n [!code-cs[Thread.GetSetTrySetApartmentState#1](~/add/codesnippet/csharp/m-system.threading.threa_26_1.cs)]"
  syntax:
    content: public bool TrySetApartmentState (System.Threading.ApartmentState state);
    parameters:
    - id: state
      type: System.Threading.ApartmentState
      description: "新的 apartment 狀態。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果已設定 apartment 狀態。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.Thread.TrySetApartmentState*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>state</code>不是有效的 apartment 狀態。"
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "已啟動執行緒。"
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  id: VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "讀取欄位值。 值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。"
  remarks: "VolatileRead 和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，VolatileRead 會取得由任意處理器寫入記憶體位置的最新值。 這可能需要清除處理器快取。       甚至單一處理器的系統上，VolatileRead 和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用 VolatileRead 或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用 VolatileRead 或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A>"
  syntax:
    content: public static byte VolatileRead (ref byte address);
    parameters:
    - id: address
      type: System.Byte
      description: "要讀取的欄位。"
    return:
      type: System.Byte
      description: "由任意處理器寫入欄位的最新值。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  id: VolatileRead(System.Double@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "讀取欄位值。 值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</xref:System.Threading.Thread.VolatileRead%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static double VolatileRead (ref double address);
    parameters:
    - id: address
      type: System.Double
      description: "要讀取的欄位。"
    return:
      type: System.Double
      description: "由任意處理器寫入欄位的最新值。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  id: VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "讀取欄位值。 值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</xref:System.Threading.Thread.VolatileRead%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static short VolatileRead (ref short address);
    parameters:
    - id: address
      type: System.Int16
      description: "要讀取的欄位。"
    return:
      type: System.Int16
      description: "由任意處理器寫入欄位的最新值。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  id: VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "讀取欄位值。 值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</xref:System.Threading.Thread.VolatileRead%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static int VolatileRead (ref int address);
    parameters:
    - id: address
      type: System.Int32
      description: "要讀取的欄位。"
    return:
      type: System.Int32
      description: "由任意處理器寫入欄位的最新值。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  id: VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "讀取欄位值。 值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</xref:System.Threading.Thread.VolatileRead%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static long VolatileRead (ref long address);
    parameters:
    - id: address
      type: System.Int64
      description: "要讀取的欄位。"
    return:
      type: System.Int64
      description: "由任意處理器寫入欄位的最新值。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  id: VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "讀取欄位值。 值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</xref:System.Threading.Thread.VolatileRead%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static IntPtr VolatileRead (ref IntPtr address);
    parameters:
    - id: address
      type: System.IntPtr
      description: "要讀取的欄位。"
    return:
      type: System.IntPtr
      description: "由任意處理器寫入欄位的最新值。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  id: VolatileRead(System.Object@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "讀取欄位值。 值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</xref:System.Threading.Thread.VolatileRead%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static object VolatileRead (ref object address);
    parameters:
    - id: address
      type: System.Object
      description: "要讀取的欄位。"
    return:
      type: System.Object
      description: "由任意處理器寫入欄位的最新值。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  id: VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "讀取欄位值。 值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</xref:System.Threading.Thread.VolatileRead%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static sbyte VolatileRead (ref sbyte address);
    parameters:
    - id: address
      type: System.SByte
      description: "要讀取的欄位。"
    return:
      type: System.SByte
      description: "由任意處理器寫入欄位的最新值。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  id: VolatileRead(System.Single@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "讀取欄位值。 值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</xref:System.Threading.Thread.VolatileRead%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static float VolatileRead (ref float address);
    parameters:
    - id: address
      type: System.Single
      description: "要讀取的欄位。"
    return:
      type: System.Single
      description: "由任意處理器寫入欄位的最新值。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  id: VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "讀取欄位值。 值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</xref:System.Threading.Thread.VolatileRead%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static ushort VolatileRead (ref ushort address);
    parameters:
    - id: address
      type: System.UInt16
      description: "要讀取的欄位。"
    return:
      type: System.UInt16
      description: "由任意處理器寫入欄位的最新值。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  id: VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "讀取欄位值。 值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</xref:System.Threading.Thread.VolatileRead%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static uint VolatileRead (ref uint address);
    parameters:
    - id: address
      type: System.UInt32
      description: "要讀取的欄位。"
    return:
      type: System.UInt32
      description: "由任意處理器寫入欄位的最新值。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  id: VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "讀取欄位值。 值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</xref:System.Threading.Thread.VolatileRead%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static ulong VolatileRead (ref ulong address);
    parameters:
    - id: address
      type: System.UInt64
      description: "要讀取的欄位。"
    return:
      type: System.UInt64
      description: "由任意處理器寫入欄位的最新值。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  id: VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "讀取欄位值。 值是由在電腦上，不論的處理器數目或處理器快取狀態的任意處理器最新寫入的。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileRead%2A>取得最新的值由任意處理器寫入記憶體位置。</xref:System.Threading.Thread.VolatileRead%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static UIntPtr VolatileRead (ref UIntPtr address);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "要讀取的欄位。"
    return:
      type: System.UIntPtr
      description: "由任意處理器寫入欄位的最新值。"
  overload: System.Threading.Thread.VolatileRead*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  id: VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將值寫入欄位，以便都可以看到電腦中的所有處理器的值。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>而且 VolatileWrite 的同步處理的特殊案例。</xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，VolatileWrite 可確保寫入記憶體位置的值就會立即顯示所有處理器。 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和 VolatileWrite 確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效欄位的同步處理，必須使用欄位的所有存取<xref:System.Threading.Thread.VolatileRead%2A>或 VolatileWrite。</xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位會都使用<xref:System.Threading.Thread.VolatileRead%2A>或 VolatileWrite。</xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref byte address, byte value);
    parameters:
    - id: address
      type: System.Byte
      description: "要寫入的值欄位。"
    - id: value
      type: System.Byte
      description: "要寫入的值。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  id: VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將值寫入欄位，以便都可以看到電腦中的所有處理器的值。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</xref:System.Threading.Thread.VolatileWrite%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref double address, double value);
    parameters:
    - id: address
      type: System.Double
      description: "要寫入的值欄位。"
    - id: value
      type: System.Double
      description: "要寫入的值。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  id: VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將值寫入欄位，以便都可以看到電腦中的所有處理器的值。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</xref:System.Threading.Thread.VolatileWrite%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref short address, short value);
    parameters:
    - id: address
      type: System.Int16
      description: "要寫入的值欄位。"
    - id: value
      type: System.Int16
      description: "要寫入的值。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  id: VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將值寫入欄位，以便都可以看到電腦中的所有處理器的值。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</xref:System.Threading.Thread.VolatileWrite%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref int address, int value);
    parameters:
    - id: address
      type: System.Int32
      description: "要寫入的值欄位。"
    - id: value
      type: System.Int32
      description: "要寫入的值。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  id: VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將值寫入欄位，以便都可以看到電腦中的所有處理器的值。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</xref:System.Threading.Thread.VolatileWrite%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref long address, long value);
    parameters:
    - id: address
      type: System.Int64
      description: "要寫入的值欄位。"
    - id: value
      type: System.Int64
      description: "要寫入的值。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  id: VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將值寫入欄位，以便都可以看到電腦中的所有處理器的值。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</xref:System.Threading.Thread.VolatileWrite%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref IntPtr address, IntPtr value);
    parameters:
    - id: address
      type: System.IntPtr
      description: "要寫入的值欄位。"
    - id: value
      type: System.IntPtr
      description: "要寫入的值。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  id: VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將值寫入欄位，以便都可以看到電腦中的所有處理器的值。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</xref:System.Threading.Thread.VolatileWrite%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref object address, object value);
    parameters:
    - id: address
      type: System.Object
      description: "要寫入的值欄位。"
    - id: value
      type: System.Object
      description: "要寫入的值。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  id: VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將值寫入欄位，以便都可以看到電腦中的所有處理器的值。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</xref:System.Threading.Thread.VolatileWrite%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref sbyte address, sbyte value);
    parameters:
    - id: address
      type: System.SByte
      description: "要寫入的值欄位。"
    - id: value
      type: System.SByte
      description: "要寫入的值。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  id: VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將值寫入欄位，以便都可以看到電腦中的所有處理器的值。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</xref:System.Threading.Thread.VolatileWrite%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref float address, float value);
    parameters:
    - id: address
      type: System.Single
      description: "要寫入的值欄位。"
    - id: value
      type: System.Single
      description: "要寫入的值。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  id: VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將值寫入欄位，以便都可以看到電腦中的所有處理器的值。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</xref:System.Threading.Thread.VolatileWrite%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref ushort address, ushort value);
    parameters:
    - id: address
      type: System.UInt16
      description: "要寫入的值欄位。"
    - id: value
      type: System.UInt16
      description: "要寫入的值。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  id: VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將值寫入欄位，以便都可以看到電腦中的所有處理器的值。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</xref:System.Threading.Thread.VolatileWrite%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref uint address, uint value);
    parameters:
    - id: address
      type: System.UInt32
      description: "要寫入的值欄位。"
    - id: value
      type: System.UInt32
      description: "要寫入的值。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  id: VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將值寫入欄位，以便都可以看到電腦中的所有處理器的值。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</xref:System.Threading.Thread.VolatileWrite%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref ulong address, ulong value);
    parameters:
    - id: address
      type: System.UInt64
      description: "要寫入的值欄位。"
    - id: value
      type: System.UInt64
      description: "要寫入的值。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  id: VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  langs:
  - csharp
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將值寫入欄位，以便都可以看到電腦中的所有處理器的值。"
  remarks: "<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>會同步處理的特殊案例。</xref:System.Threading.Thread.VolatileWrite%2A></xref:System.Threading.Thread.VolatileRead%2A> 在一般情況下，C#`lock`陳述式，Visual Basic`SyncLock`陳述式，而<xref:System.Threading.Monitor>類別提供您更輕鬆的替代項目。</xref:System.Threading.Monitor>       在多處理器系統上，<xref:System.Threading.Thread.VolatileWrite%2A>可確保寫入記憶體位置的值就會立即顯示所有處理器。</xref:System.Threading.Thread.VolatileWrite%2A> 這可能需要清除處理器快取。       在單一處理器系統上，甚至<xref:System.Threading.Thread.VolatileRead%2A>和<xref:System.Threading.Thread.VolatileWrite%2A>確保某值為讀取或寫入記憶體，並不會快取 （例如，在處理器暫存器）。</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A> 因此，您可以使用它們來進行同步存取另一個執行緒，或硬體可更新的欄位。       呼叫這個方法只會影響單一記憶體存取。 若要提供有效的同步處理欄位，欄位的所有存取必須都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>      > [!NOTE] > 在 C# 中，使用`volatile`欄位修飾詞可確保所有存取該欄位都使用<xref:System.Threading.Thread.VolatileRead%2A>或<xref:System.Threading.Thread.VolatileWrite%2A>.</xref:System.Threading.Thread.VolatileWrite%2A> </xref:System.Threading.Thread.VolatileRead%2A>"
  syntax:
    content: public static void VolatileWrite (ref UIntPtr address, UIntPtr value);
    parameters:
    - id: address
      type: System.UIntPtr
      description: "要寫入的值欄位。"
    - id: value
      type: System.UIntPtr
      description: "要寫入的值。"
  overload: System.Threading.Thread.VolatileWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.Thread.Yield
  id: Yield
  parent: System.Threading.Thread
  langs:
  - csharp
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "造成呼叫執行緒執行的準備好要執行目前處理器上的另一個執行緒。 作業系統會選擇要到執行的執行緒。"
  remarks: "如果此方法成功，會產生其他執行緒的目前時間配量。 作業系統排程呼叫執行緒的另一個時間配量，根據其優先順序和可執行其他執行緒的狀態。       產生僅限於用來執行呼叫執行緒的處理器。 作業系統不會切換執行為另一個處理器，即使該處理器處於閒置狀態，或正在執行較低優先權的執行緒。 如果沒有其他準備好要執行目前處理器上的執行緒、 作業系統並不會執行，產生和這個方法會傳回`false`。       這個方法相當於使用平台叫用呼叫原生 Win32`SwitchToThread`函式。 您應該呼叫方法，而不要使用平台叫用時，結果因為平台叫用略過任何自訂主應用程式已要求的執行緒行為。"
  syntax:
    content: public static bool Yield ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果作業系統切換為執行其他執行緒，否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.Thread.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  isExternal: false
  name: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Threading.ThreadStateException
  parent: System.Threading
  isExternal: false
  name: ThreadStateException
  nameWithType: ThreadStateException
  fullName: System.Threading.ThreadStateException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Threading.ThreadInterruptedException
  parent: System.Threading
  isExternal: false
  name: ThreadInterruptedException
  nameWithType: ThreadInterruptedException
  fullName: System.Threading.ThreadInterruptedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart)
  nameWithType: Thread.Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart)
- uid: System.Threading.ParameterizedThreadStart
  parent: System.Threading
  isExternal: false
  name: ParameterizedThreadStart
  nameWithType: ParameterizedThreadStart
  fullName: System.Threading.ParameterizedThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart)
  nameWithType: Thread.Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(ThreadStart)
- uid: System.Threading.ThreadStart
  parent: System.Threading
  isExternal: false
  name: ThreadStart
  nameWithType: ThreadStart
  fullName: System.Threading.ThreadStart
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ParameterizedThreadStart,Int32)
  nameWithType: Thread.Thread(ParameterizedThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ParameterizedThreadStart,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Thread(ThreadStart,Int32)
  nameWithType: Thread.Thread(ThreadStart,Int32)
  fullName: System.Threading.Thread.Thread(ThreadStart,Int32)
- uid: System.Threading.Thread.Abort
  parent: System.Threading.Thread
  isExternal: false
  name: Abort()
  nameWithType: Thread.Abort()
  fullName: System.Threading.Thread.Abort()
- uid: System.Threading.Thread.Abort(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Abort(Object)
  nameWithType: Thread.Abort(Object)
  fullName: System.Threading.Thread.Abort(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Threading.Thread.AllocateDataSlot
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot()
  nameWithType: Thread.AllocateDataSlot()
  fullName: System.Threading.Thread.AllocateDataSlot()
- uid: System.LocalDataStoreSlot
  parent: System
  isExternal: false
  name: LocalDataStoreSlot
  nameWithType: LocalDataStoreSlot
  fullName: System.LocalDataStoreSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot(String)
  nameWithType: Thread.AllocateNamedDataSlot(String)
  fullName: System.Threading.Thread.AllocateNamedDataSlot(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Threading.Thread.ApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
  fullName: System.Threading.Thread.ApartmentState
- uid: System.Threading.ApartmentState
  parent: System.Threading
  isExternal: false
  name: ApartmentState
  nameWithType: ApartmentState
  fullName: System.Threading.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion()
  nameWithType: Thread.BeginCriticalRegion()
  fullName: System.Threading.Thread.BeginCriticalRegion()
- uid: System.Threading.Thread.BeginThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity()
  nameWithType: Thread.BeginThreadAffinity()
  fullName: System.Threading.Thread.BeginThreadAffinity()
- uid: System.Threading.Thread.CurrentContext
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
  fullName: System.Threading.Thread.CurrentContext
- uid: System.Runtime.Remoting.Contexts.Context
  parent: System.Runtime.Remoting.Contexts
  isExternal: false
  name: Context
  nameWithType: Context
  fullName: System.Runtime.Remoting.Contexts.Context
- uid: System.Threading.Thread.CurrentCulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
  fullName: System.Threading.Thread.CurrentCulture
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Threading.Thread.CurrentPrincipal
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
  fullName: System.Threading.Thread.CurrentPrincipal
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.Threading.Thread.CurrentThread
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
  fullName: System.Threading.Thread.CurrentThread
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Threading.Thread.CurrentUICulture
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
  fullName: System.Threading.Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup()
  nameWithType: Thread.DisableComObjectEagerCleanup()
  fullName: System.Threading.Thread.DisableComObjectEagerCleanup()
- uid: System.Threading.Thread.EndCriticalRegion
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion()
  nameWithType: Thread.EndCriticalRegion()
  fullName: System.Threading.Thread.EndCriticalRegion()
- uid: System.Threading.Thread.EndThreadAffinity
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity()
  nameWithType: Thread.EndThreadAffinity()
  fullName: System.Threading.Thread.EndThreadAffinity()
- uid: System.Threading.Thread.ExecutionContext
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
  fullName: System.Threading.Thread.ExecutionContext
- uid: System.Threading.ExecutionContext
  parent: System.Threading
  isExternal: true
  name: ExecutionContext
  nameWithType: ExecutionContext
  fullName: System.Threading.ExecutionContext
- uid: System.Threading.Thread.Finalize
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize()
  nameWithType: Thread.Finalize()
  fullName: System.Threading.Thread.Finalize()
- uid: System.Threading.Thread.FreeNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot(String)
  nameWithType: Thread.FreeNamedDataSlot(String)
  fullName: System.Threading.Thread.FreeNamedDataSlot(String)
- uid: System.Threading.Thread.GetApartmentState
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState()
  nameWithType: Thread.GetApartmentState()
  fullName: System.Threading.Thread.GetApartmentState()
- uid: System.Threading.Thread.GetCompressedStack
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack()
  nameWithType: Thread.GetCompressedStack()
  fullName: System.Threading.Thread.GetCompressedStack()
- uid: System.Threading.CompressedStack
  parent: System.Threading
  isExternal: false
  name: CompressedStack
  nameWithType: CompressedStack
  fullName: System.Threading.CompressedStack
- uid: System.Threading.Thread.GetData(System.LocalDataStoreSlot)
  parent: System.Threading.Thread
  isExternal: false
  name: GetData(LocalDataStoreSlot)
  nameWithType: Thread.GetData(LocalDataStoreSlot)
  fullName: System.Threading.Thread.GetData(LocalDataStoreSlot)
- uid: System.Threading.Thread.GetDomain
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain()
  nameWithType: Thread.GetDomain()
  fullName: System.Threading.Thread.GetDomain()
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.Threading.Thread.GetDomainID
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID()
  nameWithType: Thread.GetDomainID()
  fullName: System.Threading.Thread.GetDomainID()
- uid: System.Threading.Thread.GetHashCode
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode()
  nameWithType: Thread.GetHashCode()
  fullName: System.Threading.Thread.GetHashCode()
- uid: System.Threading.Thread.GetNamedDataSlot(System.String)
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot(String)
  nameWithType: Thread.GetNamedDataSlot(String)
  fullName: System.Threading.Thread.GetNamedDataSlot(String)
- uid: System.Threading.Thread.Interrupt
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt()
  nameWithType: Thread.Interrupt()
  fullName: System.Threading.Thread.Interrupt()
- uid: System.Threading.Thread.IsAlive
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
  fullName: System.Threading.Thread.IsAlive
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Threading.Thread.IsBackground
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
  fullName: System.Threading.Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
  fullName: System.Threading.Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join
  parent: System.Threading.Thread
  isExternal: false
  name: Join()
  nameWithType: Thread.Join()
  fullName: System.Threading.Thread.Join()
- uid: System.Threading.Thread.Join(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(Int32)
  nameWithType: Thread.Join(Int32)
  fullName: System.Threading.Thread.Join(Int32)
- uid: System.Threading.Thread.Join(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Join(TimeSpan)
  nameWithType: Thread.Join(TimeSpan)
  fullName: System.Threading.Thread.Join(TimeSpan)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.Thread.ManagedThreadId
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier()
  nameWithType: Thread.MemoryBarrier()
  fullName: System.Threading.Thread.MemoryBarrier()
- uid: System.Threading.Thread.Name
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
  fullName: System.Threading.Thread.Name
- uid: System.Threading.Thread.Priority
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
  fullName: System.Threading.Thread.Priority
- uid: System.Threading.ThreadPriority
  parent: System.Threading
  isExternal: false
  name: ThreadPriority
  nameWithType: ThreadPriority
  fullName: System.Threading.ThreadPriority
- uid: System.Threading.Thread.ResetAbort
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort()
  nameWithType: Thread.ResetAbort()
  fullName: System.Threading.Thread.ResetAbort()
- uid: System.Threading.Thread.Resume
  parent: System.Threading.Thread
  isExternal: false
  name: Resume()
  nameWithType: Thread.Resume()
  fullName: System.Threading.Thread.Resume()
- uid: System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState(ApartmentState)
  nameWithType: Thread.SetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.SetApartmentState(ApartmentState)
- uid: System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack(CompressedStack)
  nameWithType: Thread.SetCompressedStack(CompressedStack)
  fullName: System.Threading.Thread.SetCompressedStack(CompressedStack)
- uid: System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: SetData(LocalDataStoreSlot,Object)
  nameWithType: Thread.SetData(LocalDataStoreSlot,Object)
  fullName: System.Threading.Thread.SetData(LocalDataStoreSlot,Object)
- uid: System.Threading.Thread.Sleep(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(Int32)
  nameWithType: Thread.Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(Int32)
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep(TimeSpan)
  nameWithType: Thread.Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(TimeSpan)
- uid: System.Threading.Thread.SpinWait(System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait(Int32)
  nameWithType: Thread.SpinWait(Int32)
  fullName: System.Threading.Thread.SpinWait(Int32)
- uid: System.Threading.Thread.Start
  parent: System.Threading.Thread
  isExternal: false
  name: Start()
  nameWithType: Thread.Start()
  fullName: System.Threading.Thread.Start()
- uid: System.Threading.Thread.Start(System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: Start(Object)
  nameWithType: Thread.Start(Object)
  fullName: System.Threading.Thread.Start(Object)
- uid: System.Threading.Thread.Suspend
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend()
  nameWithType: Thread.Suspend()
  fullName: System.Threading.Thread.Suspend()
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount(UInt32)
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.Threading.Thread.System.Runtime.InteropServices._Thread.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Threading.Thread.ThreadState
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
  fullName: System.Threading.Thread.ThreadState
- uid: System.Threading.ThreadState
  parent: System.Threading
  isExternal: false
  name: ThreadState
  nameWithType: ThreadState
  fullName: System.Threading.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState(ApartmentState)
  nameWithType: Thread.TrySetApartmentState(ApartmentState)
  fullName: System.Threading.Thread.TrySetApartmentState(ApartmentState)
- uid: System.Threading.Thread.VolatileRead(System.Byte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Byte)
  nameWithType: Thread.VolatileRead(Byte)
  fullName: System.Threading.Thread.VolatileRead(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.Threading.Thread.VolatileRead(System.Double@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Double)
  nameWithType: Thread.VolatileRead(Double)
  fullName: System.Threading.Thread.VolatileRead(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Threading.Thread.VolatileRead(System.Int16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int16)
  nameWithType: Thread.VolatileRead(Int16)
  fullName: System.Threading.Thread.VolatileRead(Int16)
- uid: System.Threading.Thread.VolatileRead(System.Int32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int32)
  nameWithType: Thread.VolatileRead(Int32)
  fullName: System.Threading.Thread.VolatileRead(Int32)
- uid: System.Threading.Thread.VolatileRead(System.Int64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Int64)
  nameWithType: Thread.VolatileRead(Int64)
  fullName: System.Threading.Thread.VolatileRead(Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.Thread.VolatileRead(System.IntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(IntPtr)
  nameWithType: Thread.VolatileRead(IntPtr)
  fullName: System.Threading.Thread.VolatileRead(IntPtr)
- uid: System.Threading.Thread.VolatileRead(System.Object@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Object)
  nameWithType: Thread.VolatileRead(Object)
  fullName: System.Threading.Thread.VolatileRead(Object)
- uid: System.Threading.Thread.VolatileRead(System.SByte@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(SByte)
  nameWithType: Thread.VolatileRead(SByte)
  fullName: System.Threading.Thread.VolatileRead(SByte)
- uid: System.SByte
  parent: System
  isExternal: true
  name: SByte
  nameWithType: SByte
  fullName: System.SByte
- uid: System.Threading.Thread.VolatileRead(System.Single@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(Single)
  nameWithType: Thread.VolatileRead(Single)
  fullName: System.Threading.Thread.VolatileRead(Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Threading.Thread.VolatileRead(System.UInt16@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt16)
  nameWithType: Thread.VolatileRead(UInt16)
  fullName: System.Threading.Thread.VolatileRead(UInt16)
- uid: System.UInt16
  parent: System
  isExternal: true
  name: UInt16
  nameWithType: UInt16
  fullName: System.UInt16
- uid: System.Threading.Thread.VolatileRead(System.UInt32@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt32)
  nameWithType: Thread.VolatileRead(UInt32)
  fullName: System.Threading.Thread.VolatileRead(UInt32)
- uid: System.Threading.Thread.VolatileRead(System.UInt64@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UInt64)
  nameWithType: Thread.VolatileRead(UInt64)
  fullName: System.Threading.Thread.VolatileRead(UInt64)
- uid: System.UInt64
  parent: System
  isExternal: true
  name: UInt64
  nameWithType: UInt64
  fullName: System.UInt64
- uid: System.Threading.Thread.VolatileRead(System.UIntPtr@)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead(UIntPtr)
  nameWithType: Thread.VolatileRead(UIntPtr)
  fullName: System.Threading.Thread.VolatileRead(UIntPtr)
- uid: System.UIntPtr
  parent: System
  isExternal: true
  name: UIntPtr
  nameWithType: UIntPtr
  fullName: System.UIntPtr
- uid: System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Byte,Byte)
  nameWithType: Thread.VolatileWrite(Byte,Byte)
  fullName: System.Threading.Thread.VolatileWrite(Byte,Byte)
- uid: System.Threading.Thread.VolatileWrite(System.Double@,System.Double)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Double,Double)
  nameWithType: Thread.VolatileWrite(Double,Double)
  fullName: System.Threading.Thread.VolatileWrite(Double,Double)
- uid: System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int16,Int16)
  nameWithType: Thread.VolatileWrite(Int16,Int16)
  fullName: System.Threading.Thread.VolatileWrite(Int16,Int16)
- uid: System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int32,Int32)
  nameWithType: Thread.VolatileWrite(Int32,Int32)
  fullName: System.Threading.Thread.VolatileWrite(Int32,Int32)
- uid: System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Int64,Int64)
  nameWithType: Thread.VolatileWrite(Int64,Int64)
  fullName: System.Threading.Thread.VolatileWrite(Int64,Int64)
- uid: System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(IntPtr,IntPtr)
  nameWithType: Thread.VolatileWrite(IntPtr,IntPtr)
  fullName: System.Threading.Thread.VolatileWrite(IntPtr,IntPtr)
- uid: System.Threading.Thread.VolatileWrite(System.Object@,System.Object)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Object,Object)
  nameWithType: Thread.VolatileWrite(Object,Object)
  fullName: System.Threading.Thread.VolatileWrite(Object,Object)
- uid: System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(SByte,SByte)
  nameWithType: Thread.VolatileWrite(SByte,SByte)
  fullName: System.Threading.Thread.VolatileWrite(SByte,SByte)
- uid: System.Threading.Thread.VolatileWrite(System.Single@,System.Single)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(Single,Single)
  nameWithType: Thread.VolatileWrite(Single,Single)
  fullName: System.Threading.Thread.VolatileWrite(Single,Single)
- uid: System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt16,UInt16)
  nameWithType: Thread.VolatileWrite(UInt16,UInt16)
  fullName: System.Threading.Thread.VolatileWrite(UInt16,UInt16)
- uid: System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt32,UInt32)
  nameWithType: Thread.VolatileWrite(UInt32,UInt32)
  fullName: System.Threading.Thread.VolatileWrite(UInt32,UInt32)
- uid: System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UInt64,UInt64)
  nameWithType: Thread.VolatileWrite(UInt64,UInt64)
  fullName: System.Threading.Thread.VolatileWrite(UInt64,UInt64)
- uid: System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite(UIntPtr,UIntPtr)
  nameWithType: Thread.VolatileWrite(UIntPtr,UIntPtr)
  fullName: System.Threading.Thread.VolatileWrite(UIntPtr,UIntPtr)
- uid: System.Threading.Thread.Yield
  parent: System.Threading.Thread
  isExternal: false
  name: Yield()
  nameWithType: Thread.Yield()
  fullName: System.Threading.Thread.Yield()
- uid: System.Threading.Thread.#ctor*
  parent: System.Threading.Thread
  isExternal: false
  name: Thread
  nameWithType: Thread.Thread
- uid: System.Threading.Thread.Abort*
  parent: System.Threading.Thread
  isExternal: false
  name: Abort
  nameWithType: Thread.Abort
- uid: System.Threading.Thread.AllocateDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateDataSlot
  nameWithType: Thread.AllocateDataSlot
- uid: System.Threading.Thread.AllocateNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: AllocateNamedDataSlot
  nameWithType: Thread.AllocateNamedDataSlot
- uid: System.Threading.Thread.ApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: ApartmentState
  nameWithType: Thread.ApartmentState
- uid: System.Threading.Thread.BeginCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginCriticalRegion
  nameWithType: Thread.BeginCriticalRegion
- uid: System.Threading.Thread.BeginThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: BeginThreadAffinity
  nameWithType: Thread.BeginThreadAffinity
- uid: System.Threading.Thread.CurrentContext*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentContext
  nameWithType: Thread.CurrentContext
- uid: System.Threading.Thread.CurrentCulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentCulture
  nameWithType: Thread.CurrentCulture
- uid: System.Threading.Thread.CurrentPrincipal*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentPrincipal
  nameWithType: Thread.CurrentPrincipal
- uid: System.Threading.Thread.CurrentThread*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentThread
  nameWithType: Thread.CurrentThread
- uid: System.Threading.Thread.CurrentUICulture*
  parent: System.Threading.Thread
  isExternal: false
  name: CurrentUICulture
  nameWithType: Thread.CurrentUICulture
- uid: System.Threading.Thread.DisableComObjectEagerCleanup*
  parent: System.Threading.Thread
  isExternal: false
  name: DisableComObjectEagerCleanup
  nameWithType: Thread.DisableComObjectEagerCleanup
- uid: System.Threading.Thread.EndCriticalRegion*
  parent: System.Threading.Thread
  isExternal: false
  name: EndCriticalRegion
  nameWithType: Thread.EndCriticalRegion
- uid: System.Threading.Thread.EndThreadAffinity*
  parent: System.Threading.Thread
  isExternal: false
  name: EndThreadAffinity
  nameWithType: Thread.EndThreadAffinity
- uid: System.Threading.Thread.ExecutionContext*
  parent: System.Threading.Thread
  isExternal: false
  name: ExecutionContext
  nameWithType: Thread.ExecutionContext
- uid: System.Threading.Thread.Finalize*
  parent: System.Threading.Thread
  isExternal: false
  name: Finalize
  nameWithType: Thread.Finalize
- uid: System.Threading.Thread.FreeNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: FreeNamedDataSlot
  nameWithType: Thread.FreeNamedDataSlot
- uid: System.Threading.Thread.GetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: GetApartmentState
  nameWithType: Thread.GetApartmentState
- uid: System.Threading.Thread.GetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: GetCompressedStack
  nameWithType: Thread.GetCompressedStack
- uid: System.Threading.Thread.GetData*
  parent: System.Threading.Thread
  isExternal: false
  name: GetData
  nameWithType: Thread.GetData
- uid: System.Threading.Thread.GetDomain*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomain
  nameWithType: Thread.GetDomain
- uid: System.Threading.Thread.GetDomainID*
  parent: System.Threading.Thread
  isExternal: false
  name: GetDomainID
  nameWithType: Thread.GetDomainID
- uid: System.Threading.Thread.GetHashCode*
  parent: System.Threading.Thread
  isExternal: false
  name: GetHashCode
  nameWithType: Thread.GetHashCode
- uid: System.Threading.Thread.GetNamedDataSlot*
  parent: System.Threading.Thread
  isExternal: false
  name: GetNamedDataSlot
  nameWithType: Thread.GetNamedDataSlot
- uid: System.Threading.Thread.Interrupt*
  parent: System.Threading.Thread
  isExternal: false
  name: Interrupt
  nameWithType: Thread.Interrupt
- uid: System.Threading.Thread.IsAlive*
  parent: System.Threading.Thread
  isExternal: false
  name: IsAlive
  nameWithType: Thread.IsAlive
- uid: System.Threading.Thread.IsBackground*
  parent: System.Threading.Thread
  isExternal: false
  name: IsBackground
  nameWithType: Thread.IsBackground
- uid: System.Threading.Thread.IsThreadPoolThread*
  parent: System.Threading.Thread
  isExternal: false
  name: IsThreadPoolThread
  nameWithType: Thread.IsThreadPoolThread
- uid: System.Threading.Thread.Join*
  parent: System.Threading.Thread
  isExternal: false
  name: Join
  nameWithType: Thread.Join
- uid: System.Threading.Thread.ManagedThreadId*
  parent: System.Threading.Thread
  isExternal: false
  name: ManagedThreadId
  nameWithType: Thread.ManagedThreadId
- uid: System.Threading.Thread.MemoryBarrier*
  parent: System.Threading.Thread
  isExternal: false
  name: MemoryBarrier
  nameWithType: Thread.MemoryBarrier
- uid: System.Threading.Thread.Name*
  parent: System.Threading.Thread
  isExternal: false
  name: Name
  nameWithType: Thread.Name
- uid: System.Threading.Thread.Priority*
  parent: System.Threading.Thread
  isExternal: false
  name: Priority
  nameWithType: Thread.Priority
- uid: System.Threading.Thread.ResetAbort*
  parent: System.Threading.Thread
  isExternal: false
  name: ResetAbort
  nameWithType: Thread.ResetAbort
- uid: System.Threading.Thread.Resume*
  parent: System.Threading.Thread
  isExternal: false
  name: Resume
  nameWithType: Thread.Resume
- uid: System.Threading.Thread.SetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: SetApartmentState
  nameWithType: Thread.SetApartmentState
- uid: System.Threading.Thread.SetCompressedStack*
  parent: System.Threading.Thread
  isExternal: false
  name: SetCompressedStack
  nameWithType: Thread.SetCompressedStack
- uid: System.Threading.Thread.SetData*
  parent: System.Threading.Thread
  isExternal: false
  name: SetData
  nameWithType: Thread.SetData
- uid: System.Threading.Thread.Sleep*
  parent: System.Threading.Thread
  isExternal: false
  name: Sleep
  nameWithType: Thread.Sleep
- uid: System.Threading.Thread.SpinWait*
  parent: System.Threading.Thread
  isExternal: false
  name: SpinWait
  nameWithType: Thread.SpinWait
- uid: System.Threading.Thread.Start*
  parent: System.Threading.Thread
  isExternal: false
  name: Start
  nameWithType: Thread.Start
- uid: System.Threading.Thread.Suspend*
  parent: System.Threading.Thread
  isExternal: false
  name: Suspend
  nameWithType: Thread.Suspend
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetIDsOfNames
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetIDsOfNames
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfo
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfo
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.GetTypeInfoCount
  nameWithType: Thread.System.Runtime.InteropServices._Thread.GetTypeInfoCount
- uid: System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke*
  parent: System.Threading.Thread
  isExternal: false
  name: System.Runtime.InteropServices._Thread.Invoke
  nameWithType: Thread.System.Runtime.InteropServices._Thread.Invoke
- uid: System.Threading.Thread.ThreadState*
  parent: System.Threading.Thread
  isExternal: false
  name: ThreadState
  nameWithType: Thread.ThreadState
- uid: System.Threading.Thread.TrySetApartmentState*
  parent: System.Threading.Thread
  isExternal: false
  name: TrySetApartmentState
  nameWithType: Thread.TrySetApartmentState
- uid: System.Threading.Thread.VolatileRead*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileRead
  nameWithType: Thread.VolatileRead
- uid: System.Threading.Thread.VolatileWrite*
  parent: System.Threading.Thread
  isExternal: false
  name: VolatileWrite
  nameWithType: Thread.VolatileWrite
- uid: System.Threading.Thread.Yield*
  parent: System.Threading.Thread
  isExternal: false
  name: Yield
  nameWithType: Thread.Yield
