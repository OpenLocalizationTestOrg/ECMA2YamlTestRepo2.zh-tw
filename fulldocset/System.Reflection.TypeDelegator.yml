### YamlMime:ManagedReference
items:
- uid: System.Reflection.TypeDelegator
  id: TypeDelegator
  children:
  - System.Reflection.TypeDelegator.#ctor
  - System.Reflection.TypeDelegator.#ctor(System.Type)
  - System.Reflection.TypeDelegator.Assembly
  - System.Reflection.TypeDelegator.AssemblyQualifiedName
  - System.Reflection.TypeDelegator.BaseType
  - System.Reflection.TypeDelegator.FullName
  - System.Reflection.TypeDelegator.GetAttributeFlagsImpl
  - System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  - System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)
  - System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)
  - System.Reflection.TypeDelegator.GetElementType
  - System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetEvents
  - System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)
  - System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)
  - System.Reflection.TypeDelegator.GetInterfaces
  - System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  - System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)
  - System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  - System.Reflection.TypeDelegator.GUID
  - System.Reflection.TypeDelegator.HasElementTypeImpl
  - System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  - System.Reflection.TypeDelegator.IsArrayImpl
  - System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)
  - System.Reflection.TypeDelegator.IsByRefImpl
  - System.Reflection.TypeDelegator.IsCOMObjectImpl
  - System.Reflection.TypeDelegator.IsConstructedGenericType
  - System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)
  - System.Reflection.TypeDelegator.IsPointerImpl
  - System.Reflection.TypeDelegator.IsPrimitiveImpl
  - System.Reflection.TypeDelegator.IsValueTypeImpl
  - System.Reflection.TypeDelegator.MetadataToken
  - System.Reflection.TypeDelegator.Module
  - System.Reflection.TypeDelegator.Name
  - System.Reflection.TypeDelegator.Namespace
  - System.Reflection.TypeDelegator.TypeHandle
  - System.Reflection.TypeDelegator.typeImpl
  - System.Reflection.TypeDelegator.UnderlyingSystemType
  langs:
  - csharp
  name: TypeDelegator
  nameWithType: TypeDelegator
  fullName: System.Reflection.TypeDelegator
  type: Class
  summary: "包裝&lt;xref:System.Type?displayProperty=fullName&gt;物件和委派方法， <xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;> </xref>。"
  remarks: "衍生自這個型別，並只有在您必須提供在中，自訂的成員再加上任何成員，您的程式所需而且尚未由 TypeDelegator 覆寫。       TypeDelegator 衍生自<xref:System.Type?displayProperty=fullName>並實作的屬性和方法的<xref:System.Type>。</xref:System.Type>大部分</xref:System.Type?displayProperty=fullName> 它會實作每個成員，TypeDelegator 自動委派至內部的對應成員<xref:System.Type>物件，以建構函式的引數的形式提供。</xref:System.Type> 這個內部<xref:System.Type>物件公開給衍生類別`protected`<xref:System.Reflection.TypeDelegator.typeImpl>欄位。</xref:System.Reflection.TypeDelegator.typeImpl> </xref:System.Type>      > [!NOTE] > TypeDelegator 的某些成員已實作，即使成員本身直接繼承自<xref:System.Type>.</xref:System.Type> 在這些情況下，提供的實作所覆寫`protected`方法結束於 」 Impl&quot;中的名稱。 例如，針對所有多載的實作<xref:System.Reflection.TypeDelegator.GetMethod%2A>提供方法的覆寫<xref:System.Reflection.TypeDelegator.GetMethodImpl%2A>方法。</xref:System.Reflection.TypeDelegator.GetMethodImpl%2A> </xref:System.Reflection.TypeDelegator.GetMethod%2A> 實作繼承屬性例如<xref:System.Type.IsPublic%2A>和<xref:System.Type.IsNestedAssembly%2A>提供的覆寫<xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A>方法。</xref:System.Reflection.TypeDelegator.GetAttributeFlagsImpl%2A> </xref:System.Type.IsNestedAssembly%2A> </xref:System.Type.IsPublic%2A>       衍生類別可以提供的公用建構函式採用<xref:System.Type>物件做為其參數，並只將物件加入該<xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29>建構函式，或者可以設定內部<xref:System.Type>以其他方法的物件。</xref:System.Type> </xref:System.Reflection.TypeDelegator.%23ctor%28System.Type%29> </xref:System.Type>       如果衍生的類別使用 TypeDelegator 未實作的成員，它必須覆寫該成員，並提供實作。 最簡單的實作會呼叫對應的成員上的內部<xref:System.Type>所公開物件<xref:System.Reflection.TypeDelegator.typeImpl>欄位，但您可以提供任何應用程式所需的實作。</xref:System.Reflection.TypeDelegator.typeImpl> </xref:System.Type> 不需要覆寫這些成員，如果它們不會使用您的應用程式或程式庫函式應用程式呼叫 (例如，藉由<xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=fullName>建構函式)。</xref:System.CodeDom.CodeTypeReference.%23ctor%28System.Type%29?displayProperty=fullName>       下列虛擬方法 (`Overridable`方法，在 Visual Basic 中的) 的<xref:System.Type>未實作的 TypeDelegator: <xref:System.Type.MakeGenericType%2A> <xref:System.Type.GetGenericTypeDefinition%2A> <xref:System.Type.GetGenericArguments%2A> <xref:System.Type.GetGenericParameterConstraints%2A> <xref:System.Type.MakeArrayType%2A> <xref:System.Type.MakeByRefType%2A> <xref:System.Type.MakePointerType%2A> <xref:System.Type.GetEnumNames%2A> <xref:System.Type.GetEnumValues%2A> <xref:System.Type.GetEnumUnderlyingType%2A> <xref:System.Type.GetTypeCodeImpl%2A> <xref:System.Type.IsEnumDefined%2A>、 <xref:System.Type.IsEquivalentTo%2A>.</xref:System.Type.IsEquivalentTo%2A> </xref:System.Type.IsEnumDefined%2A> </xref:System.Type.GetTypeCodeImpl%2A> </xref:System.Type.GetEnumUnderlyingType%2A> </xref:System.Type.GetEnumValues%2A> </xref:System.Type.GetEnumNames%2A> </xref:System.Type.MakePointerType%2A> </xref:System.Type.MakeByRefType%2A> </xref:System.Type.MakeArrayType%2A> </xref:System.Type.GetGenericParameterConstraints%2A> </xref:System.Type.GetGenericArguments%2A> </xref:System.Type.GetGenericTypeDefinition%2A> </xref:System.Type.MakeGenericType%2A> </xref:System.Type>       下列虛擬屬性 (`Overridable`屬性在 Visual Basic 中的) 的<xref:System.Type>未實作的 TypeDelegator: <xref:System.Type.IsGenericType%2A> <xref:System.Type.IsGenericTypeDefinition%2A> <xref:System.Type.IsGenericParameter%2A> <xref:System.Type.ContainsGenericParameters%2A> <xref:System.Type.DeclaringMethod%2A> <xref:System.Type.GenericParameterAttributes%2A> <xref:System.Type.GenericParameterPosition%2A> <xref:System.Type.IsSecurityCritical%2A> <xref:System.Type.IsSecuritySafeCritical%2A>、 <xref:System.Type.IsSecurityTransparent%2A>.</xref:System.Type.IsSecurityTransparent%2A> </xref:System.Type.IsSecuritySafeCritical%2A> </xref:System.Type.IsSecurityCritical%2A> </xref:System.Type.GenericParameterPosition%2A> </xref:System.Type.GenericParameterAttributes%2A> </xref:System.Type.DeclaringMethod%2A> </xref:System.Type.ContainsGenericParameters%2A> </xref:System.Type.IsGenericParameter%2A> </xref:System.Type.IsGenericTypeDefinition%2A> </xref:System.Type.IsGenericType%2A> </xref:System.Type>"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class TypeDelegator : System.Reflection.TypeInfo
  inheritance:
  - System.Reflection.TypeInfo
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.#ctor
  id: '#ctor'
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: TypeDelegator()
  nameWithType: TypeDelegator.TypeDelegator()
  fullName: System.Reflection.TypeDelegator.TypeDelegator()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "初始化的新執行個體<xref href=&quot;System.Reflection.TypeDelegator&quot;></xref>使用預設屬性的類別。"
  syntax:
    content: protected TypeDelegator ();
    parameters: []
  overload: System.Reflection.TypeDelegator.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.#ctor(System.Type)
  id: '#ctor(System.Type)'
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: TypeDelegator(Type)
  nameWithType: TypeDelegator.TypeDelegator(Type)
  fullName: System.Reflection.TypeDelegator.TypeDelegator(Type)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "初始化的新執行個體<xref href=&quot;System.Reflection.TypeDelegator&quot;></xref>類別指定封裝的執行個體。"
  remarks: "這個建構函式從類別產生為基礎的委派呼叫`Type`定義方法的類別的物件。"
  syntax:
    content: public TypeDelegator (Type delegatingType);
    parameters:
    - id: delegatingType
      type: System.Type
      description: "類別的執行個體<xref:System.Type>封裝物件的方法呼叫。</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>delegatingType</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.Assembly
  id: Assembly
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: Assembly
  nameWithType: TypeDelegator.Assembly
  fullName: System.Reflection.TypeDelegator.Assembly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得實作型別的組件。"
  remarks: "組件是在 common language runtime 中的部署單位。 組件建立的命名空間解析要求，並決定哪些資源會公開外部、 哪些是可從組件內存取。 Common language runtime 可以判斷及找出任何執行中物件的組件。"
  syntax:
    content: public override System.Reflection.Assembly Assembly { get; }
    return:
      type: System.Reflection.Assembly
      description: "&lt;Xref:System.Reflection.Assembly?displayProperty=fullName&gt;物件，代表實作類型的組件。"
  overload: System.Reflection.TypeDelegator.Assembly*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.AssemblyQualifiedName
  id: AssemblyQualifiedName
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: AssemblyQualifiedName
  nameWithType: TypeDelegator.AssemblyQualifiedName
  fullName: System.Reflection.TypeDelegator.AssemblyQualifiedName
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得組件的完整的名稱。"
  syntax:
    content: public override string AssemblyQualifiedName { get; }
    return:
      type: System.String
      description: "A <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref>包含組件的完整的名稱。"
  overload: System.Reflection.TypeDelegator.AssemblyQualifiedName*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.BaseType
  id: BaseType
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: BaseType
  nameWithType: TypeDelegator.BaseType
  fullName: System.Reflection.TypeDelegator.BaseType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得目前類型的基底類型。"
  remarks: "基底類型是此類型直接繼承的型別。 因為<xref:System.Object>類別類型是所有其他類型的超基底類別，它是唯一沒有基底類型的類型。</xref:System.Object> 在此情況下，`null`傳回基底型別`Object`型別。"
  syntax:
    content: public override Type BaseType { get; }
    return:
      type: System.Type
      description: "類型的基底類型。"
  overload: System.Reflection.TypeDelegator.BaseType*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.FullName
  id: FullName
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: FullName
  nameWithType: TypeDelegator.FullName
  fullName: System.Reflection.TypeDelegator.FullName
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得實作型別的完整的名稱。"
  remarks: "字串，包含目前的完整的名稱`TypeDelegator`。"
  syntax:
    content: public override string FullName { get; }
    return:
      type: System.String
      description: "A <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref>包含類型的完整的名稱。"
  overload: System.Reflection.TypeDelegator.FullName*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetAttributeFlagsImpl
  id: GetAttributeFlagsImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetAttributeFlagsImpl()
  nameWithType: TypeDelegator.GetAttributeFlagsImpl()
  fullName: System.Reflection.TypeDelegator.GetAttributeFlagsImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得指派給屬性<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>。"
  remarks: "這個方法可用來判斷是否`TypeDelegator`是抽象、 public 等等。"
  syntax:
    content: protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();
    parameters: []
    return:
      type: System.Reflection.TypeAttributes
      description: "A <xref uid=&quot;langword_csharp_TypeAttributes&quot; name=&quot;TypeAttributes&quot; href=&quot;&quot;> </xref>物件，代表實作的屬性旗標。"
  overload: System.Reflection.TypeDelegator.GetAttributeFlagsImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  id: GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得建構函式實作<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>。"
  remarks: "`callConvention`參數表示的進入點的呼叫慣例。 如果沒有呼叫慣例會指定，預設值<xref:System.Reflection.CallingConventions>值`Standard`用。</xref:System.Reflection.CallingConventions>"
  syntax:
    content: protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "位元遮罩，會影響搜尋的進行的方式。 值是從零個或更多的位元旗標的組合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    - id: binder
      type: System.Reflection.Binder
      description: "物件，來啟用繫結、 強制引數類型、 成員的引動過程和擷取<xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;></xref>物件，使用反映。 如果`binder`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，使用預設繫結器。"
    - id: callConvention
      type: System.Reflection.CallingConventions
      description: "呼叫慣例。"
    - id: types
      type: System.Type[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;></xref>包含清單的參數數目、 順序和類型。 類型不可為<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; 使用適當<xref uid=&quot;langword_csharp_GetMethod&quot; name=&quot;GetMethod&quot; href=&quot;&quot;></xref>方法或要搜尋的方法，不含參數的空陣列。"
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_ParameterModifier&quot; name=&quot;ParameterModifier&quot; href=&quot;&quot;></xref>具有相同的長度為`types`陣列，其項目代表之參數的方法來取得相關聯的屬性。"
    return:
      type: System.Reflection.ConstructorInfo
      description: "A <xref uid=&quot;langword_csharp_ConstructorInfo&quot; name=&quot;ConstructorInfo&quot; href=&quot;&quot;> </xref>物件的方法之符合指定的準則，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果找不到相符項目。"
  overload: System.Reflection.TypeDelegator.GetConstructorImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)
  id: GetConstructors(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetConstructors(BindingFlags)
  nameWithType: TypeDelegator.GetConstructors(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetConstructors(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回的陣列<xref:System.Reflection.ConstructorInfo>代表包裝由目前類型所定義的建構函式物件<xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>。</xref:System.Reflection.ConstructorInfo>"
  remarks: "類別初始設定式是只能透過`GetMember`， `GetMembers`， `FindMembers`，和`GetConstructors`。"
  syntax:
    content: public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "位元遮罩，會影響搜尋的進行的方式。 值是從零個或更多的位元旗標的組合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.ConstructorInfo[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_ConstructorInfo&quot; name=&quot;ConstructorInfo&quot; href=&quot;&quot;></xref>包含為這個類別所定義的指定建構函式。 如果未不定義任何建構函式，則會傳回空陣列。 根據指定的參數的值，只有公用建構函式或公用和非公用建構函式會傳回。"
  overload: System.Reflection.TypeDelegator.GetConstructors*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)
  id: GetCustomAttributes(System.Boolean)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetCustomAttributes(Boolean)
  nameWithType: TypeDelegator.GetCustomAttributes(Boolean)
  fullName: System.Reflection.TypeDelegator.GetCustomAttributes(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回定義此類型，指定是否要搜尋的型別繼承鏈結的所有自訂屬性。"
  syntax:
    content: public override object[] GetCustomAttributes (bool inherit);
    parameters:
    - id: inherit
      type: System.Boolean
      description: "指定是否要搜尋這個類型的繼承鏈結以尋找屬性。"
    return:
      type: System.Object[]
      description: "物件包含為這個類型定義的自訂屬性的陣列。"
  overload: System.Reflection.TypeDelegator.GetCustomAttributes*
  exceptions:
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "無法載入自訂屬性型別。"
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)
  id: GetCustomAttributes(System.Type,System.Boolean)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetCustomAttributes(Type,Boolean)
  nameWithType: TypeDelegator.GetCustomAttributes(Type,Boolean)
  fullName: System.Reflection.TypeDelegator.GetCustomAttributes(Type,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回類型所識別的自訂屬性的陣列。"
  syntax:
    content: public override object[] GetCustomAttributes (Type attributeType, bool inherit);
    parameters:
    - id: attributeType
      type: System.Type
      description: "陣列的類型所識別的自訂屬性。"
    - id: inherit
      type: System.Boolean
      description: "指定是否要搜尋這個類型的繼承鏈結以尋找屬性。"
    return:
      type: System.Object[]
      description: "包含此類型中定義的比對的自訂屬性的物件陣列<code> attributeType </code>參數，指定是否要搜尋的型別繼承鏈結，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>這個類型上所定義的自訂屬性。"
  overload: System.Reflection.TypeDelegator.GetCustomAttributes*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>attributeType</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "無法載入自訂屬性型別。"
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetElementType
  id: GetElementType
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetElementType()
  nameWithType: TypeDelegator.GetElementType()
  fullName: System.Reflection.TypeDelegator.GetElementType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回<xref:System.Type>之物件所內含或參考目前陣列、 指標或 ByRef。</xref:System.Type>"
  syntax:
    content: public override Type GetElementType ();
    parameters: []
    return:
      type: System.Type
      description: "<xref:System.Type>物件所內含或參考目前的陣列的指標或<xref uid=&quot;langword_csharp_ByRef&quot; name=&quot;ByRef&quot; href=&quot;&quot;> </xref>，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果目前<xref:System.Type>不是陣列、 指標或<xref uid=&quot;langword_csharp_ByRef&quot; name=&quot;ByRef&quot; href=&quot;&quot;> </xref>。</xref:System.Type> </xref:System.Type>"
  overload: System.Reflection.TypeDelegator.GetElementType*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)
  id: GetEvent(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetEvent(String,BindingFlags)
  nameWithType: TypeDelegator.GetEvent(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetEvent(String,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回指定的事件。"
  remarks: "如果`bindingAttr`是<xref:System.Reflection.BindingFlags>。`IgnoreCase`、 案例的`name`參數已忽略。</xref:System.Reflection.BindingFlags>"
  syntax:
    content: public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: "若要取得事件的名稱。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "位元遮罩，會影響搜尋的進行的方式。 值是從零個或更多的位元旗標的組合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.EventInfo
      description: "<xref:System.Reflection.EventInfo>物件，表示事件宣告或繼承此型別與指定的名稱。</xref:System.Reflection.EventInfo> 這個方法會傳回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果不找到任何這類事件。"
  overload: System.Reflection.TypeDelegator.GetEvent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetEvents
  id: GetEvents
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetEvents()
  nameWithType: TypeDelegator.GetEvents()
  fullName: System.Reflection.TypeDelegator.GetEvents()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回的陣列<xref:System.Reflection.EventInfo>物件代表的所有公用事件所宣告或繼承目前<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>。</xref:System.Reflection.EventInfo>"
  syntax:
    content: public override System.Reflection.EventInfo[] GetEvents ();
    parameters: []
    return:
      type: System.Reflection.EventInfo[]
      description: "傳回類型的陣列<xref uid=&quot;langword_csharp_EventInfo&quot; name=&quot;EventInfo&quot; href=&quot;&quot;></xref>包含所有事件所宣告或繼承目前的類型。 如果有任何事件，則會傳回空陣列。"
  overload: System.Reflection.TypeDelegator.GetEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)
  id: GetEvents(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetEvents(BindingFlags)
  nameWithType: TypeDelegator.GetEvents(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetEvents(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回在指定的事件<code> bindingAttr </code> ，所宣告或繼承目前<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>。"
  syntax:
    content: public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "位元遮罩，會影響搜尋的進行的方式。 值是從零個或更多的位元旗標的組合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.EventInfo[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_EventInfo&quot; name=&quot;EventInfo&quot; href=&quot;&quot;></xref>包含中指定的事件<code> bindingAttr </code>。 如果有任何事件，則會傳回空陣列。"
  overload: System.Reflection.TypeDelegator.GetEvents*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)
  id: GetField(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetField(String,BindingFlags)
  nameWithType: TypeDelegator.GetField(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetField(String,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回<xref:System.Reflection.FieldInfo>物件，代表具有指定名稱的欄位。</xref:System.Reflection.FieldInfo>"
  remarks: "使用`bindingAttr` <xref:System.Reflection.BindingFlags>。傳回所有的公用和非公用欄位 nonPublic。</xref:System.Reflection.BindingFlags> 使用`BindingFlags.IgnoreCase`來搜尋不區分大小寫，預設會忽略欄位的大小寫。"
  syntax:
    content: public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: "要尋找的欄位名稱。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "位元遮罩，會影響搜尋的進行的方式。 值是從零個或更多的位元旗標的組合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.FieldInfo
      description: "A <xref uid=&quot;langword_csharp_FieldInfo&quot; name=&quot;FieldInfo&quot; href=&quot;&quot;> </xref>物件，代表欄位宣告或繼承由此<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;></xref>具有指定名稱。 傳回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果不找到任何這類的欄位。"
  overload: System.Reflection.TypeDelegator.GetField*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)
  id: GetFields(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetFields(BindingFlags)
  nameWithType: TypeDelegator.GetFields(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetFields(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回的陣列<xref:System.Reflection.FieldInfo>物件包裝由目前類型所代表資料欄位定義<xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>。</xref:System.Reflection.FieldInfo>"
  remarks: "GetFields 方法不會傳回欄位以特定順序，例如依字母順序排列或按宣告順序。 您的程式碼必須依賴欄位會傳回的順序，因為該順序可能會有所不同。       使用`bindingAttr` <xref:System.Reflection.BindingFlags>。傳回所有的公用和非公用欄位 nonPublic。</xref:System.Reflection.BindingFlags>"
  syntax:
    content: public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "位元遮罩，會影響搜尋的進行的方式。 值是從零個或更多的位元旗標的組合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.FieldInfo[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_FieldInfo&quot; name=&quot;FieldInfo&quot; href=&quot;&quot;></xref>其中包含的欄位所宣告或繼承目前<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>。 如果沒有相符的欄位，會傳回空陣列。"
  overload: System.Reflection.TypeDelegator.GetFields*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)
  id: GetInterface(System.String,System.Boolean)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetInterface(String,Boolean)
  nameWithType: TypeDelegator.GetInterface(String,Boolean)
  fullName: System.Reflection.TypeDelegator.GetInterface(String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回指定包裝由目前類型所實作的介面<xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>。"
  syntax:
    content: public override Type GetInterface (string name, bool ignoreCase);
    parameters:
    - id: name
      type: System.String
      description: "目前類別所實作的介面的完整的名稱。"
    - id: ignoreCase
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果該案例會被忽略;否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Type
      description: "A <xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;> </xref>物件代表由目前類別實作 （直接或間接），以符合指定之名稱的完整限定名稱的介面。 如果沒有符合名稱的介面找不到 null 會傳回。"
  overload: System.Reflection.TypeDelegator.GetInterface*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)
  id: GetInterfaceMap(System.Type)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetInterfaceMap(Type)
  nameWithType: TypeDelegator.GetInterfaceMap(Type)
  fullName: System.Reflection.TypeDelegator.GetInterfaceMap(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回指定的介面類型的介面對應。"
  remarks: "介面對應代表介面如何對應到實作該介面的類別上的實際方法。"
  syntax:
    content: public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);
    parameters:
    - id: interfaceType
      type: System.Type
      description: "<xref:System.Type>要擷取的對應的介面。</xref:System.Type>"
    return:
      type: System.Reflection.InterfaceMapping
      description: "<xref:System.Reflection.InterfaceMapping>物件，代表的介面對應<code> interfaceType </code>。</xref:System.Reflection.InterfaceMapping>"
  overload: System.Reflection.TypeDelegator.GetInterfaceMap*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetInterfaces
  id: GetInterfaces
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetInterfaces()
  nameWithType: TypeDelegator.GetInterfaces()
  fullName: System.Reflection.TypeDelegator.GetInterfaces()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回所有目前的類別和其基底類別上實作的介面。"
  syntax:
    content: public override Type[] GetInterfaces ();
    parameters: []
    return:
      type: System.Type[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;></xref>包含所有在目前的類別和其基底類別上實作的介面。 如果未定義，則會傳回空陣列。"
  overload: System.Reflection.TypeDelegator.GetInterfaces*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  id: GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetMember(String,MemberTypes,BindingFlags)
  nameWithType: TypeDelegator.GetMember(String,MemberTypes,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMember(String,MemberTypes,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回成員 （屬性、 方法、 建構函式、 欄位、 事件和巢狀型別） 所指定給定<code> name </code>， <code> type </code>，和<code> bindingAttr </code>。"
  remarks: "If `bindingAttr` is <xref:System.Reflection.BindingFlags>.NonPublic 所有成員會被都視為。</xref:System.Reflection.BindingFlags> 如果沒有相符的項目，則會傳回空陣列。"
  syntax:
    content: public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: "要取得之成員的名稱。"
    - id: type
      type: System.Reflection.MemberTypes
      description: "位元遮罩，會影響搜尋的進行的方式。 值是從零個或更多的位元旗標的組合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "若要取得的成員類型。"
    return:
      type: System.Reflection.MemberInfo[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;></xref>包含目前的類別和其基底類別，符合指定的準則的所有成員。"
  overload: System.Reflection.TypeDelegator.GetMember*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)
  id: GetMembers(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetMembers(BindingFlags)
  nameWithType: TypeDelegator.GetMembers(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMembers(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回所指定的成員<code> bindingAttr </code>。"
  remarks: "If `bindingAttr` is <xref:System.Reflection.BindingFlags>.NonPublic 所有成員會被都視為。</xref:System.Reflection.BindingFlags> 如果沒有相符的項目，則會傳回空陣列。"
  syntax:
    content: public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "位元遮罩，會影響搜尋的進行的方式。 值是從零個或更多的位元旗標的組合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.MemberInfo[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;></xref>包含目前類別及符合其基底類別的所有成員<code> bindingAttr </code>篩選器。"
  overload: System.Reflection.TypeDelegator.GetMembers*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  id: GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "搜尋指定的參數符合指定引數類型和修飾詞，使用指定的繫結條件約束和指定的呼叫慣例的方法。"
  remarks: "`callConvention`參數表示的進入點的呼叫慣例。 如果沒有<xref:System.Reflection.CallingConventions>指定，預設值`CallingConventions`值`Standard`用。</xref:System.Reflection.CallingConventions>"
  syntax:
    content: protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);
    parameters:
    - id: name
      type: System.String
      description: "方法名稱。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "位元遮罩，會影響搜尋的進行的方式。 值是從零個或更多的位元旗標的組合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    - id: binder
      type: System.Reflection.Binder
      description: "物件，來啟用繫結、 強制引數類型、 成員的引動過程和擷取<xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;></xref>物件，使用反映。 如果`binder`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，使用預設繫結器。"
    - id: callConvention
      type: System.Reflection.CallingConventions
      description: "呼叫慣例。"
    - id: types
      type: System.Type[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;></xref>包含清單的參數數目、 順序和類型。 類型不可為<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; 使用適當<xref uid=&quot;langword_csharp_GetMethod&quot; name=&quot;GetMethod&quot; href=&quot;&quot;></xref>方法或要搜尋的方法，不含參數的空陣列。"
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_ParameterModifier&quot; name=&quot;ParameterModifier&quot; href=&quot;&quot;></xref>具有相同的長度為`types`陣列，其項目代表之參數的方法來取得相關聯的屬性。"
    return:
      type: System.Reflection.MethodInfo
      description: "A <xref uid=&quot;langword_csharp_MethodInfoInfo&quot; name=&quot;MethodInfoInfo&quot; href=&quot;&quot;> </xref>物件符合指定的準則，實作方法或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果找不到相符項目。"
  overload: System.Reflection.TypeDelegator.GetMethodImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)
  id: GetMethods(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetMethods(BindingFlags)
  nameWithType: TypeDelegator.GetMethods(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMethods(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回的陣列<xref:System.Reflection.MethodInfo>物件，代表指定的類型方法的包裝由目前<xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>。</xref:System.Reflection.MethodInfo>"
  syntax:
    content: public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "位元遮罩，會影響搜尋的進行的方式。 值是從零個或更多的位元旗標的組合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.MethodInfo[]
      description: "陣列<xref uid=&quot;langword_csharp_MethodInfo&quot; name=&quot;MethodInfo&quot; href=&quot;&quot;></xref>物件代表定義上的方法<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>。"
  overload: System.Reflection.TypeDelegator.GetMethods*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)
  id: GetNestedType(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetNestedType(String,BindingFlags)
  nameWithType: TypeDelegator.GetNestedType(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetNestedType(String,BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回所指定的巢狀的類型<code> name </code>和<code> bindingAttr </code> ，所宣告或繼承表示由目前類型所<xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>。"
  syntax:
    content: public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: name
      type: System.String
      description: "巢狀型別名稱。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "位元遮罩，會影響搜尋的進行的方式。 值是從零個或更多的位元旗標的組合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Type
      description: "A <xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;> </xref>物件，代表巢狀的類型。"
  overload: System.Reflection.TypeDelegator.GetNestedType*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>name</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)
  id: GetNestedTypes(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetNestedTypes(BindingFlags)
  nameWithType: TypeDelegator.GetNestedTypes(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetNestedTypes(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回在指定的巢狀型別<code> bindingAttr </code>所宣告或繼承包裝由目前類型所<xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>。"
  syntax:
    content: public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "位元遮罩，會影響搜尋的進行的方式。 值是從零個或更多的位元旗標的組合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Type[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_Type&quot; name=&quot;Type&quot; href=&quot;&quot;></xref>包含巢狀型別。"
  overload: System.Reflection.TypeDelegator.GetNestedTypes*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)
  id: GetProperties(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetProperties(BindingFlags)
  nameWithType: TypeDelegator.GetProperties(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetProperties(BindingFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回的陣列<xref:System.Reflection.PropertyInfo>代表包裝由目前類型的屬性物件<xref href=&quot;System.Reflection.TypeDelegator&quot;> </xref>。</xref:System.Reflection.PropertyInfo>"
  syntax:
    content: public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);
    parameters:
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "位元遮罩，會影響搜尋的進行的方式。 值是從零個或更多的位元旗標的組合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    return:
      type: System.Reflection.PropertyInfo[]
      description: "陣列<xref uid=&quot;langword_csharp_PropertyInfo&quot; name=&quot;PropertyInfo&quot; href=&quot;&quot;></xref>物件代表定義這個屬性<xref uid=&quot;langword_csharp_TypeDelegator&quot; name=&quot;TypeDelegator&quot; href=&quot;&quot;> </xref>。"
  overload: System.Reflection.TypeDelegator.GetProperties*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  id: GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "當在衍生類別中覆寫時，搜尋其參數符合指定的引數類型和修飾詞，使用指定的繫結條件約束的指定屬性。"
  syntax:
    content: protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);
    parameters:
    - id: name
      type: System.String
      description: "要取得的屬性。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "位元遮罩，會影響搜尋的進行的方式。 值是從零個或更多的位元旗標的組合<xref href=&quot;System.Reflection.BindingFlags&quot;> </xref>。"
    - id: binder
      type: System.Reflection.Binder
      description: "物件，來啟用繫結、 強制引數類型、 成員的引動過程和擷取<xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;></xref>透過反映的物件。 如果`binder`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，使用預設繫結器。 See <xref href=&quot;System.Reflection.Binder&quot;></xref>."
    - id: returnType
      type: System.Type
      description: "屬性的傳回型別。"
    - id: types
      type: System.Type[]
      description: "參數型別的清單。 清單代表數目、 順序和類型的參數。 類型不可為 null。使用適當<xref uid=&quot;langword_csharp_GetMethod&quot; name=&quot;GetMethod&quot; href=&quot;&quot;></xref>方法或要搜尋的方法，不含參數的空陣列。"
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: "為具有項目，代表要取得之方法的參數相關聯的屬性類型的長度相同的陣列。"
    return:
      type: System.Reflection.PropertyInfo
      description: "A<xref:System.Reflection.PropertyInfo>符合指定的準則，屬性的物件，或如果找不到相符項目，則為 null。</xref:System.Reflection.PropertyInfo>"
  overload: System.Reflection.TypeDelegator.GetPropertyImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.GUID
  id: GUID
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: GUID
  nameWithType: TypeDelegator.GUID
  fullName: System.Reflection.TypeDelegator.GUID
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得實作類型的 GUID （全域唯一識別項）。"
  remarks: "GUID （全域唯一識別項） 是用來識別在類別或介面的 128 位元的唯一識別碼字串。 它是主要適用於 Microsoft.NET Framework 和 COM 之間的互通性"
  syntax:
    content: public override Guid GUID { get; }
    return:
      type: System.Guid
      description: "GUID。"
  overload: System.Reflection.TypeDelegator.GUID*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.HasElementTypeImpl
  id: HasElementTypeImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: HasElementTypeImpl()
  nameWithType: TypeDelegator.HasElementTypeImpl()
  fullName: System.Reflection.TypeDelegator.HasElementTypeImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得值，指出是否目前<xref:System.Type>內含或參考其他類型; 也就是說，是否目前<xref:System.Type>是陣列、 指標或將 ByRef。</xref:System.Type> </xref:System.Type>"
  syntax:
    content: protected override bool HasElementTypeImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Type>是陣列、 指標或將 ByRef; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.HasElementTypeImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  id: InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  nameWithType: TypeDelegator.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  fullName: System.Reflection.TypeDelegator.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "叫用指定的成員。 要叫用的方法必須可存取，並提供尋找最符合指定的引數清單中，指定繫結器和引動過程屬性的條件約束。"
  remarks: "如果下列條件成立，會叫用方法:-數字方法宣告中的參數等於指定的引數清單中的引數數目 （除非在成員上定義預設引數）。      -每個引數的類型可以轉換為型別參數的繫結器。       繫結器會尋找所有相符的方法。 這些方法找到要求的繫結的類型為基礎 (`BindingFlags.MethodInvoke`，`BindingFlags.GetProperties`等等)。 方法的集合會依名稱、 引數數目和一組繫結器中所定義的搜尋修飾詞進行篩選。       選取方法之後，就會叫用。 協助工具會在該點檢查。 搜尋可能會控制哪一組方法會搜尋根據與方法相關聯的協助工具屬性。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName>方法負責選取方法被叫用。</xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> 預設繫結器選取最適合的相符項目。      > [!NOTE] > 會忽略存取限制為完全信任程式碼。 也就是說，私用建構函式、 方法、 欄位和屬性可以存取，而且只要完全信任程式碼使用反映來叫用。       目前，`InvokeMember`執行 Microsoft.NET Framework 反映語意的每個類型的物件。       如果依名稱指定的成員為陣列和`BindingFlags.GetField`上設定旗標`invokeAttr`、`args`陣列指定其值要傳回的項目。 例如，下列呼叫透過`Type`物件`t`傳回字串陣列 MyArray，呼叫物件的成員的第一個元素的值︰`String ret = (String) t.InvokeMember (&quot;MyArray&quot;, BindingFlags.GetField, null, this, new Variant[]{0});`您可以使用`InvokeMember`以設定成員陣列的一個或多個項目。 所有項目會設定為相同的值。 `args`陣列必須以下列格式︰```   {index1,       index2,, value}   ```比方說，若要從先前的範例設定 MyArray 的第一個成員，語法如下所示︰```   t.InvokeMember (&quot;MyArray&quot;, BindingFlags.SetField, null, this, new       Variant[]{0,&quot;Updated&quot;});   ```"
  syntax:
    content: public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
    parameters:
    - id: name
      type: System.String
      description: "要叫用之成員的名稱。 這可能是建構函式、 方法、 屬性或欄位。 如果將空字串 (&quot;&quot;) 傳遞時，預設成員叫用。"
    - id: invokeAttr
      type: System.Reflection.BindingFlags
      description: '中的引動過程屬性。 This must be one of the following <xref href=&quot;System.Reflection.BindingFlags&quot;></xref> : <xref uid=&quot;langword_csharp_InvokeMethod&quot; name=&quot;InvokeMethod&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_CreateInstance&quot; name=&quot;CreateInstance&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Static&quot; name=&quot;Static&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_GetField&quot; name=&quot;GetField&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_SetField&quot; name=&quot;SetField&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_GetProperty&quot; name=&quot;GetProperty&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_SetProperty&quot; name=&quot;SetProperty&quot; href=&quot;&quot;></xref>. 必須指定適當的引動過程屬性。 要叫用靜態成員是否<xref uid=&quot;langword_csharp_Static&quot; name=&quot;Static&quot; href=&quot;&quot;></xref>旗標必須設定。'
    - id: binder
      type: System.Reflection.Binder
      description: "物件，來啟用繫結、 強制引數類型、 成員的引動過程和擷取<xref uid=&quot;langword_csharp_MemberInfo&quot; name=&quot;MemberInfo&quot; href=&quot;&quot;></xref>透過反映的物件。 如果`binder`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，使用預設繫結器。 See <xref href=&quot;System.Reflection.Binder&quot;></xref>."
    - id: target
      type: System.Object
      description: "要叫用指定的成員物件。"
    - id: args
      type: System.Object[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;> </xref> ，其中包含要叫用數目、 順序和類型成員的參數。 如果`args`包含未初始化<xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;> </xref>，它會被視為空字串，使用預設繫結器，可以擴展為 0、 0.0 或字串。"
    - id: modifiers
      type: System.Reflection.ParameterModifier[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_ParameterModifer&quot; name=&quot;ParameterModifer&quot; href=&quot;&quot;></xref>也就是相同的長度為`args`，與項目，代表要叫用之成員的引數與相關聯的屬性。 參數具有與其相關聯成員的簽章中的屬性。 用於 ByRef <xref uid=&quot;langword_csharp_ParameterModifer.ByRef&quot; name=&quot;ParameterModifer.ByRef&quot; href=&quot;&quot;> </xref>，並為 none、 使用<xref uid=&quot;langword_csharp_ParameterModifer.None&quot; name=&quot;ParameterModifer.None&quot; href=&quot;&quot;> </xref>。 確實比對這些的預設繫結器。 等屬性<xref uid=&quot;langword_csharp_In&quot; name=&quot;In&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_InOut&quot; name=&quot;InOut&quot; href=&quot;&quot;></xref>則不會使用在繫結，而且您可以使用檢視<xref uid=&quot;langword_csharp_ParameterInfo&quot; name=&quot;ParameterInfo&quot; href=&quot;&quot;> </xref>。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "執行個體<xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;></xref>用於管理類型的強制型轉。 這是必要的比方說，代表到 1000年的 string 轉換成<xref uid=&quot;langword_csharp_Double&quot; name=&quot;Double&quot; href=&quot;&quot;></xref>值，因為 1000年表示方式會因不同文化特性。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、 <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref>目前的執行緒<xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;></xref>用。"
    - id: namedParameters
      type: System.String[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>包含參數名稱，符合項目為零，開始與`args`陣列。 陣列中必須沒有安全漏洞。 If `args`. <xref uid=&quot;langword_csharp_Length&quot; name=&quot;Length&quot; href=&quot;&quot;></xref>大於`namedParameters`。 <xref uid=&quot;langword_csharp_Length&quot; name=&quot;Length&quot; href=&quot;&quot;></xref>順序會填入其餘的參數。"
    return:
      type: System.Object
      description: "<xref uid=&quot;langword_csharp_Object&quot; name=&quot;Object&quot; href=&quot;&quot;> </xref>代表叫用的成員的傳回值。"
  overload: System.Reflection.TypeDelegator.InvokeMember*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsArrayImpl
  id: IsArrayImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsArrayImpl()
  nameWithType: TypeDelegator.IsArrayImpl()
  fullName: System.Reflection.TypeDelegator.IsArrayImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回值，指出是否<xref:System.Type>是陣列。</xref:System.Type>"
  syntax:
    content: protected override bool IsArrayImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Type>是陣列，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsArrayImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)
  id: IsAssignableFrom(System.Reflection.TypeInfo)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsAssignableFrom(TypeInfo)
  nameWithType: TypeDelegator.IsAssignableFrom(TypeInfo)
  fullName: System.Reflection.TypeDelegator.IsAssignableFrom(TypeInfo)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回值，指出指定的型別是否可以指派給這個型別。"
  syntax:
    content: public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);
    parameters:
    - id: typeInfo
      type: System.Reflection.TypeInfo
      description: "要檢查的類型。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果指定的型別可以指派給這個型別。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Reflection.TypeDelegator.IsAssignableFrom*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsByRefImpl
  id: IsByRefImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsByRefImpl()
  nameWithType: TypeDelegator.IsByRefImpl()
  fullName: System.Reflection.TypeDelegator.IsByRefImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回值，指出是否<xref:System.Type>傳址方式傳遞。</xref:System.Type>"
  syntax:
    content: protected override bool IsByRefImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Type>傳遞的參考; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsByRefImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsCOMObjectImpl
  id: IsCOMObjectImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsCOMObjectImpl()
  nameWithType: TypeDelegator.IsCOMObjectImpl()
  fullName: System.Reflection.TypeDelegator.IsCOMObjectImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回值，指出是否<xref:System.Type>是 COM 物件。</xref:System.Type>"
  syntax:
    content: protected override bool IsCOMObjectImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Type>是 COM 物件，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsCOMObjectImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsConstructedGenericType
  id: IsConstructedGenericType
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsConstructedGenericType
  nameWithType: TypeDelegator.IsConstructedGenericType
  fullName: System.Reflection.TypeDelegator.IsConstructedGenericType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得值，指出這個物件是否表示建構的泛型型別。"
  syntax:
    content: public override bool IsConstructedGenericType { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個物件代表建構的泛型型別。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Reflection.TypeDelegator.IsConstructedGenericType*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)
  id: IsDefined(System.Type,System.Boolean)
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsDefined(Type,Boolean)
  nameWithType: TypeDelegator.IsDefined(Type,Boolean)
  fullName: System.Reflection.TypeDelegator.IsDefined(Type,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "表示所識別的自訂屬性是否<code> attributeType </code>定義。"
  syntax:
    content: public override bool IsDefined (Type attributeType, bool inherit);
    parameters:
    - id: attributeType
      type: System.Type
      description: "指定是否要搜尋這個類型的繼承鏈結以尋找屬性。"
    - id: inherit
      type: System.Boolean
      description: "陣列的類型所識別的自訂屬性。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果所識別的自訂屬性<code> attributeType </code>定義; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Reflection.TypeDelegator.IsDefined*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>attributeType</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Reflection.ReflectionTypeLoadException
    commentId: T:System.Reflection.ReflectionTypeLoadException
    description: "無法載入自訂屬性型別。"
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsPointerImpl
  id: IsPointerImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsPointerImpl()
  nameWithType: TypeDelegator.IsPointerImpl()
  fullName: System.Reflection.TypeDelegator.IsPointerImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回值，指出是否<xref:System.Type>的指標。</xref:System.Type>"
  syntax:
    content: protected override bool IsPointerImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Type>是指標，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsPointerImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsPrimitiveImpl
  id: IsPrimitiveImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsPrimitiveImpl()
  nameWithType: TypeDelegator.IsPrimitiveImpl()
  fullName: System.Reflection.TypeDelegator.IsPrimitiveImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回值，指出是否<xref:System.Type>是其中一個基本類型。</xref:System.Type>"
  syntax:
    content: protected override bool IsPrimitiveImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Type>是其中一個基本類型，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Type>"
  overload: System.Reflection.TypeDelegator.IsPrimitiveImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.IsValueTypeImpl
  id: IsValueTypeImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: IsValueTypeImpl()
  nameWithType: TypeDelegator.IsValueTypeImpl()
  fullName: System.Reflection.TypeDelegator.IsValueTypeImpl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "傳回值，指出類型是否為實值類型。也就是不是類別或介面。"
  syntax:
    content: protected override bool IsValueTypeImpl ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果類型是實值類型。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Reflection.TypeDelegator.IsValueTypeImpl*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.MetadataToken
  id: MetadataToken
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: MetadataToken
  nameWithType: TypeDelegator.MetadataToken
  fullName: System.Reflection.TypeDelegator.MetadataToken
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得值，識別這個中繼資料中的實體。"
  remarks: "使用這個屬性取得的權杖可以傳遞至 unmanaged 反映 API。 如需詳細資訊，請參閱[Unmanaged 反映 API](http://msdn.microsoft.com/en-us/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)。"
  syntax:
    content: public override int MetadataToken { get; }
    return:
      type: System.Int32
      description: "值，與模組，可唯一識別這個中繼資料中的實體。"
  overload: System.Reflection.TypeDelegator.MetadataToken*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.Module
  id: Module
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: Module
  nameWithType: TypeDelegator.Module
  fullName: System.Reflection.TypeDelegator.Module
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得包含實作的類型的模組。"
  remarks: "模組已載入的單位可以包含型別宣告和實作。 模組包含足夠的資訊來啟用 common language runtime 在載入模組，請找出所有實作位元。"
  syntax:
    content: public override System.Reflection.Module Module { get; }
    return:
      type: System.Reflection.Module
      description: "A<xref:System.Reflection.Module>代表模組的實作類型的物件。</xref:System.Reflection.Module>"
  overload: System.Reflection.TypeDelegator.Module*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.Name
  id: Name
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: Name
  nameWithType: TypeDelegator.Name
  fullName: System.Reflection.TypeDelegator.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得實作的型別，名稱與移除的路徑。"
  remarks: "字串，包含目前的名稱`TypeDelegator`。 只有簡單名稱，不是完整限定名稱，會傳回。 若要取得的名稱和路徑，請使用  <xref:System.Reflection.TypeDelegator.FullName%2A>.</xref:System.Reflection.TypeDelegator.FullName%2A>"
  syntax:
    content: public override string Name { get; }
    return:
      type: System.String
      description: "A <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref>包含的型別非限定名稱。"
  overload: System.Reflection.TypeDelegator.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.Namespace
  id: Namespace
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: Namespace
  nameWithType: TypeDelegator.Namespace
  fullName: System.Reflection.TypeDelegator.Namespace
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得實作型別的命名空間。"
  remarks: "這個屬性會取得字串，包含目前的命名空間`TypeDelegator`。 例如，如果`TypeDelegator`為<xref:System.Reflection.TypeFilter>，傳回的命名空間為<xref:System.Reflection>.</xref:System.Reflection> </xref:System.Reflection.TypeFilter>"
  syntax:
    content: public override string Namespace { get; }
    return:
      type: System.String
      description: "A <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref>包含類型的命名空間。"
  overload: System.Reflection.TypeDelegator.Namespace*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.TypeHandle
  id: TypeHandle
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: TypeHandle
  nameWithType: TypeDelegator.TypeHandle
  fullName: System.Reflection.TypeDelegator.TypeHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得實作的型別之內部中繼資料表示的控制代碼。"
  remarks: "類型控制代碼是每個型別相關聯的唯一整數值。 在執行階段控制代碼是唯一的。"
  syntax:
    content: public override RuntimeTypeHandle TypeHandle { get; }
    return:
      type: System.RuntimeTypeHandle
      description: "A <xref uid=&quot;langword_csharp_RuntimeTypeHandle&quot; name=&quot;RuntimeTypeHandle&quot; href=&quot;&quot;></xref> object."
  overload: System.Reflection.TypeDelegator.TypeHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.typeImpl
  id: typeImpl
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: typeImpl
  nameWithType: TypeDelegator.typeImpl
  fullName: System.Reflection.TypeDelegator.typeImpl
  type: Field
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "值，表示型別資訊。"
  syntax:
    content: protected Type typeImpl;
    return:
      type: System.Type
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Reflection.TypeDelegator.UnderlyingSystemType
  id: UnderlyingSystemType
  parent: System.Reflection.TypeDelegator
  langs:
  - csharp
  name: UnderlyingSystemType
  nameWithType: TypeDelegator.UnderlyingSystemType
  fullName: System.Reflection.TypeDelegator.UnderlyingSystemType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Reflection
  summary: "取得基礎<xref:System.Type>表示已實作的型別。</xref:System.Type>"
  syntax:
    content: public override Type UnderlyingSystemType { get; }
    return:
      type: System.Type
      description: "基礎類型。"
  overload: System.Reflection.TypeDelegator.UnderlyingSystemType*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Reflection.TypeInfo
  isExternal: false
  name: System.Reflection.TypeInfo
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.TypeLoadException
  isExternal: true
  name: System.TypeLoadException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Reflection.ReflectionTypeLoadException
  isExternal: true
  name: System.Reflection.ReflectionTypeLoadException
- uid: System.Reflection.TypeDelegator.#ctor
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeDelegator()
  nameWithType: TypeDelegator.TypeDelegator()
  fullName: System.Reflection.TypeDelegator.TypeDelegator()
- uid: System.Reflection.TypeDelegator.#ctor(System.Type)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeDelegator(Type)
  nameWithType: TypeDelegator.TypeDelegator(Type)
  fullName: System.Reflection.TypeDelegator.TypeDelegator(Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Reflection.TypeDelegator.Assembly
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Assembly
  nameWithType: TypeDelegator.Assembly
  fullName: System.Reflection.TypeDelegator.Assembly
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.Reflection.TypeDelegator.AssemblyQualifiedName
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: AssemblyQualifiedName
  nameWithType: TypeDelegator.AssemblyQualifiedName
  fullName: System.Reflection.TypeDelegator.AssemblyQualifiedName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Reflection.TypeDelegator.BaseType
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: BaseType
  nameWithType: TypeDelegator.BaseType
  fullName: System.Reflection.TypeDelegator.BaseType
- uid: System.Reflection.TypeDelegator.FullName
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: FullName
  nameWithType: TypeDelegator.FullName
  fullName: System.Reflection.TypeDelegator.FullName
- uid: System.Reflection.TypeDelegator.GetAttributeFlagsImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetAttributeFlagsImpl()
  nameWithType: TypeDelegator.GetAttributeFlagsImpl()
  fullName: System.Reflection.TypeDelegator.GetAttributeFlagsImpl()
- uid: System.Reflection.TypeAttributes
  parent: System.Reflection
  isExternal: true
  name: TypeAttributes
  nameWithType: TypeAttributes
  fullName: System.Reflection.TypeAttributes
- uid: System.Reflection.TypeDelegator.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
- uid: System.Reflection.ConstructorInfo
  parent: System.Reflection
  isExternal: true
  name: ConstructorInfo
  nameWithType: ConstructorInfo
  fullName: System.Reflection.ConstructorInfo
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Reflection.CallingConventions
  parent: System.Reflection
  isExternal: true
  name: CallingConventions
  nameWithType: CallingConventions
  fullName: System.Reflection.CallingConventions
- uid: System.Type[]
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type[]
  spec.csharp:
  - uid: System.Type
    name: Type
    nameWithType: Type
    fullName: Type[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.ParameterModifier[]
  parent: System.Reflection
  isExternal: false
  name: ParameterModifier
  nameWithType: ParameterModifier
  fullName: System.Reflection.ParameterModifier[]
  spec.csharp:
  - uid: System.Reflection.ParameterModifier
    name: ParameterModifier
    nameWithType: ParameterModifier
    fullName: ParameterModifier[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetConstructors(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetConstructors(BindingFlags)
  nameWithType: TypeDelegator.GetConstructors(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetConstructors(BindingFlags)
- uid: System.Reflection.ConstructorInfo[]
  parent: System.Reflection
  isExternal: true
  name: ConstructorInfo
  nameWithType: ConstructorInfo
  fullName: System.Reflection.ConstructorInfo[]
  spec.csharp:
  - uid: System.Reflection.ConstructorInfo
    name: ConstructorInfo
    nameWithType: ConstructorInfo
    fullName: ConstructorInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetCustomAttributes(System.Boolean)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetCustomAttributes(Boolean)
  nameWithType: TypeDelegator.GetCustomAttributes(Boolean)
  fullName: System.Reflection.TypeDelegator.GetCustomAttributes(Boolean)
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Reflection.TypeDelegator.GetCustomAttributes(System.Type,System.Boolean)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetCustomAttributes(Type,Boolean)
  nameWithType: TypeDelegator.GetCustomAttributes(Type,Boolean)
  fullName: System.Reflection.TypeDelegator.GetCustomAttributes(Type,Boolean)
- uid: System.Reflection.TypeDelegator.GetElementType
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetElementType()
  nameWithType: TypeDelegator.GetElementType()
  fullName: System.Reflection.TypeDelegator.GetElementType()
- uid: System.Reflection.TypeDelegator.GetEvent(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvent(String,BindingFlags)
  nameWithType: TypeDelegator.GetEvent(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetEvent(String,BindingFlags)
- uid: System.Reflection.EventInfo
  parent: System.Reflection
  isExternal: true
  name: EventInfo
  nameWithType: EventInfo
  fullName: System.Reflection.EventInfo
- uid: System.Reflection.TypeDelegator.GetEvents
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvents()
  nameWithType: TypeDelegator.GetEvents()
  fullName: System.Reflection.TypeDelegator.GetEvents()
- uid: System.Reflection.EventInfo[]
  parent: System.Reflection
  isExternal: true
  name: EventInfo
  nameWithType: EventInfo
  fullName: System.Reflection.EventInfo[]
  spec.csharp:
  - uid: System.Reflection.EventInfo
    name: EventInfo
    nameWithType: EventInfo
    fullName: EventInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetEvents(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvents(BindingFlags)
  nameWithType: TypeDelegator.GetEvents(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetEvents(BindingFlags)
- uid: System.Reflection.TypeDelegator.GetField(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetField(String,BindingFlags)
  nameWithType: TypeDelegator.GetField(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetField(String,BindingFlags)
- uid: System.Reflection.FieldInfo
  parent: System.Reflection
  isExternal: true
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo
- uid: System.Reflection.TypeDelegator.GetFields(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetFields(BindingFlags)
  nameWithType: TypeDelegator.GetFields(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetFields(BindingFlags)
- uid: System.Reflection.FieldInfo[]
  parent: System.Reflection
  isExternal: true
  name: FieldInfo
  nameWithType: FieldInfo
  fullName: System.Reflection.FieldInfo[]
  spec.csharp:
  - uid: System.Reflection.FieldInfo
    name: FieldInfo
    nameWithType: FieldInfo
    fullName: FieldInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetInterface(System.String,System.Boolean)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterface(String,Boolean)
  nameWithType: TypeDelegator.GetInterface(String,Boolean)
  fullName: System.Reflection.TypeDelegator.GetInterface(String,Boolean)
- uid: System.Reflection.TypeDelegator.GetInterfaceMap(System.Type)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterfaceMap(Type)
  nameWithType: TypeDelegator.GetInterfaceMap(Type)
  fullName: System.Reflection.TypeDelegator.GetInterfaceMap(Type)
- uid: System.Reflection.InterfaceMapping
  parent: System.Reflection
  isExternal: true
  name: InterfaceMapping
  nameWithType: InterfaceMapping
  fullName: System.Reflection.InterfaceMapping
- uid: System.Reflection.TypeDelegator.GetInterfaces
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterfaces()
  nameWithType: TypeDelegator.GetInterfaces()
  fullName: System.Reflection.TypeDelegator.GetInterfaces()
- uid: System.Reflection.TypeDelegator.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMember(String,MemberTypes,BindingFlags)
  nameWithType: TypeDelegator.GetMember(String,MemberTypes,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMember(String,MemberTypes,BindingFlags)
- uid: System.Reflection.MemberInfo[]
  parent: System.Reflection
  isExternal: true
  name: MemberInfo
  nameWithType: MemberInfo
  fullName: System.Reflection.MemberInfo[]
  spec.csharp:
  - uid: System.Reflection.MemberInfo
    name: MemberInfo
    nameWithType: MemberInfo
    fullName: MemberInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.MemberTypes
  parent: System.Reflection
  isExternal: false
  name: MemberTypes
  nameWithType: MemberTypes
  fullName: System.Reflection.MemberTypes
- uid: System.Reflection.TypeDelegator.GetMembers(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMembers(BindingFlags)
  nameWithType: TypeDelegator.GetMembers(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMembers(BindingFlags)
- uid: System.Reflection.TypeDelegator.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])
- uid: System.Reflection.MethodInfo
  parent: System.Reflection
  isExternal: true
  name: MethodInfo
  nameWithType: MethodInfo
  fullName: System.Reflection.MethodInfo
- uid: System.Reflection.TypeDelegator.GetMethods(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMethods(BindingFlags)
  nameWithType: TypeDelegator.GetMethods(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetMethods(BindingFlags)
- uid: System.Reflection.MethodInfo[]
  parent: System.Reflection
  isExternal: true
  name: MethodInfo
  nameWithType: MethodInfo
  fullName: System.Reflection.MethodInfo[]
  spec.csharp:
  - uid: System.Reflection.MethodInfo
    name: MethodInfo
    nameWithType: MethodInfo
    fullName: MethodInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetNestedType(System.String,System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetNestedType(String,BindingFlags)
  nameWithType: TypeDelegator.GetNestedType(String,BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetNestedType(String,BindingFlags)
- uid: System.Reflection.TypeDelegator.GetNestedTypes(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetNestedTypes(BindingFlags)
  nameWithType: TypeDelegator.GetNestedTypes(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetNestedTypes(BindingFlags)
- uid: System.Reflection.TypeDelegator.GetProperties(System.Reflection.BindingFlags)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetProperties(BindingFlags)
  nameWithType: TypeDelegator.GetProperties(BindingFlags)
  fullName: System.Reflection.TypeDelegator.GetProperties(BindingFlags)
- uid: System.Reflection.PropertyInfo[]
  parent: System.Reflection
  isExternal: true
  name: PropertyInfo
  nameWithType: PropertyInfo
  fullName: System.Reflection.PropertyInfo[]
  spec.csharp:
  - uid: System.Reflection.PropertyInfo
    name: PropertyInfo
    nameWithType: PropertyInfo
    fullName: PropertyInfo[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  nameWithType: TypeDelegator.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
  fullName: System.Reflection.TypeDelegator.GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])
- uid: System.Reflection.PropertyInfo
  parent: System.Reflection
  isExternal: true
  name: PropertyInfo
  nameWithType: PropertyInfo
  fullName: System.Reflection.PropertyInfo
- uid: System.Reflection.TypeDelegator.GUID
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GUID
  nameWithType: TypeDelegator.GUID
  fullName: System.Reflection.TypeDelegator.GUID
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.Reflection.TypeDelegator.HasElementTypeImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: HasElementTypeImpl()
  nameWithType: TypeDelegator.HasElementTypeImpl()
  fullName: System.Reflection.TypeDelegator.HasElementTypeImpl()
- uid: System.Reflection.TypeDelegator.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  nameWithType: TypeDelegator.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
  fullName: System.Reflection.TypeDelegator.InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Reflection.TypeDelegator.IsArrayImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsArrayImpl()
  nameWithType: TypeDelegator.IsArrayImpl()
  fullName: System.Reflection.TypeDelegator.IsArrayImpl()
- uid: System.Reflection.TypeDelegator.IsAssignableFrom(System.Reflection.TypeInfo)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsAssignableFrom(TypeInfo)
  nameWithType: TypeDelegator.IsAssignableFrom(TypeInfo)
  fullName: System.Reflection.TypeDelegator.IsAssignableFrom(TypeInfo)
- uid: System.Reflection.TypeDelegator.IsByRefImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsByRefImpl()
  nameWithType: TypeDelegator.IsByRefImpl()
  fullName: System.Reflection.TypeDelegator.IsByRefImpl()
- uid: System.Reflection.TypeDelegator.IsCOMObjectImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsCOMObjectImpl()
  nameWithType: TypeDelegator.IsCOMObjectImpl()
  fullName: System.Reflection.TypeDelegator.IsCOMObjectImpl()
- uid: System.Reflection.TypeDelegator.IsConstructedGenericType
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsConstructedGenericType
  nameWithType: TypeDelegator.IsConstructedGenericType
  fullName: System.Reflection.TypeDelegator.IsConstructedGenericType
- uid: System.Reflection.TypeDelegator.IsDefined(System.Type,System.Boolean)
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsDefined(Type,Boolean)
  nameWithType: TypeDelegator.IsDefined(Type,Boolean)
  fullName: System.Reflection.TypeDelegator.IsDefined(Type,Boolean)
- uid: System.Reflection.TypeDelegator.IsPointerImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsPointerImpl()
  nameWithType: TypeDelegator.IsPointerImpl()
  fullName: System.Reflection.TypeDelegator.IsPointerImpl()
- uid: System.Reflection.TypeDelegator.IsPrimitiveImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsPrimitiveImpl()
  nameWithType: TypeDelegator.IsPrimitiveImpl()
  fullName: System.Reflection.TypeDelegator.IsPrimitiveImpl()
- uid: System.Reflection.TypeDelegator.IsValueTypeImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsValueTypeImpl()
  nameWithType: TypeDelegator.IsValueTypeImpl()
  fullName: System.Reflection.TypeDelegator.IsValueTypeImpl()
- uid: System.Reflection.TypeDelegator.MetadataToken
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: MetadataToken
  nameWithType: TypeDelegator.MetadataToken
  fullName: System.Reflection.TypeDelegator.MetadataToken
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Reflection.TypeDelegator.Module
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Module
  nameWithType: TypeDelegator.Module
  fullName: System.Reflection.TypeDelegator.Module
- uid: System.Reflection.Module
  parent: System.Reflection
  isExternal: true
  name: Module
  nameWithType: Module
  fullName: System.Reflection.Module
- uid: System.Reflection.TypeDelegator.Name
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Name
  nameWithType: TypeDelegator.Name
  fullName: System.Reflection.TypeDelegator.Name
- uid: System.Reflection.TypeDelegator.Namespace
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Namespace
  nameWithType: TypeDelegator.Namespace
  fullName: System.Reflection.TypeDelegator.Namespace
- uid: System.Reflection.TypeDelegator.TypeHandle
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeHandle
  nameWithType: TypeDelegator.TypeHandle
  fullName: System.Reflection.TypeDelegator.TypeHandle
- uid: System.RuntimeTypeHandle
  parent: System
  isExternal: true
  name: RuntimeTypeHandle
  nameWithType: RuntimeTypeHandle
  fullName: System.RuntimeTypeHandle
- uid: System.Reflection.TypeDelegator.typeImpl
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: typeImpl
  nameWithType: TypeDelegator.typeImpl
  fullName: System.Reflection.TypeDelegator.typeImpl
- uid: System.Reflection.TypeDelegator.UnderlyingSystemType
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: UnderlyingSystemType
  nameWithType: TypeDelegator.UnderlyingSystemType
  fullName: System.Reflection.TypeDelegator.UnderlyingSystemType
- uid: System.Reflection.TypeDelegator.#ctor*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeDelegator
  nameWithType: TypeDelegator.TypeDelegator
- uid: System.Reflection.TypeDelegator.Assembly*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Assembly
  nameWithType: TypeDelegator.Assembly
- uid: System.Reflection.TypeDelegator.AssemblyQualifiedName*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: AssemblyQualifiedName
  nameWithType: TypeDelegator.AssemblyQualifiedName
- uid: System.Reflection.TypeDelegator.BaseType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: BaseType
  nameWithType: TypeDelegator.BaseType
- uid: System.Reflection.TypeDelegator.FullName*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: FullName
  nameWithType: TypeDelegator.FullName
- uid: System.Reflection.TypeDelegator.GetAttributeFlagsImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetAttributeFlagsImpl
  nameWithType: TypeDelegator.GetAttributeFlagsImpl
- uid: System.Reflection.TypeDelegator.GetConstructorImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetConstructorImpl
  nameWithType: TypeDelegator.GetConstructorImpl
- uid: System.Reflection.TypeDelegator.GetConstructors*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetConstructors
  nameWithType: TypeDelegator.GetConstructors
- uid: System.Reflection.TypeDelegator.GetCustomAttributes*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetCustomAttributes
  nameWithType: TypeDelegator.GetCustomAttributes
- uid: System.Reflection.TypeDelegator.GetElementType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetElementType
  nameWithType: TypeDelegator.GetElementType
- uid: System.Reflection.TypeDelegator.GetEvent*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvent
  nameWithType: TypeDelegator.GetEvent
- uid: System.Reflection.TypeDelegator.GetEvents*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetEvents
  nameWithType: TypeDelegator.GetEvents
- uid: System.Reflection.TypeDelegator.GetField*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetField
  nameWithType: TypeDelegator.GetField
- uid: System.Reflection.TypeDelegator.GetFields*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetFields
  nameWithType: TypeDelegator.GetFields
- uid: System.Reflection.TypeDelegator.GetInterface*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterface
  nameWithType: TypeDelegator.GetInterface
- uid: System.Reflection.TypeDelegator.GetInterfaceMap*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterfaceMap
  nameWithType: TypeDelegator.GetInterfaceMap
- uid: System.Reflection.TypeDelegator.GetInterfaces*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetInterfaces
  nameWithType: TypeDelegator.GetInterfaces
- uid: System.Reflection.TypeDelegator.GetMember*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMember
  nameWithType: TypeDelegator.GetMember
- uid: System.Reflection.TypeDelegator.GetMembers*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMembers
  nameWithType: TypeDelegator.GetMembers
- uid: System.Reflection.TypeDelegator.GetMethodImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMethodImpl
  nameWithType: TypeDelegator.GetMethodImpl
- uid: System.Reflection.TypeDelegator.GetMethods*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetMethods
  nameWithType: TypeDelegator.GetMethods
- uid: System.Reflection.TypeDelegator.GetNestedType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetNestedType
  nameWithType: TypeDelegator.GetNestedType
- uid: System.Reflection.TypeDelegator.GetNestedTypes*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetNestedTypes
  nameWithType: TypeDelegator.GetNestedTypes
- uid: System.Reflection.TypeDelegator.GetProperties*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetProperties
  nameWithType: TypeDelegator.GetProperties
- uid: System.Reflection.TypeDelegator.GetPropertyImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GetPropertyImpl
  nameWithType: TypeDelegator.GetPropertyImpl
- uid: System.Reflection.TypeDelegator.GUID*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: GUID
  nameWithType: TypeDelegator.GUID
- uid: System.Reflection.TypeDelegator.HasElementTypeImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: HasElementTypeImpl
  nameWithType: TypeDelegator.HasElementTypeImpl
- uid: System.Reflection.TypeDelegator.InvokeMember*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: InvokeMember
  nameWithType: TypeDelegator.InvokeMember
- uid: System.Reflection.TypeDelegator.IsArrayImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsArrayImpl
  nameWithType: TypeDelegator.IsArrayImpl
- uid: System.Reflection.TypeDelegator.IsAssignableFrom*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsAssignableFrom
  nameWithType: TypeDelegator.IsAssignableFrom
- uid: System.Reflection.TypeDelegator.IsByRefImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsByRefImpl
  nameWithType: TypeDelegator.IsByRefImpl
- uid: System.Reflection.TypeDelegator.IsCOMObjectImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsCOMObjectImpl
  nameWithType: TypeDelegator.IsCOMObjectImpl
- uid: System.Reflection.TypeDelegator.IsConstructedGenericType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsConstructedGenericType
  nameWithType: TypeDelegator.IsConstructedGenericType
- uid: System.Reflection.TypeDelegator.IsDefined*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsDefined
  nameWithType: TypeDelegator.IsDefined
- uid: System.Reflection.TypeDelegator.IsPointerImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsPointerImpl
  nameWithType: TypeDelegator.IsPointerImpl
- uid: System.Reflection.TypeDelegator.IsPrimitiveImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsPrimitiveImpl
  nameWithType: TypeDelegator.IsPrimitiveImpl
- uid: System.Reflection.TypeDelegator.IsValueTypeImpl*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: IsValueTypeImpl
  nameWithType: TypeDelegator.IsValueTypeImpl
- uid: System.Reflection.TypeDelegator.MetadataToken*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: MetadataToken
  nameWithType: TypeDelegator.MetadataToken
- uid: System.Reflection.TypeDelegator.Module*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Module
  nameWithType: TypeDelegator.Module
- uid: System.Reflection.TypeDelegator.Name*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Name
  nameWithType: TypeDelegator.Name
- uid: System.Reflection.TypeDelegator.Namespace*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: Namespace
  nameWithType: TypeDelegator.Namespace
- uid: System.Reflection.TypeDelegator.TypeHandle*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: TypeHandle
  nameWithType: TypeDelegator.TypeHandle
- uid: System.Reflection.TypeDelegator.UnderlyingSystemType*
  parent: System.Reflection.TypeDelegator
  isExternal: false
  name: UnderlyingSystemType
  nameWithType: TypeDelegator.UnderlyingSystemType
