### YamlMime:ManagedReference
items:
- uid: System.Windows.FrameworkPropertyMetadata
  id: FrameworkPropertyMetadata
  children:
  - System.Windows.FrameworkPropertyMetadata.#ctor
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)
  - System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)
  - System.Windows.FrameworkPropertyMetadata.AffectsArrange
  - System.Windows.FrameworkPropertyMetadata.AffectsMeasure
  - System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
  - System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
  - System.Windows.FrameworkPropertyMetadata.AffectsRender
  - System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
  - System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  - System.Windows.FrameworkPropertyMetadata.Inherits
  - System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
  - System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
  - System.Windows.FrameworkPropertyMetadata.Journal
  - System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)
  - System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)
  - System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
  - System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  langs:
  - csharp
  name: FrameworkPropertyMetadata
  nameWithType: FrameworkPropertyMetadata
  fullName: System.Windows.FrameworkPropertyMetadata
  type: Class
  summary: "回報或套用中繼資料相依性屬性，特別加入架構專屬的屬性系統特性。"
  remarks: "此類別衍生自<xref:System.Windows.PropertyMetadata>(透過<xref:System.Windows.UIPropertyMetadata>)。</xref:System.Windows.UIPropertyMetadata> </xref:System.Windows.PropertyMetadata> 大部分的 WPF 架構層級應用程式開發用途而言，FrameworkPropertyMetadata 是用於相依性屬性中繼資料，而不是基底中繼資料型別<xref:System.Windows.PropertyMetadata>或<xref:System.Windows.UIPropertyMetadata>.</xref:System.Windows.UIPropertyMetadata></xref:System.Windows.PropertyMetadata>的類型 這適用於現有的相依性屬性和大部分自訂相依性屬性。       這個宣告的成員類別該補充<xref:System.Windows.PropertyMetadata>基底類別包含各種布林屬性，可指定或報表 WPF 架構層級屬性的系統行為，例如屬性繼承、 資料繫結和版面配置。</xref:System.Windows.PropertyMetadata>       建立 FrameworkPropertyMetadata 執行個體的數個建構函式簽章需要<xref:System.Windows.FrameworkPropertyMetadataOptions>參數。</xref:System.Windows.FrameworkPropertyMetadataOptions> <xref:System.Windows.FrameworkPropertyMetadataOptions>列舉型別只用於指定初始的行為在建構函式，而且否則未公開 FrameworkPropertyMetadata 建構後。</xref:System.Windows.FrameworkPropertyMetadataOptions> 建構的執行個體中，您可以取得或設定共用的建構函式呼叫中使用的列舉值名稱的各種屬性對應的資訊。      <a name=&quot;xamlTextUsage_FrameworkPropertyMetadata&quot;></a># # XAML 文字用法中通常不使用這個類別[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  example:
  - "The following example gets metadata for a dependency property on a particular owner as the initial base <xref:System.Windows.PropertyMetadata> type. That metadata is cast to FrameworkPropertyMetadata. If the cast returned a valid FrameworkPropertyMetadata, then various FrameworkPropertyMetadata property values are reported through a simple UI (not shown).  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: 'public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata'
  inheritance:
  - System.Object
  - System.Windows.PropertyMetadata
  - System.Windows.UIPropertyMetadata
  implements: []
  inheritedMembers:
  - System.Windows.PropertyMetadata.CoerceValueCallback
  - System.Windows.PropertyMetadata.DefaultValue
  - System.Windows.PropertyMetadata.IsSealed
  - System.Windows.PropertyMetadata.PropertyChangedCallback
  - System.Windows.UIPropertyMetadata.IsAnimationProhibited
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor
  id: '#ctor'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata()
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata()
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;></xref>類別。"
  remarks: "此簽章初始化 FrameworkPropertyMetadata 為其屬性的預設值的所有值。 <xref:System.Windows.PropertyMetadata.DefaultValue%2A>將`null`，各種<xref:System.Windows.FrameworkPropertyMetadata>將布林值屬性`false`。</xref:System.Windows.FrameworkPropertyMetadata></xref:System.Windows.PropertyMetadata.DefaultValue%2A>"
  syntax:
    content: public FrameworkPropertyMetadata ();
    parameters: []
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)
  id: '#ctor(System.Object)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;></xref>類別，而指定的預設值。"
  remarks: "提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。       值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。</xref:System.Windows.DependencyProperty.UnsetValue>"
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor1param](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor1param)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "預設值的相依性屬性，通常是提供給特定類型的值。"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>設定為<xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; 請參閱 < 備註 >。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)
  id: '#ctor(System.Windows.PropertyChangedCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;></xref>類別具有指定<xref href=&quot;System.Windows.PropertyChangedCallback&quot;></xref>回呼。"
  remarks: ''
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor1paramcallback](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor1paramcallback)]"
  syntax:
    content: public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);
    parameters:
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "對屬性系統有效的屬性值變更時，會呼叫處理常式實作的參考。"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;></xref>架構層級中繼資料 選項提供的預設值與類別。"
  remarks: "提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。       值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。</xref:System.Windows.DependencyProperty.UnsetValue>       值標記中設定旗標為`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> 接下來，只要中繼資料尚未套用至特定的屬性系統作業，您可以變更在中繼資料，屬性的值。"
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "預設值的相依性屬性，通常是提供給特定類型的值。"
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "中繼資料的選項旗標 (的組合<xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;></xref>值)。 這些選項會指定配置或資料繫結之類的系統互動的相依性屬性的特性。"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>設定為<xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; 請參閱 < 備註 >。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)
  id: '#ctor(System.Object,System.Windows.PropertyChangedCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;></xref>類別提供的預設值，並指定<xref href=&quot;System.Windows.PropertyChangedCallback&quot;></xref>回呼。"
  remarks: "提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。       值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。</xref:System.Windows.DependencyProperty.UnsetValue>"
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor2param](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor2param)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "預設值的相依性屬性，通常是提供給特定類型的值。"
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "對屬性系統有效的屬性值變更時，會呼叫處理常式實作的參考。"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>設定為<xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; 請參閱 < 備註 >。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  id: '#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;></xref>類別指定的回呼。"
  remarks: "此實作會呼叫基底的初始設定式，然後新增`coerceValueCallback`基底的執行個體上設定的屬性。"
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_pcc_cvc)]"
  syntax:
    content: public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);
    parameters:
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "對屬性系統有效的屬性值變更時，會呼叫處理常式實作的參考。"
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "每當對屬性系統呼叫，就會呼叫處理常式實作的參考<xref:System.Windows.DependencyObject.CoerceValue*>這個相依性屬性。</xref:System.Windows.DependencyObject.CoerceValue*>"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;></xref>類別提供的預設值和架構中繼資料 選項，並指定<xref href=&quot;System.Windows.PropertyChangedCallback&quot;></xref>回呼。"
  remarks: "提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。       值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。</xref:System.Windows.DependencyProperty.UnsetValue>       值標記中設定旗標為`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> 中繼資料尚未套用至特定的屬性系統作業時，您仍可以變更在中繼資料，屬性的值。"
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo_pcc)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "預設值的相依性屬性，通常是提供給特定類型的值。"
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "中繼資料的選項旗標 (的組合<xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;></xref>值)。 這些選項會指定配置或資料繫結之類的系統互動的相依性屬性的特性。"
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "對屬性系統有效的屬性值變更時，會呼叫處理常式實作的參考。"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>設定為<xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; 請參閱 < 備註 >。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  id: '#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;></xref>類別提供的預設值與指定的回呼。"
  remarks: "提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。       值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。</xref:System.Windows.DependencyProperty.UnsetValue>"
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor3param](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor3param)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "相依性屬性，通常提供做為特定類型的預設值。"
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "對屬性系統有效的屬性值變更時，會呼叫處理常式實作的參考。"
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "每當對屬性系統呼叫將會呼叫處理常式實作的參考<xref:System.Windows.DependencyObject.CoerceValue*>這個相依性屬性。</xref:System.Windows.DependencyObject.CoerceValue*>"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>設定為<xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; 請參閱 < 備註 >。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;></xref>類別提供的預設值和架構中繼資料 選項，並指定的回呼。"
  remarks: "提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。       值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。</xref:System.Windows.DependencyProperty.UnsetValue>       值標記中設定旗標為`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> 中繼資料尚未套用至特定的屬性系統作業時，您仍可以變更在中繼資料，屬性的值。"
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "相依性屬性，通常提供做為特定類型的預設值。"
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "中繼資料的選項旗標 (的組合<xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;></xref>值)。 這些選項會指定配置或資料繫結之類的系統互動的相依性屬性的特性。"
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "對屬性系統有效的屬性值變更時，會呼叫處理常式實作的參考。"
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "每當對屬性系統呼叫將會呼叫處理常式實作的參考<xref:System.Windows.DependencyObject.CoerceValue*>針對這個屬性。</xref:System.Windows.DependencyObject.CoerceValue*>"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>設定為<xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; 請參閱 < 備註 >。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;></xref>使用提供的預設值和架構中繼資料 選項、 指定的回呼和布林值，可用來防止動畫之屬性的類別。"
  remarks: "提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。       值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。</xref:System.Windows.DependencyProperty.UnsetValue>       `isAnimationProhibited`參數集的<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>立即的基底<xref:System.Windows.UIPropertyMetadata>類別</xref:System.Windows.UIPropertyMetadata>所宣告的屬性</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>的初始值       值標記中設定旗標為`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> 中繼資料尚未套用至特定的屬性系統作業時，您仍可以變更在中繼資料，屬性的值。"
  example:
  - "The following example calls this constructor signature:  \n  \n [!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "相依性屬性，通常提供做為特定類型的預設值。"
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "中繼資料的選項旗標 (的組合<xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;></xref>值)。 這些選項會指定配置或資料繫結之類的系統互動的相依性屬性的特性。"
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "對屬性系統有效的屬性值變更時，會呼叫處理常式實作的參考。"
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "每當對屬性系統呼叫將會呼叫處理常式實作的參考<xref:System.Windows.DependencyObject.CoerceValue*>此相依性屬性。</xref:System.Windows.DependencyObject.CoerceValue*>"
    - id: isAnimationProhibited
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要防止對屬性系統要套用這個中繼資料的屬性顯示動畫。 這類屬性會引發執行階段例外狀況源自屬性系統，如果嘗試的這些動畫。 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>若要允許的屬性顯示動畫。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>設定為<xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; 請參閱 < 備註 >。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)
  id: '#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)'
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.FrameworkPropertyMetadata&quot;></xref>類別提供的預設值和架構中繼資料的選項，指定的回呼，布林值，可用來防止動畫的屬性和資料繫結更新觸發程序預設值。"
  remarks: "提供值的型別`defaultValue`必須符合或與原始的相依性屬性會套用這個中繼資料登錄中指定的型別。 因為在編譯期間無法偵測不符項目，很難偵錯時，中繼資料的預設值類型與套用至相依性屬性的型別之間的不符。 對屬性系統之前不會評估屬性的有效值執行階段，因此預設值類型/屬性型別不相符的結果是執行階段錯誤。       值<xref:System.Windows.DependencyProperty.UnsetValue>屬性系統中, 具有特殊意義，也不能做為相依性屬性的預設值。</xref:System.Windows.DependencyProperty.UnsetValue>       `isAnimationProhibited`參數集的<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>立即的基底<xref:System.Windows.UIPropertyMetadata>類別</xref:System.Windows.UIPropertyMetadata>所宣告的屬性</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>的初始值       如需繫結的更新來源行為的詳細資訊，請參閱[資料繫結概觀](~/add/includes/ajax-current-ext-md.md)。       值標記中設定旗標為`flags`參數會設定的布林值<xref:System.Windows.FrameworkPropertyMetadata>屬性，使其符合<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標的名稱，以`true`。</xref:System.Windows.FrameworkPropertyMetadataOptions> </xref:System.Windows.FrameworkPropertyMetadata> 中繼資料尚未套用至特定的屬性系統作業時，您仍可以變更在中繼資料，屬性的值。"
  example:
  - "[!code-cs[PropertyMetadataAPIs#Initfpm](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#initfpm)]  \n[!code-cs[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/add/codesnippet/csharp/PropertyMetadataAPIs/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]"
  syntax:
    content: public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);
    parameters:
    - id: defaultValue
      type: System.Object
      description: "相依性屬性，通常提供做為特定類型的預設值。"
    - id: flags
      type: System.Windows.FrameworkPropertyMetadataOptions
      description: "中繼資料的選項旗標 (的組合<xref href=&quot;System.Windows.FrameworkPropertyMetadataOptions&quot;></xref>值)。 這些選項會指定配置或資料繫結之類的系統互動的相依性屬性的特性。"
    - id: propertyChangedCallback
      type: System.Windows.PropertyChangedCallback
      description: "對屬性系統有效的屬性值變更時，會呼叫處理常式實作的參考。"
    - id: coerceValueCallback
      type: System.Windows.CoerceValueCallback
      description: "每當對屬性系統呼叫將會呼叫處理常式實作的參考<xref:System.Windows.DependencyObject.CoerceValue*>針對這個屬性。</xref:System.Windows.DependencyObject.CoerceValue*>"
    - id: isAnimationProhibited
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要防止對屬性系統要套用這個中繼資料的屬性顯示動畫。 這類屬性會引發執行階段例外狀況源自屬性系統，如果嘗試的這些動畫。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: defaultUpdateSourceTrigger
      type: System.Windows.Data.UpdateSourceTrigger
      description: "<xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref>時套用這個屬性的繫結所要使用其<xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;></xref>設<xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>defaultValue</code>設定為<xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>; 請參閱 < 備註 >。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsArrange
  id: AffectsArrange
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsArrange
  nameWithType: FrameworkPropertyMetadata.AffectsArrange
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsArrange
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，這個值指出相依性屬性可能會在配置引擎作業期間影響排列傳遞。"
  remarks: "<xref:System.Windows.FrameworkElement>和<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，監視存在的項目的所有相依性屬性的有效值變更。</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> 有效的值變更，並具有 AffectsArrange 的中繼資料的相依性屬性設定為該邏輯的一部分，`true`會初始化延後的要求，使該元素的視覺效果 (呼叫<xref:System.Windows.UIElement.InvalidateArrange%2A>)。</xref:System.Windows.UIElement.InvalidateArrange%2A> 因為此 WPF 架構層級實作已備妥，通常不需要尋找 AffectsArrange 與相依性屬性，除非您基本上要取代或修改的 WPF 架構層級配置行為。       自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將相依性屬性變更的類似行為 AffectsArrange 所在`true`。</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。</xref:System.Windows.PropertyMetadata> 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsArrange&quot;></a># # XAML 文字使用這個類別的成員不常使用中[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool AffectsArrange { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個中繼資料所在潛在的相依性屬性會影響排列傳遞。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.AffectsArrange*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "中繼資料已套用至相依性屬性作業，使中繼資料已密封且無法設定屬性的中繼資料。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsMeasure
  id: AffectsMeasure
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsMeasure
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsMeasure
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，指出相依性屬性是否可能影響在版面配置引擎作業期間的測量傳遞。"
  remarks: "<xref:System.Windows.FrameworkElement>和<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，監視存在的項目的所有相依性屬性的有效值變更。</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> 有效的值變更，並具有 AffectsMeasure 的中繼資料的相依性屬性設定為該邏輯的一部分，`true`會初始化延後的要求，使該元素的視覺效果。 因為此 WPF 架構層級實作已備妥，通常不需要尋找 AffectsMeasure 與相依性屬性，除非您基本上要取代或修改的 WPF 架構層級配置行為。       自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將相依性屬性變更的類似行為 AffectsMeasure 所在`true`。</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。</xref:System.Windows.PropertyMetadata> 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsMeasure&quot;></a># # XAML 文字使用這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool AffectsMeasure { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個中繼資料所在潛在的相依性屬性會影響測量行程。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.AffectsMeasure*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "中繼資料已套用至相依性屬性作業，使中繼資料已密封且無法設定屬性的中繼資料。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
  id: AffectsParentArrange
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsParentArrange
  nameWithType: FrameworkPropertyMetadata.AffectsParentArrange
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，這個值指出相依性屬性可能會在配置引擎作業期間影響其父項目配置的排列傳遞。"
  remarks: "<xref:System.Windows.FrameworkElement>和<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，監視存在的項目的所有相依性屬性的有效值變更。</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> 有效的值變更，並具有 AffectsParentArrange 的中繼資料的相依性屬性設定為該邏輯的一部分，`true`會初始化延後的要求，使視覺效果的父項目。       一般而言，您不需要來報告變更的<xref:System.Windows.FrameworkElement>使用 AffectsParentArrange，因為項目本身會已經有它自己的父項目屬性<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>為`true`。</xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> </xref:System.Windows.FrameworkElement> 通常已足夠，因為子元素中的變更通常起始父代排列在適當時。 AffectsParentArrange 有時會用<xref:System.Windows.FrameworkContentElement>在衍生類別。</xref:System.Windows.FrameworkContentElement> 在此情況下，子系項目集合的屬性，但有<xref:System.Windows.FrameworkContentElement>衍生的類別不會控制自己的轉譯。</xref:System.Windows.FrameworkContentElement> 轉譯由<xref:System.Windows.FrameworkElement>做為內容主機的父項目。</xref:System.Windows.FrameworkElement> 比方說的值變更<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=fullName>失效附加的屬性的子元素所排列的父代，因為必須變更子系的父系中的位置。</xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=fullName> 因此，<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=fullName>附加的屬性的中繼資料所在 AffectsParentArrange `true`。</xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=fullName> 另一個例子是<xref:System.Windows.Controls.Control.Padding%2A>; 當此屬性的變更，父代可能會變更位置的子系，視可用空間而定。</xref:System.Windows.Controls.Control.Padding%2A>       因為此 WPF 架構層級實作已備妥，通常不需要尋找 AffectsParentArrange 與相依性屬性，除非您基本上要取代或修改的 WPF 架構層級配置行為。       自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將相依性屬性變更的類似行為 AffectsParentArrange 所在`true`。</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       任何屬性衍生的類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。</xref:System.Windows.PropertyMetadata> 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsParentArrange&quot;></a># # XAML 文字使用這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  syntax:
    content: public bool AffectsParentArrange { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個中繼資料所在潛在的相依性屬性會影響排列傳遞，特別是在其父項目。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "中繼資料已套用至相依性屬性作業，使中繼資料已密封且無法設定屬性的中繼資料。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
  id: AffectsParentMeasure
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsParentMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsParentMeasure
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，這個值指出相依性屬性可能會在配置引擎作業期間影響其父項目配置的測量傳遞。"
  remarks: "<xref:System.Windows.FrameworkElement>和<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，監視存在的項目的所有相依性屬性的有效值變更。</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> 有效的值變更，並具有 AffectsParentMeasure 的中繼資料的相依性屬性設定為該邏輯的一部分，`true`會初始化延後的要求，使視覺效果的父項目。 因為此 WPF 架構層級實作已備妥，通常不需要尋找 AffectsParentMeasure 與相依性屬性，除非您基本上要取代或修改的 WPF 架構層級配置行為。       一般而言，您不需要來報告變更的<xref:System.Windows.FrameworkElement>使用 AffectsParentMeasure，因為項目本身會已經有它自己的父項目屬性<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>為`true`。</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement> 通常已足夠，因為子元素中的變更通常會起始時適當的父量值傳遞。 AffectsParentMeasure 有時會用<xref:System.Windows.FrameworkContentElement>在衍生類別。</xref:System.Windows.FrameworkContentElement> 在此情況下，子系項目集合的屬性，但有<xref:System.Windows.FrameworkContentElement>衍生的類別不會控制自己的轉譯。</xref:System.Windows.FrameworkContentElement> 轉譯由<xref:System.Windows.FrameworkElement>做為內容主機的父項目。</xref:System.Windows.FrameworkElement> 比方說的值變更<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=fullName>是被子元素的屬性會使量值的父代，因為段落的相對間距可能變更，可能會增加或減少內容主機大小。</xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=fullName> 因此，<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=fullName>屬性的中繼資料所在 AffectsParentMeasure `true`。</xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=fullName>       內容主機項目也經常尋找相依性屬性的變更 AffectsParentMeasure 所在`true`，內容主機轉譯邏輯的一部分。 比方說，<xref:System.Windows.Controls.TextBox>項目必須回應某些變更可能會要求的文字中的週框方塊<xref:System.Windows.Controls.TextBox>本身變更。</xref:System.Windows.Controls.TextBox> </xref:System.Windows.Controls.TextBox>       自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將相依性屬性變更的類似行為 AffectsParentMeasure 所在`true`。</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       任何屬性衍生的類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。</xref:System.Windows.PropertyMetadata> 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsParentMeasure&quot;></a># # XAML 文字使用這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  syntax:
    content: public bool AffectsParentMeasure { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個中繼資料所在潛在的相依性屬性會影響測量行程，特別是在其父項目。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "中繼資料已套用至相依性屬性作業，使中繼資料已密封且無法設定屬性的中繼資料。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.AffectsRender
  id: AffectsRender
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: AffectsRender
  nameWithType: FrameworkPropertyMetadata.AffectsRender
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsRender
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，指出相依性屬性是否可能影響一般的版面配置，而不會特別影響排列或測量，但需要重新繪製。"
  remarks: "<xref:System.Windows.FrameworkElement>和<xref:System.Windows.FrameworkContentElement>包含實作<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>，監視存在的項目的所有相依性屬性的有效值變更。</xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> </xref:System.Windows.FrameworkContentElement></xref:System.Windows.FrameworkElement> 有效的值變更，並具有 AffectsRender 的中繼資料的相依性屬性設定為該邏輯的一部分，`true`會初始化延後的要求，使該元素的視覺效果。 因為此 WPF 架構層級實作已備妥，通常不需要尋找 AffectsRender 與相依性屬性，除非您基本上要取代或修改的 WPF 架構層級配置行為。       自訂<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>實作可能會選擇將相依性屬性變更的類似行為 AffectsRender 所在`true`。</xref:System.Windows.DependencyObject.OnPropertyChanged%2A>       任何屬性衍生的類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。</xref:System.Windows.PropertyMetadata> 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_AffectsRender&quot;></a># # XAML 文字使用這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool AffectsRender { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個中繼資料所在的相依性屬性會影響呈現。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.AffectsRender*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "中繼資料已套用至相依性屬性作業，使中繼資料已密封且無法設定屬性的中繼資料。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
  id: BindsTwoWayByDefault
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: BindsTwoWayByDefault
  nameWithType: FrameworkPropertyMetadata.BindsTwoWayByDefault
  fullName: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，指出是否將屬性預設雙向繫結。"
  remarks: "沒有這個屬性被`true`，更新繫結預設為單向，根據的預設行為<xref:System.Windows.Data.Binding>建構函式或對等項目[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]語法。</xref:System.Windows.Data.Binding>       在現有的項目，您通常會發現這個屬性設定為`true`中的報告狀態和可修改的使用者動作，例如<xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=fullName>.</xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=fullName>的相依性屬性的中繼資料       這個屬性只在一般情況下報告的相依性屬性的預設繫結更新特性。 任何繫結設定為執行個體上的這個屬性可以在本機設定<xref:System.Windows.Data.Binding.Mode%2A>繫結屬性和變更這個預設值。</xref:System.Windows.Data.Binding.Mode%2A>       任何屬性衍生的類別<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。</xref:System.Windows.PropertyMetadata> 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_BindsTwoWayByDefault&quot;></a># # XAML 文字使用這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool BindsTwoWayByDefault { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個中繼資料所在的相依性屬性預設雙向繫結。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "中繼資料已套用至相依性屬性作業，使中繼資料已密封且無法設定屬性的中繼資料。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  id: DefaultUpdateSourceTrigger
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: DefaultUpdateSourceTrigger
  nameWithType: FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  fullName: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定的預設值為<xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;></xref>套用繫結屬性與這個中繼資料時使用，其具有其<xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;></xref>設<xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref>。"
  remarks: "在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。</xref:System.Windows.PropertyMetadata> 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_DefaultUpdateSourceTrigger&quot;></a># # XAML 文字使用這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  syntax:
    content: public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }
    return:
      type: System.Windows.Data.UpdateSourceTrigger
      description: "列舉型別，而不是值<xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "這個屬性設定為<xref href=&quot;System.Windows.Data.UpdateSourceTrigger&quot;> </xref>; 您設定的值應該是成為繫結要求時的預設值。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "中繼資料已套用至相依性屬性作業，使中繼資料已密封且無法設定屬性的中繼資料。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.Inherits
  id: Inherits
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: Inherits
  nameWithType: FrameworkPropertyMetadata.Inherits
  fullName: System.Windows.FrameworkPropertyMetadata.Inherits
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，指出相依性屬性的值是否可繼承。"
  remarks: "屬性值繼承是一項功能[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]屬性系統，在 WPF 架構層級，讓特定相依性屬性可以在本機設定的項目或附近的根目錄[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]項目樹狀結構，然後將其也會包含該屬性的子項目之邏輯樹狀結構內的所有項目繼承的值。 根據預設，未啟用屬性值繼承，且啟用一些效能隱含作用。 如需詳細資訊，請參閱[屬性值繼承](~/add/includes/ajax-current-ext-md.md)。      > [!NOTE] > 雖然繼承屬性值可能會顯示適用於非附加相依性屬性，請透過在執行階段樹狀目錄中的某些物件部門附加屬性的繼承行為是未定義。 一律使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>註冊，您指定 Inherits 中繼資料中的屬性。</xref:System.Windows.DependencyProperty.RegisterAttached%2A>       在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。</xref:System.Windows.PropertyMetadata> 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_Inherits&quot;></a># # XAML 文字使用這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool Inherits { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果屬性值為可繼承。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.Inherits*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "中繼資料已套用至相依性屬性作業，使中繼資料已密封且無法設定屬性的中繼資料。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
  id: IsDataBindingAllowed
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: IsDataBindingAllowed
  nameWithType: FrameworkPropertyMetadata.IsDataBindingAllowed
  fullName: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得值，指出是否支援資料繫結的相依性屬性。"
  remarks: "這個屬性會報告`false`其中兩個可能的狀況︰ 不允許其中一個相依性屬性的資料繫結，因為相依性屬性是唯讀的 （如報告相依性屬性的識別項，不是中繼資料中），或另一個中繼資料屬性的值<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>，設為`true`此中繼資料中。</xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> 這個屬性公開為方便起見，讓呼叫端沒有檢查這兩個<xref:System.Windows.DependencyProperty.ReadOnly%2A>和<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>。</xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> </xref:System.Windows.DependencyProperty.ReadOnly%2A>       如果您嘗試建立其他的讀/寫屬性應該不支援資料繫結所指定的中繼資料，請指定此旗標<xref:System.Windows.FrameworkPropertyMetadataOptions>(請注意有些微的命名慣例差異與<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>)。</xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> </xref:System.Windows.FrameworkPropertyMetadataOptions>      <a name=&quot;xamlTextUsage_IsDataBindingAllowed&quot;></a># # XAML 文字使用這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  example:
  - "The following example obtains the default metadata from various dependency property fields, queries the value of various <xref:System.Windows.FrameworkPropertyMetadata> properties on it, and uses the information to populate a table to implement a \"metadata browser\".  \n  \n [!code-cs[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]\n [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  \n[!code-cs[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/csharp/PropertySystemEsoterics/XAMLAPP/page2.xaml.cs#fpmproperties)]\n[!code-vb[PropertySystemEsoterics#FPMProperties](~/add/codesnippet/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]"
  syntax:
    content: public bool IsDataBindingAllowed { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果要套用這個中繼資料; 的相依性屬性支援資料繫結否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
  id: IsNotDataBindable
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: IsNotDataBindable
  nameWithType: FrameworkPropertyMetadata.IsNotDataBindable
  fullName: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，這個值，指出相依性屬性是否支援資料繫結。"
  remarks: "請注意，此中繼資料屬性設定為`true`特別針對不支援資料繫結，儘管讀寫屬性的屬性。 預期是，在其中宣告相依性屬性的大部分情況下，資料繫結想要使用，因為資料繫結是其中一個重要的案例，其中的相依性屬性是很有用。 不同於<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>，這並不只是變更稍後可變更特定的繫結的預設值。</xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A> 設定這個屬性`true`相依性屬性的中繼資料中的中繼資料將會停用透過運算式將值套用至該相依性屬性的所有繫結。       唯讀相依性屬性不支援資料繫結 （因為它們沒有 setter 可套用變更的值），但仍會報告`false`IsNotDataBindable 的。 這是因為屬性對應到<xref:System.Windows.FrameworkPropertyMetadataOptions>值將會報告使用方式中繼資料已實際建立，而不是一律報告結束結果行為的屬性命名可能會隱含的權限的同位檢查。</xref:System.Windows.FrameworkPropertyMetadataOptions> 若要判斷給定的相依性屬性是否允許資料繫結，您應該通常檢查<xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>改用。</xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>同時檢查方便<xref:System.Windows.DependencyProperty.ReadOnly%2A>和 IsNotDataBindable 成單一作業，而產生預期的結果。</xref:System.Windows.DependencyProperty.ReadOnly%2A></xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>       在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。</xref:System.Windows.PropertyMetadata> 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_IsNotDataBindable&quot;></a># # XAML 文字使用這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  syntax:
    content: public bool IsNotDataBindable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果屬性不支援資料繫結。，否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "中繼資料已套用至相依性屬性作業，使中繼資料已密封且無法設定屬性的中繼資料。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.Journal
  id: Journal
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: Journal
  nameWithType: FrameworkPropertyMetadata.Journal
  fullName: System.Windows.FrameworkPropertyMetadata.Journal
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，指出此屬性是否包含日誌記錄資訊的應用程式可以或應該儲存為日誌記錄實作的一部分。"
  remarks: "在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。</xref:System.Windows.PropertyMetadata> 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_Journal&quot;></a># # XAML 文字使用這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  syntax:
    content: public bool Journal { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果日誌記錄應該執行; 套用這個中繼資料的相依性屬性否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.Journal*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "中繼資料已套用至相依性屬性作業，使中繼資料已密封且無法設定屬性的中繼資料。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)
  id: Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: Merge(PropertyMetadata,DependencyProperty)
  nameWithType: FrameworkPropertyMetadata.Merge(PropertyMetadata,DependencyProperty)
  fullName: System.Windows.FrameworkPropertyMetadata.Merge(PropertyMetadata,DependencyProperty)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "可讓基底中繼資料的來源中繼資料的合併。"
  remarks: "中繼資料覆寫時，為內部使用這個方法。"
  syntax:
    content: protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);
    parameters:
    - id: baseMetadata
      type: System.Windows.PropertyMetadata
      description: "要合併的基底中繼資料。"
    - id: dp
      type: System.Windows.DependencyProperty
      description: "此中繼資料套用至相依性屬性。"
  overload: System.Windows.FrameworkPropertyMetadata.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)
  id: OnApply(System.Windows.DependencyProperty,System.Type)
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: OnApply(DependencyProperty,Type)
  nameWithType: FrameworkPropertyMetadata.OnApply(DependencyProperty,Type)
  fullName: System.Windows.FrameworkPropertyMetadata.OnApply(DependencyProperty,Type)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "此中繼資料已套用至屬性，指出密封的中繼資料時呼叫。"
  remarks: "任何可變動性的資料結構的<xref:System.Windows.FrameworkPropertyMetadata>執行個體應該標記為當做不變時叫用此方法。</xref:System.Windows.FrameworkPropertyMetadata>"
  syntax:
    content: protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "相依性屬性中繼資料套用。"
    - id: targetType
      type: System.Type
      description: "如果這是特定類型的中繼資料，此中繼資料與相關聯的類型。 如果這是預設的中繼資料時，這個值可以是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.OnApply*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
  id: OverridesInheritanceBehavior
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: OverridesInheritanceBehavior
  nameWithType: FrameworkPropertyMetadata.OverridesInheritanceBehavior
  fullName: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，指出屬性值繼承評估是否應該跨越特定內容界限邏輯樹狀結構中的項目。"
  remarks: "此中繼資料會報告跨特殊的父項目子系項目界限少見修改屬性值繼承行為。 這類界限的標準範例是內容<xref:System.Windows.Controls.Frame>，其中的<xref:System.Windows.Controls.Frame>內容可能會取得獨立的<xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame>存在重新載入</xref:System.Windows.Controls.Frame></xref:System.Windows.Controls.Frame> 所需的屬性系統行為是屬性值繼承應該周遊到的內容<xref:System.Windows.Controls.Frame>，因為這些內容可能會裝載框架的應用程式不會擁有或控制的項目。</xref:System.Windows.Controls.Frame> 指定中繼資料與 OverridesInheritanceBehavior 設`true`，也會為指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>做為`true`，會導致的屬性的中繼資料套用為可繼承即使透過<xref:System.Windows.Controls.Frame>界限或類似的界限。</xref:System.Windows.Controls.Frame> </xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>       在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。</xref:System.Windows.PropertyMetadata> 這是讓可在執行個體的初始設定之後加以調整。 不過，呼叫的一部分，會使用中繼資料之後<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_OverridesInheritanceBehavior&quot;></a># # XAML 文字使用這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  syntax:
    content: public bool OverridesInheritanceBehavior { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果屬性值繼承應該跨越特定內容界限。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "中繼資料已套用至相依性屬性作業，使中繼資料已密封且無法設定屬性的中繼資料。"
  platform:
  - net462
- uid: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  id: SubPropertiesDoNotAffectRender
  parent: System.Windows.FrameworkPropertyMetadata
  langs:
  - csharp
  name: SubPropertiesDoNotAffectRender
  nameWithType: FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  fullName: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，指出是否相依性屬性的子屬性不會影響包含物件的轉譯。"
  remarks: "此中繼資料的選項是相關的是參考類型，其中該類型有它自己的屬性值的相依性屬性。 一般而言，配置系統邏輯是假設任何具有子屬性的相依性屬性可能會影響配置，因為檢查所有的子屬性的變更會耗用更多時間比實際執行另一個呈現的傳遞。 此選項設為`true`適用於最佳化 WPF 架構層級的版面配置系統實作的效能。       在衍生類別的屬性<xref:System.Windows.PropertyMetadata>通常定義為讀寫物件模型中。</xref:System.Windows.PropertyMetadata> 這是讓可在執行個體的初始設定之後加以調整。 不過，一旦一部分的呼叫會使用中繼資料<xref:System.Windows.DependencyProperty.Register%2A>， <xref:System.Windows.DependencyProperty.AddOwner%2A>，或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>屬性系統將密封該中繼資料執行個體，傳遞的中繼資料的細節的屬性現在會被視為不變。</xref:System.Windows.DependencyProperty.OverrideMetadata%2A> </xref:System.Windows.DependencyProperty.AddOwner%2A> </xref:System.Windows.DependencyProperty.Register%2A> 嘗試設定此屬性之後<xref:System.Windows.PropertyMetadata.IsSealed%2A>是`true`此中繼資料執行個體將會引發例外狀況。</xref:System.Windows.PropertyMetadata.IsSealed%2A>      <a name=&quot;xamlTextUsage_SubPropertiesDoNotAffectRender&quot;></a># # XAML 文字使用這個類別的成員不通常會以[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  syntax:
    content: public bool SubPropertiesDoNotAffectRender { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果子屬性值的變更不會影響呈現，如果變更，否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "中繼資料已套用至相依性屬性作業，使中繼資料已密封且無法設定屬性的中繼資料。"
  platform:
  - net462
references:
- uid: System.Windows.UIPropertyMetadata
  isExternal: false
  name: System.Windows.UIPropertyMetadata
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.FrameworkPropertyMetadata.#ctor
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata()
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata()
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata()
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback)
- uid: System.Windows.PropertyChangedCallback
  parent: System.Windows
  isExternal: false
  name: PropertyChangedCallback
  nameWithType: PropertyChangedCallback
  fullName: System.Windows.PropertyChangedCallback
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions)
- uid: System.Windows.FrameworkPropertyMetadataOptions
  parent: System.Windows
  isExternal: false
  name: FrameworkPropertyMetadataOptions
  nameWithType: FrameworkPropertyMetadataOptions
  fullName: System.Windows.FrameworkPropertyMetadataOptions
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback)
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(PropertyChangedCallback,CoerceValueCallback)
- uid: System.Windows.CoerceValueCallback
  parent: System.Windows
  isExternal: false
  name: CoerceValueCallback
  nameWithType: CoerceValueCallback
  fullName: System.Windows.CoerceValueCallback
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback)
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,PropertyChangedCallback,CoerceValueCallback)
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback)
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
  fullName: System.Windows.FrameworkPropertyMetadata.FrameworkPropertyMetadata(Object,FrameworkPropertyMetadataOptions,PropertyChangedCallback,CoerceValueCallback,Boolean,UpdateSourceTrigger)
- uid: System.Windows.Data.UpdateSourceTrigger
  parent: System.Windows.Data
  isExternal: false
  name: UpdateSourceTrigger
  nameWithType: UpdateSourceTrigger
  fullName: System.Windows.Data.UpdateSourceTrigger
- uid: System.Windows.FrameworkPropertyMetadata.AffectsArrange
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsArrange
  nameWithType: FrameworkPropertyMetadata.AffectsArrange
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsArrange
- uid: System.Windows.FrameworkPropertyMetadata.AffectsMeasure
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsMeasure
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsMeasure
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsParentArrange
  nameWithType: FrameworkPropertyMetadata.AffectsParentArrange
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsParentMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsParentMeasure
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure
- uid: System.Windows.FrameworkPropertyMetadata.AffectsRender
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsRender
  nameWithType: FrameworkPropertyMetadata.AffectsRender
  fullName: System.Windows.FrameworkPropertyMetadata.AffectsRender
- uid: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: BindsTwoWayByDefault
  nameWithType: FrameworkPropertyMetadata.BindsTwoWayByDefault
  fullName: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault
- uid: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: DefaultUpdateSourceTrigger
  nameWithType: FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
  fullName: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
- uid: System.Windows.FrameworkPropertyMetadata.Inherits
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Inherits
  nameWithType: FrameworkPropertyMetadata.Inherits
  fullName: System.Windows.FrameworkPropertyMetadata.Inherits
- uid: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: IsDataBindingAllowed
  nameWithType: FrameworkPropertyMetadata.IsDataBindingAllowed
  fullName: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed
- uid: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: IsNotDataBindable
  nameWithType: FrameworkPropertyMetadata.IsNotDataBindable
  fullName: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable
- uid: System.Windows.FrameworkPropertyMetadata.Journal
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Journal
  nameWithType: FrameworkPropertyMetadata.Journal
  fullName: System.Windows.FrameworkPropertyMetadata.Journal
- uid: System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Merge(PropertyMetadata,DependencyProperty)
  nameWithType: FrameworkPropertyMetadata.Merge(PropertyMetadata,DependencyProperty)
  fullName: System.Windows.FrameworkPropertyMetadata.Merge(PropertyMetadata,DependencyProperty)
- uid: System.Windows.PropertyMetadata
  parent: System.Windows
  isExternal: false
  name: PropertyMetadata
  nameWithType: PropertyMetadata
  fullName: System.Windows.PropertyMetadata
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: OnApply(DependencyProperty,Type)
  nameWithType: FrameworkPropertyMetadata.OnApply(DependencyProperty,Type)
  fullName: System.Windows.FrameworkPropertyMetadata.OnApply(DependencyProperty,Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: OverridesInheritanceBehavior
  nameWithType: FrameworkPropertyMetadata.OverridesInheritanceBehavior
  fullName: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior
- uid: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: SubPropertiesDoNotAffectRender
  nameWithType: FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
  fullName: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
- uid: System.Windows.FrameworkPropertyMetadata.#ctor*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: FrameworkPropertyMetadata
  nameWithType: FrameworkPropertyMetadata.FrameworkPropertyMetadata
- uid: System.Windows.FrameworkPropertyMetadata.AffectsArrange*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsArrange
  nameWithType: FrameworkPropertyMetadata.AffectsArrange
- uid: System.Windows.FrameworkPropertyMetadata.AffectsMeasure*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsMeasure
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentArrange*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsParentArrange
  nameWithType: FrameworkPropertyMetadata.AffectsParentArrange
- uid: System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsParentMeasure
  nameWithType: FrameworkPropertyMetadata.AffectsParentMeasure
- uid: System.Windows.FrameworkPropertyMetadata.AffectsRender*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: AffectsRender
  nameWithType: FrameworkPropertyMetadata.AffectsRender
- uid: System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: BindsTwoWayByDefault
  nameWithType: FrameworkPropertyMetadata.BindsTwoWayByDefault
- uid: System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: DefaultUpdateSourceTrigger
  nameWithType: FrameworkPropertyMetadata.DefaultUpdateSourceTrigger
- uid: System.Windows.FrameworkPropertyMetadata.Inherits*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Inherits
  nameWithType: FrameworkPropertyMetadata.Inherits
- uid: System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: IsDataBindingAllowed
  nameWithType: FrameworkPropertyMetadata.IsDataBindingAllowed
- uid: System.Windows.FrameworkPropertyMetadata.IsNotDataBindable*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: IsNotDataBindable
  nameWithType: FrameworkPropertyMetadata.IsNotDataBindable
- uid: System.Windows.FrameworkPropertyMetadata.Journal*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Journal
  nameWithType: FrameworkPropertyMetadata.Journal
- uid: System.Windows.FrameworkPropertyMetadata.Merge*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: Merge
  nameWithType: FrameworkPropertyMetadata.Merge
- uid: System.Windows.FrameworkPropertyMetadata.OnApply*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: OnApply
  nameWithType: FrameworkPropertyMetadata.OnApply
- uid: System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: OverridesInheritanceBehavior
  nameWithType: FrameworkPropertyMetadata.OverridesInheritanceBehavior
- uid: System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender*
  parent: System.Windows.FrameworkPropertyMetadata
  isExternal: false
  name: SubPropertiesDoNotAffectRender
  nameWithType: FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender
