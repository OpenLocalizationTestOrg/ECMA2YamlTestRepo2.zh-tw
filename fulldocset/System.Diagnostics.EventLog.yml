### YamlMime:ManagedReference
items:
- uid: System.Diagnostics.EventLog
  id: EventLog
  children:
  - System.Diagnostics.EventLog.#ctor
  - System.Diagnostics.EventLog.#ctor(System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String)
  - System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.BeginInit
  - System.Diagnostics.EventLog.Clear
  - System.Diagnostics.EventLog.Close
  - System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  - System.Diagnostics.EventLog.Delete(System.String)
  - System.Diagnostics.EventLog.Delete(System.String,System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String)
  - System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  - System.Diagnostics.EventLog.Dispose(System.Boolean)
  - System.Diagnostics.EventLog.EnableRaisingEvents
  - System.Diagnostics.EventLog.EndInit
  - System.Diagnostics.EventLog.Entries
  - System.Diagnostics.EventLog.EntryWritten
  - System.Diagnostics.EventLog.Exists(System.String)
  - System.Diagnostics.EventLog.Exists(System.String,System.String)
  - System.Diagnostics.EventLog.GetEventLogs
  - System.Diagnostics.EventLog.GetEventLogs(System.String)
  - System.Diagnostics.EventLog.Log
  - System.Diagnostics.EventLog.LogDisplayName
  - System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  - System.Diagnostics.EventLog.MachineName
  - System.Diagnostics.EventLog.MaximumKilobytes
  - System.Diagnostics.EventLog.MinimumRetentionDays
  - System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  - System.Diagnostics.EventLog.OverflowAction
  - System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  - System.Diagnostics.EventLog.Source
  - System.Diagnostics.EventLog.SourceExists(System.String)
  - System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  - System.Diagnostics.EventLog.SynchronizingObject
  - System.Diagnostics.EventLog.WriteEntry(System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  - System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  - System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  langs:
  - csharp
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog
  type: Class
  summary: "提供與 Windows 事件記錄檔的互動。"
  remarks: "事件記錄檔可讓您存取或自訂 Windows 事件記錄檔，它會記錄重要的軟體或硬體事件的相關資訊。 使用事件記錄檔，您可以從現有的記錄檔讀取、 寫入記錄檔中的項目，建立或刪除事件來源、 刪除記錄檔，以及回應記錄項目。 建立事件來源時，您也可以建立新的記錄檔。      > [!IMPORTANT] > 這個型別實作<xref:System.IDisposable>介面。</xref:System.IDisposable> 當您完成使用類型時，您應該會處置它直接或間接。 若要直接處置的類型，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。</xref:System.IDisposable.Dispose%2A> 若要為其配置間接，使用語言建構例如`using`（C# 中） 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱中的 「 使用物件的實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。</xref:System.IDisposable>       除了提供個別的事件記錄檔和其項目存取權，EventLog 類別可讓您存取的所有事件記錄檔集合。 您可以使用`static`成員的事件記錄檔來刪除記錄檔，取得記錄清單、 建立或刪除來源，或判斷電腦是否已包含特定的來源。       有三個預設事件記錄檔︰ 應用程式、 系統及安全性。 安全性記錄檔為唯讀。 其他應用程式和服務安裝，例如 Active Directory 中，可能會有額外的事件記錄檔。       使用事件記錄檔類別時，有一些安全性考量。 事件記錄檔需要<xref:System.Diagnostics.EventLogPermission>的.NET Framework 2.0 和更新版本中中的特定動作或.NET Framework 1.0 和 1.1 版中的完全信任權限。</xref:System.Diagnostics.EventLogPermission> 我們建議最好讓<xref:System.Diagnostics.EventLogPermission>授與部分信任程式碼。</xref:System.Diagnostics.EventLogPermission>  您應該永遠不會傳遞任何事件記錄檔物件，包括<xref:System.Diagnostics.EventLogEntryCollection>和<xref:System.Diagnostics.EventLogEntry>較不受信任的程式碼的物件。</xref:System.Diagnostics.EventLogEntry> </xref:System.Diagnostics.EventLogEntryCollection> 比方說，建立 EventLog 物件、 撰寫一個項目，然後再將傳遞的事件記錄檔以部分信任程式碼的物件可以建立安全性問題，因為能夠讀取和寫入事件記錄檔可讓程式碼來執行動作，例如發出事件記錄檔訊息，另一個應用程式的名稱。       從 Windows Vista 開始，使用者帳戶控制 (UAC) 會判斷使用者的認證。 如果您是內建的 Administrators 群組的成員，您就會指派兩個執行階段存取語彙基元︰ 標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼存取安全性記錄檔，您必須先將您的認證從標準使用者提高為系統管理員。 您可以開啟應用程式的捷徑功能表啟動應用程式時 （如果您使用滑鼠，以滑鼠右鍵按一下應用程式圖示），並指出您想要以系統管理員身分執行。       若要建立自訂的事件記錄檔，您可以透過伺服器的事件檢視器檢視，您可以使用事件記錄檔。 使用<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>方法，以顯示事件檢視器中的事件記錄檔的當地語系化的名稱。</xref:System.Diagnostics.EventLog.RegisterDisplayName%2A> 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法以設定事件記錄檔的行為，當它在達到最大記錄檔大小。</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>       若要從事件記錄檔讀取，指定記錄檔名稱 (<xref:System.Diagnostics.EventLog.Log%2A>屬性) 和伺服器電腦名稱 (<xref:System.Diagnostics.EventLog.MachineName%2A>事件記錄檔的屬性</xref:System.Diagnostics.EventLog.MachineName%2A></xref:System.Diagnostics.EventLog.Log%2A> 如果您未指定伺服器的電腦名稱，在本機電腦 」。 」，會假設。 不需要指定事件來源 (<xref:System.Diagnostics.EventLog.Source%2A>屬性)，因為來源是只有需要寫入記錄檔。</xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.Entries%2A>屬性會自動填入的項目事件記錄檔的清單。</xref:System.Diagnostics.EventLog.Entries%2A>       若要寫入事件記錄檔，指定或建立事件來源 (<xref:System.Diagnostics.EventLog.Source%2A>屬性)。</xref:System.Diagnostics.EventLog.Source%2A> 您必須建立新的事件來源電腦上具有系統管理認證。 事件來源使用，註冊您的應用程式事件記錄檔項目的有效來源。 您可以使用事件來源寫入一次只能有一個記錄。 <xref:System.Diagnostics.EventLog.Source%2A>屬性可以是隨機的任何字串，但必須是相異的電腦上的其他來源的名稱。</xref:System.Diagnostics.EventLog.Source%2A> 事件來源通常是應用程式或另一個的識別字串的名稱。 嘗試建立重複<xref:System.Diagnostics.EventLog.Source%2A>值擲回例外狀況。</xref:System.Diagnostics.EventLog.Source%2A> 不過，單一的事件記錄檔可以與多個來源產生關聯。       如果事件來源的事件記錄檔執行個體相關聯的事件記錄檔不存在，則會建立新的事件來源。 若要建立事件來源在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理認證。       這是因為必須搜尋所有的事件記錄檔，包括安全性記錄檔，以判斷事件來源是否為唯一。 從 Windows Vista 開始，使用者沒有權限來存取安全性記錄檔中。因此，<xref:System.Security.SecurityException>就會擲回。</xref:System.Security.SecurityException>      > [!IMPORTANT] > 建立或刪除事件來源，需要同步處理的基礎程式碼使用具名的 mutex。 如果高特殊權限的應用程式鎖定具名的 mutex，嘗試建立或刪除事件來源會導致應用程式停止回應，直到釋放鎖定為止。 若要避免這個問題，永遠不會授與<xref:System.Security.Permissions.SecurityPermissionFlag>不受信任的程式碼的權限。</xref:System.Security.Permissions.SecurityPermissionFlag> 此外，<xref:System.Security.Permissions.SecurityPermissionFlag>權限可能會允許略過其他使用權限，以及應該只授與高度信任的程式碼。</xref:System.Security.Permissions.SecurityPermissionFlag>       應用程式和服務應該寫入應用程式記錄檔或自訂的記錄檔。 裝置驅動程式應該寫入至系統記錄檔。 如果您沒有明確設定<xref:System.Diagnostics.EventLog.Log%2A>屬性，應用程式記錄檔的事件記錄檔預設值</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > 沒有要保護應用程式做為任何已註冊的來源寫入項目。  如果應用程式授與<xref:System.Diagnostics.EventLogPermissionAccess>權限，它可以寫入事件的任何有效的來源電腦上註冊。</xref:System.Diagnostics.EventLogPermissionAccess>       使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>寫入事件記錄檔事件的方法</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.WriteEvent%2A> 您必須指定事件來源寫入事件。您必須建立並設定事件來源寫入來源的第一個項目之前。       在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統沒有重新整理其事件來源的清單，而且您嘗試要寫入的事件，該新的來源寫入作業將會失敗。 您可以使用設定新的來源<xref:System.Diagnostics.EventLogInstaller>物件或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理認證。       只有一個事件記錄檔可以寫入每個來源一次。不過，您的應用程式可以使用多個來源來寫入多個事件記錄檔。 例如，您的應用程式可能需要多個來源設定為不同的事件記錄檔或不同的資源檔案。 若要變更現有來源的設定詳細資料，您必須刪除來源，並再建立使用新的設定。 如果其他應用程式或元件使用現有的來源，建立新的來源與更新的組態，而不是刪除現有的來源。       您可以向事件來源的當地語系化資源的事件類別目錄和訊息字串。 您的應用程式可以使用資源識別項，而不是指定實際的字串值寫入事件記錄檔項目。 請參閱<xref:System.Diagnostics.EventLogInstaller>和<xref:System.Diagnostics.EventSourceCreationData>設定您的來源的資源檔的相關資訊的類別。</xref:System.Diagnostics.EventSourceCreationData> </xref:System.Diagnostics.EventLogInstaller>       如果您的應用程式會將字串值，直接寫入事件記錄檔，您不必設定資源的來源檔案內容。 必須設定來源，寫入當地語系化的項目或寫入直接的字串。 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>       當寫入事件時，至少必須指定訊息字串或訊息字串的資源識別項。 其他屬性是選擇性的。 選擇性的事件設定的範例包括下列:-您可以設定<xref:System.Diagnostics.EventLogEntryType>指定 事件檢視器顯示之項目的圖示。</xref:System.Diagnostics.EventLogEntryType>      -您可以指定事件的類別識別項，如果您的應用程式使用類別來進行篩選的事件。      -您可以將二進位資料附加到事件的項目，如果您想要與指定的事件產生關聯的其他資訊。      > [!IMPORTANT] > 事件記錄會耗用磁碟空間、 處理器時間，以及其他系統資源。 請務必記錄重要的資訊。 我們建議您將事件記錄檔呼叫放在錯誤路徑，而不是主要的程式碼的路徑中，因此它們不效能產生負面影響。       如需事件記錄檔的執行個體的初始屬性值的清單，請參閱<xref:System.Diagnostics.EventLog.%23ctor%2A>建構函式。</xref:System.Diagnostics.EventLog.%23ctor%2A>"
  example:
  - "The following example creates the event source `MySource` if it doesn't already exist, and writes an entry to the event log `MyNewLog`.  \n  \n> [!NOTE]\n>  Starting with Windows Vista, you must run this application as an administrator.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/t-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/t-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/t-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("EntryWritten")]

      [System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Diagnostics.MonitoringDescription("EventLogDesc")]

      public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor
  id: '#ctor'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初始化的新執行個體<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>類別。 不將執行個體關聯的任何記錄檔。"
  remarks: "然後再呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>屬性<xref:System.Diagnostics.EventLog>執行個體。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> 如果您只讀取<xref:System.Diagnostics.EventLog.Entries%2A>從記錄檔，您也可以指定只<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>屬性。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦 (&quot;。&quot;) 會假設。</xref:System.Diagnostics.EventLog.MachineName%2A>       下表顯示<xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>的執行個體的初始屬性值      |屬性 |初始值 |  |--------------|-------------------|  |<xref:System.Diagnostics.EventLog.Source%2A>|空字串 (&quot;&quot;)。 | |<xref:System.Diagnostics.EventLog.Log%2A>|空字串 (&quot;&quot;)。 | |<xref:System.Diagnostics.EventLog.MachineName%2A>|在本機電腦 (&quot;。&quot;)。 |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_9_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_9_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_9_1.vb)]"
  syntax:
    content: public EventLog ();
    parameters: []
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初始化的新執行個體<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>類別。 將執行個體與本機電腦上的記錄檔產生關聯。"
  remarks: "這個多載設定<xref:System.Diagnostics.EventLog.Log%2A>屬性`logName`參數。</xref:System.Diagnostics.EventLog.Log%2A> 然後再呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>，指定<xref:System.Diagnostics.EventLog.Source%2A>屬性<xref:System.Diagnostics.EventLog>執行個體。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> 如果您只讀取<xref:System.Diagnostics.EventLog.Entries%2A>從記錄檔，您也可以指定只<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>屬性。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦 (&quot;。&quot;) 會假設。</xref:System.Diagnostics.EventLog.MachineName%2A> 這個建構函式的多載指定<xref:System.Diagnostics.EventLog.Log%2A>屬性，但是您可以變更此值之前讀取<xref:System.Diagnostics.EventLog.Entries%2A>屬性。</xref:System.Diagnostics.EventLog.Entries%2A> </xref:System.Diagnostics.EventLog.Log%2A>       如果您指定在來源<xref:System.Diagnostics.EventLog.Source%2A>屬性是唯一的其他來源的電腦上，後續呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>不存在時，具有指定名稱，建立記錄檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A>       下表顯示<xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>的執行個體的初始屬性值      |屬性 |初始值 |  |--------------|-------------------|  |<xref:System.Diagnostics.EventLog.Source%2A>|空字串 (&quot;&quot;)。 | |<xref:System.Diagnostics.EventLog.Log%2A>|`logName`參數。 |  |<xref:System.Diagnostics.EventLog.MachineName%2A>|在本機電腦 (&quot;。&quot;)。 |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_13_1.cpp)]\n [!code-cs[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_13_1.cs)]\n [!code-vb[Classic EventLog.EventLog1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_13_1.vb)]"
  syntax:
    content: public EventLog (string logName);
    parameters:
    - id: logName
      type: System.String
      description: "在本機電腦上的記錄檔名稱。"
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "記錄檔名稱是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "記錄檔名稱無效。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初始化的新執行個體<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>類別。 將執行個體與指定的電腦上的記錄檔產生關聯。"
  remarks: "這個多載設定<xref:System.Diagnostics.EventLog.Log%2A>屬性`logName`參數和<xref:System.Diagnostics.EventLog.MachineName%2A>屬性`machineName`參數。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 然後再呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>中，指定<xref:System.Diagnostics.EventLog.Source%2A><xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>屬性</xref:System.Diagnostics.EventLog.Source%2A></xref:System.Diagnostics.EventLog.WriteEntry%2A> 如果您只讀取<xref:System.Diagnostics.EventLog.Entries%2A>從記錄檔，您也可以指定只<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>屬性。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Entries%2A>      > [!NOTE] > 建構函式的這個多載指定<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>屬性，但您可以變更之前讀取<xref:System.Diagnostics.EventLog.Entries%2A>屬性。</xref:System.Diagnostics.EventLog.Entries%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>       下表顯示<xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>的執行個體的初始屬性值      |屬性 |初始值 |  |--------------|-------------------|  |<xref:System.Diagnostics.EventLog.Source%2A>|空字串 (&quot;&quot;)。 | |<xref:System.Diagnostics.EventLog.Log%2A>|`logName`參數。 |  |<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName`參數。 |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example reads entries in the event log, \"myNewLog\", on the computer \"myServer\".  \n  \n [!code-cs[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_0_1.cs)]\n [!code-cpp[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_0_1.cpp)]\n [!code-vb[Classic EventLog.EventLog2 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_0_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: "指定的電腦上的記錄檔名稱。"
    - id: machineName
      type: System.String
      description: "記錄檔所在的電腦。"
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "記錄檔名稱是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "記錄檔名稱無效。       -或者-電腦名稱無效。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  id: '#ctor(System.String,System.String,System.String)'
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
  type: Constructor
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初始化的新執行個體<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>類別。 將執行個體與指定的電腦上的記錄檔產生關聯，並建立或指派至指定的來源<xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>。"
  remarks: "這個建構函式設定<xref:System.Diagnostics.EventLog.Log%2A>屬性`logName`參數，<xref:System.Diagnostics.EventLog.MachineName%2A>屬性`machineName`參數，而<xref:System.Diagnostics.EventLog.Source%2A>屬性`source`參數。</xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 的<xref:System.Diagnostics.EventLog.Source%2A>屬性時，需要寫入事件記錄檔。</xref:System.Diagnostics.EventLog.Source%2A> 不過，如果您只讀取事件記錄檔，只<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>（只要伺服器事件記錄檔包含已與它相關聯的來源），都需要屬性。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 如果您只讀取事件記錄檔，另一個多載建構函式可能會就夠了。       下表顯示<xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog>的執行個體的初始屬性值      |屬性 |初始值 |  |--------------|-------------------|  |<xref:System.Diagnostics.EventLog.Source%2A>|`source`參數。 |  |<xref:System.Diagnostics.EventLog.Log%2A>|`logName`參數。 |  |<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName`參數。 |</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.Source%2A>"
  example:
  - "The following example writes an entry to an event log, \"MyNewLog\", on the local computer, using the source \"MySource\".  \n  \n [!code-cs[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/csharp/fd99d44e-2d79-45f8-97e3-_1.cs)]\n [!code-cpp[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/cpp/fd99d44e-2d79-45f8-97e3-_1.cpp)]\n [!code-vb[Classic EventLog.EventLog3 Example#1](~/add/codesnippet/visualbasic/fd99d44e-2d79-45f8-97e3-_1.vb)]"
  syntax:
    content: public EventLog (string logName, string machineName, string source);
    parameters:
    - id: logName
      type: System.String
      description: "指定的電腦上的記錄檔名稱"
    - id: machineName
      type: System.String
      description: "記錄檔所在的電腦。"
    - id: source
      type: System.String
      description: "事件記錄檔項目的來源。"
  overload: System.Diagnostics.EventLog.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "記錄檔名稱是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "記錄檔名稱無效。       -或者-電腦名稱無效。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.BeginInit
  id: BeginInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "開始初始化<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>對表單或另一個元件所使用。 初始化發生於執行階段。"
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]設計環境會使用這個方法來開始初始化用於表單或另一個元件所使用的元件。 <xref:System.Diagnostics.EventLog.EndInit%2A>方法結束初始化。</xref:System.Diagnostics.EventLog.EndInit%2A> 使用 BeginInit 和<xref:System.Diagnostics.EventLog.EndInit%2A>方法會防止控制項完全初始化之前使用。</xref:System.Diagnostics.EventLog.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.BeginInit*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>已初始化。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Clear
  id: Clear
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "從事件記錄檔中移除所有項目。"
  remarks: "事件記錄檔會以判斷它們可以包含的項目數量的大小上限設定。 事件記錄檔已滿時，它會停止記錄新事件的資訊，或開始覆寫先前項目。 如果事件錄製隨即停止，您可以使用這個方法來清除現有的項目記錄，讓它再次啟動錄製事件。 您必須擁有清除事件記錄檔項目記錄檔所在電腦的系統管理員權限。       清除關閉事件記錄檔，釋出事件控制代碼，擷取新的讀取和寫入控制代碼，並重新開啟事件記錄檔。 在方法呼叫之後收到的事件不會清除和現有的事件。"
  example:
  - "The following example clears an event log.  \n  \n> [!CAUTION]\n>  Because Application, System, Security, and other non-custom logs can contain crucial information; be sure to specify a custom log before executing this example code. This example deletes the custom log `myNewLog`.  \n  \n [!code-cs[Classic EventLog.Clear Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_11_1.cs)]\n [!code-vb[Classic EventLog.Clear Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_11_1.vb)]\n [!code-cpp[Classic EventLog.Clear Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_11_1.cpp)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Diagnostics.EventLog.Clear*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "未成功清除事件記錄檔。       -或者-無法開啟記錄檔。 無法使用 Windows 錯誤程式碼。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "如未指定值<xref:System.Diagnostics.EventLog.Log*>屬性。</xref:System.Diagnostics.EventLog.Log*> 請確定記錄檔名稱不是空字串。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "記錄檔不存在。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Close
  id: Close
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "關閉事件記錄檔並釋放讀取和寫入控制代碼。"
  remarks: "Close 方法會呼叫受保護的<xref:System.ComponentModel.Component.Dispose%2A>方法。</xref:System.ComponentModel.Component.Dispose%2A> 您不需要在之前呼叫<xref:System.ComponentModel.Component.Dispose%2A>.</xref:System.ComponentModel.Component.Dispose%2A>叫用關閉"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Diagnostics.EventLog.Close*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "未成功釋放事件記錄檔讀取的控制代碼或寫入控制代碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  id: CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "建立有效的事件來源的撰寫當地語系化的事件訊息，使用指定的組態屬性的事件來源和對應的事件記錄檔。"
  remarks: "Use this overload to configure a new source for writing entries to an event log on the local computer or a remote computer. It is not necessary to use this method to read from an event log.  \n  \n The CreateEventSource method uses the input `sourceData`<xref:System.Diagnostics.EventSourceCreationData.Source%2A>, <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> and <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> properties to create registry values on the target computer for the new source and its associated event log. A new source name cannot match an existing source name or an existing event log name on the target computer. If the <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> property is not set, the source is registered for the Application event log. If the <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A> is not set, the source is registered on the local computer.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  Starting with Windows Vista, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n Each source can only write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n You can register the event source with localized resource file(s) for your event category and message strings. Your application can write event log entries using resource identifiers, rather than specifying the actual string. The Event Viewer uses the resource identifier to find and display the corresponding string from the localized resource file based on current language settings. You can register a separate file for event categories, messages and parameter insertion strings, or you can register the same resource file for all three types of strings. Use the <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>, <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>, <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>, and <xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> properties to configure the source to write localized entries to the event log. If your application writes strings values directly to the event log, you do not need to set these properties.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source is configured for an event log, and you reconfigure it for another event log, you must restart the computer for the changes to take effect."
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/4fd418fb-73e7-42a9-9ba2-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/4fd418fb-73e7-42a9-9ba2-_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/4fd418fb-73e7-42a9-9ba2-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);
    parameters:
    - id: sourceData
      type: System.Diagnostics.EventSourceCreationData
      description: "事件來源和目標事件記錄檔的組態屬性。"
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The computer name specified in <code>sourceData</code> is not valid.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid. Event log names must consist of printable characters and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n The log name specified in <code>sourceData</code> is not valid for user log creation. The Event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of the log name specified in <code>sourceData</code> are not unique.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> is already registered.  \n  \n \\- or -  \n  \n The source name specified in <code>sourceData</code> matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>sourceData</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  id: CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "建立指定的來源名稱做為有效的事件來源的項目寫入本機電腦上的記錄檔。 這個方法也可以在本機電腦上建立新的自訂記錄檔。"
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the local computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the local computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. Starting with Windows Vista, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log on the local computer. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A> when reading from a log, the local computer (\".\") is assumed.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_15_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_15_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_15_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName);
    parameters:
    - id: source
      type: System.String
      description: "來源名稱，藉以在本機電腦註冊應用程式。"
    - id: logName
      type: System.String
      description: "來源項目會寫入記錄檔的名稱。 可能的值包括應用程式、 系統或自訂的事件記錄檔。"
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the local computer.  \n  \n \\- or -  \n  \n The source name matches an existing event log name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法在本機電腦上開啟事件記錄檔的登錄機碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  id: CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "建立指定的來源名稱做為有效的事件來源的項目寫入指定的電腦上的記錄檔。 這個方法也可用來指定電腦上建立新的自訂記錄檔。"
  remarks: "Use this overload to create a custom log or to create and register a <xref:System.Diagnostics.EventLog.Source%2A> to an existing log on the specified computer.  \n  \n If `logName` is `null` or an empty string (\"\") when you call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, the log defaults to the Application log. If the log does not exist on the specified computer, the system creates a custom log and registers your application as a <xref:System.Diagnostics.EventLog.Source%2A> for that log.  \n  \n You only need to create an event source if you are writing to the event log. Before writing an entry to an event log, you must register the event source with the event log as a valid source of events. When you write a log entry, the system uses the <xref:System.Diagnostics.EventLog.Source%2A> to find the appropriate log in which to place your entry. If you are reading the event log, you can either specify the <xref:System.Diagnostics.EventLog.Source%2A>, or a <xref:System.Diagnostics.EventLog.Log%2A> and <xref:System.Diagnostics.EventLog.MachineName%2A>.  \n  \n> [!NOTE]\n>  To create an event source in Windows Vista and later or Windows Server 2003, you must have administrative privileges.  \n>   \n>  The reason for this requirement is that all event logs, including security, must be searched to determine whether the event source is unique. In Windows Vista and later, users do not have permission to access the security log; therefore, a <xref:System.Security.SecurityException> is thrown.  \n>   \n>  In Windows Vista and later, User Account Control (UAC) determines the privileges of a user. If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token. By default, you are in the standard user role. To execute the code that accesses the security log, you must first elevate your privileges from standard user to administrator. You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.  \n  \n Use <xref:System.Diagnostics.EventLog.WriteEvent%2A> and <xref:System.Diagnostics.EventLog.WriteEntry%2A> to write events to an event log. You must specify an event source to write events; you must create and configure the event source before writing the first entry with the source.  \n  \n Create the new event source during the installation of your application. This allows time for the operating system to refresh its list of registered event sources and their configuration. If the operating system has not refreshed its list of event sources, and you attempt to write an event with the new source, the write operation will fail. You can configure a new source using an <xref:System.Diagnostics.EventLogInstaller>, or using the <xref:System.Diagnostics.EventLog.CreateEventSource%2A> method. You must have administrative rights on the computer to create a new event source.  \n  \n You can create an event source for an existing event log or a new event log. When you create a new source for a new event log, the system registers the source for that log, but the log is not created until the first entry is written to it.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the <xref:System.Diagnostics.EventLog.Log%2A> property with the \".evt\" file name extension.  \n  \n The source must be unique on the local computer; a new source name cannot match an existing source name or an existing event log name. Each source can write to only one event log at a time; however, your application can use multiple sources to write to multiple event logs. For example, your application might require multiple sources configured for different event logs or different resource files.  \n  \n The source must be configured either for writing localized entries or for writing direct strings. If your application writes entries using both resource identifiers and string values, you must register two separate sources. For example, configure one source with resource files, and then use that source in the <xref:System.Diagnostics.EventLog.WriteEvent%2A> method to write entries using resource identifiers to the event log. Then create a different source without resource files, and use that source in the <xref:System.Diagnostics.EventLog.WriteEntry%2A> method to write strings directly to the event log using that source.  \n  \n To change the configuration details of an existing source, you must delete the source and then create it with the new configuration. If other applications or components use the existing source, create a new source with the updated configuration rather than deleting the existing source.  \n  \n> [!NOTE]\n>  If a source has already been mapped to a log and you remap it to a new log, you must restart the computer for the changes to take effect."
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/86732307-05e6-4c1a-b98e-_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/86732307-05e6-4c1a-b98e-_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/86732307-05e6-4c1a-b98e-_1.vb)]"
  syntax:
    content: public static void CreateEventSource (string source, string logName, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "依據指定的電腦註冊應用程式的來源。"
    - id: logName
      type: System.String
      description: "來源項目會寫入記錄檔的名稱。 可能的值包括應用程式、 系統或自訂的事件記錄檔。 如果您未指定值，`logName`應用程式的預設值。"
    - id: machineName
      type: System.String
      description: "若要註冊，這個事件來源電腦的名稱或 」。 「 本機電腦。"
  overload: System.Diagnostics.EventLog.CreateEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> is not a valid computer name.  \n  \n \\- or -  \n  \n <code>source</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>logName</code> is not a valid event log name. Event log names must consist of printable characters, and cannot include the characters '*', '?', or '\\\\'.  \n  \n \\- or -  \n  \n <code>logName</code> is not valid for user log creation. The event log names AppEvent, SysEvent, and SecEvent are reserved for system use.  \n  \n \\- or -  \n  \n The log name matches an existing event source name.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters.  \n  \n \\- or -  \n  \n The first 8 characters of <code>logName</code> match the first 8 characters of an existing event log name on the specified computer.  \n  \n \\- or -  \n  \n The source cannot be registered because it already exists on the specified computer.  \n  \n \\- or -  \n  \n The source name matches an existing event source name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法在指定的電腦上開啟事件記錄檔的登錄機碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String)
  id: Delete(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "從本機電腦中移除事件記錄檔。"
  remarks: "在本機電腦上您想要刪除的記錄檔時，請使用這個方法。 您可以刪除任何記錄檔的電腦上，提供您有適當的登錄權限。       Delete 會移除所指定的記錄檔`logName`從本機電腦。 如果您想要刪除僅註冊記錄檔的來源，呼叫<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 如果您只想要刪除的記錄項目，呼叫<xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> 刪除和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，因此您可以使用在本身的類別呼叫。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 不需要建立的新執行個體<xref:System.Diagnostics.EventLog>呼叫這些方法。</xref:System.Diagnostics.EventLog>       Delete 方法會先刪除保留的記錄檔內容的檔案。 接著會存取登錄，並移除已註冊為該記錄檔的所有事件來源。 如果您重新建立在稍後針對某個點的記錄，您應該註冊的事件來源同樣地，如果它們是可重複使用。 如果您不會登錄事件來源，而且其他使用者撰寫，事件來源，而不指定記錄檔名稱，將應用程式事件記錄檔中建立事件來源。 因此，應用程式，先前能夠寫入您刪除並重新建立記錄檔中的項目會寫入應用程式記錄檔相反地，因為它現在包含事件來源。      > [!NOTE] > 重新建立事件記錄檔可以很困難。 避免刪除任何系統建立的事件記錄檔，例如應用程式記錄檔。       刪除記錄，以透過呼叫 Delete 會自動刪除該記錄檔登錄來源。 這可讓其他應用程式使用該記錄檔無法作業。"
  example:
  - "The following example deletes a log from the local computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_12_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_12_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public static void Delete (string logName);
    parameters:
    - id: logName
      type: System.String
      description: '要刪除的記錄檔名稱。 可能的值包括︰ 應用程式、 安全性、 系統和任何自訂的事件記錄檔的電腦上。'
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code>為空字串 (&quot;&quot;) 或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the local computer.  \n  \n \\- or -  \n  \n The log does not exist on the local computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "未成功清除事件記錄檔。       -或者-無法開啟記錄檔。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  id: Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "從指定的電腦中移除事件記錄檔。"
  remarks: "在遠端電腦上您想要刪除的記錄檔時，請使用這個方法。 您可以刪除任何記錄檔的電腦上，提供您有適當的登錄權限。       <xref:System.Diagnostics.EventLog.Delete%2A>移除所指定的記錄檔`logName`所指定的電腦從`machineName`。</xref:System.Diagnostics.EventLog.Delete%2A> 如果您想要刪除僅註冊記錄檔的來源，呼叫<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>.</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 如果您只想要刪除的記錄項目，呼叫<xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，因此您可以使用在本身的類別呼叫。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Delete%2A> 不需要建立的執行個體<xref:System.Diagnostics.EventLog>呼叫這些方法。</xref:System.Diagnostics.EventLog>       這個方法會先刪除保留的記錄檔內容的檔案。 接著會存取登錄，並移除已註冊為該記錄檔的所有事件來源。 如果您重新建立在稍後針對某個點的記錄，您應該註冊的事件來源同樣地，如果它們是可重複使用。 如果您不會登錄事件來源，而且其他使用者撰寫，事件來源，而不指定記錄檔名稱，將應用程式事件記錄檔中建立事件來源。 因此，應用程式，先前能夠寫入您刪除並重新建立記錄檔中的項目會寫入應用程式記錄檔相反地，因為它現在包含事件來源。      > [!NOTE] > 重新建立事件記錄檔可以很困難。 避免刪除任何系統建立的事件記錄檔，例如應用程式記錄檔。       刪除記錄檔，透過呼叫<xref:System.Diagnostics.EventLog.Delete%2A>會自動刪除該記錄檔登錄來源</xref:System.Diagnostics.EventLog.Delete%2A> 這可讓其他應用程式使用該記錄檔無法作業。"
  example:
  - "The following example deletes a log from the specified computer. The example determines the log from its source.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_17_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_17_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public static void Delete (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: '要刪除的記錄檔名稱。 可能的值包括︰ 應用程式、 安全性、 系統和指定的電腦上的任何自訂事件記錄檔。'
    - id: machineName
      type: System.String
      description: "若要刪除的記錄檔，從電腦的名稱或 」。 「 本機電腦。"
  overload: System.Diagnostics.EventLog.Delete*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logName</code> is an empty string (\"\") or <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>machineName</code> is not a valid computer name."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The registry key for the event log could not be opened on the specified computer.  \n  \n \\- or -  \n  \n The log does not exist on the specified computer."
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "未成功清除事件記錄檔。       -或者-無法開啟記錄檔。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  id: DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "移除事件來源登錄從本機電腦的事件記錄檔。"
  remarks: "使用這個方法來移除註冊<xref:System.Diagnostics.EventLog.Source%2A>從本機電腦。</xref:System.Diagnostics.EventLog.Source%2A> DeleteEventSource 存取本機電腦上的登錄，並移除您的應用程式做為有效的事件來源註冊。       如果您不再需要寫入該記錄檔項目，您可以為有效的事件來源移除您的元件。 例如，您可能會執行這如果您需要變更您的元件和一個記錄檔。 一次只有一個記錄檔登錄來源，因為變更記錄檔需要您移除目前的登錄。       DeleteEventSource 移除僅註冊記錄檔的來源。 如果您想要移除記錄檔本身，呼叫<xref:System.Diagnostics.EventLog.Delete%2A>.</xref:System.Diagnostics.EventLog.Delete%2A> 如果您只想要刪除的記錄項目，呼叫<xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>而且 DeleteEventSource`static`方法，因此您可以使用在本身的類別呼叫。</xref:System.Diagnostics.EventLog.Delete%2A> 不需要建立的執行個體<xref:System.Diagnostics.EventLog>呼叫這些方法。</xref:System.Diagnostics.EventLog>       刪除記錄檔，透過呼叫<xref:System.Diagnostics.EventLog.Delete%2A>會自動刪除該記錄檔登錄來源</xref:System.Diagnostics.EventLog.Delete%2A> 這可讓其他應用程式使用該記錄檔無法作業。      > [!NOTE] > 如果來源已經對應到記錄檔，而且對應至新的記錄檔，您必須重新啟動電腦，變更才會生效。"
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_8_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_8_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_8_1.cs)]"
  syntax:
    content: public static void DeleteEventSource (string source);
    parameters:
    - id: source
      type: System.String
      description: "依據事件記錄檔系統中註冊應用程式名稱。"
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> parameter does not exist in the registry of the local computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  id: DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "應用程式的事件來源登錄從指定的電腦中移除。"
  remarks: "若要移除註冊使用此多載<xref:System.Diagnostics.EventLog.Source%2A>從遠端電腦。</xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>存取所指定的電腦上的登錄`machineName`，並移除您的應用程式做為有效的事件來源註冊。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A>       如果您不再需要寫入該記錄檔項目，您可以為有效的事件來源移除您的元件。 例如，您可能會執行這如果您需要變更您的元件和一個記錄檔。 一次只有一個記錄檔登錄來源，因為變更記錄檔需要您移除目前的登錄。       <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>移除只登錄到記錄檔的來源。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 如果您想要移除記錄檔本身，呼叫<xref:System.Diagnostics.EventLog.Delete%2A>.</xref:System.Diagnostics.EventLog.Delete%2A> 如果您只想要刪除的記錄項目，呼叫<xref:System.Diagnostics.EventLog.Clear%2A>.</xref:System.Diagnostics.EventLog.Clear%2A> <xref:System.Diagnostics.EventLog.Delete%2A>和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>是`static`方法，因此您可以使用在本身的類別呼叫。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A></xref:System.Diagnostics.EventLog.Delete%2A> 不需要建立的執行個體<xref:System.Diagnostics.EventLog>呼叫這些方法。</xref:System.Diagnostics.EventLog>       刪除記錄檔，透過呼叫<xref:System.Diagnostics.EventLog.Delete%2A>會自動刪除該記錄檔登錄來源</xref:System.Diagnostics.EventLog.Delete%2A> 這可讓其他應用程式使用該記錄檔無法作業。      > [!NOTE] > 如果來源已經對應到記錄檔，而且對應至新的記錄檔，您必須重新啟動電腦，變更才會生效。"
  example:
  - "The following example deletes a source from the specified computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cs[Classic EventLog.Delete1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_6_1.cs)]\n [!code-cpp[Classic EventLog.Delete1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_6_1.cpp)]\n [!code-vb[Classic EventLog.Delete1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_6_1.vb)]"
  syntax:
    content: public static void DeleteEventSource (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "依據事件記錄檔系統中註冊應用程式名稱。"
    - id: machineName
      type: System.String
      description: "若要移除登錄，電腦名稱或 」。 「 本機電腦。"
  overload: System.Diagnostics.EventLog.DeleteEventSource*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>machineName</code> parameter is invalid.  \n  \n \\- or -  \n  \n The <code>source</code> parameter does not exist in the registry of the specified computer.  \n  \n \\- or -  \n  \n You do not have write access on the registry key for the event log."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>source</code>無法刪除，因為在登錄中的父登錄機碼<code>source</code>不包含具有相同名稱的子機碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "所使用的 unmanaged 的資源釋出<xref href=&quot;System.Diagnostics.EventLog&quot;> </xref>，並選擇性釋放 managed 的資源。"
  remarks: "這個方法會呼叫公用`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。</xref:System.Object.Finalize%2A> `Dispose()`叫用受保護`Dispose(Boolean)`方法`disposing`參數設定為`true`。 <xref:System.Object.Finalize%2A>叫用`Dispose`與`disposing`設`false`。</xref:System.Object.Finalize%2A>       當`disposing`參數為 true，這個方法的任何 managed 物件所持有的資源全部釋出這個<xref:System.Diagnostics.EventLog>參考。</xref:System.Diagnostics.EventLog> 這個方法會叫用`Dispose()`每個參考物件的方法。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示釋放 managed 和 unmanaged 資源，<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示只釋放 unmanaged 的資源。"
  overload: System.Diagnostics.EventLog.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得或設定值，指出是否<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>接收<xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;></xref>事件通知。"
  remarks: "EnableRaisingEvents 屬性會決定是否<xref:System.Diagnostics.EventLog>會寫入記錄檔的項目時引發事件</xref:System.Diagnostics.EventLog> 若屬性是`true`，接收的元件<xref:System.Diagnostics.EventLog.EntryWritten>事件將會收到通知隨時將項目會寫入記錄檔中指定<xref:System.Diagnostics.EventLog.Log%2A>屬性。</xref:System.Diagnostics.EventLog.Log%2A> </xref:System.Diagnostics.EventLog.EntryWritten> 如果是 EnableRaisingEvents `false`，不會引發事件。      > [!NOTE] > 項目寫入本機電腦上時，才，可以接收事件通知。 您無法接收通知的遠端電腦上寫入的項目。"
  example:
  - "The following example handles an <xref:System.Diagnostics.EventLog.EntryWritten> event.  \n  \n [!code-cs[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_32_1.cs)]\n [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_32_1.vb)]\n [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_32_1.cpp)]"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>時項目寫入記錄檔，否則會收到通知<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.EventLog.EnableRaisingEvents*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "事件記錄檔是遠端電腦上。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EndInit
  id: EndInit
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "初始化結束<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>用於表單或另一個元件所使用。 初始化發生於執行階段。"
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]設計環境會使用這個方法來結束初始化用於表單或另一個元件所使用的元件。 <xref:System.Diagnostics.EventLog.BeginInit%2A>方法會啟動初始化。</xref:System.Diagnostics.EventLog.BeginInit%2A> 使用<xref:System.Diagnostics.EventLog.BeginInit%2A>和 EndInit 方法可防止控制項完全初始化之前使用。</xref:System.Diagnostics.EventLog.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Diagnostics.EventLog.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Entries
  id: Entries
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得事件記錄檔的內容。"
  remarks: "讀取事件記錄檔時，請使用項目成員。       因為屬性是唯讀，則您無法修改項目，或使用寫入記錄檔項目。 請改為指定<xref:System.Diagnostics.EventLog.Source%2A>呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>寫入新的記錄檔項目。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.Source%2A> 您可以使用來計算事件記錄檔中的項目數的項目，並檢視每個<xref:System.Diagnostics.EventLogEntry>集合中。</xref:System.Diagnostics.EventLogEntry> 使用索引<xref:System.Diagnostics.EventLogEntryCollection.Item%2A>成員，才能擷取資訊的特定項目，例如<xref:System.Diagnostics.EventLogEntry.Message%2A>， <xref:System.Diagnostics.EventLogEntry.Category%2A>， <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>，或<xref:System.Diagnostics.EventLogEntry.EntryType%2A>.</xref:System.Diagnostics.EventLogEntry.EntryType%2A> </xref:System.Diagnostics.EventLogEntry.TimeWritten%2A> </xref:System.Diagnostics.EventLogEntry.Category%2A> </xref:System.Diagnostics.EventLogEntry.Message%2A> </xref:System.Diagnostics.EventLogEntryCollection.Item%2A>       不需要指定<xref:System.Diagnostics.EventLog.Source%2A>時只會讀取記錄檔。</xref:System.Diagnostics.EventLog.Source%2A> 您可以只指定<xref:System.Diagnostics.EventLog.Log%2A>名稱和<xref:System.Diagnostics.EventLog.MachineName%2A>（伺服器電腦名稱） 的屬性<xref:System.Diagnostics.EventLog>執行個體。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 在任一情況下，系統會自動填入 項目成員的項目事件記錄檔的清單。 您可以讀取個別項目這份清單中選取適當的項目索引。       讀取和寫入記錄項目之間的一個重大差異是不需要明確地呼叫讀取的方法。 之後<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>指定，會自動填入的項目屬性。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A> 如果您變更的值<xref:System.Diagnostics.EventLog.Log%2A>或<xref:System.Diagnostics.EventLog.MachineName%2A>屬性，屬性重新讀取。 請在下一次擴展之後的項目</xref:System.Diagnostics.EventLog.MachineName%2A></xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > 您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>您要連接到記錄檔。</xref:System.Diagnostics.EventLog.MachineName%2A> 如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦中，&quot;。&quot;，會假設。</xref:System.Diagnostics.EventLog.MachineName%2A>"
  example:
  - "The following example reads entries in the event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.Entries Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_23_1.cs)]\n [!code-cpp[Classic EventLog.Entries Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_23_1.cpp)]\n [!code-vb[Classic EventLog.Entries Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_23_1.vb)]"
  syntax:
    content: public System.Diagnostics.EventLogEntryCollection Entries { get; }
    return:
      type: System.Diagnostics.EventLogEntryCollection
      description: "<xref href=&quot;System.Diagnostics.EventLogEntryCollection&quot;> </xref>項目保存事件記錄檔中。 每個項目是相關聯的執行個體<xref href=&quot;System.Diagnostics.EventLogEntry&quot;></xref>類別。"
  overload: System.Diagnostics.EventLog.Entries*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.EntryWritten
  id: EntryWritten
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
  type: Event
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "發生於項目寫入事件記錄檔在本機電腦上。"
  remarks: "若要取得事件通知，您必須設定<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>至`true`。</xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> 項目寫入本機電腦上時，您只可以接收事件通知。 您無法接收通知的遠端電腦上寫入的項目。       當您建立的 EntryWritten 委派時，您可以識別即將處理此事件的方法。 若要將事件與您的事件處理常式產生關聯，將委派的執行個體加入此事件。 每當事件發生時，直到您移除委派，會呼叫事件處理常式。 如需處理事件的委派的詳細資訊，請參閱[事件](~/add/includes/ajax-current-ext-md.md)。       系統會回應至<xref:System.Diagnostics.EventLog.WriteEntry%2A>才發生至少六秒之前的最後一個寫入事件。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 這表示您只會接收一個六秒間隔內的 EntryWritten 事件通知，即使一個以上的事件記錄檔變更，就會發生。 如果您插入夠長的睡眠狀態 （約 10 秒） 之間間隔呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>，您不太可能會遺失事件。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 不過，如果寫入事件經常發生，您可能不會收到事件通知，直到下一個間隔。 一般而言，遺失的事件通知不會遺失，但延遲。"
  example:
  - "The following example handles an entry written event.  \n  \n [!code-cs[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/csharp/e-system.diagnostics.eve_1.cs)]\n [!code-cpp[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/cpp/e-system.diagnostics.eve_1.cpp)]\n [!code-vb[Classic EventLog.EntryWritten Example#1](~/add/codesnippet/visualbasic/e-system.diagnostics.eve_1.vb)]"
  syntax:
    content: public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;
    return:
      type: System.Diagnostics.EntryWrittenEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String)
  id: Exists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "決定記錄檔是否存在於本機電腦上。"
  remarks: "若要判斷本機電腦上是否有記錄檔中使用這個方法。 如果您想要判斷來源是否存在於本機電腦上，，使用<xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A>       這個方法會存取登錄，因此您必須為本機電腦上擁有適當的登錄權限否則，查詢會傳回`false`。       因為您無法在相同電腦上讓新的記錄檔的現有記錄檔名稱，建立新的記錄檔之前先使用此方法來判斷是否指定`logName`已存在於本機電腦上。 `logName`參數不區分大小寫。       存在是`static`方法，所以它可以呼叫此類別本身。 不需要建立的執行個體<xref:System.Diagnostics.EventLog>呼叫 Exists。</xref:System.Diagnostics.EventLog>"
  example:
  - >-
    [!code-cpp[EventLog_Exists_1#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_4_1.cpp)]
     [!code-vb[EventLog_Exists_1#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_4_1.vb)]
     [!code-cs[EventLog_Exists_1#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_4_1.cs)]
  syntax:
    content: public static bool Exists (string logName);
    parameters:
    - id: logName
      type: System.String
      description: '要搜尋的記錄檔名稱。 可能的值包括︰ 應用程式、 安全性、 系統、 其他應用程式特定的記錄檔 （例如 Active Directory 相關聯） 或在電腦上的任何自訂記錄檔。'
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果記錄檔是否位於本機電腦。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "LogName 是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>或值是空的。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  id: Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "判斷記錄檔是否存在指定的電腦上。"
  remarks: "若要判斷遠端電腦上是否有記錄檔中使用這個方法。 如果您想要判斷來源是否存在於遠端電腦上，，使用<xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A>       這個方法會存取登錄，因此您必須為指定電腦上擁有適當的登錄權限否則，查詢會傳回`false`。       因為您無法在相同電腦上讓新的記錄檔的現有記錄檔名稱，建立新的記錄檔之前使用這個方法來判斷是否有一個具有指定`logName`已存在於所指定的伺服器上`machineName`參數。 `logName`和`machineName`參數不區分大小寫。       <xref:System.Diagnostics.EventLog.Exists%2A>是`static`方法，所以它可以呼叫此類別本身。</xref:System.Diagnostics.EventLog.Exists%2A> 不需要建立新的執行個體的<xref:System.Diagnostics.EventLog>呼叫<xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A> </xref:System.Diagnostics.EventLog>"
  syntax:
    content: public static bool Exists (string logName, string machineName);
    parameters:
    - id: logName
      type: System.String
      description: '要搜尋記錄檔。 可能的值包括︰ 應用程式、 安全性、 系統、 其他應用程式特定的記錄檔 （例如 Active Directory 相關聯） 或在電腦上的任何自訂記錄檔。'
    - id: machineName
      type: System.String
      description: "在其上搜尋記錄檔中，電腦名稱或 」。 「 本機電腦。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果記錄檔存在指定的電腦否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.EventLog.Exists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code>參數是無效的格式。 請確定您已使用正確的語法，您要搜尋之電腦。       -或- <code> logName </code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>或值是空的。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs
  id: GetEventLogs
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "搜尋本機電腦上的所有事件記錄檔，並建立的陣列<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>包含清單的物件。"
  remarks: "陣列<xref:System.Diagnostics.EventLog>物件時，才能在本機電腦上的所有事件記錄檔的快照集呼叫 GetEventLogs。</xref:System.Diagnostics.EventLog> 這不是動態的集合，所以不會反映的刪除或建立的即時記錄檔。 您應該確認陣列中的記錄存在才能讀取或寫入其中。 陣列通常包括至少三個記錄檔︰ 應用程式、 系統及安全性。 如果您在本機電腦上建立的自訂記錄檔，它們會出現在陣列中。       若要擷取的事件記錄檔清單，您必須使用適當的登錄權限。 這些權限是相同的呼叫<xref:System.Diagnostics.EventLog.Exists%2A>和<xref:System.Diagnostics.EventLog.SourceExists%2A>。</xref:System.Diagnostics.EventLog.SourceExists%2A></xref:System.Diagnostics.EventLog.Exists%2A>所需"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_10_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/m-system.diagnostics.eve_10_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/m-system.diagnostics.eve_10_1.cs)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs ();
    parameters: []
    return:
      type: System.Diagnostics.EventLog[]
      description: "類型的陣列<xref href=&quot;System.Diagnostics.EventLog&quot;> </xref> ，代表本機電腦上的記錄檔。"
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "登錄沒有讀取權限。       -或者-在電腦上沒有事件記錄檔服務。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  id: GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "搜尋指定的電腦上的所有事件記錄檔，並建立的陣列<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>包含清單的物件。"
  remarks: "陣列<xref:System.Diagnostics.EventLog>物件是所指定的電腦上的所有事件記錄檔的快照集`machineName`參數時呼叫<xref:System.Diagnostics.EventLog.GetEventLogs%2A>進行。</xref:System.Diagnostics.EventLog.GetEventLogs%2A> </xref:System.Diagnostics.EventLog> 這不是動態的集合，所以不會反映的刪除或建立的即時記錄檔。 您應該確認陣列中的記錄存在才能讀取或寫入其中。 陣列通常包括至少三個記錄檔︰ 應用程式、 系統及安全性。 如果您指定的電腦上建立的自訂記錄檔，它們會出現在陣列中。       <xref:System.Diagnostics.EventLog.GetEventLogs%2A>是`static`方法，所以它可以呼叫<xref:System.Diagnostics.EventLog>類別本身。</xref:System.Diagnostics.EventLog></xref:System.Diagnostics.EventLog.GetEventLogs%2A> 不需要建立的執行個體<xref:System.Diagnostics.EventLog>物件，讓方法的呼叫。</xref:System.Diagnostics.EventLog>       若要擷取的事件記錄檔清單，您必須使用適當的登錄權限。 這些權限是相同的呼叫<xref:System.Diagnostics.EventLog.Exists%2A>和<xref:System.Diagnostics.EventLog.SourceExists%2A>。</xref:System.Diagnostics.EventLog.SourceExists%2A></xref:System.Diagnostics.EventLog.Exists%2A>所需"
  example:
  - "The following example gets a list of logs on the computer \"myServer\". It then outputs the name of each log.  \n  \n [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_18_1.cpp)]\n [!code-cs[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_18_1.vb)]"
  syntax:
    content: public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);
    parameters:
    - id: machineName
      type: System.String
      description: "要搜尋事件記錄檔的電腦。"
    return:
      type: System.Diagnostics.EventLog[]
      description: "類型的陣列<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>表示指定的電腦上的記錄檔。"
  overload: System.Diagnostics.EventLog.GetEventLogs*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> machineName </code>參數是無效的電腦名稱。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "登錄沒有讀取權限。       -或者-在電腦上沒有事件記錄檔服務。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Log
  id: Log
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得或設定要讀取或寫入記錄檔的名稱。"
  remarks: "Three log files exist by default on the server: Application, System, and Security. Applications and services use the Application log file. Device drivers use the System log file. The system generates success and failure audit events in the Security log when auditing is turned on. If you have other applications installed, like Active Directory on Windows servers, there might be other default log files. In addition, you can create custom log files on a local or remote computer. Custom logs help organize your entries in a more detailed way than is allowed when your components write events to the default Application log.  \n  \n> [!NOTE]\n>  Log names are limited to eight characters. According to the system, MyLogSample1 and MyLogSample2 are the same log.  \n  \n If you write to an event log, it is not enough to specify the Log property. You must associate a <xref:System.Diagnostics.EventLog.Source%2A> property with your event log resource to connect it to a particular log. It is not necessary to specify a <xref:System.Diagnostics.EventLog.Source%2A> when only reading from a log, but an event source must be associated with the event log resource in the server's registry. You can specify only the Log name and <xref:System.Diagnostics.EventLog.MachineName%2A> (server computer name) to read from it.  \n  \n> [!NOTE]\n>  You are not required to specify the <xref:System.Diagnostics.EventLog.MachineName%2A> if you are connecting to a log. If you do not specify the <xref:System.Diagnostics.EventLog.MachineName%2A>, the local computer (\".\") is assumed.  \n  \n If the <xref:System.Diagnostics.EventLog.Source%2A> property has not been specified, a call to Log returns an empty string if Log has not been explicitly set (by setting the Log property, or through the constructor). If the <xref:System.Diagnostics.EventLog.Source%2A> has been specified, Log returns the name of the log to which that source was registered.  \n  \n A source can only be registered to one log at a time. If the <xref:System.Diagnostics.EventLog.Source%2A> property was set for an instance of <xref:System.Diagnostics.EventLog>, you cannot change the Log property for that <xref:System.Diagnostics.EventLog> without changing the value of <xref:System.Diagnostics.EventLog.Source%2A> or calling <xref:System.Diagnostics.EventLog.DeleteEventSource%2A> first. If you change the Log property after the <xref:System.Diagnostics.EventLog.Source%2A> property has been set, writing a log entry throws an exception.  \n  \n The operating system stores event logs as files. When you use <xref:System.Diagnostics.EventLogInstaller> or <xref:System.Diagnostics.EventLog.CreateEventSource%2A> to create a new event log, the associated file is stored in the %SystemRoot%\\System32\\Config directory on the specified computer. The file name is set by appending the first 8 characters of the Log property with the \".evt\" file name extension.  \n  \n You cannot create a new log using the Log property alone (without specifying a source for the log). You can call <xref:System.Diagnostics.EventLog.CreateEventSource%2A>, passing in a new log name as a parameter, and then call <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>. However, the intent is usually either to create (and write entries to) new application-specific logs, or to read from existing logs.  \n  \n If the Log value changes, the event log is closed and all event handles are released.  \n  \n> [!CAUTION]\n>  If you set the Log property to the name of a log that does not exist, the system attaches the <xref:System.Diagnostics.EventLog> to the Application log, but does not warn you that it is using a log other than the one you specified."
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.Log Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_17_1.cpp)]\n [!code-cs[Classic EventLog.Log Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_17_1.cs)]\n [!code-vb[Classic EventLog.Log Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_17_1.vb)]"
  syntax:
    content: public string Log { get; set; }
    return:
      type: System.String
      description: "記錄檔的名稱。 這可以是應用程式、 系統、 安全性或自訂的記錄檔名稱。 預設為空字串 (&quot;&quot;)。"
  overload: System.Diagnostics.EventLog.Log*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogDisplayName
  id: LogDisplayName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得事件記錄檔的易記名稱。"
  remarks: "> [!NOTE]> 在 Windows Vista 和更新版本，使用者沒有存取安全性記錄檔的權限。 如果您執行 Windows Vista 或更新版本的使用者身分，您會取得<xref:System.Security.SecurityException>當您嘗試存取安全性記錄檔中事件的顯示名稱</xref:System.Security.SecurityException>   >> 在 Windows Vista 和更新版本，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建的 Administrators 群組的成員，您就會指派兩個執行階段存取語彙基元︰ 標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼存取安全性記錄檔，您必須先將您的權限從標準使用者提高為系統管理員。 當您啟動應用程式的應用程式圖示上按一下滑鼠右鍵，並指出您想要以系統管理員身分執行時，您可以這樣做。"
  example:
  - "The following example enumerates the event logs defined on the local computer and displays the LogDisplayName for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_29_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_29_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_29_1.cs)]"
  syntax:
    content: public string LogDisplayName { get; }
    return:
      type: System.String
      description: "代表系統的事件檢視器中的事件記錄檔的名稱。"
  overload: System.Diagnostics.EventLog.LogDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定<xref:System.Diagnostics.EventLog.Log*>不存在於此電腦的登錄。</xref:System.Diagnostics.EventLog.Log*>"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  id: LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得指定的來源註冊記錄檔的名稱。"
  remarks: "事件來源會指出項目會記錄事件。 它通常是應用程式的名稱或名稱的子元件的應用程式，如果應用程式很大。 應用程式和服務應該寫入應用程式記錄檔或自訂的記錄檔。 裝置驅動程式應該寫入至系統記錄檔。       當您建立新的來源，可以只撰寫一個記錄檔一次，則系統會登錄事件記錄檔與您的應用程式項目的有效來源。 <xref:System.Diagnostics.EventLog.Source%2A>屬性可以是任何字串，但名稱不能在電腦上的其他來源。</xref:System.Diagnostics.EventLog.Source%2A> 嘗試建立重複的<xref:System.Diagnostics.EventLog.Source%2A>值擲回例外狀況。</xref:System.Diagnostics.EventLog.Source%2A> 不過，單一的事件記錄檔可以有許多不同的來源寫入。"
  example:
  - "The following example deletes a source from the local computer. The example determines the log from its source, and then deletes the log.  \n  \n> [!NOTE]\n>  More than one source might write to an event log. Before deleting a custom log, make sure there are no other sources writing to that log.  \n  \n [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_2_1.cpp)]\n [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_2_1.vb)]\n [!code-cs[Classic EventLog.DeleteEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_2_1.cs)]"
  syntax:
    content: public static string LogNameFromSourceName (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "事件來源的名稱。"
    - id: machineName
      type: System.String
      description: "在其上搜尋，電腦名稱或 」。 「 本機電腦。"
    return:
      type: System.String
      description: "在登錄中指定的來源相關聯的記錄檔的名稱。"
  overload: System.Diagnostics.EventLog.LogNameFromSourceName*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MachineName
  id: MachineName
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得或設定用來讀取或寫入事件之電腦的名稱。"
  remarks: "如果您寫入事件記錄檔時，您必須將<xref:System.Diagnostics.EventLog.Source%2A>與您的事件記錄檔物件，來連接到特定的記錄檔。</xref:System.Diagnostics.EventLog.Source%2A> 不需要指定<xref:System.Diagnostics.EventLog.Source%2A>屬性時只會讀取記錄檔。</xref:System.Diagnostics.EventLog.Source%2A> 您可以只指定<xref:System.Diagnostics.EventLog.Log%2A>名稱和 MachineName （伺服器電腦名稱）。</xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > 您不需要指定 MachineName，如果您要連接到記錄檔。 如果您未指定 MachineName，本機電腦 (&quot;。&quot;) 會假設。       一次只有一個記錄檔登錄來源。 如果<xref:System.Diagnostics.EventLog.Source%2A>的執行個體已設定屬性<xref:System.Diagnostics.EventLog>，您無法變更的 MachineName 屬性<xref:System.Diagnostics.EventLog>而不需要變更的值<xref:System.Diagnostics.EventLog.Source%2A>或呼叫<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>第一次。</xref:System.Diagnostics.EventLog.DeleteEventSource%2A> </xref:System.Diagnostics.EventLog.Source%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A> 如果您將 MachineName 屬性中，變更<xref:System.Diagnostics.EventLog>關閉所有控制代碼，並附加記錄檔和新的電腦上的來源。</xref:System.Diagnostics.EventLog>       MachineName 值不可以是空的字串。 若未明確設定，則預設為本機電腦 (&quot;。&quot;)。"
  example:
  - "The following example reads entries in the event log, \"NewEventLog\", on a specified computer.  \n  \n [!code-cs[Classic EventLog.MachineName Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_6_1.cs)]\n [!code-vb[Classic EventLog.MachineName Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_6_1.vb)]\n [!code-cpp[Classic EventLog.MachineName Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_6_1.cpp)]"
  syntax:
    content: public string MachineName { get; set; }
    return:
      type: System.String
      description: "事件記錄檔所在的伺服器名稱。 預設值是本機電腦 (&quot;。&quot;)。"
  overload: System.Diagnostics.EventLog.MachineName*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "電腦名稱無效。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  id: MaximumKilobytes
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得或設定最大事件記錄檔大小，以 kb 為單位。"
  remarks: "MaximumKilobytes 屬性代表的事件記錄檔的大小限制。 當事件記錄檔到達大小限制，設定<xref:System.Diagnostics.EventLog.OverflowAction%2A>值決定是否會捨棄新的項目，或新的項目是否覆寫較舊的項目。</xref:System.Diagnostics.EventLog.OverflowAction%2A>      > [!NOTE] > 這個屬性表示這個執行個體所代表的事件記錄檔的組態設定。 當事件記錄檔到達大小上限時，此屬性會指定作業系統如何處理新的項目寫入事件記錄檔已註冊的所有事件來源。"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_15_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_15_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_15_1.cs)]"
  syntax:
    content: public long MaximumKilobytes { get; set; }
    return:
      type: System.Int64
      description: "最大事件記錄檔大小，以 kb 為單位。 預設值為 512，表示檔案大小上限為 512 kb。"
  overload: System.Diagnostics.EventLog.MaximumKilobytes*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "指定的值小於 64，或大於 4194240 或不 64 的偶數倍數。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  id: MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得事件記錄檔中的項目的保留天數。"
  remarks: "您可以使用的 MinimumRetentionDays 屬性來檢查事件記錄檔的目前設定。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>變更最小數目的事件記錄檔中的每個項目必須保留的天數。</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>       MinimumRetentionDays 值取決於設定的溢位行為的事件記錄檔。 如果<xref:System.Diagnostics.OverflowAction>事件記錄檔的屬性設定為<xref:System.Diagnostics.OverflowAction>，然後 MinimumRetentionDays 值為 0。</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> 如果<xref:System.Diagnostics.OverflowAction>事件記錄檔的屬性設定為<xref:System.Diagnostics.OverflowAction>，然後 MinimumRetentionDays 值為-1。</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction> 如果<xref:System.Diagnostics.OverflowAction>事件記錄檔的屬性設定為<xref:System.Diagnostics.OverflowAction>，MinimumRetentionDays 值是小於或等於零，而且代表的事件記錄檔項目的事件記錄檔已滿時保留的天數。</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.OverflowAction>       事件記錄檔達到大小限制時，才會發生溢位行為。 當<xref:System.Diagnostics.EventLog>具有其<xref:System.Diagnostics.EventLog.OverflowAction%2A>設<xref:System.Diagnostics.OverflowAction>，和事件記錄檔達到大小上限，則新的項目寫入只可以取代其時間超過 MinimumRetentionDays 期間的項目。</xref:System.Diagnostics.OverflowAction> </xref:System.Diagnostics.EventLog.OverflowAction%2A> </xref:System.Diagnostics.EventLog> 保留的最小週期的事件項目時，適當的事件記錄檔會定期封存。 否則，就可能會遺失事件記錄檔達到限制時的新項目。 若要避免遺失新的事件資訊，請設定根據特定的事件記錄檔的封存排程事件的最小保留天數。"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_12_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_12_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_12_1.cs)]"
  syntax:
    content: public int MinimumRetentionDays { get; }
    return:
      type: System.Int32
      description: "事件記錄檔中的項目所保留的天數。 預設值為 7。"
  overload: System.Diagnostics.EventLog.MinimumRetentionDays*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  id: ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "變更事件記錄檔達到檔案大小上限時寫入新的項目已設定的行為。"
  remarks: "事件記錄檔的溢位行為會指定要寫入的記錄檔已達到其最大檔案大小，新的項目時，會發生什麼事。      > [!NOTE] > 溢位行為在事件記錄檔達到檔案大小上限時，才會生效。 溢位行為不會影響新的項目寫入記錄檔可容納額外的事件記錄項目。       ModifyOverflowPolicy 方法設定事件記錄檔的溢位行為。 <xref:System.Diagnostics.EventLog>執行個體。</xref:System.Diagnostics.EventLog> 呼叫這個方法所指定的事件記錄檔後<xref:System.Diagnostics.EventLog.Log%2A>屬性，<xref:System.Diagnostics.EventLog.OverflowAction%2A>和<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>屬性值會反映新設定的溢位行為。</xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A> </xref:System.Diagnostics.EventLog.OverflowAction%2A> </xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > 這個屬性表示這個執行個體所代表的事件記錄檔的組態設定。 當事件記錄檔到達大小上限時，此屬性會指定作業系統如何處理新的項目寫入事件記錄檔已註冊的所有事件來源。       設定`action`參數<xref:System.Diagnostics.OverflowAction>表示新項目會覆寫舊的項目時<xref:System.Diagnostics.EventLog>達到最大值。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.OverflowAction> 如果`action`參數設定為<xref:System.Diagnostics.OverflowAction>、`retentionDays`參數值會被忽略。</xref:System.Diagnostics.OverflowAction>       設定`action`參數<xref:System.Diagnostics.OverflowAction>來表示，每個新的項目會覆寫舊的項目時<xref:System.Diagnostics.EventLog>達到最大值。</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.OverflowAction> 指定在記錄檔中使用的事件必須保留的天數`retentionDays`參數。 新的項目不會覆寫的保留範圍內寫入的事件。       設定`action`參數<xref:System.Diagnostics.OverflowAction>捨棄新的事件，當達到最大記錄檔大小。</xref:System.Diagnostics.OverflowAction> 如果`action`參數設定為<xref:System.Diagnostics.OverflowAction>、`retentionDays`參數值會被忽略。</xref:System.Diagnostics.OverflowAction>      > [!CAUTION] > 將溢位原則設定為<xref:System.Diagnostics.OverflowAction>指定事件記錄檔已滿時，就會捨棄新的項目。</xref:System.Diagnostics.OverflowAction> 如果您使用此設定，請確定事件記錄檔定期封存和清除，以避免達到其大小上限。"
  example:
  - "The following example displays the configured overflow policy for a specified event log, and allows the user to select a new overflow policy setting for the event log.  \n  \n [!code-vb[EventLogProperties#3](~/add/codesnippet/visualbasic/0b0fc273-a638-4af9-ae99-_1.vb)]\n [!code-cpp[EventLogProperties#3](~/add/codesnippet/cpp/0b0fc273-a638-4af9-ae99-_1.cpp)]\n [!code-cs[EventLogProperties#3](~/add/codesnippet/csharp/0b0fc273-a638-4af9-ae99-_1.cs)]"
  syntax:
    content: public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);
    parameters:
    - id: action
      type: System.Diagnostics.OverflowAction
      description: "新的項目寫入事件記錄檔溢位行為。"
    - id: retentionDays
      type: System.Int32
      description: "每個事件記錄檔項目會保留最少天數。 只有當使用這個參數`action`設<xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>。"
  overload: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>action</code>不是有效<xref:System.Diagnostics.EventLog.OverflowAction*>值。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>retentionDays</code>小於 1，或大於 365。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.OverflowAction
  id: OverflowAction
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得當事件記錄檔到達最大記錄檔大小時，儲存新項目的已設定的行為。"
  remarks: "在新的事件會寫入事件記錄檔大小變大。 每個事件記錄檔已設定的最大大小的限制;<xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>屬性會定義事件記錄檔大小所允許的 kb 數目上限。</xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>       若要檢查事件記錄檔，在其大小上限所設定的溢位的行為使用 OverflowAction 屬性值。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法來變更溢位行為的事件記錄檔。</xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>      > [!NOTE] > 溢位行為在事件記錄檔達到檔案大小上限時，才會生效。 溢位行為不會影響新的項目寫入記錄檔可容納額外的事件記錄項目。"
  example:
  - "The following example enumerates the event logs defined on the local computer, and displays configuration details for each event log.  \n  \n [!code-vb[EventLogProperties#2](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_28_1.vb)]\n [!code-cpp[EventLogProperties#2](~/add/codesnippet/cpp/p-system.diagnostics.eve_28_1.cpp)]\n [!code-cs[EventLogProperties#2](~/add/codesnippet/csharp/p-system.diagnostics.eve_28_1.cs)]"
  syntax:
    content: public System.Diagnostics.OverflowAction OverflowAction { get; }
    return:
      type: System.Diagnostics.OverflowAction
      description: "<xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>值，指定當事件記錄檔到達最大記錄檔大小時，儲存新項目的已設定的行為。 預設值是<xref href=&quot;System.Diagnostics.OverflowAction&quot;> </xref>。"
  overload: System.Diagnostics.EventLog.OverflowAction*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  id: RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "指定事件記錄檔，它會顯示在伺服器事件檢視器的當地語系化的名稱。"
  remarks: "使用 RegisterDisplayName 登錄和自訂事件記錄檔的事件檢視器中顯示的當地語系化的名稱。       指定的資源識別碼必須對應到資源檔中定義的當地語系化字串。 事件檢視器會顯示使用當地語系化的字串和目前的文化特性設定的自訂事件記錄檔名稱。 例如，您可以定義多個資源檔中的不同文化特性的當地語系化的事件記錄檔名稱。 事件檢視器會顯示對應到目前使用者的文化特性設定當地語系化的字串。       如果事件檢視器無法從資源檔，載入當地語系化的字串，或如果沒有顯示名稱已註冊的事件記錄檔，事件檢視器顯示<xref:System.Diagnostics.EventLog.Log%2A>.</xref:System.Diagnostics.EventLog.Log%2A>中定義的事件記錄檔名稱      > [!NOTE] > 您不需要註冊預先定義的事件記錄檔的顯示名稱。 作業系統會註冊應用程式、 系統及安全性事件記錄檔的當地語系化的顯示名稱。"
  example:
  - "The following example determines whether the event source named `SampleApplicationSource` is registered on the local computer. If the event source does not exist, the example sets the message resource file for the source and creates the new event source. Finally, the example sets the localized display name for the event log, using the resource identifier value in `DisplayNameMsgId` and the resource file path in `messageFile`.  \n  \n [!code-cpp[EventLog_WriteEvent#6](~/add/codesnippet/cpp/m-system.diagnostics.eve_1_1.cpp)]\n [!code-vb[EventLog_WriteEvent#6](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_1_1.vb)]\n [!code-cs[EventLog_WriteEvent#6](~/add/codesnippet/csharp/m-system.diagnostics.eve_1_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings. Specifically, resource identifier 5001 is defined for the localized name of the event log.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void RegisterDisplayName (string resourceFile, long resourceId);
    parameters:
    - id: resourceFile
      type: System.String
      description: "當地語系化的資源檔案的完整指定的路徑。"
    - id: resourceId
      type: System.Int64
      description: "索引內的資源檔的當地語系化的字串資源識別項。"
  overload: System.Diagnostics.EventLog.RegisterDisplayName*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "The <xref:System.Diagnostics.EventLog.Log*> value is not a valid log name.  \n  \n \\- or -  \n  \n The registry key for the event log could not be opened on the target computer."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceFile </code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Diagnostics.EventLog.Source
  id: Source
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得或設定寫入事件記錄檔時登錄和使用的來源名稱。"
  remarks: "事件來源會指出項目會記錄事件。 它通常是應用程式的名稱或名稱的子元件的應用程式，如果應用程式很大。 應用程式和服務應該寫入應用程式記錄檔或自訂的記錄檔。 裝置驅動程式應該寫入至系統記錄檔。       您只需要指定事件來源，如果您要撰寫事件記錄檔。 之前將項目寫入事件記錄檔，您必須與事件記錄檔登錄事件來源為有效的事件來源。 當您撰寫的記錄項目時，系統會使用 [來源] 屬性來尋找適當的記錄檔中要放置您的項目。 如果您正在閱讀事件記錄檔，您可以指定來源，或<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>。</xref:System.Diagnostics.EventLog.MachineName%2A> </xref:System.Diagnostics.EventLog.Log%2A>      > [!NOTE] > 您不需要指定<xref:System.Diagnostics.EventLog.MachineName%2A>如果您要連接至本機電腦上的記錄檔。</xref:System.Diagnostics.EventLog.MachineName%2A> 如果您未指定<xref:System.Diagnostics.EventLog.MachineName%2A>，本機電腦 (&quot;。&quot;) 會假設。</xref:System.Diagnostics.EventLog.MachineName%2A>       使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>和<xref:System.Diagnostics.EventLog.WriteEntry%2A>寫入事件記錄檔的事件</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.WriteEvent%2A> 您必須指定事件來源寫入事件。您必須建立並設定事件來源寫入來源的第一個項目之前。       在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。       您可以建立現有的事件記錄檔或新的事件記錄檔事件來源。 當您建立新的事件記錄檔的新來源時，系統會註冊為該記錄檔中，來源，但寫入第一個項目之前，不會建立記錄檔。       來源必須為本機電腦上唯一新的來源名稱不符合現有的來源名稱或現有的事件記錄檔名稱。 只有一個事件記錄檔可以寫入每個來源一次。不過，您的應用程式可以使用多個來源來寫入多個事件記錄檔。 例如，您的應用程式可能需要多個來源設定為不同的事件記錄檔或不同的資源檔案。       如果您變更來源值<xref:System.Diagnostics.EventLog>來登錄它已關閉，且會釋放所有的事件控制代碼。</xref:System.Diagnostics.EventLog>       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>       若要變更現有來源的設定詳細資料，您必須刪除來源，並再建立使用新的設定。 如果其他應用程式或元件使用現有的來源，請使用更新的組態，而不會刪除現有的來源建立新的來源。      > [!NOTE] > 如果來源已經對應到記錄檔，而且對應至新的記錄檔，您必須重新啟動電腦，變更才會生效。"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/p-system.diagnostics.eve_18_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/p-system.diagnostics.eve_18_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/p-system.diagnostics.eve_18_1.cpp)]"
  syntax:
    content: public string Source { get; set; }
    return:
      type: System.String
      description: "事件記錄檔與登錄項目的來源的名稱。 預設為空字串 (&quot;&quot;)。"
  overload: System.Diagnostics.EventLog.Source*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "來源名稱會導致超過 254 個字元的登錄機碼路徑。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  id: SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "決定是否要將事件來源登錄在本機電腦上。"
  remarks: "若要判斷事件來源是否存在於本機電腦上使用這個方法。 如果您想要判斷本機電腦上是否有記錄，，使用<xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A>       這個方法會存取登錄，因此您必須為本機電腦上擁有適當的登錄權限否則，<xref:System.Security.SecurityException>就會擲回。</xref:System.Security.SecurityException>      > [!NOTE] > 若要搜尋的事件來源在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理權限。   >> 這項需求的原因是，必須搜尋所有的事件記錄檔，包括安全性、 以判斷事件來源是否為唯一。 從 Windows Vista 開始，使用者沒有權限來存取安全性記錄檔中。因此，<xref:System.Security.SecurityException>就會擲回。</xref:System.Security.SecurityException>   >> 從 Windows Vista 開始，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建的 Administrators 群組的成員，您就會指派兩個執行階段存取語彙基元︰ 標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼會存取效能計數器，您必須先將您的權限從標準使用者提高為系統管理員。 當您啟動應用程式的應用程式圖示上按一下滑鼠右鍵，並指出您想要以系統管理員身分執行時，您可以這樣做。      > [!NOTE] > 下執行時的服務<xref:System.ServiceProcess.ServiceAccount>帳戶沒有執行這個方法所需的權限。</xref:System.ServiceProcess.ServiceAccount> 解決方法是檢查 事件來源是否存在於<xref:System.ServiceProcess.ServiceInstaller>，而且如果它不存在，安裝程式中建立的來源。</xref:System.ServiceProcess.ServiceInstaller>       因為您無法讓新的來源的同一部電腦上現有的來源名稱，然後再嘗試使用這個方法來呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，確保來源所指定的名稱與`source`不存在本機電腦上。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> `source`參數不區分大小寫。"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.Source Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_14_1.cs)]\n [!code-vb[Classic EventLog.Source Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_14_1.vb)]\n [!code-cpp[Classic EventLog.Source Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_14_1.cpp)]"
  syntax:
    content: public static bool SourceExists (string source);
    parameters:
    - id: source
      type: System.String
      description: "事件來源的名稱。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果事件來源註冊為本機電腦上，否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>找不到，但無法搜尋部分或全部的事件記錄檔。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  id: SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "判斷指定的電腦上是否已註冊的事件來源。"
  remarks: "使用這個方法來判斷所指定的電腦上是否有事件來源`machineName`參數。 如果您想要判斷記錄檔是否存在指定的電腦上，，使用<xref:System.Diagnostics.EventLog.Exists%2A>.</xref:System.Diagnostics.EventLog.Exists%2A>       這個方法會存取登錄，因為您必須指定伺服器上擁有適當的登錄權限否則，<xref:System.Security.SecurityException>就會擲回。</xref:System.Security.SecurityException>      > [!NOTE] > 若要搜尋的事件來源在 Windows Vista 和更新版本或 Windows Server 2003，您必須具有系統管理權限。   >> 這項需求的原因是，必須搜尋所有的事件記錄檔，包括安全性、 以判斷事件來源是否為唯一。 從 Windows Vista 開始，使用者沒有權限來存取安全性記錄檔中。因此，<xref:System.Security.SecurityException>就會擲回。</xref:System.Security.SecurityException>   >> 從 Windows Vista 開始，使用者帳戶控制 (UAC) 會判斷使用者的權限。 如果您是內建的 Administrators 群組的成員，您就會指派兩個執行階段存取語彙基元︰ 標準使用者存取語彙基元及管理員存取語彙基元。 根據預設，您會屬於標準使用者角色。 若要執行的程式碼會存取效能計數器，您必須先將您的權限從標準使用者提高為系統管理員。 當您啟動應用程式的應用程式圖示上按一下滑鼠右鍵，並指出您想要以系統管理員身分執行時，您可以這樣做。      > [!NOTE] > 下執行時的服務<xref:System.ServiceProcess.ServiceAccount>帳戶沒有執行這個方法所需的權限。</xref:System.ServiceProcess.ServiceAccount> 解決方法是檢查 事件來源是否存在於<xref:System.ServiceProcess.ServiceInstaller>，而且如果它不存在，安裝程式中建立的來源。</xref:System.ServiceProcess.ServiceInstaller>       因為您無法讓新的來源的同一部電腦上現有的來源名稱，然後再嘗試使用這個方法來呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>，確保來源所指定的名稱與`source`不存在電腦上。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> `source`和`machineName`參數不區分大小寫。       <xref:System.Diagnostics.EventLog.SourceExists%2A>是`static`方法，所以它可以呼叫此類別本身。</xref:System.Diagnostics.EventLog.SourceExists%2A> 不需要建立<xref:System.Diagnostics.EventLog>呼叫<xref:System.Diagnostics.EventLog.SourceExists%2A>.</xref:System.Diagnostics.EventLog.SourceExists%2A></xref:System.Diagnostics.EventLog>的執行個體"
  example:
  - "The following example creates the source `MySource` on the computer `MyServer`, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_16_1.cpp)]\n [!code-cs[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_16_1.cs)]\n [!code-vb[Classic EventLog.SourceExists1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_16_1.vb)]"
  syntax:
    content: public static bool SourceExists (string source, string machineName);
    parameters:
    - id: source
      type: System.String
      description: "事件來源的名稱。"
    - id: machineName
      type: System.String
      description: "名稱的電腦上尋找，或 」。 「 本機電腦。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果事件來源註冊指定的電腦。，否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Diagnostics.EventLog.SourceExists*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>machineName</code>這是不正確的電腦名稱。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<code>source</code>找不到，但無法搜尋部分或全部的事件記錄檔。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.SynchronizingObject
  id: SynchronizingObject
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "取得或設定物件，用以封送處理的事件處理常式呼叫<xref href=&quot;System.Diagnostics.EventLog&quot;></xref>項目寫入事件。"
  remarks: "SynchronizingObject 時`null`，方法處理<xref:System.Diagnostics.EventLog.EntryWritten>系統執行緒集區的執行緒上呼叫事件。</xref:System.Diagnostics.EventLog.EntryWritten> 如需有關系統執行緒集區的詳細資訊，請參閱<xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       當<xref:System.Diagnostics.EventLog.EntryWritten>事件由 visual 的 Windows Form 的元件，例如按鈕，存取元件，透過系統執行緒集區可能無法運作，或可能會導致例外狀況處理。</xref:System.Diagnostics.EventLog.EntryWritten> 避免這種藉由設定至 Windows Form 的元件，這會導致處理方法 SynchronizingObject<xref:System.Diagnostics.EventLog.EntryWritten>元件建立所在的相同執行緒上呼叫的事件。</xref:System.Diagnostics.EventLog.EntryWritten>       如果<xref:System.Diagnostics.EventLog>內使用[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]在 Windows Form 設計工具中，SynchronizingObject 會自動設定為包含<xref:System.Diagnostics.EventLog>.</xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog> 例如，如果您將<xref:System.Diagnostics.EventLog>form1 設計工具上 (繼承自<xref:System.Windows.Forms.Form>) 的 SynchronizingObject 屬性<xref:System.Diagnostics.EventLog>設為 Form1 的執行個體。</xref:System.Diagnostics.EventLog> </xref:System.Windows.Forms.Form> </xref:System.Diagnostics.EventLog>"
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "<xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref>用來封送處理發出的事件處理常式呼叫<xref href=&quot;System.Diagnostics.EventLog.EntryWritten&quot;></xref>事件記錄檔的事件。"
  overload: System.Diagnostics.EventLog.SynchronizingObject*
  exceptions: []
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  id: WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "具有指定的訊息文字的資訊類型項目寫入事件記錄檔。"
  remarks: "使用這個方法來寫入事件記錄檔與此相關聯的資訊項目<xref:System.Diagnostics.EventLog>執行個體。</xref:System.Diagnostics.EventLog> 如果您想要指定任何其他已設定<xref:System.Diagnostics.EventLogEntryType>，請使用不同的多載的<xref:System.Diagnostics.EventLog.WriteEntry%2A>。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLogEntryType>      > [!NOTE] >`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。       您必須設定<xref:System.Diagnostics.EventLog.Source%2A>您的<xref:System.Diagnostics.EventLog>元件，您才能寫入記錄檔項目</xref:System.Diagnostics.EventLog>上的屬性</xref:System.Diagnostics.EventLog.Source%2A> 您必須建立並設定事件來源寫入來源的第一個項目之前。       在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。       如果在指定來源<xref:System.Diagnostics.EventLog.Source%2A>屬性這<xref:System.Diagnostics.EventLog>寫入您的元件，在電腦上未註冊執行個體<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>如您<xref:System.Diagnostics.EventLog>執行個體，才能呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 (&quot;。&quot;) 會假設。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       系統是否需要<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>而且<xref:System.Diagnostics.EventLog.Log%2A>未在您的<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔</xref:System.Diagnostics.EventLog>設定屬性</xref:System.Diagnostics.EventLog.Log%2A>的</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.Source%2A>註冊      > [!NOTE] > 註冊<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>的程序期間引發的錯誤時會產生許多上面所列的例外狀況       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 項目寫入遠端的電腦上，如果訊息 （文字字串） 的值可能不會不如預期如果遠端電腦未執行.NET Framework。      > [!NOTE] > 如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cs[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_7_1.cs)]\n [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_7_1.cpp)]\n [!code-vb[Classic EventLog.CreateEventSource Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_7_1.vb)]"
  syntax:
    content: public void WriteEntry (string message);
    parameters:
    - id: message
      type: System.String
      description: "要寫入事件記錄檔的字串。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件項目寫入事件記錄檔時，作業系統回報錯誤。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "寫入事件記錄檔的錯誤、 警告、 資訊、 成功稽核或失敗稽核項目，以指定的訊息文字。"
  remarks: "使用此方法來撰寫的指定<xref:System.Diagnostics.EventLogEntryType>事件記錄檔</xref:System.Diagnostics.EventLogEntryType>項目 `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。      > [!NOTE] >`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。       您必須設定<xref:System.Diagnostics.EventLog.Source%2A>您的<xref:System.Diagnostics.EventLog>元件，您才能寫入記錄檔項目</xref:System.Diagnostics.EventLog>上的屬性</xref:System.Diagnostics.EventLog.Source%2A> 您必須建立並設定事件來源寫入來源的第一個項目之前。       在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。       如果在指定來源<xref:System.Diagnostics.EventLog.Source%2A>屬性這<xref:System.Diagnostics.EventLog>寫入您的元件，在電腦上未註冊執行個體<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>如您<xref:System.Diagnostics.EventLog>執行個體，才能呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 (&quot;。&quot;) 會假設。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       系統是否需要<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>而且<xref:System.Diagnostics.EventLog.Log%2A>未在您的<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔</xref:System.Diagnostics.EventLog>設定屬性</xref:System.Diagnostics.EventLog.Log%2A>的</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.Source%2A>註冊      > [!NOTE] > 註冊<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>的程序期間引發的錯誤所產生以上所列的許多例外狀況       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 項目寫入遠端的電腦上，如果訊息 （文字字串） 的值可能不會不如預期如果遠端電腦未執行.NET Framework。      > [!NOTE] > 如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。"
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/cpp/19aeba79-224e-4604-90d9-_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/csharp/19aeba79-224e-4604-90d9-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/add/codesnippet/visualbasic/19aeba79-224e-4604-90d9-_1.vb)]"
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: message
      type: System.String
      description: "要寫入事件記錄檔的字串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "其中一個<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件項目寫入事件記錄檔時，作業系統回報錯誤。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  id: WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "使用指定的訊息文字的資訊類型項目寫入事件記錄檔，使用指定的登錄的事件來源。"
  remarks: "您可以使用這個方法，將資訊項目寫入事件記錄檔，使用已登錄為適當的記錄檔事件來源的來源。 如果您想要指定任何其他已設定<xref:System.Diagnostics.EventLogEntryType>，請使用不同的多載的<xref:System.Diagnostics.EventLog.WriteEntry%2A>。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLogEntryType>       您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。   >>`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。"
  example:
  - "The following example creates the source `MySource` if it does not already exist, and writes an entry to the event log `MyNewLog`.  \n  \n [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/cpp/m-system.diagnostics.eve_3_1.cpp)]\n [!code-cs[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/csharp/m-system.diagnostics.eve_3_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/add/codesnippet/visualbasic/m-system.diagnostics.eve_3_1.vb)]"
  syntax:
    content: public static void WriteEntry (string source, string message);
    parameters:
    - id: source
      type: System.String
      description: "依據指定的電腦註冊應用程式的來源。"
    - id: message
      type: System.String
      description: "要寫入事件記錄檔的字串。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件項目寫入事件記錄檔時，作業系統回報錯誤。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "具有指定的訊息文字和應用程式定義的事件識別項的項目寫入事件記錄檔。"
  remarks: "使用此方法來撰寫應用程式定義的項目`eventID`事件記錄檔。 `eventID`來源一起唯一識別的事件。 每個應用程式可以定義自己的編號的事件和它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者瞭解何處出錯，並建議要採取的動作。      > [!NOTE] >`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。       事件識別項，除了您可以指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。</xref:System.Diagnostics.EventLogEntryType> `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。       您必須設定<xref:System.Diagnostics.EventLog.Source%2A>您的<xref:System.Diagnostics.EventLog>元件，您才能寫入記錄檔項目</xref:System.Diagnostics.EventLog>上的屬性</xref:System.Diagnostics.EventLog.Source%2A> 您必須建立並設定事件來源寫入來源的第一個項目之前。       在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。       如果在指定來源<xref:System.Diagnostics.EventLog.Source%2A>屬性這<xref:System.Diagnostics.EventLog>寫入您的元件，在電腦上未註冊執行個體<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>如您<xref:System.Diagnostics.EventLog>執行個體，才能呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 (&quot;。&quot;) 會假設。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       系統是否需要<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>而且<xref:System.Diagnostics.EventLog.Log%2A>未在您的<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔</xref:System.Diagnostics.EventLog>設定屬性</xref:System.Diagnostics.EventLog.Log%2A>的</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.Source%2A>註冊      > [!NOTE] > 註冊<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>的程序期間引發的錯誤所產生以上所列的許多例外狀況       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 項目寫入遠端的電腦上，如果訊息 （文字字串） 的值可能不會不如預期如果遠端電腦未執行.NET Framework。      > [!NOTE] > 如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。"
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/597042ed-6d84-4ccf-a867-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/597042ed-6d84-4ccf-a867-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/597042ed-6d84-4ccf-a867-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: message
      type: System.String
      description: "要寫入事件記錄檔的字串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "其中一個<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
    - id: eventID
      type: System.Int32
      description: "應用程式特定事件識別項。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件項目寫入事件記錄檔時，作業系統回報錯誤。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "寫入事件記錄檔，使用指定的登錄的事件來源的錯誤、 警告、 資訊、 成功稽核或失敗稽核項目，以指定的訊息文字。"
  remarks: "使用這個方法來寫入<xref:System.Diagnostics.EventLogEntryType>事件記錄檔中，使用 已註冊適當的記錄檔事件來源為來源</xref:System.Diagnostics.EventLogEntryType>指定的項目 `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。      > [!NOTE] >`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。       您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。"
  example:
  - "The following example writes a warning entry to an event log, \"MyNewLog\", on the local computer.  \n  \n [!code-cs[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/csharp/c03f903c-8fbd-441f-afe0-_1.cs)]\n [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/visualbasic/c03f903c-8fbd-441f-afe0-_1.vb)]\n [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/add/codesnippet/cpp/c03f903c-8fbd-441f-afe0-_1.cpp)]"
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);
    parameters:
    - id: source
      type: System.String
      description: "依據指定的電腦註冊應用程式的來源。"
    - id: message
      type: System.String
      description: "要寫入事件記錄檔的字串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "其中一個<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件項目寫入事件記錄檔時，作業系統回報錯誤。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "具有指定的訊息文字、 應用程式定義的事件識別項和應用程式定義的分類的項目寫入事件記錄檔中。"
  remarks: "使用此方法來撰寫應用程式定義的項目`category`事件記錄檔。 事件檢視器會使用要寫入的事件來源的篩選事件的類別目錄。 事件檢視器可以顯示類別目錄做為數值，或它可以使用 「 類別目錄做為資源識別項若要顯示的當地語系化類別目錄字串。      > [!NOTE] >`category`參數應該是正值。 負的類別值會顯示為互補的正數在事件檢視器。 例如，– 10 會顯示為 65526，-1 為 65535。      > [!NOTE] >`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。       若要顯示事件檢視器中的當地語系化類別目錄字串，您必須使用事件來源類別資源檔案後，設定和設定`category`類別資源檔案中的資源識別項。 如果事件來源沒有已設定的類別資源檔案，或指定`category`未索引的字串，在類別資源檔案中，事件檢視器會顯示該項目的數值分類值。 設定類別資源檔案，以及使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>類別</xref:System.Diagnostics.EventSourceCreationData></xref:System.Diagnostics.EventLogInstaller>資源檔案中中的類別字串的數目       除了類別目錄中，您可以指定要寫入事件記錄檔事件的事件識別項。 事件的識別項，以及事件來源，可唯一識別事件。 每個應用程式可以定義自己的編號的事件和它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者瞭解何處出錯，並建議要採取的動作。       最後，您可以指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。</xref:System.Diagnostics.EventLogEntryType> `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。       您必須設定<xref:System.Diagnostics.EventLog.Source%2A>您的<xref:System.Diagnostics.EventLog>元件，您才能寫入記錄檔項目</xref:System.Diagnostics.EventLog>上的屬性</xref:System.Diagnostics.EventLog.Source%2A> 您必須建立並設定事件來源寫入來源的第一個項目之前。       在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。       如果在指定來源<xref:System.Diagnostics.EventLog.Source%2A>屬性這<xref:System.Diagnostics.EventLog>寫入您的元件，在電腦上未註冊執行個體<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>如您<xref:System.Diagnostics.EventLog>執行個體，才能呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 (&quot;。&quot;) 會假設。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       系統是否需要<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>而且<xref:System.Diagnostics.EventLog.Log%2A>未在您的<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔</xref:System.Diagnostics.EventLog>設定屬性</xref:System.Diagnostics.EventLog.Log%2A>的</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.Source%2A>註冊      > [!NOTE] > 註冊<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>的程序期間引發的錯誤所產生以上所列的許多例外狀況       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 項目寫入遠端的電腦上，如果訊息 （文字字串） 的值可能不會不如預期如果遠端電腦未執行.NET Framework。      > [!NOTE] > 如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。"
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#3](~/add/codesnippet/cpp/b3db94bc-a96c-4168-a8f0-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#3](~/add/codesnippet/csharp/b3db94bc-a96c-4168-a8f0-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#3](~/add/codesnippet/visualbasic/b3db94bc-a96c-4168-a8f0-_1.vb)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: message
      type: System.String
      description: "要寫入事件記錄檔的字串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "其中一個<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
    - id: eventID
      type: System.Int32
      description: "應用程式特定事件識別項。"
    - id: category
      type: System.Int16
      description: "與訊息相關聯應用程式特定的子類別。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件項目寫入事件記錄檔時，作業系統回報錯誤。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "具有指定的訊息文字和應用程式定義的事件識別項的項目寫入事件記錄檔，使用指定的登錄的事件來源。"
  remarks: "使用此方法來撰寫應用程式定義的項目`eventID`事件記錄檔中，已使用來源登錄為適當的記錄檔事件來源。 `eventID`，以及來源，可唯一識別事件。 每個應用程式可以定義自己的編號的事件和它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者瞭解何處出錯，並建議要採取的動作。      > [!NOTE] >`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。       除了事件識別項，<xref:System.Diagnostics.EventLog.WriteEntry%2A>可讓您指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔</xref:System.Diagnostics.EventLogEntryType></xref:System.Diagnostics.EventLog.WriteEntry%2A>的這個多載 `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。       您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。"
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_4#1](~/add/codesnippet/csharp/2d8498b8-a54d-48c9-9ee7-_1.cs)]
     [!code-cpp[EventLog_WriteEntry_4#1](~/add/codesnippet/cpp/2d8498b8-a54d-48c9-9ee7-_1.cpp)]
     [!code-vb[EventLog_WriteEntry_4#1](~/add/codesnippet/visualbasic/2d8498b8-a54d-48c9-9ee7-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);
    parameters:
    - id: source
      type: System.String
      description: "依據指定的電腦註冊應用程式的來源。"
    - id: message
      type: System.String
      description: "要寫入事件記錄檔的字串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "其中一個<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
    - id: eventID
      type: System.Int32
      description: "應用程式特定事件識別項。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件項目寫入事件記錄檔時，作業系統回報錯誤。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "具有指定的訊息文字、 應用程式定義的事件識別項和應用程式定義的分類的項目寫入事件記錄檔，並將二進位資料附加至訊息。"
  remarks: "使用此多載將應用程式定義的事件特定資料寫入事件記錄檔。 事件檢視器不會解譯這項資料。它只能在組合的十六進位和文字格式顯示未經處理資料。 使用事件的特定資料謹慎使用，包括它只有在確定會很有用給偵錯問題。 您也可以使用特定的事件資料來儲存應用程式可以處理與事件檢視器無關的資訊。 例如，您可以編寫特別為您的事件檢視器，或編寫程式，以掃描記錄檔，並建立報告，其中包含從特定的事件資料的資訊。       除了二進位資料，您可以指定應用程式定義的類別目錄和應用程式定義的事件識別項。 事件檢視器會使用要寫入的事件來源的篩選事件的類別目錄。 事件檢視器可以顯示類別目錄做為數值，或它可以使用 「 類別目錄做為資源識別項若要顯示的當地語系化類別目錄字串。      > [!NOTE] >`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。      > [!NOTE] >`category`參數應該是正值。 負的類別值會顯示為互補的正數在事件檢視器。 例如，– 10 會顯示為 65526，-1 為 65535。       若要顯示事件檢視器中的當地語系化類別目錄字串，您必須使用事件來源類別資源檔案後，設定和設定`category`類別資源檔案中的資源識別項。 如果事件來源沒有已設定的類別資源檔案，或指定`category`未索引的字串，在類別資源檔案中，事件檢視器會顯示該項目的數值分類值。 設定類別資源檔案，以及使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>類別</xref:System.Diagnostics.EventSourceCreationData></xref:System.Diagnostics.EventLogInstaller>資源檔案中中的類別字串的數目       事件的識別項，以及事件來源，可唯一識別事件。 每個應用程式可以定義自己的編號的事件和它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者瞭解何處出錯，並建議要採取的動作。       最後，您可以指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。</xref:System.Diagnostics.EventLogEntryType> `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。       您必須設定<xref:System.Diagnostics.EventLog.Source%2A>您的<xref:System.Diagnostics.EventLog>元件，您才能寫入記錄檔項目</xref:System.Diagnostics.EventLog>上的屬性</xref:System.Diagnostics.EventLog.Source%2A> 您必須建立並設定事件來源寫入來源的第一個項目之前。       在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。       如果在指定來源<xref:System.Diagnostics.EventLog.Source%2A>屬性這<xref:System.Diagnostics.EventLog>寫入您的元件，在電腦上未註冊執行個體<xref:System.Diagnostics.EventLog.WriteEntry%2A>呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>並註冊來源。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.Source%2A>      > [!NOTE] > 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>如您<xref:System.Diagnostics.EventLog>執行個體，才能呼叫<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或<xref:System.Diagnostics.EventLog.WriteEntry%2A>，本機電腦 (&quot;。&quot;) 會假設。</xref:System.Diagnostics.EventLog.WriteEntry%2A> </xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       系統是否需要<xref:System.Diagnostics.EventLog.Source%2A>透過呼叫<xref:System.Diagnostics.EventLog.WriteEntry%2A>而且<xref:System.Diagnostics.EventLog.Log%2A>未在您的<xref:System.Diagnostics.EventLog>執行個體，預設為應用程式記錄檔的記錄檔</xref:System.Diagnostics.EventLog>設定屬性</xref:System.Diagnostics.EventLog.Log%2A>的</xref:System.Diagnostics.EventLog.WriteEntry%2A></xref:System.Diagnostics.EventLog.Source%2A>註冊      > [!NOTE] > 註冊<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>的程序期間引發的錯誤所產生以上所列的許多例外狀況       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 項目寫入遠端的電腦上，如果訊息 （文字字串） 的值可能不會不如預期如果遠端電腦未執行.NET Framework。      > [!NOTE] > 如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。"
  example:
  - >-
    [!code-cs[EventLog_WriteEntry_5#1](~/add/codesnippet/csharp/1c6518b6-dc55-4c74-9028-_1.cs)]
     [!code-vb[EventLog_WriteEntry_5#1](~/add/codesnippet/visualbasic/1c6518b6-dc55-4c74-9028-_1.vb)]
     [!code-cpp[EventLog_WriteEntry_5#1](~/add/codesnippet/cpp/1c6518b6-dc55-4c74-9028-_1.cpp)]
  syntax:
    content: public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: message
      type: System.String
      description: "要寫入事件記錄檔的字串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "其中一個<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
    - id: eventID
      type: System.Int32
      description: "應用程式特定事件識別項。"
    - id: category
      type: System.Int16
      description: "與訊息相關聯應用程式特定的子類別。"
    - id: rawData
      type: System.Byte[]
      description: "保存與項目相關聯的二進位資料的位元組陣列。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件項目寫入事件記錄檔時，作業系統回報錯誤。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "具有指定的訊息文字、 應用程式定義的事件識別項和應用程式定義的分類的項目寫入事件記錄檔，使用指定的登錄的事件來源。 <code> category </code>可用來篩選事件記錄檔中，事件檢視器。"
  remarks: "使用此方法來撰寫應用程式定義的項目`category`事件記錄檔中，使用 已登錄為適當的記錄檔事件來源的來源。 事件檢視器會使用要寫入的事件來源的篩選事件的類別目錄。 事件檢視器可以顯示類別目錄做為數值，或它可以使用 「 類別目錄做為資源識別項若要顯示的當地語系化類別目錄字串。      > [!NOTE] >`category`參數應該是正值。 負的類別值會顯示為互補的正數在事件檢視器。 例如，– 10 會顯示為 65526，-1 為 65535。       若要顯示事件檢視器中的當地語系化類別目錄字串，您必須使用事件來源類別資源檔案後，設定和設定`category`類別資源檔案中的資源識別項。 如果事件來源沒有已設定的類別資源檔案，或指定`category`未索引的字串，在類別資源檔案中，事件檢視器會顯示該項目的數值分類值。 設定類別資源檔案，以及使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>類別</xref:System.Diagnostics.EventSourceCreationData></xref:System.Diagnostics.EventLogInstaller>資源檔案中中的類別字串的數目       除了類別目錄中，您可以指定要寫入事件記錄檔事件的事件識別項。 事件的識別項，以及事件來源，可唯一識別事件。 每個應用程式可以定義自己的編號的事件和它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者瞭解何處出錯，並建議要採取的動作。       最後，您可以指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。</xref:System.Diagnostics.EventLogEntryType> `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。       您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。   >>`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。"
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#1](~/add/codesnippet/cpp/189fd615-c100-4e72-9c0b-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#1](~/add/codesnippet/csharp/189fd615-c100-4e72-9c0b-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#1](~/add/codesnippet/visualbasic/189fd615-c100-4e72-9c0b-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);
    parameters:
    - id: source
      type: System.String
      description: "依據指定的電腦註冊應用程式的來源。"
    - id: message
      type: System.String
      description: "要寫入事件記錄檔的字串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "其中一個<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
    - id: eventID
      type: System.Int32
      description: "應用程式特定事件識別項。"
    - id: category
      type: System.Int16
      description: "與訊息相關聯應用程式特定的子類別。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件項目寫入事件記錄檔時，作業系統回報錯誤。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  id: WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "具有指定的訊息文字、 應用程式定義的事件識別項和應用程式定義的分類的項目寫入事件記錄檔 （使用指定的登錄的事件來源），並將二進位資料附加至訊息。"
  remarks: "使用這個方法，將應用程式定義的事件特定資料寫入事件記錄檔，使用已登錄為適當的記錄檔事件來源的來源。 事件檢視器不會解譯這項資料。它只能在組合的十六進位和文字格式顯示未經處理資料。 謹慎使用; 使用特定的事件資料包含只有在確定會很有用。 您也可以使用特定的事件資料來儲存應用程式可以處理與事件檢視器無關的資訊。 例如，您可以編寫特別為您的事件檢視器，或編寫程式，以掃描記錄檔，並建立報告，其中包含從特定的事件資料的資訊。       除了二進位資料，您可以指定應用程式定義的類別目錄和應用程式定義的事件識別項。 事件檢視器會使用要寫入的事件來源的篩選事件的類別目錄。 事件檢視器可以顯示類別目錄做為數值，或它可以使用 「 類別目錄做為資源識別項若要顯示的當地語系化類別目錄字串。      > [!NOTE] >`category`參數應該是正值。 負的類別值會顯示為互補的正數在事件檢視器。 例如，– 10 會出現為 65526，-1 為 65535。       若要顯示事件檢視器中的當地語系化類別目錄字串，您必須使用事件來源類別資源檔案後，設定和設定`category`類別資源檔案中的資源識別項。 如果事件來源沒有已設定的類別資源檔案，或指定`category`未索引的字串，在類別資源檔案中，事件檢視器會顯示該項目的數值分類值。 設定類別資源檔案，以及使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventSourceCreationData>類別</xref:System.Diagnostics.EventSourceCreationData></xref:System.Diagnostics.EventLogInstaller>資源檔案中中的類別字串的數目       事件的識別項，以及事件來源，可唯一識別事件。 每個應用程式可以定義自己的編號的事件和它們所對應的描述字串。 事件檢視器會顯示這些字串值，以協助使用者瞭解何處出錯，並建議要採取的動作。       最後，您可以指定<xref:System.Diagnostics.EventLogEntryType>事件寫入事件記錄檔。</xref:System.Diagnostics.EventLogEntryType> `type`由圖示和記錄檔的事件檢視器的類型資料行中的文字。 這個參數會指出事件類型是錯誤、 警告、 資訊、 成功稽核或失敗稽核。       您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法事件記錄檔中直接寫入指定的字串; 它不會使用可當地語系化的訊息資源檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A> 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法，以使用當地語系化的訊息資源檔寫入事件。</xref:System.Diagnostics.EventLog.WriteEvent%2A>       如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 如果`message`參數包含 NUL 字元，則 NUL 字元在終止事件記錄檔中的訊息。   >>`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。"
  example:
  - >-
    [!code-cpp[EventLog_WriteEntry_1_3#2](~/add/codesnippet/cpp/0b90a83a-dcc8-46e6-a8db-_1.cpp)]
     [!code-cs[EventLog_WriteEntry_1_3#2](~/add/codesnippet/csharp/0b90a83a-dcc8-46e6-a8db-_1.cs)]
     [!code-vb[EventLog_WriteEntry_1_3#2](~/add/codesnippet/visualbasic/0b90a83a-dcc8-46e6-a8db-_1.vb)]
  syntax:
    content: public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);
    parameters:
    - id: source
      type: System.String
      description: "依據指定的電腦註冊應用程式的來源。"
    - id: message
      type: System.String
      description: "要寫入事件記錄檔的字串。"
    - id: type
      type: System.Diagnostics.EventLogEntryType
      description: "其中一個<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;></xref>值。"
    - id: eventID
      type: System.Int32
      description: "應用程式特定事件識別項。"
    - id: category
      type: System.Int16
      description: "與訊息相關聯應用程式特定的子類別。"
    - id: rawData
      type: System.Byte[]
      description: "保存與項目相關聯的二進位資料的位元組陣列。"
  overload: System.Diagnostics.EventLog.WriteEntry*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>eventID</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n The message string is longer than 31,839 bytes (32,766 bytes on Windows operating systems before Windows Vista).  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>type</code>不是有效<xref href=&quot;System.Diagnostics.EventLogEntryType&quot;> </xref>。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件項目寫入事件記錄檔時，作業系統回報錯誤。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "當地語系化的項目寫入事件記錄檔。"
  remarks: "將當地語系化的項目寫入事件記錄檔中使用這個方法。 您可以指定事件屬性的資源識別項，而不是字串值。 事件檢視器使用的資源識別碼來顯示<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>的當地語系化的資源檔中的對應字串 您必須先使用資源識別項寫入事件，以對應的資源檔註冊來源。       輸入`instance`事件訊息和屬性，指定執行個體。 設定<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`輸入來源訊息資源檔中定義的訊息。</xref:System.Diagnostics.EventInstance.InstanceId%2A> 您可以選擇設定<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`來定義您的事件項目分類和事件類型的輸入。</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> 您也可以指定要插入當地語系化的訊息文字的語言無關字串陣列。 設定`values`至`null`如果事件訊息未包含的取代字串格式化預留位置。       您必須設定<xref:System.Diagnostics.EventLog.Source%2A>您的<xref:System.Diagnostics.EventLog>元件之前使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A></xref:System.Diagnostics.EventLog>屬性</xref:System.Diagnostics.EventLog.Source%2A> 指定的來源必須設定當地語系化的項目寫入記錄檔。來源最小值必須已定義的訊息資源檔。       您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，如果您的應用程式寫入的字串值，直接以事件記錄檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A>       如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 如果您將項目寫入遠端電腦時，值`message`字串可能不是您預期如果遠端電腦未執行.NET Framework。 此外，`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。"
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/6a714dbf-bcbc-4f5a-a8b4-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/6a714dbf-bcbc-4f5a-a8b4-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/6a714dbf-bcbc-4f5a-a8b4-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref>執行個體，表示當地語系化的事件記錄項目。"
    - id: values
      type: System.Object[]
      description: "要合併到事件記錄檔項目的訊息文字的字串陣列。"
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件項目寫入事件記錄檔時，作業系統回報錯誤。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "寫入具有指定的事件資料、 訊息取代字串和相關聯的二進位資料的事件記錄檔項目。"
  remarks: "將當地語系化的項目與其他事件的特定資料寫入事件記錄檔中使用這個方法。 您可以指定事件屬性的資源識別項，而不是字串值。 事件檢視器使用的資源識別碼來顯示<xref:System.Diagnostics.EventLog.Source%2A>.</xref:System.Diagnostics.EventLog.Source%2A>的當地語系化的資源檔中的對應字串 您必須先使用資源識別項寫入事件，以對應的資源檔註冊來源。       輸入`instance`事件訊息和屬性，指定執行個體。 設定<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`輸入來源訊息資源檔中定義的訊息。</xref:System.Diagnostics.EventInstance.InstanceId%2A> 您可以選擇設定<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`來定義您的事件項目分類和事件類型的輸入。</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> 您也可以指定要插入當地語系化的訊息文字的語言無關字串陣列。 設定`values`至`null`如果事件訊息未包含的取代字串格式化預留位置。       指定二進位資料時必須提供其他詳細資料事件的事件。 例如，使用`data`參數來包含特定錯誤的資訊。 事件檢視器不會解譯相關聯的事件資料。它會顯示資料組合的十六進位和文字格式。 謹慎使用; 使用特定的事件資料包含只有在確定會很有用。 您也可以使用特定的事件資料來儲存應用程式可以處理與事件檢視器無關的資訊。 例如，您可以編寫特別為您的事件檢視器，或編寫程式，以掃描事件記錄檔，並建立報告，其中包含從特定的事件資料的資訊。       您必須設定<xref:System.Diagnostics.EventLog.Source%2A>您的<xref:System.Diagnostics.EventLog>元件之前使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A>之前，元件</xref:System.Diagnostics.EventLog>的屬性</xref:System.Diagnostics.EventLog.Source%2A> 指定的來源必須設定當地語系化的項目寫入記錄檔。來源最小值必須已定義的訊息資源檔。       您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。      > [!NOTE] > 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>如您<xref:System.Diagnostics.EventLog>執行個體，才能呼叫<xref:System.Diagnostics.EventLog.WriteEvent%2A>，本機電腦 (&quot;。&quot;) 會假設。</xref:System.Diagnostics.EventLog.WriteEvent%2A> </xref:System.Diagnostics.EventLog> </xref:System.Diagnostics.EventLog.MachineName%2A>       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，如果您的應用程式寫入的字串值，直接以事件記錄檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A>       如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>      > [!NOTE] > 如果您將項目寫入遠端電腦時，值`message`字串可能不是您預期如果遠端電腦未執行.NET Framework。 此外，`message`字串不能包含 %*n*，其中*n*是整數值 (例如，%1)，因為事件檢視器會將它視為插入字串。 「 網際網路 」 通訊協定版本 6 (IPv6) 位址都可以包含這個字元順序，因為無法記錄包含一個 IPv6 位址的事件訊息。"
  example:
  - "The following example writes two audit entries to the event log `myNewLog`. The example creates a new event source and a new event log if they do not exist on the local computer. The event message text is specified using a resource identifier in a resource file.  \n  \n [!code-cpp[EventLog_WriteEvent#7](~/add/codesnippet/cpp/9c997f17-0108-4c5c-b894-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#7](~/add/codesnippet/visualbasic/9c997f17-0108-4c5c-b894-_1.vb)]\n [!code-cs[EventLog_WriteEvent#7](~/add/codesnippet/csharp/9c997f17-0108-4c5c-b894-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref>執行個體，表示當地語系化的事件記錄項目。"
    - id: data
      type: System.Byte[]
      description: "保存與項目相關聯的二進位資料的位元組陣列。"
    - id: values
      type: System.Object[]
      description: "要合併到事件記錄檔項目的訊息文字的字串陣列。"
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref:System.Diagnostics.EventLog.Source*> property of the <xref href=\"System.Diagnostics.EventLog\"></xref> has not been set.  \n  \n -or-  \n  \n The method attempted to register a new event source, but the computer name in <xref:System.Diagnostics.EventLog.MachineName*> is not valid.  \n  \n \\- or -  \n  \n The source is already registered for a different event log.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件項目寫入事件記錄檔時，作業系統回報錯誤。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "寫入事件記錄檔項目以指定的事件資料、 訊息取代字串，使用指定的登錄的事件來源。"
  remarks: "使用這個方法將當地語系化的項目寫入事件記錄檔，使用已登錄為適當的記錄檔事件來源的來源。 您可以指定事件屬性的資源識別項，而不是字串值。 事件檢視器使用的資源識別碼，來顯示來源的當地語系化的資源檔中的對應字串。 您必須先使用資源識別項寫入事件，以對應的資源檔註冊來源。       輸入`instance`事件訊息和屬性，指定執行個體。 設定<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`輸入來源訊息資源檔中定義的訊息。</xref:System.Diagnostics.EventInstance.InstanceId%2A> 您可以選擇設定<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`來定義您的事件項目分類和事件類型的輸入。</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> 您也可以指定要插入當地語系化的訊息文字的語言無關字串陣列。 設定`values`至`null`如果事件訊息未包含的取代字串格式化預留位置。       指定的來源必須使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A>之前註冊事件記錄檔 指定的來源必須設定當地語系化的項目寫入記錄檔。來源最小值必須已定義的訊息資源檔。       您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，如果您的應用程式寫入的字串值，直接以事件記錄檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A>       如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/a57d89b3-94d2-4b9a-803c-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/a57d89b3-94d2-4b9a-803c-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/a57d89b3-94d2-4b9a-803c-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "註冊指定的電腦上的應用程式的事件來源的名稱。"
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref>執行個體，表示當地語系化的事件記錄項目。"
    - id: values
      type: System.Object[]
      description: "要合併到事件記錄檔項目的訊息文字的字串陣列。"
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件項目寫入事件記錄檔時，作業系統回報錯誤。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  id: WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  langs:
  - csharp
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  type: Method
  assemblies:
  - System
  namespace: System.Diagnostics
  summary: "寫入事件記錄項目與指定的事件資料、 訊息取代字串和相關聯的二進位資料，並使用指定的已登錄事件來源。"
  remarks: "使用這個方法將當地語系化的項目與其他事件的特定資料寫入事件記錄檔，使用已登錄為適當的記錄檔事件來源的來源。 您可以指定事件屬性的資源識別項，而不是字串值。 事件檢視器使用的資源識別碼，來顯示來源的當地語系化的資源檔中的對應字串。 您必須先使用資源識別項寫入事件，以對應的資源檔註冊來源。       輸入`instance`事件訊息和屬性，指定執行個體。 設定<xref:System.Diagnostics.EventInstance.InstanceId%2A>的`instance`輸入來源訊息資源檔中定義的訊息。</xref:System.Diagnostics.EventInstance.InstanceId%2A> 您可以選擇設定<xref:System.Diagnostics.EventInstance.CategoryId%2A>和<xref:System.Diagnostics.EventInstance.EntryType%2A>的`instance`來定義您的事件項目分類和事件類型的輸入。</xref:System.Diagnostics.EventInstance.EntryType%2A> </xref:System.Diagnostics.EventInstance.CategoryId%2A> 您也可以指定要插入當地語系化的訊息文字的語言無關字串陣列。 設定`values`至`null`如果事件訊息未包含的取代字串格式化預留位置。       指定二進位資料時必須提供其他詳細資料事件的事件。 例如，使用`data`參數來包含特定錯誤的資訊。 事件檢視器不會解譯相關聯的事件資料。它會顯示資料組合的十六進位和文字格式。 謹慎使用; 使用特定的事件資料包含只有在確定會很有用。 您也可以使用特定的事件資料來儲存應用程式可以處理與事件檢視器無關的資訊。 例如，您可以編寫特別為您的事件檢視器，或編寫程式，以掃描事件記錄檔，並建立報告，其中包含從特定的事件資料的資訊。       指定的來源必須使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>.</xref:System.Diagnostics.EventLog.WriteEvent%2A>之前註冊事件記錄檔 指定的來源必須設定當地語系化的項目寫入記錄檔。來源最小值必須已定義的訊息資源檔。       您必須建立並設定事件來源寫入來源的第一個項目之前。 在您的應用程式的安裝期間建立新的事件來源。 這可讓作業系統重新整理其已註冊的事件來源的清單和其設定的時間。 如果作業系統不重新整理其事件來源的清單，而且您嘗試寫入的事件，該新的來源寫入作業將會失敗。 您可以設定新的來源使用<xref:System.Diagnostics.EventLogInstaller>，或使用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法。</xref:System.Diagnostics.EventLog.CreateEventSource%2A> </xref:System.Diagnostics.EventLogInstaller> 您必須建立新的事件來源電腦上具有系統管理權限。       必須設定來源，寫入當地語系化的項目或寫入直接的字串。 使用<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，如果您的應用程式寫入的字串值，直接以事件記錄檔。</xref:System.Diagnostics.EventLog.WriteEntry%2A>       如果您的應用程式將使用的資源識別元和字串值的項目寫入，您必須註冊兩個不同的來源。 例如，設定一個來源的資源檔，然後使用 該<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法來寫入項目使用事件記錄檔的資源識別項</xref:System.Diagnostics.EventLog.WriteEvent%2A>中的來源 然後建立不同的來源，如果沒有資源檔，並使用該來源中的<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法，將使用該來源的事件記錄檔中直接寫入字串。</xref:System.Diagnostics.EventLog.WriteEntry%2A>"
  example:
  - "The following example writes an informational event entry and a warning event entry to an existing event log. The event message text is specified using a resource identifier in a resource file. The example assumes the corresponding resource file has been registered for the source.  \n  \n [!code-cpp[EventLog_WriteEvent#8](~/add/codesnippet/cpp/d4971002-e0d1-493b-96f8-_1.cpp)]\n [!code-vb[EventLog_WriteEvent#8](~/add/codesnippet/visualbasic/d4971002-e0d1-493b-96f8-_1.vb)]\n [!code-cs[EventLog_WriteEvent#8](~/add/codesnippet/csharp/d4971002-e0d1-493b-96f8-_1.cs)]  \n  \n The example uses the following message text file, built into the resource library EventLogMsgs.dll. A message text file is the source from which the message resource file is created. The message text file defines the resource identifiers and text for the category, event message, and parameter insertion strings.  \n  \n```  \n; // EventLogMsgs.mc  \n; // ********************************************************  \n  \n; // Use the following commands to build this file:  \n  \n; //   mc -s EventLogMsgs.mc  \n; //   rc EventLogMsgs.rc  \n; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   \n; // ********************************************************  \n  \n; // - Event categories -  \n; // Categories must be numbered consecutively starting at 1.  \n; // ********************************************************  \n  \nMessageId=0x1  \nSeverity=Success  \nSymbolicName=INSTALL_CATEGORY  \nLanguage=English  \nInstallation  \n.  \n  \nMessageId=0x2  \nSeverity=Success  \nSymbolicName=QUERY_CATEGORY  \nLanguage=English  \nDatabase Query  \n.  \n  \nMessageId=0x3  \nSeverity=Success  \nSymbolicName=REFRESH_CATEGORY  \nLanguage=English  \nData Refresh  \n.  \n  \n; // - Event messages -  \n; // *********************************  \n  \nMessageId = 1000  \nSeverity = Success  \nFacility = Application  \nSymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  \nLanguage=English  \nMy application message text, in English, for message id 1000, called from %1.  \n.  \n  \nMessageId = 1001  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  \nLanguage=English  \nMy application message text, in English, for message id 1001, called from %1.  \n.  \n  \nMessageId = 1002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = GENERIC_INFO_MESSAGE_ID_1002  \nLanguage=English  \nMy generic information message in English, for message id 1002.  \n.  \n  \nMessageId = 1003  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  \nLanguage=English  \nMy generic warning message in English, for message id 1003, called from %1.  \n.  \n  \nMessageId = 1004  \nSeverity = Success  \nFacility = Application  \nSymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  \nLanguage=English  \nThe update cycle is complete for %%5002.  \n.  \n  \nMessageId = 1005  \nSeverity = Warning  \nFacility = Application  \nSymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  \nLanguage=English  \nThe refresh operation did not complete because the connection to server %1 could not be established.  \n.  \n  \n; // - Event log display name -  \n; // ********************************************************  \n  \nMessageId = 5001  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  \nLanguage=English  \nSample Event Log  \n.  \n  \n; // - Event message parameters -  \n; //   Language independent insertion strings  \n; // ********************************************************  \n  \nMessageId = 5002  \nSeverity = Success  \nFacility = Application  \nSymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  \nLanguage=English  \nSVC_UPDATE.EXE  \n.  \n```"
  syntax:
    content: public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, object[] values);
    parameters:
    - id: source
      type: System.String
      description: "註冊指定的電腦上的應用程式的事件來源的名稱。"
    - id: instance
      type: System.Diagnostics.EventInstance
      description: "<xref href=&quot;System.Diagnostics.EventInstance&quot;> </xref>執行個體，表示當地語系化的事件記錄項目。"
    - id: data
      type: System.Byte[]
      description: "保存與項目相關聯的二進位資料的位元組陣列。"
    - id: values
      type: System.Object[]
      description: "要合併到事件記錄檔項目的訊息文字的字串陣列。"
  overload: System.Diagnostics.EventLog.WriteEvent*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>source</code> value is an empty string (\"\").  \n  \n \\- or -  \n  \n The <code>source</code> value is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>instance.InstanceId</code> is less than zero or greater than &lt;xref:System.UInt16.MaxValue?displayProperty=fullName&gt;.  \n  \n \\- or -  \n  \n <code>values</code> has more than 256 elements.  \n  \n \\- or -  \n  \n One of the <code>values</code> elements is longer than 32766 bytes.  \n  \n \\- or -  \n  \n The source name results in a registry key path longer than 254 characters."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>instance</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法開啟事件記錄檔的登錄機碼。"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "事件項目寫入事件記錄檔時，作業系統回報錯誤。 無法使用 Windows 錯誤程式碼。"
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.Diagnostics.EventLog.#ctor
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog()
  nameWithType: EventLog.EventLog()
  fullName: System.Diagnostics.EventLog.EventLog()
- uid: System.Diagnostics.EventLog.#ctor(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String)
  nameWithType: EventLog.EventLog(String)
  fullName: System.Diagnostics.EventLog.EventLog(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String)
  nameWithType: EventLog.EventLog(String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String)
- uid: System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog(String,String,String)
  nameWithType: EventLog.EventLog(String,String,String)
  fullName: System.Diagnostics.EventLog.EventLog(String,String,String)
- uid: System.Diagnostics.EventLog.BeginInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit()
  nameWithType: EventLog.BeginInit()
  fullName: System.Diagnostics.EventLog.BeginInit()
- uid: System.Diagnostics.EventLog.Clear
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear()
  nameWithType: EventLog.Clear()
  fullName: System.Diagnostics.EventLog.Clear()
- uid: System.Diagnostics.EventLog.Close
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close()
  nameWithType: EventLog.Close()
  fullName: System.Diagnostics.EventLog.Close()
- uid: System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(EventSourceCreationData)
  nameWithType: EventLog.CreateEventSource(EventSourceCreationData)
  fullName: System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData)
- uid: System.Diagnostics.EventSourceCreationData
  parent: System.Diagnostics
  isExternal: false
  name: EventSourceCreationData
  nameWithType: EventSourceCreationData
  fullName: System.Diagnostics.EventSourceCreationData
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String)
  nameWithType: EventLog.CreateEventSource(String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String)
- uid: System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource(String,String,String)
  nameWithType: EventLog.CreateEventSource(String,String,String)
  fullName: System.Diagnostics.EventLog.CreateEventSource(String,String,String)
- uid: System.Diagnostics.EventLog.Delete(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String)
  nameWithType: EventLog.Delete(String)
  fullName: System.Diagnostics.EventLog.Delete(String)
- uid: System.Diagnostics.EventLog.Delete(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete(String,String)
  nameWithType: EventLog.Delete(String,String)
  fullName: System.Diagnostics.EventLog.Delete(String,String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String)
  nameWithType: EventLog.DeleteEventSource(String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String)
- uid: System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource(String,String)
  nameWithType: EventLog.DeleteEventSource(String,String)
  fullName: System.Diagnostics.EventLog.DeleteEventSource(String,String)
- uid: System.Diagnostics.EventLog.Dispose(System.Boolean)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: EventLog.Dispose(Boolean)
  fullName: System.Diagnostics.EventLog.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Diagnostics.EventLog.EnableRaisingEvents
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
  fullName: System.Diagnostics.EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit()
  nameWithType: EventLog.EndInit()
  fullName: System.Diagnostics.EventLog.EndInit()
- uid: System.Diagnostics.EventLog.Entries
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
  fullName: System.Diagnostics.EventLog.Entries
- uid: System.Diagnostics.EventLogEntryCollection
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryCollection
  nameWithType: EventLogEntryCollection
  fullName: System.Diagnostics.EventLogEntryCollection
- uid: System.Diagnostics.EventLog.EntryWritten
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EntryWritten
  nameWithType: EventLog.EntryWritten
  fullName: System.Diagnostics.EventLog.EntryWritten
- uid: System.Diagnostics.EntryWrittenEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: EntryWrittenEventHandler
  nameWithType: EntryWrittenEventHandler
  fullName: System.Diagnostics.EntryWrittenEventHandler
- uid: System.Diagnostics.EventLog.Exists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String)
  nameWithType: EventLog.Exists(String)
  fullName: System.Diagnostics.EventLog.Exists(String)
- uid: System.Diagnostics.EventLog.Exists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists(String,String)
  nameWithType: EventLog.Exists(String,String)
  fullName: System.Diagnostics.EventLog.Exists(String,String)
- uid: System.Diagnostics.EventLog.GetEventLogs
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs()
  nameWithType: EventLog.GetEventLogs()
  fullName: System.Diagnostics.EventLog.GetEventLogs()
- uid: System.Diagnostics.EventLog[]
  parent: System.Diagnostics
  isExternal: false
  name: EventLog
  nameWithType: EventLog
  fullName: System.Diagnostics.EventLog[]
  spec.csharp:
  - uid: System.Diagnostics.EventLog
    name: EventLog
    nameWithType: EventLog
    fullName: EventLog[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.GetEventLogs(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs(String)
  nameWithType: EventLog.GetEventLogs(String)
  fullName: System.Diagnostics.EventLog.GetEventLogs(String)
- uid: System.Diagnostics.EventLog.Log
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
  fullName: System.Diagnostics.EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
  fullName: System.Diagnostics.EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName(String,String)
  nameWithType: EventLog.LogNameFromSourceName(String,String)
  fullName: System.Diagnostics.EventLog.LogNameFromSourceName(String,String)
- uid: System.Diagnostics.EventLog.MachineName
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
  fullName: System.Diagnostics.EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
  fullName: System.Diagnostics.EventLog.MaximumKilobytes
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Diagnostics.EventLog.MinimumRetentionDays
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
  fullName: System.Diagnostics.EventLog.MinimumRetentionDays
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy(OverflowAction,Int32)
  nameWithType: EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
  fullName: System.Diagnostics.EventLog.ModifyOverflowPolicy(OverflowAction,Int32)
- uid: System.Diagnostics.OverflowAction
  parent: System.Diagnostics
  isExternal: false
  name: OverflowAction
  nameWithType: OverflowAction
  fullName: System.Diagnostics.OverflowAction
- uid: System.Diagnostics.EventLog.OverflowAction
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
  fullName: System.Diagnostics.EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName(String,Int64)
  nameWithType: EventLog.RegisterDisplayName(String,Int64)
  fullName: System.Diagnostics.EventLog.RegisterDisplayName(String,Int64)
- uid: System.Diagnostics.EventLog.Source
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
  fullName: System.Diagnostics.EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String)
  nameWithType: EventLog.SourceExists(String)
  fullName: System.Diagnostics.EventLog.SourceExists(String)
- uid: System.Diagnostics.EventLog.SourceExists(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists(String,String)
  nameWithType: EventLog.SourceExists(String,String)
  fullName: System.Diagnostics.EventLog.SourceExists(String,String)
- uid: System.Diagnostics.EventLog.SynchronizingObject
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
  fullName: System.Diagnostics.EventLog.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Diagnostics.EventLog.WriteEntry(System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String)
  nameWithType: EventLog.WriteEntry(String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType)
- uid: System.Diagnostics.EventLogEntryType
  parent: System.Diagnostics
  isExternal: false
  name: EventLogEntryType
  nameWithType: EventLogEntryType
  fullName: System.Diagnostics.EventLogEntryType
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String)
  nameWithType: EventLog.WriteEntry(String,String)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16)
- uid: System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  nameWithType: EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
  fullName: System.Diagnostics.EventLog.WriteEntry(String,String,EventLogEntryType,Int32,Int16,Byte[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Object[])
- uid: System.Diagnostics.EventInstance
  parent: System.Diagnostics
  isExternal: false
  name: EventInstance
  nameWithType: EventInstance
  fullName: System.Diagnostics.EventInstance
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Object[])
- uid: System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent(String,EventInstance,Byte[],Object[])
  nameWithType: EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
  fullName: System.Diagnostics.EventLog.WriteEvent(String,EventInstance,Byte[],Object[])
- uid: System.Diagnostics.EventLog.#ctor*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EventLog
  nameWithType: EventLog.EventLog
- uid: System.Diagnostics.EventLog.BeginInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: BeginInit
  nameWithType: EventLog.BeginInit
- uid: System.Diagnostics.EventLog.Clear*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Clear
  nameWithType: EventLog.Clear
- uid: System.Diagnostics.EventLog.Close*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Close
  nameWithType: EventLog.Close
- uid: System.Diagnostics.EventLog.CreateEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: CreateEventSource
  nameWithType: EventLog.CreateEventSource
- uid: System.Diagnostics.EventLog.Delete*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Delete
  nameWithType: EventLog.Delete
- uid: System.Diagnostics.EventLog.DeleteEventSource*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: DeleteEventSource
  nameWithType: EventLog.DeleteEventSource
- uid: System.Diagnostics.EventLog.Dispose*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Dispose
  nameWithType: EventLog.Dispose
- uid: System.Diagnostics.EventLog.EnableRaisingEvents*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EnableRaisingEvents
  nameWithType: EventLog.EnableRaisingEvents
- uid: System.Diagnostics.EventLog.EndInit*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: EndInit
  nameWithType: EventLog.EndInit
- uid: System.Diagnostics.EventLog.Entries*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Entries
  nameWithType: EventLog.Entries
- uid: System.Diagnostics.EventLog.Exists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Exists
  nameWithType: EventLog.Exists
- uid: System.Diagnostics.EventLog.GetEventLogs*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: GetEventLogs
  nameWithType: EventLog.GetEventLogs
- uid: System.Diagnostics.EventLog.Log*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Log
  nameWithType: EventLog.Log
- uid: System.Diagnostics.EventLog.LogDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogDisplayName
  nameWithType: EventLog.LogDisplayName
- uid: System.Diagnostics.EventLog.LogNameFromSourceName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: LogNameFromSourceName
  nameWithType: EventLog.LogNameFromSourceName
- uid: System.Diagnostics.EventLog.MachineName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MachineName
  nameWithType: EventLog.MachineName
- uid: System.Diagnostics.EventLog.MaximumKilobytes*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MaximumKilobytes
  nameWithType: EventLog.MaximumKilobytes
- uid: System.Diagnostics.EventLog.MinimumRetentionDays*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: MinimumRetentionDays
  nameWithType: EventLog.MinimumRetentionDays
- uid: System.Diagnostics.EventLog.ModifyOverflowPolicy*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: ModifyOverflowPolicy
  nameWithType: EventLog.ModifyOverflowPolicy
- uid: System.Diagnostics.EventLog.OverflowAction*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: OverflowAction
  nameWithType: EventLog.OverflowAction
- uid: System.Diagnostics.EventLog.RegisterDisplayName*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: RegisterDisplayName
  nameWithType: EventLog.RegisterDisplayName
- uid: System.Diagnostics.EventLog.Source*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: Source
  nameWithType: EventLog.Source
- uid: System.Diagnostics.EventLog.SourceExists*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SourceExists
  nameWithType: EventLog.SourceExists
- uid: System.Diagnostics.EventLog.SynchronizingObject*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: SynchronizingObject
  nameWithType: EventLog.SynchronizingObject
- uid: System.Diagnostics.EventLog.WriteEntry*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEntry
  nameWithType: EventLog.WriteEntry
- uid: System.Diagnostics.EventLog.WriteEvent*
  parent: System.Diagnostics.EventLog
  isExternal: false
  name: WriteEvent
  nameWithType: EventLog.WriteEvent
