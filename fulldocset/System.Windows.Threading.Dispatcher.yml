### YamlMime:ManagedReference
items:
- uid: System.Windows.Threading.Dispatcher
  id: Dispatcher
  children:
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.CheckAccess
  - System.Windows.Threading.Dispatcher.CurrentDispatcher
  - System.Windows.Threading.Dispatcher.DisableProcessing
  - System.Windows.Threading.Dispatcher.ExitAllFrames
  - System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  - System.Windows.Threading.Dispatcher.HasShutdownFinished
  - System.Windows.Threading.Dispatcher.HasShutdownStarted
  - System.Windows.Threading.Dispatcher.Hooks
  - System.Windows.Threading.Dispatcher.Invoke(System.Action)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  - System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  - System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  - System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  - System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  - System.Windows.Threading.Dispatcher.InvokeShutdown
  - System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  - System.Windows.Threading.Dispatcher.Run
  - System.Windows.Threading.Dispatcher.ShutdownFinished
  - System.Windows.Threading.Dispatcher.ShutdownStarted
  - System.Windows.Threading.Dispatcher.Thread
  - System.Windows.Threading.Dispatcher.UnhandledException
  - System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  - System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  - System.Windows.Threading.Dispatcher.VerifyAccess
  - System.Windows.Threading.Dispatcher.Yield
  - System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  langs:
  - csharp
  name: Dispatcher
  nameWithType: Dispatcher
  fullName: System.Windows.Threading.Dispatcher
  type: Class
  summary: "提供用於管理執行緒的工作項目佇列的服務。"
  remarks: "發送器會維護優先順序的佇列特定執行緒的工作項目。       發送器執行緒上建立時，即使關閉發送器會變成只可以與執行緒相關聯的發送器。       如果您嘗試取得<xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>目前的執行緒和發送器未與執行緒相關聯，則將會建立發送器。</xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> 當您建立<xref:System.Windows.Threading.DispatcherObject>.</xref:System.Windows.Threading.DispatcherObject>時，也會建立發送器 如果您在背景執行緒上建立的發送器，請務必關閉發送器在結束的執行緒之前。       如果發送器關閉時，就無法重新啟動。       在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]、<xref:System.Windows.Threading.DispatcherObject>只能存取由發送器相關聯。</xref:System.Windows.Threading.DispatcherObject>  例如，背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>與發送器關聯上[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]執行緒。</xref:System.Windows.Controls.Button>  為了讓背景執行緒存取<xref:System.Windows.Controls.ContentControl.Content%2A>屬性<xref:System.Windows.Controls.Button>，背景執行緒必須委派至發送器相關聯的工作[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]執行緒。</xref:System.Windows.Controls.Button> </xref:System.Windows.Controls.ContentControl.Content%2A>  這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  作業加入佇列的位置指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority>發送器       如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>呼叫的已關閉的 status 屬性<xref:System.Windows.Threading.DispatcherOperation>設為<xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus></xref:System.Windows.Threading.DispatcherOperation>傳回的發送器上</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       所有發生的例外狀況的方法上發送器， <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>，是無限制執行緒。</xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>       衍生自<xref:System.Windows.Threading.DispatcherObject>具有執行緒相似性。</xref:System.Windows.Threading.DispatcherObject>       衍生自<xref:System.Windows.Freezable>是無限制執行緒時就會凍結。</xref:System.Windows.Freezable>  如需詳細資訊，請參閱[Freezable 物件概觀](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example shows how to place an operation onto a Dispatcher.  For the full source code of this example, see [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  \n  \n First, a delegate is created that accepts no arguments.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/visualbasic/t-system.windows.threadi_2_1.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/csharp/t-system.windows.threadi_2_1.cs)]  \n  \n Next, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> is called.  This call to <xref:System.Windows.Threading.Dispatcher.BeginInvoke%28System.Windows.Threading.DispatcherPriority%2CSystem.Delegate%29> takes two parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>, and the callback, which is passed in through an instance of the delegate `NextPrimeDelegate`.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/visualbasic/t-system.windows.threadi_2_2.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/csharp/t-system.windows.threadi_2_2.cs)]"
  syntax:
    content: public sealed class Dispatcher
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  id: BeginInvoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(Delegate,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在執行緒上執行指定的委派，使用指定的引數以非同步方式， <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>上建立。"
  remarks: "<xref:System.Windows.Threading.DispatcherOperation>所傳回物件<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可以用數種方式，與指定的委派，例如互動:-變更<xref:System.Windows.Threading.DispatcherPriority>委派的暫止，所以執行事件佇列中。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -從事件佇列中移除的委派。      -正在等候要傳回的委派。      -取得委派之後，它會傳回的值會執行。       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。因此，控制項會立即傳回呼叫的物件後呼叫。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject> 例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button> 為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> 這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> 作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>呼叫<xref:System.Windows.Threading.Dispatcher>的已關閉，<xref:System.Windows.Threading.DispatcherOperation>會設定為<xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus></xref:System.Windows.Threading.DispatcherOperation>傳回的 status 屬性</xref:System.Windows.Threading.Dispatcher></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "參數中指定的方法委派`args`，這會推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    - id: args
      type: System.Object[]
      description: "做為引數傳遞至指定方法的物件陣列。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "物件，傳回後立即<xref:System.Windows.Threading.Dispatcher.BeginInvoke*>呼叫時，可用以互動的委派，因為它是暫止執行的事件佇列。</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在執行緒上執行指定的委派，以非同步方式在指定的優先順序<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。"
  remarks: "如果同時進行多個 BeginInvoke 呼叫<xref:System.Windows.Threading.DispatcherPriority>，將會執行被呼叫的順序。</xref:System.Windows.Threading.DispatcherPriority>       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>傳回<xref:System.Windows.Threading.DispatcherOperation>物件，可以用互動與委派，當委派被在事件佇列。</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       <xref:System.Windows.Threading.DispatcherOperation>所傳回物件<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可以用數種方式，與指定的委派，例如互動:-變更<xref:System.Windows.Threading.DispatcherPriority>委派的暫止，所以執行事件佇列中。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -從事件佇列中移除的委派。      -正在等候要傳回的委派。      -取得委派之後，它會傳回的值會執行。       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。因此，控制項會立即傳回呼叫的物件後呼叫。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject>  例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button>  為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>呼叫<xref:System.Windows.Threading.Dispatcher>的已關閉，<xref:System.Windows.Threading.DispatcherOperation>會設定為<xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus></xref:System.Windows.Threading.DispatcherOperation>傳回的 status 屬性</xref:System.Windows.Threading.Dispatcher></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  example:
  - "The following example shows how to place an operation onto a <xref:System.Windows.Threading.Dispatcher>.  For the full source code of this example, see [Single-Threaded Application with Long-Running Calculation Sample](http://go.microsoft.com/fwlink/?LinkID=160038).  \n  \n First, a delegate is created that accepts no arguments.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/visualbasic/8c08cb62-5b5f-4560-a7bd-_1.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberInit](~/add/codesnippet/csharp/8c08cb62-5b5f-4560-a7bd-_1.cs)]  \n  \n Next, BeginInvoke is called.  Because every <xref:System.Windows.Threading.DispatcherObject> has a property that returns the <xref:System.Windows.Threading.Dispatcher> it is associated with, the desired <xref:System.Windows.Threading.Dispatcher> is obtained by querying the <xref:System.Windows.Threading.DispatcherObject>, in this case a <xref:System.Windows.Controls.Button> named `startStopButton`.   The call to BeginInvoke takes two parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>, and the callback, which is passed in through an instance of the delegate `NextPrimeDelegate`.  \n  \n [!code-vb[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/visualbasic/8c08cb62-5b5f-4560-a7bd-_2.vb)]\n [!code-cs[ThreadingPrimeNumber#ThreadingPrimeNumberBeingInvoke](~/add/codesnippet/csharp/8c08cb62-5b5f-4560-a7bd-_2.cs)]"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "優先權，相較於其他暫止的作業中<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列中，指定的方法會叫用。"
    - id: method
      type: System.Delegate
      description: "方法的委派，採用任何引數，這會推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "物件，傳回後立即<xref:System.Windows.Threading.Dispatcher.BeginInvoke*>呼叫時，可用以互動的委派，因為它是暫止執行的事件佇列。</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在執行緒上執行指定的委派，使用指定的引數，以指定的優先權，以非同步方式， <xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>上建立。"
  remarks: "<xref:System.Windows.Threading.DispatcherOperation>所傳回物件<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可以用數種方式，與指定的委派，例如互動:-變更<xref:System.Windows.Threading.DispatcherPriority>委派的暫止，所以執行事件佇列中。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -從事件佇列中移除的委派。      -正在等候要傳回的委派。      -取得委派之後，它會傳回的值會執行。       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。因此，控制項會立即傳回呼叫的物件後呼叫。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject> 例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button> 為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> 這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> 作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>呼叫<xref:System.Windows.Threading.Dispatcher>的已關閉，<xref:System.Windows.Threading.DispatcherOperation>會設定為<xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus></xref:System.Windows.Threading.DispatcherOperation>傳回的 status 屬性</xref:System.Windows.Threading.Dispatcher></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "參數中指定的方法委派`args`，這會推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "優先權，相較於其他暫止的作業中<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列中，指定的方法會叫用。"
    - id: args
      type: System.Object[]
      description: "做為引數傳遞至指定方法的物件陣列。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "物件，傳回後立即<xref:System.Windows.Threading.Dispatcher.BeginInvoke*>呼叫時，可用以互動的委派，因為它是暫止執行的事件佇列。</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "執行緒上執行指定的委派，以指定的引數，以非同步方式在指定的優先順序<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。"
  remarks: "`Arg`可以是`null`如果不需要任何引數。       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>傳回<xref:System.Windows.Threading.DispatcherOperation>物件，可以用互動與委派，當委派被在事件佇列。</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       <xref:System.Windows.Threading.DispatcherOperation>所傳回物件<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可以用數種方式，與指定的委派，例如互動:-變更<xref:System.Windows.Threading.DispatcherPriority>委派的暫止，所以執行事件佇列中。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -從事件佇列中移除的委派。      -正在等候要傳回的委派。      -取得委派之後，它會傳回的值會執行。       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。因此，控制項會立即傳回呼叫的物件後呼叫。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject>  例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button>  為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       若為多個<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>呼叫會在相同<xref:System.Windows.Threading.DispatcherPriority>，將會執行被呼叫的順序。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>呼叫<xref:System.Windows.Threading.Dispatcher>的已關閉，<xref:System.Windows.Threading.DispatcherOperation>會設定為<xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus></xref:System.Windows.Threading.DispatcherOperation>傳回的 status 屬性</xref:System.Windows.Threading.Dispatcher></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  example:
  - "The following example shows how to place an operation onto a <xref:System.Windows.Threading.Dispatcher>.  \n  \n First, a delegate is created that accepts one argument, in this case a string.  \n  \n [!code-vb[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/add/codesnippet/visualbasic/threadingweatherforecastsample/window1.xaml.vb#threadingweatherdelegates)]\n [!code-cs[ThreadingWeatherForecast#ThreadingWeatherDelegates](~/add/codesnippet/csharp/ThreadingWeatherForecastSample/Window1.xaml.cs#threadingweatherdelegates)]  \n  \n Next, BeginInvoke is called.  Because every <xref:System.Windows.Threading.DispatcherObject> has a property that returns the <xref:System.Windows.Threading.Dispatcher> it is associated with, the desired <xref:System.Windows.Threading.Dispatcher> is obtained by querying the <xref:System.Windows.Threading.DispatcherObject>, in this case a <xref:System.Windows.Controls.Grid> named `tomorrowsWeather`. The call to BeginInvoke takes three parameters: the priority, which is set to <xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>; the callback, which is passed in through an instance of the delegate `OneArgDelegate`; and a string named `weather`, which is the argument for the callback.  \n  \n [!code-vb[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/add/codesnippet/visualbasic/threadingweatherforecastsample/window1.xaml.vb#threadingweatherdispatcheronearge)]\n [!code-cs[threadingweatherforecast#ThreadingWeatherDispatcherOneArge](~/add/codesnippet/csharp/ThreadingWeatherForecastSample/Window1.xaml.cs#threadingweatherdispatcheronearge)]"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "優先權，相較於其他暫止的作業中<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列中，指定的方法會叫用。"
    - id: method
      type: System.Delegate
      description: "委派的方法會接受一個引數，推入至<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    - id: arg
      type: System.Object
      description: "要做為引數傳遞至指定方法的物件。"
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "物件，傳回後立即<xref:System.Windows.Threading.Dispatcher.BeginInvoke*>呼叫時，可用以互動的委派，因為它是暫止執行的事件佇列。</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  id: BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "執行緒上執行指定的委派，以指定的引數的陣列，以非同步方式在指定的優先順序<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。"
  remarks: "`arg`參數可以是`null`如果不需要任何引數。       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>傳回<xref:System.Windows.Threading.DispatcherOperation>物件，可以用互動與委派，當委派被在事件佇列。</xref:System.Windows.Threading.DispatcherOperation></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       <xref:System.Windows.Threading.DispatcherOperation>所傳回物件<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>可以用數種方式，與指定的委派，例如互動:-變更<xref:System.Windows.Threading.DispatcherPriority>委派的暫止，所以執行事件佇列中。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.DispatcherOperation>      -從事件佇列中移除的委派。      -正在等候要傳回的委派。      -取得委派之後，它會傳回的值會執行。       <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。因此，控制項會立即傳回呼叫的物件後呼叫。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject>  例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button>  為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       若為多個<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>呼叫會在相同<xref:System.Windows.Threading.DispatcherPriority>，將會執行被呼叫的順序。</xref:System.Windows.Threading.DispatcherPriority> </xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>       如果<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>呼叫<xref:System.Windows.Threading.Dispatcher>的已關閉，<xref:System.Windows.Threading.DispatcherOperation>會設定為<xref:System.Windows.Threading.DispatcherOperationStatus>.</xref:System.Windows.Threading.DispatcherOperationStatus></xref:System.Windows.Threading.DispatcherOperation>傳回的 status 屬性</xref:System.Windows.Threading.Dispatcher></xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation BeginInvoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "優先權，相較於其他暫止的作業中<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列中，指定的方法會叫用。"
    - id: method
      type: System.Delegate
      description: "方法的委派，使用多個引數，這會推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    - id: arg
      type: System.Object
      description: "要做為引數傳遞至指定方法的物件。"
    - id: args
      type: System.Object[]
      description: "做為引數傳遞至指定方法的物件陣列。"
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "物件，傳回後立即<xref:System.Windows.Threading.Dispatcher.BeginInvoke*>呼叫時，可用互動與委派，因為它是暫止中的執行<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>佇列。</xref:System.Windows.Threading.Dispatcher.BeginInvoke*>"
  overload: System.Windows.Threading.Dispatcher.BeginInvoke*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;></xref>不是有效的優先順序。"
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  id: BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: BeginInvokeShutdown(DispatcherPriority)
  nameWithType: Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "起始關機的<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>以非同步的方式。"
  remarks: "BeginInvokeShutdown 要求不受限制的 UI 權限。       當<xref:System.Windows.Threading.Dispatcher>開始關閉，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>就會引發事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>設`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>便不會關閉完全直到事件佇列會回溯。</xref:System.Windows.Threading.Dispatcher>       當發送器完成關閉，<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>就會引發事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>屬性設定為`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       關機程序開始時，所有暫止的工作佇列中的項目都被中止。"
  syntax:
    content: public void BeginInvokeShutdown (System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "要開始進行關閉發送器優先權。"
  overload: System.Windows.Threading.Dispatcher.BeginInvokeShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.CheckAccess
  id: CheckAccess
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: CheckAccess()
  nameWithType: Dispatcher.CheckAccess()
  fullName: System.Windows.Threading.Dispatcher.CheckAccess()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "判斷呼叫的執行緒是否與此相關聯的執行緒<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
  remarks: "只有<xref:System.Windows.Threading.Dispatcher>，<xref:System.Windows.Threading.DispatcherObject>建立在可以存取的物件。</xref:System.Windows.Threading.DispatcherObject> </xref:System.Windows.Threading.Dispatcher>  使用<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>來從不同的執行緒存取的物件。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       CheckAccess 可以從任何執行緒呼叫。       CheckAccess 之間的差異和<xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>是 CheckAccess 傳回布林值，指出呼叫的執行緒是否有存取權<xref:System.Windows.Threading.Dispatcher>和<xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>擲回例外狀況。</xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.VerifyAccess%2A>"
  example:
  - "The following example uses CheckAccess to determine whether a thread has access to a <xref:System.Windows.Controls.Button>.  The CheckAccess method on the <xref:System.Windows.Threading.Dispatcher> associated with the <xref:System.Windows.Controls.Button> is called to verify access to the thread.  If the calling thread has access to the <xref:System.Windows.Threading.Dispatcher>, the <xref:System.Windows.Controls.Button> is updated by accessing the members of the <xref:System.Windows.Controls.Button>; otherwise, a delegate, which accepts a <xref:System.Windows.Controls.Button> as an argument, is placed onto the <xref:System.Windows.Threading.Dispatcher>.  The <xref:System.Windows.Threading.Dispatcher> will delegate the work of updating the <xref:System.Windows.Controls.Button>.  \n  \n [!code-cs[DispatcherAccessSample#DispatcherAccessCheckAccess](~/add/codesnippet/csharp/DispatcherAccessSample/Window1.xaml.cs#dispatcheraccesscheckaccess)]\n [!code-vb[DispatcherAccessSample#DispatcherAccessCheckAccess](~/add/codesnippet/visualbasic/dispatcheraccesssample/window1.xaml.vb#dispatcheraccesscheckaccess)]"
  syntax:
    content: public bool CheckAccess ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果呼叫執行緒是與此相關聯的執行緒<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Threading.Dispatcher.CheckAccess*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher
  id: CurrentDispatcher
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
  fullName: System.Windows.Threading.Dispatcher.CurrentDispatcher
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "取得<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>執行緒目前正在執行，並建立新<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>如果其中一個尚未與執行緒相關聯。"
  remarks: "如果<xref:System.Windows.Threading.Dispatcher>未與目前的執行緒相關聯的新<xref:System.Windows.Threading.Dispatcher>將會建立。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>  這不是使用的情況下<xref:System.Windows.Threading.Dispatcher.FromThread%2A>方法。</xref:System.Windows.Threading.Dispatcher.FromThread%2A>  <xref:System.Windows.Threading.Dispatcher.FromThread%2A>會傳回`null`如果不指定的執行緒相關聯的發送器。</xref:System.Windows.Threading.Dispatcher.FromThread%2A>"
  syntax:
    content: public static System.Windows.Threading.Dispatcher CurrentDispatcher { get; }
    return:
      type: System.Windows.Threading.Dispatcher
      description: "與目前執行緒關聯的發送器。"
  overload: System.Windows.Threading.Dispatcher.CurrentDispatcher*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.DisableProcessing
  id: DisableProcessing
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: DisableProcessing()
  nameWithType: Dispatcher.DisableProcessing()
  fullName: System.Windows.Threading.Dispatcher.DisableProcessing()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "停用處理<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>佇列。"
  remarks: "停用發送器處理是一種進階的方法，目的是要避免不相關的重新進入的機會。       停用處理的影響如下:-[!INCLUDE[TLA2#tla_clr#initcap](~/add/includes/tla2sharptla-clrsharpinitcap-md.md)]鎖定將會不提取的訊息在內部。      -<xref:System.Windows.Threading.DispatcherFrame>物件不允許推送。</xref:System.Windows.Threading.DispatcherFrame>      的不允許訊息處理。       <xref:System.Windows.Threading.DispatcherProcessingDisabled>DisableProcessing 傳回呼叫時的結構可用來重新啟用發送器處理。</xref:System.Windows.Threading.DispatcherProcessingDisabled>  呼叫<xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A>上<xref:System.Windows.Threading.DispatcherProcessingDisabled>結構重新啟用處理。</xref:System.Windows.Threading.DispatcherProcessingDisabled> </xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A>       只可以在執行緒上呼叫 DisableProcessing<xref:System.Windows.Threading.Dispatcher>相關聯。</xref:System.Windows.Threading.Dispatcher>"
  example:
  - "The following example shows how to disable dispatcher processing and re-enable dispatcher processing.  DisableProcessing is called in a **using** statement.  DisableProcessing returns a <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure that is used as the object to be disposed when the **using** block finishes.  When <xref:System.Windows.Threading.DispatcherProcessingDisabled.Dispose%2A> is called on the <xref:System.Windows.Threading.DispatcherProcessingDisabled> structure, dispatcher processing is re-enabled.  \n  \n [!code-vb[DispatcherSnippets#DispatcherDisableProcessing](~/add/codesnippet/visualbasic/dispatchersnippets/window1.xaml.vb#dispatcherdisableprocessing)]\n [!code-cs[DispatcherSnippets#DispatcherDisableProcessing](~/add/codesnippet/csharp/DispatcherSnippets/Window1.xaml.cs#dispatcherdisableprocessing)]"
  syntax:
    content: public System.Windows.Threading.DispatcherProcessingDisabled DisableProcessing ();
    parameters: []
    return:
      type: System.Windows.Threading.DispatcherProcessingDisabled
      description: "若要重新啟用發送器處理用的結構。"
  overload: System.Windows.Threading.Dispatcher.DisableProcessing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames
  id: ExitAllFrames
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ExitAllFrames()
  nameWithType: Dispatcher.ExitAllFrames()
  fullName: System.Windows.Threading.Dispatcher.ExitAllFrames()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "結束所有框架，包括巢狀的框架的要求。"
  syntax:
    content: public static void ExitAllFrames ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.ExitAllFrames*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  id: FromThread(System.Threading.Thread)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: FromThread(Thread)
  nameWithType: Dispatcher.FromThread(Thread)
  fullName: System.Windows.Threading.Dispatcher.FromThread(Thread)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "取得<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>針對指定的執行緒。"
  remarks: "如果無法使用指定的執行緒，發送器`null`會傳回。       FromThread 不會<xref:System.Windows.Threading.Dispatcher>在沒有<xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher>執行緒上</xref:System.Windows.Threading.Dispatcher>建立   新<xref:System.Windows.Threading.Dispatcher>還沒有執行緒上所建立<xref:System.Windows.Threading.Dispatcher>時嘗試取得<xref:System.Windows.Threading.Dispatcher>使用<xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>屬性。</xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>"
  syntax:
    content: public static System.Windows.Threading.Dispatcher FromThread (System.Threading.Thread thread);
    parameters:
    - id: thread
      type: System.Threading.Thread
      description: "若要取得執行緒<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>從。"
    return:
      type: System.Windows.Threading.Dispatcher
      description: "發送器<code> thread </code>。"
  overload: System.Windows.Threading.Dispatcher.FromThread*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished
  id: HasShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.HasShutdownFinished
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "決定是否<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>關閉已完成。"
  remarks: "當<xref:System.Windows.Threading.Dispatcher>開始關閉，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>就會引發事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>設`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>不完全會關閉，直到事件佇列會回溯。</xref:System.Windows.Threading.Dispatcher>       當發送器完成關閉，<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>就會引發事件和 HasShutdownFinished 屬性設定為`true`。</xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       關機程序開始時，所有暫止的工作佇列中的項目都被中止。"
  syntax:
    content: public bool HasShutdownFinished { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果發送器已完成關機;否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Threading.Dispatcher.HasShutdownFinished*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted
  id: HasShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.HasShutdownStarted
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "決定是否<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>正在關機而關閉。"
  remarks: "當<xref:System.Windows.Threading.Dispatcher>開始關閉，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>就會引發事件和 HasShutdownStarted 設`true`。</xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>便不會關閉完全直到事件佇列會回溯。</xref:System.Windows.Threading.Dispatcher>       當發送器完成關閉，<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>就會引發事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>屬性設定為`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       關機程序開始時，所有暫止的工作佇列中的項目都被中止。"
  syntax:
    content: public bool HasShutdownStarted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>已啟動正在關閉，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Threading.Dispatcher.HasShutdownStarted*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Hooks
  id: Hooks
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Hooks
  nameWithType: Dispatcher.Hooks
  fullName: System.Windows.Threading.Dispatcher.Hooks
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "取得攔截程序，提供下列其他事件資訊的集合<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
  remarks: "<xref:System.Windows.Threading.DispatcherHooks>類別提供有關的其他事件資訊<xref:System.Windows.Threading.Dispatcher>，例如當<xref:System.Windows.Threading.Dispatcher>非使用中或當作業完成。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.DispatcherHooks>"
  syntax:
    content: public System.Windows.Threading.DispatcherHooks Hooks { get; }
    return:
      type: System.Windows.Threading.DispatcherHooks
      description: "與此相關聯的攔截<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
  overload: System.Windows.Threading.Dispatcher.Hooks*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action)
  id: Invoke(System.Action)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action)
  nameWithType: Dispatcher.Invoke(Action)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "執行指定<xref:System.Action>的執行緒上同步<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback);
    parameters:
    - id: callback
      type: System.Action
      description: "若要透過發送器叫用委派。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "執行指定<xref:System.Action>以同步方式在指定的優先順序的執行緒上<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Action
      description: "若要透過發送器叫用委派。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "決定的順序指定叫用的回呼相較於其他暫止的作業中的優先順序<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  id: Invoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在執行緒上，以同步方式執行指定的引數與指定的委派<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。"
  remarks: "在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject> 例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button> 為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> 這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> 作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步作業。因此，控制項不會傳回至呼叫的物件直到回呼傳回之後。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "參數中指定的方法委派`args`，這會推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    - id: args
      type: System.Object[]
      description: "做為引數傳遞至指定方法的物件陣列。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "所叫用委派的傳回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委派沒有傳回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "所在的執行緒上執行指定的委派，以同步方式在指定的優先順序<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。"
  remarks: "在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject>  例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button>  為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步作業。因此，控制項不會傳回至呼叫的物件直到回呼傳回之後。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  example:
  - "The following example places a delegate onto a <xref:System.Windows.Threading.Dispatcher> at <xref:System.Windows.Threading.DispatcherPriority> using Invoke.  \n  \n [!code-vb[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/add/codesnippet/visualbasic/invalidaterequerywithsystemtimer/window1.xaml.vb#systemtimerdispatcherinvoke)]\n [!code-cs[invalidaterequerywithsystemtimer#SystemTimerDispatcherInvoke](~/add/codesnippet/csharp/InvalidateRequeryWithSystemTimer/Window1.xaml.cs#systemtimerdispatcherinvoke)]"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "優先權，相較於其他暫止的作業中<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列中，指定的方法會叫用。"
    - id: method
      type: System.Delegate
      description: "方法的委派，採用任何引數，這會推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    return:
      type: System.Object
      description: "所叫用委派的傳回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委派沒有傳回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>等於<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效的優先順序。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "執行指定<xref:System.Action>以同步方式在指定的優先順序的執行緒上<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Action
      description: "若要透過發送器叫用委派。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "決定的順序指定叫用的回呼相較於其他暫止的作業中的優先順序<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "物件，指出是否要取消此動作。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  id: Invoke(System.Delegate,System.TimeSpan,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,TimeSpan,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "以同步方式將指定的委派，在指定的優先順序，與指定的引數指定的時間範圍內執行的執行緒上<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。"
  remarks: "在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject> 例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button> 為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> 這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> 作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步作業。因此，控制項不會傳回至呼叫的物件直到回呼傳回之後。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, TimeSpan timeout, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "參數中指定的方法委派`args`，這會推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    - id: timeout
      type: System.TimeSpan
      description: "最大等待作業完成的時間量。"
    - id: args
      type: System.Object[]
      description: "做為引數傳遞至指定方法的物件陣列。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "所叫用委派的傳回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委派沒有傳回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在執行緒上，以同步方式執行指定的委派，在指定的引數的指定優先權<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。"
  remarks: "在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject> 例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button> 為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> 這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> 作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步作業。因此，控制項不會傳回至呼叫的物件直到回呼傳回之後。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "參數中指定的方法委派`args`，這會推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "優先權，相較於其他暫止的作業中<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列中，指定的方法會叫用。"
    - id: args
      type: System.Object[]
      description: "做為引數傳遞至指定方法的物件陣列。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "所叫用委派的傳回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委派沒有傳回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在執行緒上，以同步方式執行指定的委派，在指定的引數的指定優先權<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。"
  remarks: "`Arg`可以是`null`如果引數中不需要[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject>  例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button>  為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步作業。因此，控制項不會傳回至呼叫的物件直到回呼傳回之後。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "優先權，相較於其他暫止的作業中<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列中，指定的方法會叫用。"
    - id: method
      type: System.Delegate
      description: "委派的方法會接受一個引數，推入至<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    - id: arg
      type: System.Object
      description: "要做為引數傳遞至指定方法的物件。"
    return:
      type: System.Object
      description: "所叫用委派的傳回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委派沒有傳回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>等於<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效的優先順序。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "執行緒上執行指定的委派，以指定的逾時值，以同步方式在指定的優先順序<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>所建立。"
  remarks: "在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject>  例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button>  為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步作業。因此，控制項不會傳回至呼叫的物件直到回呼傳回之後。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "優先權，相較於其他暫止的作業中<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列中，指定的方法會叫用。"
    - id: timeout
      type: System.TimeSpan
      description: "等待作業完成的時間上限。"
    - id: method
      type: System.Delegate
      description: "方法的委派，採用任何引數，這會推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    return:
      type: System.Object
      description: "所叫用委派的傳回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委派沒有傳回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  id: Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "執行指定<xref:System.Action>以同步方式在指定的優先順序的執行緒上<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。</xref:System.Action>"
  syntax:
    content: public void Invoke (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);
    parameters:
    - id: callback
      type: System.Action
      description: "若要透過發送器叫用委派。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "決定的順序指定叫用的回呼相較於其他暫止的作業中的優先順序<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "物件，指出是否要取消此動作。"
    - id: timeout
      type: System.TimeSpan
      description: "最小等待啟動作業的時間量。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  id: Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "以同步方式將指定的委派，在指定的優先順序，與指定的引數指定的時間範圍內執行的執行緒上<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。"
  remarks: "在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject> 例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button> 為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button> 這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A> 作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步作業。因此，控制項不會傳回至呼叫的物件直到回呼傳回之後。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (Delegate method, TimeSpan timeout, System.Windows.Threading.DispatcherPriority priority, object[] args);
    parameters:
    - id: method
      type: System.Delegate
      description: "參數中指定的方法委派`args`，這會推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    - id: timeout
      type: System.TimeSpan
      description: "最大等待作業完成的時間量。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "優先權，相較於其他暫止的作業中<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列中，指定的方法會叫用。"
    - id: args
      type: System.Object[]
      description: "做為引數傳遞至指定方法的物件陣列。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "所叫用委派的傳回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委派沒有傳回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在執行緒上，以同步方式執行指定的委派，在指定的引數的指定優先權<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。"
  remarks: "`Arg`可以是`null`如果引數中不需要[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject>  例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button>  為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步作業。因此，控制項不會傳回至呼叫的物件直到回呼傳回之後。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "優先權，相較於其他暫止的作業中<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列中，指定的方法會叫用。"
    - id: method
      type: System.Delegate
      description: "方法的委派，使用多個引數，這會推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    - id: arg
      type: System.Object
      description: "要做為引數傳遞至指定方法的物件。"
    - id: args
      type: System.Object[]
      description: "做為引數傳遞至指定方法的物件陣列。"
    return:
      type: System.Object
      description: "所叫用委派的傳回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委派沒有傳回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>等於<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效的優先順序。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在執行緒上，以同步方式執行指定的委派，在指定的引數的指定優先權<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。"
  remarks: "`Arg`可以是`null`如果引數中不需要[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject>  例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button>  為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步作業。因此，控制項不會傳回至呼叫的物件直到回呼傳回之後。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "優先權，相較於其他暫止的作業中<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列中，指定的方法會叫用。"
    - id: timeout
      type: System.TimeSpan
      description: "等待作業完成的時間上限。"
    - id: method
      type: System.Delegate
      description: "方法的委派，使用多個引數，這會推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    - id: arg
      type: System.Object
      description: "要做為引數傳遞至指定方法的物件。 這可以是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果不需要任何引數。"
    return:
      type: System.Object
      description: "所叫用委派的傳回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委派沒有傳回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>等於<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效的優先順序。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  id: Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "在執行緒上，以同步方式執行指定的委派，在指定的引數的指定優先權<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。"
  remarks: "`Arg`可以是`null`如果不需要引數。       在[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]，建立的執行緒<xref:System.Windows.Threading.DispatcherObject>可以存取該物件。</xref:System.Windows.Threading.DispatcherObject>  例如，會開始從主要 UI 執行緒背景執行緒無法更新的內容<xref:System.Windows.Controls.Button>UI 執行緒上所建立。</xref:System.Windows.Controls.Button>  為了讓背景執行緒存取的內容屬性將<xref:System.Windows.Controls.Button>，背景執行緒必須委派工作給<xref:System.Windows.Threading.Dispatcher>與 UI 執行緒相關聯。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Controls.Button>  這會透過使用其中一個<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>  <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步方法，和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>為非同步。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A></xref:System.Windows.Threading.Dispatcher.Invoke%2A>  作業會加入到事件佇列<xref:System.Windows.Threading.Dispatcher>在指定<xref:System.Windows.Threading.DispatcherPriority>.</xref:System.Windows.Threading.DispatcherPriority></xref:System.Windows.Threading.Dispatcher>的       <xref:System.Windows.Threading.Dispatcher.Invoke%2A>是同步作業。因此，控制項不會傳回至呼叫的物件直到回呼傳回之後。</xref:System.Windows.Threading.Dispatcher.Invoke%2A>"
  syntax:
    content: public object Invoke (System.Windows.Threading.DispatcherPriority priority, TimeSpan timeout, Delegate method, object arg, object[] args);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "優先權，相較於其他暫止的作業中<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列中，指定的方法會叫用。"
    - id: timeout
      type: System.TimeSpan
      description: "等待作業完成的時間上限。"
    - id: method
      type: System.Delegate
      description: "方法的委派，使用多個引數，這會推送到<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>事件佇列。"
    - id: arg
      type: System.Object
      description: "要做為引數傳遞至指定方法的物件。"
    - id: args
      type: System.Object[]
      description: "做為引數傳遞至指定方法的物件陣列。"
    return:
      type: System.Object
      description: "所叫用委派的傳回值或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果委派沒有傳回值。"
  overload: System.Windows.Threading.Dispatcher.Invoke*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>priority</code>等於<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>method</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  id: Invoke``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>)
  nameWithType: Dispatcher.Invoke(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "即將加入。"
    return:
      type: TResult
      description: "即將加入。"
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "即將加入。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "即將加入。"
    return:
      type: TResult
      description: "即將加入。"
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "即將加入。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "即將加入。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "即將加入。"
    return:
      type: TResult
      description: "即將加入。"
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  id: Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public TResult Invoke<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken, TimeSpan timeout);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "即將加入。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "即將加入。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "即將加入。"
    - id: timeout
      type: System.TimeSpan
      description: "即將加入。"
    return:
      type: TResult
      description: "即將加入。"
  overload: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  id: InvokeAsync(System.Action)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action)
  nameWithType: Dispatcher.InvokeAsync(Action)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "執行指定<xref:System.Action>在執行緒上非同步<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback);
    parameters:
    - id: callback
      type: System.Action
      description: "若要透過發送器叫用委派。"
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "物件，稱為 InvokeAsync 之後立即傳回，可用以互動的委派，因為它是暫止執行的事件佇列。"
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  id: InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "執行指定<xref:System.Action>以非同步方式在指定的優先順序的執行緒上<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Action
      description: "若要透過發送器叫用委派。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "決定的順序指定叫用的回呼相較於其他暫止的作業中的優先順序<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "物件，稱為 InvokeAsync 之後立即傳回，可用以互動的委派，因為它是暫止執行的事件佇列。"
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "執行指定<xref:System.Action>以非同步方式在指定的優先順序的執行緒上<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。</xref:System.Action>"
  syntax:
    content: public System.Windows.Threading.DispatcherOperation InvokeAsync (Action callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Action
      description: "若要透過發送器叫用委派。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "決定的順序指定叫用的回呼相較於其他暫止的作業中的優先順序<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "物件，指出是否要取消此動作。"
    return:
      type: System.Windows.Threading.DispatcherOperation
      description: "物件，稱為 InvokeAsync 之後立即傳回，可用以互動的委派，因為它是暫止執行的事件佇列。"
  overload: System.Windows.Threading.Dispatcher.InvokeAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  id: InvokeAsync``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "即將加入。"
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "即將加入。"
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  id: InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "即將加入。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "即將加入。"
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "即將加入。"
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  id: InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  syntax:
    content: public System.Windows.Threading.DispatcherOperation<TResult> InvokeAsync<TResult> (Func<TResult> callback, System.Windows.Threading.DispatcherPriority priority, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: callback
      type: System.Func{TResult}
      description: "即將加入。"
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "即將加入。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "即將加入。"
    return:
      type: System.Windows.Threading.DispatcherOperation`1
      description: "即將加入。"
  overload: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown
  id: InvokeShutdown
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: InvokeShutdown()
  nameWithType: Dispatcher.InvokeShutdown()
  fullName: System.Windows.Threading.Dispatcher.InvokeShutdown()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "起始關機程序的<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>同步。"
  remarks: "InvokeShutdown 要求不受限制的 UI 權限。       當<xref:System.Windows.Threading.Dispatcher>開始關閉，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>就會引發事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>設`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>便不會關閉完全直到事件佇列會回溯。</xref:System.Windows.Threading.Dispatcher>       當發送器完成關閉，<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>就會引發事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>屬性設定為`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       關機程序開始時，所有暫止的工作佇列中的項目都被中止。"
  syntax:
    content: public void InvokeShutdown ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.InvokeShutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  id: PushFrame(System.Windows.Threading.DispatcherFrame)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: PushFrame(DispatcherFrame)
  nameWithType: Dispatcher.PushFrame(DispatcherFrame)
  fullName: System.Windows.Threading.Dispatcher.PushFrame(DispatcherFrame)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "輸入執行迴圈。"
  remarks: "A<xref:System.Windows.Threading.DispatcherFrame>代表處理暫止的工作項目迴圈。</xref:System.Windows.Threading.DispatcherFrame>       發送器處理迴圈中的工作項目佇列。  迴圈被指在範圍內。  初始迴圈通常藉由呼叫<xref:System.Windows.Threading.Dispatcher.Run%2A>.</xref:System.Windows.Threading.Dispatcher.Run%2A>起始應用程式       PushFrame 進入迴圈參數代表`frame`。  在迴圈的每個反覆項目<xref:System.Windows.Threading.Dispatcher>會檢查<xref:System.Windows.Threading.DispatcherFrame.Continue%2A>屬性<xref:System.Windows.Threading.DispatcherFrame>類別以決定迴圈是否應該繼續，或如果應該停止。</xref:System.Windows.Threading.DispatcherFrame> </xref:System.Windows.Threading.DispatcherFrame.Continue%2A> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.DispatcherFrame>允許的<xref:System.Windows.Threading.DispatcherFrame.Continue%2A>屬性來明確設定，而且它會遵守<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A><xref:System.Windows.Threading.Dispatcher>。</xref:System.Windows.Threading.Dispatcher>屬性</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A></xref:System.Windows.Threading.DispatcherFrame.Continue%2A></xref:System.Windows.Threading.DispatcherFrame>  這表示當<xref:System.Windows.Threading.Dispatcher>關閉啟動，使用預設的框架<xref:System.Windows.Threading.DispatcherFrame>實作將會結束，可讓所有巢狀的畫面格結束。</xref:System.Windows.Threading.DispatcherFrame> </xref:System.Windows.Threading.Dispatcher>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Threading.DispatcherFrame> to achieve similar results as the [!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)] <xref:System.Windows.Forms.Application.DoEvents%2A> method.  \n  \n [!code-vb[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/add/codesnippet/visualbasic/dispatchersnippets/window1.xaml.vb#dispatcherdispatcherframedoevents)]\n [!code-cs[dispatchersnippets#DispatcherDispatcherFrameDoEvents](~/add/codesnippet/csharp/DispatcherSnippets/Window1.xaml.cs#dispatcherdispatcherframedoevents)]"
  syntax:
    content: public static void PushFrame (System.Windows.Threading.DispatcherFrame frame);
    parameters:
    - id: frame
      type: System.Windows.Threading.DispatcherFrame
      description: "發送器處理框架。"
  overload: System.Windows.Threading.Dispatcher.PushFrame*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>frame</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished*>is <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>       -or-       <code>frame</code> is running on a different <xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>.</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished*>       -或者-發送器處理已停用。"
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Run
  id: Run
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Run()
  nameWithType: Dispatcher.Run()
  fullName: System.Windows.Threading.Dispatcher.Run()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "將主要執行畫面格推入的事件佇列<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
  remarks: "<xref:System.Windows.Threading.Dispatcher>處理迴圈中的事件佇列。</xref:System.Windows.Threading.Dispatcher>  迴圈被指在範圍內。  初始迴圈通常是藉由呼叫執行起始應用程式。       主要執行畫面格將會繼續直到<xref:System.Windows.Threading.Dispatcher>關機。</xref:System.Windows.Threading.Dispatcher>"
  syntax:
    content: public static void Run ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.Run*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ShutdownFinished
  id: ShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ShutdownFinished
  nameWithType: Dispatcher.ShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.ShutdownFinished
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "發生時<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>完成正在關閉。"
  remarks: "當關機程序的<xref:System.Windows.Threading.Dispatcher>已啟動，<xref:System.Windows.Threading.Dispatcher.ShutdownStarted>就會引發事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>設`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownStarted> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>不完全會關閉，直到事件佇列會回溯。</xref:System.Windows.Threading.Dispatcher>       當發送器完成正在關閉時，就會引發 ShutdownFinished 事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>屬性設定為`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>       關機程序開始時，所有暫止的工作佇列中的項目都被中止。"
  syntax:
    content: public event EventHandler ShutdownFinished;
    return:
      type: System.EventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ShutdownStarted
  id: ShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ShutdownStarted
  nameWithType: Dispatcher.ShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.ShutdownStarted
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "發生時<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>開始關閉。"
  remarks: "當關機程序的<xref:System.Windows.Threading.Dispatcher>會啟動，就會引發 ShutdownStarted 事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A>設`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownStarted%2A> </xref:System.Windows.Threading.Dispatcher>       <xref:System.Windows.Threading.Dispatcher>不完全會關閉，直到事件佇列會回溯。</xref:System.Windows.Threading.Dispatcher>       當發送器完成關閉，<xref:System.Windows.Threading.Dispatcher.ShutdownFinished>就會引發事件和<xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A>屬性設定為`true`。</xref:System.Windows.Threading.Dispatcher.HasShutdownFinished%2A> </xref:System.Windows.Threading.Dispatcher.ShutdownFinished>       關機程序開始時，所有暫止的工作佇列中的項目都被中止。"
  syntax:
    content: public event EventHandler ShutdownStarted;
    return:
      type: System.EventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Thread
  id: Thread
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Thread
  nameWithType: Dispatcher.Thread
  fullName: System.Windows.Threading.Dispatcher.Thread
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "取得這個執行緒<xref href=&quot;System.Windows.Threading.Dispatcher&quot;></xref>相關聯。"
  syntax:
    content: public System.Threading.Thread Thread { get; }
    return:
      type: System.Threading.Thread
      description: "執行緒。"
  overload: System.Windows.Threading.Dispatcher.Thread*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.UnhandledException
  id: UnhandledException
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: UnhandledException
  nameWithType: Dispatcher.UnhandledException
  fullName: System.Windows.Threading.Dispatcher.UnhandledException
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "發生於執行緒例外狀況會擲回，並藉由委派的執行期間未能攔截<> *> 或<> *>。"
  remarks: "藉由委派的執行期間擲回的例外狀況時，會引發這個事件<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是無法攔截。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       處理常式可以標示例外狀況為已處理，這可以防止內部例外狀況處理常式呼叫。       必須小心避免建立次要的例外狀況，並攔截，就會發生寫入此事件的事件處理常式。 建議您避免配置記憶體，或執行任何資源的處理常式中的大量作業。       <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>事件提供將不會引發 UnhandledException 事件的方法。</xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>  <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>第一次，就會引發事件，而且當<xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>上<xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs>設`false`，不會引發 UnhandledException 事件。</xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A> </xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter>"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  id: UnhandledExceptionFilter
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: UnhandledExceptionFilter
  nameWithType: Dispatcher.UnhandledExceptionFilter
  fullName: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  type: Event
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "發生於執行緒例外狀況會擲回，並藉由委派的執行期間未能攔截<> *> 或<> *> 中的篩選器階段時。"
  remarks: "藉由委派的執行期間引發的例外狀況的篩選器階段會引發這個事件<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>而且無法攔截。</xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> </xref:System.Windows.Threading.Dispatcher.Invoke%2A>       無法在此時間點 （第一個可能發生例外狀況） 回溯呼叫堆疊。       必須小心避免建立次要的例外狀況，並攔截，就會發生寫入此事件的事件處理常式。  建議您避免配置記憶體，或執行任何資源的處理常式中的大量作業。       UnhandledExceptionFilter 事件提供方法來引發<xref:System.Windows.Threading.Dispatcher.UnhandledException>事件。</xref:System.Windows.Threading.Dispatcher.UnhandledException>  UnhandledExceptionFilter 引發此事件是第一次，而且如果<xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>上<xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs>設`false`、<xref:System.Windows.Threading.Dispatcher.UnhandledException>不會引發事件。</xref:System.Windows.Threading.Dispatcher.UnhandledException> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs> </xref:System.Windows.Threading.DispatcherUnhandledExceptionFilterEventArgs.RequestCatch%2A>"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler UnhandledExceptionFilter;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  id: ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: ValidatePriority(DispatcherPriority,String)
  nameWithType: Dispatcher.ValidatePriority(DispatcherPriority,String)
  fullName: System.Windows.Threading.Dispatcher.ValidatePriority(DispatcherPriority,String)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "決定是否指定<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;></xref>是有效的優先順序。"
  syntax:
    content: public static void ValidatePriority (System.Windows.Threading.DispatcherPriority priority, string parameterName);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "要檢查的優先權。"
    - id: parameterName
      type: System.String
      description: "如果是無效的優先順序，就會發生的例外狀況會傳回字串。"
  overload: System.Windows.Threading.Dispatcher.ValidatePriority*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "<code>priority</code>不是有效<xref href=&quot;System.Windows.Threading.DispatcherPriority&quot;> </xref>。"
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.VerifyAccess
  id: VerifyAccess
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: VerifyAccess()
  nameWithType: Dispatcher.VerifyAccess()
  fullName: System.Windows.Threading.Dispatcher.VerifyAccess()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "判斷呼叫的執行緒是否有存取這個<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
  remarks: "只有執行緒<xref:System.Windows.Threading.Dispatcher>建立在可以存取<xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher>       這個方法是公用的。因此，任何執行緒可以檢查以查看是否有存取權<xref:System.Windows.Threading.Dispatcher>.</xref:System.Windows.Threading.Dispatcher>       之間的差異<xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>VerifyAccess 且<xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>傳回布林值，如果呼叫的執行緒沒有存取權<xref:System.Windows.Threading.Dispatcher>VerifyAccess 擲回例外狀況。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher.CheckAccess%2A> </xref:System.Windows.Threading.Dispatcher.CheckAccess%2A>"
  example:
  - "The following example uses VerifyAccess to determine whether a thread has access to the thread that a <xref:System.Windows.Controls.Button> was created on.  The method takes an object as an argument, which is cast to a <xref:System.Windows.Controls.Button>.  The VerifyAccess method on the <xref:System.Windows.Threading.Dispatcher> of the <xref:System.Windows.Controls.Button> is called to verify access to the thread.  \n  \n If the calling thread has access to the <xref:System.Windows.Threading.Dispatcher>, the <xref:System.Windows.Controls.Button> is updated by just accessing the members of the <xref:System.Windows.Controls.Button>.  \n  \n If the calling thread does not have access, an <xref:System.InvalidOperationException> is thrown.  This example catches the exception and pushes a delegate, which accepts a <xref:System.Windows.Controls.Button> as an argument, onto the <xref:System.Windows.Threading.Dispatcher> of the <xref:System.Windows.Controls.Button>.  This <xref:System.Windows.Threading.Dispatcher> will do the work of updating the <xref:System.Windows.Controls.Button>.  \n  \n [!code-cs[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/add/codesnippet/csharp/DispatcherAccessSample/Window1.xaml.cs#dispatcheraccessverifyaccess)]\n [!code-vb[DispatcherAccessSample#DispatcherAccessVerifyAccess](~/add/codesnippet/visualbasic/dispatcheraccesssample/window1.xaml.vb#dispatcheraccessverifyaccess)]"
  syntax:
    content: public void VerifyAccess ();
    parameters: []
  overload: System.Windows.Threading.Dispatcher.VerifyAccess*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "呼叫的執行緒沒有存取這個<xref href=&quot;System.Windows.Threading.Dispatcher&quot;> </xref>。"
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Yield
  id: Yield
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Yield()
  nameWithType: Dispatcher.Yield()
  fullName: System.Windows.Threading.Dispatcher.Yield()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "建立的 awaitable 物件，以非同步方式傳回給目前的發送器可以產生控制項，並提供處理其他事件發送器的機會。"
  remarks: "這個方法可讓您可以暫時釋目前發送器的執行控制項，因此它可以執行其他工作，例如處理其他事件。 使用`await`，或`Await`在 Visual Basic，對傳回值的運算子，將控制權傳回給目前的發送器。 使用這個方法，如果想要讓您的應用程式有機會處理事件，而您的應用程式正在執行許多 UI 執行緒上的工作。 例如，您可以使用這個方法在更新控制項的長時間執行迴圈。       這個方法相當於呼叫的<xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29>方法然後傳入<xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName>.</xref:System.Windows.Threading.DispatcherPriority?displayProperty=fullName> </xref:System.Windows.Threading.Dispatcher.Yield%28System.Windows.Threading.DispatcherPriority%29>"
  syntax:
    content: public static System.Windows.Threading.DispatcherPriorityAwaitable Yield ();
    parameters: []
    return:
      type: System.Windows.Threading.DispatcherPriorityAwaitable
      description: "Awaitable 物件，以非同步方式傳回給目前的發送器可以產生控制項，並提供處理其他事件發送器的機會。"
  overload: System.Windows.Threading.Dispatcher.Yield*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  id: Yield(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  langs:
  - csharp
  name: Yield(DispatcherPriority)
  nameWithType: Dispatcher.Yield(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Yield(DispatcherPriority)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows.Threading
  summary: "建立的 awaitable 物件，以非同步方式傳回給目前的發送器可以產生控制項，並提供處理其他事件發送器的機會。  當控制項傳回正在等候此方法的結果的程式碼時，就會發生的工作會排定與指定的優先順序。"
  remarks: "這個方法可讓您可以暫時釋目前發送器的執行控制項，因此它可以執行其他工作，例如處理其他事件。 使用`await`，或`Await`在 Visual Basic，對傳回值的運算子，將控制權傳回給目前的發送器。 使用這個方法，如果想要讓您的應用程式有機會處理事件，而您的應用程式正在執行許多 UI 執行緒上的工作。 例如，您可以使用這個方法在更新控制項的長時間執行迴圈。"
  syntax:
    content: public static System.Windows.Threading.DispatcherPriorityAwaitable Yield (System.Windows.Threading.DispatcherPriority priority);
    parameters:
    - id: priority
      type: System.Windows.Threading.DispatcherPriority
      description: "在排程接續要務。"
    return:
      type: System.Windows.Threading.DispatcherPriorityAwaitable
      description: "Awaitable 物件，以非同步方式傳回給目前的發送器可以產生控制項，並提供處理其他事件發送器的機會。"
  overload: System.Windows.Threading.Dispatcher.Yield*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(Delegate,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,Object[])
- uid: System.Windows.Threading.DispatcherOperation
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherOperation
  nameWithType: DispatcherOperation
  fullName: System.Windows.Threading.DispatcherOperation
- uid: System.Delegate
  parent: System
  isExternal: true
  name: Delegate
  nameWithType: Delegate
  fullName: System.Delegate
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate)
- uid: System.Windows.Threading.DispatcherPriority
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherPriority
  nameWithType: DispatcherPriority
  fullName: System.Windows.Threading.DispatcherPriority
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(Delegate,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.BeginInvoke(DispatcherPriority,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvokeShutdown(DispatcherPriority)
  nameWithType: Dispatcher.BeginInvokeShutdown(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.BeginInvokeShutdown(DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.CheckAccess
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CheckAccess()
  nameWithType: Dispatcher.CheckAccess()
  fullName: System.Windows.Threading.Dispatcher.CheckAccess()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
  fullName: System.Windows.Threading.Dispatcher.CurrentDispatcher
- uid: System.Windows.Threading.Dispatcher
  parent: System.Windows.Threading
  isExternal: false
  name: Dispatcher
  nameWithType: Dispatcher
  fullName: System.Windows.Threading.Dispatcher
- uid: System.Windows.Threading.Dispatcher.DisableProcessing
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: DisableProcessing()
  nameWithType: Dispatcher.DisableProcessing()
  fullName: System.Windows.Threading.Dispatcher.DisableProcessing()
- uid: System.Windows.Threading.DispatcherProcessingDisabled
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherProcessingDisabled
  nameWithType: DispatcherProcessingDisabled
  fullName: System.Windows.Threading.DispatcherProcessingDisabled
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ExitAllFrames()
  nameWithType: Dispatcher.ExitAllFrames()
  fullName: System.Windows.Threading.Dispatcher.ExitAllFrames()
- uid: System.Windows.Threading.Dispatcher.FromThread(System.Threading.Thread)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: FromThread(Thread)
  nameWithType: Dispatcher.FromThread(Thread)
  fullName: System.Windows.Threading.Dispatcher.FromThread(Thread)
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  nameWithType: Thread
  fullName: System.Threading.Thread
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.HasShutdownFinished
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.HasShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Hooks
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Hooks
  nameWithType: Dispatcher.Hooks
  fullName: System.Windows.Threading.Dispatcher.Hooks
- uid: System.Windows.Threading.DispatcherHooks
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherHooks
  nameWithType: DispatcherHooks
  fullName: System.Windows.Threading.DispatcherHooks
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action)
  nameWithType: Dispatcher.Invoke(Action)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action)
- uid: System.Action
  parent: System
  isExternal: true
  name: Action
  nameWithType: Action
  fullName: System.Action
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken)
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,TimeSpan,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,Object[])
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Action,DispatcherPriority,CancellationToken,TimeSpan)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Delegate,System.TimeSpan,System.Windows.Threading.DispatcherPriority,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  nameWithType: Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(Delegate,TimeSpan,DispatcherPriority,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object)
- uid: System.Windows.Threading.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority,System.TimeSpan,System.Delegate,System.Object,System.Object[])
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  nameWithType: Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
  fullName: System.Windows.Threading.Dispatcher.Invoke(DispatcherPriority,TimeSpan,Delegate,Object,Object[])
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>)
  nameWithType: Dispatcher.Invoke(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>)
- uid: TResult
  isExternal: true
  name: TResult
  nameWithType: TResult
  fullName: TResult
- uid: System.Func{TResult}
  parent: System
  isExternal: true
  name: Func<TResult>
  nameWithType: Func<TResult>
  fullName: System.Func<TResult>
  spec.csharp:
  - uid: System.Func`1
    name: Func
    nameWithType: Func
    fullName: Func<TResult>
  - name: <
    nameWithType: <
    fullName: <
  - uid: TResult
    name: TResult
    nameWithType: TResult
    fullName: TResult
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.Invoke``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken,System.TimeSpan)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  nameWithType: Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
  fullName: System.Windows.Threading.Dispatcher.Invoke(Func<TResult>,DispatcherPriority,CancellationToken,TimeSpan)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action)
  nameWithType: Dispatcher.InvokeAsync(Action)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync(System.Action,System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Action,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Action,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0})
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>)
- uid: System.Windows.Threading.DispatcherOperation`1
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherOperation<TResult>
  nameWithType: DispatcherOperation<TResult>
  fullName: System.Windows.Threading.DispatcherOperation<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>,DispatcherPriority)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.InvokeAsync``1(System.Func{``0},System.Windows.Threading.DispatcherPriority,System.Threading.CancellationToken)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  nameWithType: Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
  fullName: System.Windows.Threading.Dispatcher.InvokeAsync(Func<TResult>,DispatcherPriority,CancellationToken)
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeShutdown()
  nameWithType: Dispatcher.InvokeShutdown()
  fullName: System.Windows.Threading.Dispatcher.InvokeShutdown()
- uid: System.Windows.Threading.Dispatcher.PushFrame(System.Windows.Threading.DispatcherFrame)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: PushFrame(DispatcherFrame)
  nameWithType: Dispatcher.PushFrame(DispatcherFrame)
  fullName: System.Windows.Threading.Dispatcher.PushFrame(DispatcherFrame)
- uid: System.Windows.Threading.DispatcherFrame
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherFrame
  nameWithType: DispatcherFrame
  fullName: System.Windows.Threading.DispatcherFrame
- uid: System.Windows.Threading.Dispatcher.Run
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Run()
  nameWithType: Dispatcher.Run()
  fullName: System.Windows.Threading.Dispatcher.Run()
- uid: System.Windows.Threading.Dispatcher.ShutdownFinished
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ShutdownFinished
  nameWithType: Dispatcher.ShutdownFinished
  fullName: System.Windows.Threading.Dispatcher.ShutdownFinished
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.Threading.Dispatcher.ShutdownStarted
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ShutdownStarted
  nameWithType: Dispatcher.ShutdownStarted
  fullName: System.Windows.Threading.Dispatcher.ShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Thread
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Thread
  nameWithType: Dispatcher.Thread
  fullName: System.Windows.Threading.Dispatcher.Thread
- uid: System.Windows.Threading.Dispatcher.UnhandledException
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: UnhandledException
  nameWithType: Dispatcher.UnhandledException
  fullName: System.Windows.Threading.Dispatcher.UnhandledException
- uid: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionEventHandler
  nameWithType: DispatcherUnhandledExceptionEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
- uid: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: UnhandledExceptionFilter
  nameWithType: Dispatcher.UnhandledExceptionFilter
  fullName: System.Windows.Threading.Dispatcher.UnhandledExceptionFilter
- uid: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionFilterEventHandler
  nameWithType: DispatcherUnhandledExceptionFilterEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionFilterEventHandler
- uid: System.Windows.Threading.Dispatcher.ValidatePriority(System.Windows.Threading.DispatcherPriority,System.String)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ValidatePriority(DispatcherPriority,String)
  nameWithType: Dispatcher.ValidatePriority(DispatcherPriority,String)
  fullName: System.Windows.Threading.Dispatcher.ValidatePriority(DispatcherPriority,String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Threading.Dispatcher.VerifyAccess
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: VerifyAccess()
  nameWithType: Dispatcher.VerifyAccess()
  fullName: System.Windows.Threading.Dispatcher.VerifyAccess()
- uid: System.Windows.Threading.Dispatcher.Yield
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield()
  nameWithType: Dispatcher.Yield()
  fullName: System.Windows.Threading.Dispatcher.Yield()
- uid: System.Windows.Threading.DispatcherPriorityAwaitable
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherPriorityAwaitable
  nameWithType: DispatcherPriorityAwaitable
  fullName: System.Windows.Threading.DispatcherPriorityAwaitable
- uid: System.Windows.Threading.Dispatcher.Yield(System.Windows.Threading.DispatcherPriority)
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield(DispatcherPriority)
  nameWithType: Dispatcher.Yield(DispatcherPriority)
  fullName: System.Windows.Threading.Dispatcher.Yield(DispatcherPriority)
- uid: System.Windows.Threading.Dispatcher.BeginInvoke*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvoke
  nameWithType: Dispatcher.BeginInvoke
- uid: System.Windows.Threading.Dispatcher.BeginInvokeShutdown*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: BeginInvokeShutdown
  nameWithType: Dispatcher.BeginInvokeShutdown
- uid: System.Windows.Threading.Dispatcher.CheckAccess*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CheckAccess
  nameWithType: Dispatcher.CheckAccess
- uid: System.Windows.Threading.Dispatcher.CurrentDispatcher*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: CurrentDispatcher
  nameWithType: Dispatcher.CurrentDispatcher
- uid: System.Windows.Threading.Dispatcher.DisableProcessing*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: DisableProcessing
  nameWithType: Dispatcher.DisableProcessing
- uid: System.Windows.Threading.Dispatcher.ExitAllFrames*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ExitAllFrames
  nameWithType: Dispatcher.ExitAllFrames
- uid: System.Windows.Threading.Dispatcher.FromThread*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: FromThread
  nameWithType: Dispatcher.FromThread
- uid: System.Windows.Threading.Dispatcher.HasShutdownFinished*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownFinished
  nameWithType: Dispatcher.HasShutdownFinished
- uid: System.Windows.Threading.Dispatcher.HasShutdownStarted*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: HasShutdownStarted
  nameWithType: Dispatcher.HasShutdownStarted
- uid: System.Windows.Threading.Dispatcher.Hooks*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Hooks
  nameWithType: Dispatcher.Hooks
- uid: System.Windows.Threading.Dispatcher.Invoke*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke
  nameWithType: Dispatcher.Invoke
- uid: System.Windows.Threading.Dispatcher.Invoke<TResult>*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Invoke<TResult>
  nameWithType: Dispatcher.Invoke<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeAsync*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync
  nameWithType: Dispatcher.InvokeAsync
- uid: System.Windows.Threading.Dispatcher.InvokeAsync<TResult>*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeAsync<TResult>
  nameWithType: Dispatcher.InvokeAsync<TResult>
- uid: System.Windows.Threading.Dispatcher.InvokeShutdown*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: InvokeShutdown
  nameWithType: Dispatcher.InvokeShutdown
- uid: System.Windows.Threading.Dispatcher.PushFrame*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: PushFrame
  nameWithType: Dispatcher.PushFrame
- uid: System.Windows.Threading.Dispatcher.Run*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Run
  nameWithType: Dispatcher.Run
- uid: System.Windows.Threading.Dispatcher.Thread*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Thread
  nameWithType: Dispatcher.Thread
- uid: System.Windows.Threading.Dispatcher.ValidatePriority*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: ValidatePriority
  nameWithType: Dispatcher.ValidatePriority
- uid: System.Windows.Threading.Dispatcher.VerifyAccess*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: VerifyAccess
  nameWithType: Dispatcher.VerifyAccess
- uid: System.Windows.Threading.Dispatcher.Yield*
  parent: System.Windows.Threading.Dispatcher
  isExternal: false
  name: Yield
  nameWithType: Dispatcher.Yield
