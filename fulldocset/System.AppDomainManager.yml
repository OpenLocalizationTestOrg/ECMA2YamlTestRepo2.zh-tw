### YamlMime:ManagedReference
items:
- uid: System.AppDomainManager
  id: AppDomainManager
  children:
  - System.AppDomainManager.#ctor
  - System.AppDomainManager.ApplicationActivator
  - System.AppDomainManager.CheckSecuritySettings(System.Security.SecurityState)
  - System.AppDomainManager.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  - System.AppDomainManager.CreateDomainHelper(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  - System.AppDomainManager.EntryAssembly
  - System.AppDomainManager.HostExecutionContextManager
  - System.AppDomainManager.HostSecurityManager
  - System.AppDomainManager.InitializationFlags
  - System.AppDomainManager.InitializeNewDomain(System.AppDomainSetup)
  langs:
  - csharp
  name: AppDomainManager
  nameWithType: AppDomainManager
  fullName: System.AppDomainManager
  type: Class
  summary: "提供 unmanaged 主機的 managed 對等項目。"
  remarks: "> [!IMPORTANT]\n>  Do not use AppDomainManager to configure an application domain in ASP.NET. In ASP.NET, configuration must be handled by the host.  \n  \n Implementing the AppDomainManager class enables a hosting application to participate in the creation of new application domains. To replace the default AppDomainManager, identify the assembly and type of the replacement AppDomainManager in the APPDOMAIN_MANAGER_ASM and APPDOMAIN_MANAGER_TYPE environment variables, or use the [\\<appDomainManagerAssembly>](../Topic/%3CappDomainManagerAssembly%3E%20Element.md) and [\\<appDomainManagerType>](../Topic/%3CappDomainManagerType%3E%20Element.md) elements in your configuration file. The assembly must be fully trusted and be contained in the global assembly cache or the directory of the starting application. The type and assembly names must be fully qualified in the environment variables. For example:  \n  \n `set APPDOMAIN_MANAGER_TYPE=MyNamespace.TestAppDomainManager`  \n  \n `set APPDOMAIN_MANAGER_ASM=customappDomainmanager, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f1368f7b12a08d72`  \n  \n> [!IMPORTANT]\n>  If the assembly that contains your subclass of AppDomainManager depends on assemblies that are marked with the conditional <xref:System.Security.AllowPartiallyTrustedCallersAttribute> (APTCA) attribute, you must include those assemblies in the list that you pass to the <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> property of the <xref:System.AppDomainSetup> you use to create application domains. Otherwise, the assemblies that are marked with the conditional APTCA attribute will be disabled.  \n  \n The AppDomainManager is the managed equivalent of the unmanaged host. An AppDomainManager object participates in the creation of new application domains in a process and can customize the new <xref:System.AppDomain> before other managed code runs. The AppDomainManager can also supply host managers that participate in other aspects of common language runtime execution. For example, an AppDomainManager can identify a <xref:System.Security.HostSecurityManager> object that participates in the security decisions of the application domain.  \n  \n> [!NOTE]\n>  Only assemblies granted `FullTrust`, such as assemblies in the global assembly cache or identified as `fullTrustAssemblies` in the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method can be loaded in the  <xref:System.AppDomainManager.%23ctor%2A> constructor and the <xref:System.AppDomainManager.InitializeNewDomain%2A> method.  \n  \n> [!NOTE]\n>  This class contains a link demand and an inheritance demand at the class level. A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have infrastructure permission. For details about security demands, see [Link Demands](~/add/includes/ajax-current-ext-md.md) and [Inheritance Demands](http://msdn.microsoft.com/en-us/28b9adbb-8f08-4f10-b856-dbf59eb932d9)."
  example:
  - "The following example shows a very simple implementation of AppDomainManager.  \n  \n [!code-vb[System.AppDomainManager#1](~/add/codesnippet/visualbasic/t-system.appdomainmanager_1.vb)]\n [!code-cs[System.AppDomainManager#1](~/add/codesnippet/csharp/t-system.appdomainmanager_1.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      [System.Security.SecurityCritical]

      public class AppDomainManager : MarshalByRefObject
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements: []
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.AppDomainManager.#ctor
  id: '#ctor'
  parent: System.AppDomainManager
  langs:
  - csharp
  name: AppDomainManager()
  nameWithType: AppDomainManager.AppDomainManager()
  fullName: System.AppDomainManager.AppDomainManager()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: "初始化的新執行個體<xref href=&quot;System.AppDomainManager&quot;></xref>類別。"
  remarks: >-
    > [!NOTE]

    >  Only assemblies granted `FullTrust`, such as assemblies in the global assembly cache or identified as `fullTrustAssemblies` in the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\[\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method can be loaded in the  AppDomainManager constructor and the <xref:System.AppDomainManager.InitializeNewDomain%2A> method.
  syntax:
    content: public AppDomainManager ();
    parameters: []
  overload: System.AppDomainManager.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainManager.ApplicationActivator
  id: ApplicationActivator
  parent: System.AppDomainManager
  langs:
  - csharp
  name: ApplicationActivator
  nameWithType: AppDomainManager.ApplicationActivator
  fullName: System.AppDomainManager.ApplicationActivator
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得處理增益集和資訊清單為基礎的應用程式定義域的啟動應用程式啟動項。"
  remarks: "沒有單一的指定執行個體的<xref:System.Runtime.Hosting.ApplicationActivator>中每個類別<xref:System.AppDomain>啟用呼叫路由傳送至的所有增益集和資訊清單為主應用程式。</xref:System.AppDomain> </xref:System.Runtime.Hosting.ApplicationActivator> <xref:System.AppDomainManager>目前<xref:System.AppDomain>可以提供自己的自訂<xref:System.Runtime.Hosting.ApplicationActivator>，或預設的執行個體<xref:System.Runtime.Hosting.ApplicationActivator>建立。</xref:System.Runtime.Hosting.ApplicationActivator> </xref:System.Runtime.Hosting.ApplicationActivator> </xref:System.AppDomain> </xref:System.AppDomainManager>"
  syntax:
    content: public virtual System.Runtime.Hosting.ApplicationActivator ApplicationActivator { get; }
    return:
      type: System.Runtime.Hosting.ApplicationActivator
      description: "應用程式啟動項。"
  overload: System.AppDomainManager.ApplicationActivator*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainManager.CheckSecuritySettings(System.Security.SecurityState)
  id: CheckSecuritySettings(System.Security.SecurityState)
  parent: System.AppDomainManager
  langs:
  - csharp
  name: CheckSecuritySettings(SecurityState)
  nameWithType: AppDomainManager.CheckSecuritySettings(SecurityState)
  fullName: System.AppDomainManager.CheckSecuritySettings(SecurityState)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "表示應用程式定義域是否允許指定的作業。"
  remarks: "這個方法的預設實作會傳回`false`。       這個方法時，會呼叫<xref:System.IO.IsolatedStorage.IsolatedStorageFile.IncreaseQuotaTo%2A?displayProperty=fullName>增加隔離儲存區配額已呼叫方法。</xref:System.IO.IsolatedStorage.IsolatedStorageFile.IncreaseQuotaTo%2A?displayProperty=fullName> 裝載 common language runtime (CLR) 的應用程式可以覆寫 CheckSecuritySettings 方法，以執行原則決策依據<xref:System.IO.IsolatedStorage.IsolatedStorageSecurityState>物件 (後者繼承<xref:System.Security.SecurityState>)，並可以再允許或防止增加。</xref:System.Security.SecurityState> </xref:System.IO.IsolatedStorage.IsolatedStorageSecurityState> 例如，主機內容可以提示使用者核准或拒絕該要求增加配額。 CheckSecuritySettings 主應用程式的實作應該納入考量的阻絕服務攻擊的可能性。 比方說，它應該從使用者啟動的事件會呼叫此方法，例如按一下按鈕時，才會提示使用者。"
  syntax:
    content: public virtual bool CheckSecuritySettings (System.Security.SecurityState state);
    parameters:
    - id: state
      type: System.Security.SecurityState
      description: "子類別<xref href=&quot;System.Security.SecurityState&quot;></xref>可識別的安全性狀態所要求的作業。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果主機可允許指定的作業<code> state </code>應用程式定義域中執行，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomainManager.CheckSecuritySettings*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainManager.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomainManager
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomainManager.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomainManager.CreateDomain(String,Evidence,AppDomainSetup)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "傳回新的或現有的應用程式定義域。"
  remarks: "所指定的易記名稱`friendlyName`參數，可顯示在使用者介面，以識別該定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.FriendlyName%2A>屬性。</xref:System.AppDomain.FriendlyName%2A>       預設 CreateDomain 方法會呼叫受保護的<xref:System.AppDomainManager.CreateDomainHelper%2A>方法，以建立<xref:System.AppDomain>.</xref:System.AppDomain> </xref:System.AppDomainManager.CreateDomainHelper%2A> 覆寫這個方法不需要呼叫<xref:System.AppDomainManager.CreateDomainHelper%2A>方法可以傳回現有的網域。</xref:System.AppDomainManager.CreateDomainHelper%2A>"
  syntax:
    content: public virtual AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup appDomainInfo);
    parameters:
    - id: friendlyName
      type: System.String
      description: "網域的好記的名稱。"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "物件，其中包含透過安全性原則，以建立堆疊頂端的權限對應的辨識項設定。"
    - id: appDomainInfo
      type: System.AppDomainSetup
      description: "物件，包含應用程式定義域初始化資訊。"
    return:
      type: System.AppDomain
      description: "新的或現有應用程式定義域。"
  overload: System.AppDomainManager.CreateDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainManager.CreateDomainHelper(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  id: CreateDomainHelper(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomainManager
  langs:
  - csharp
  name: CreateDomainHelper(String,Evidence,AppDomainSetup)
  nameWithType: AppDomainManager.CreateDomainHelper(String,Evidence,AppDomainSetup)
  fullName: System.AppDomainManager.CreateDomainHelper(String,Evidence,AppDomainSetup)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "提供 helper 方法來建立應用程式定義域。"
  remarks: "這個受保護的 helper 方法會負責建立新的應用程式定義域。       此易記名稱，由指定`friendlyName`參數，可顯示在使用者介面，以識別該定義域。 如需詳細資訊，請參閱<xref:System.AppDomain.FriendlyName%2A>屬性。</xref:System.AppDomain.FriendlyName%2A>"
  syntax:
    content: protected static AppDomain CreateDomainHelper (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup appDomainInfo);
    parameters:
    - id: friendlyName
      type: System.String
      description: "網域的好記的名稱。"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "物件，其中包含透過安全性原則，以建立堆疊頂端的權限對應的辨識項設定。"
    - id: appDomainInfo
      type: System.AppDomainSetup
      description: "物件，包含應用程式定義域初始化資訊。"
    return:
      type: System.AppDomain
      description: "新建立的應用程式網域。"
  overload: System.AppDomainManager.CreateDomainHelper*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomainManager.EntryAssembly
  id: EntryAssembly
  parent: System.AppDomainManager
  langs:
  - csharp
  name: EntryAssembly
  nameWithType: AppDomainManager.EntryAssembly
  fullName: System.AppDomainManager.EntryAssembly
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得應用程式的項目組件。"
  remarks: "如果應用程式資訊清單啟動應用程式，項目組件由應用程式資訊清單中。 如果應用程式不是資訊清單啟動，進入點的組件是可執行程序預設應用程式定義域中。 在其他應用程式定義域中，項目組件是已執行的第一個可執行檔<xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=fullName>方法。</xref:System.AppDomain.ExecuteAssembly%2A?displayProperty=fullName>"
  syntax:
    content: public virtual System.Reflection.Assembly EntryAssembly { get; }
    return:
      type: System.Reflection.Assembly
      description: "應用程式項目組件。"
  overload: System.AppDomainManager.EntryAssembly*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainManager.HostExecutionContextManager
  id: HostExecutionContextManager
  parent: System.AppDomainManager
  langs:
  - csharp
  name: HostExecutionContextManager
  nameWithType: AppDomainManager.HostExecutionContextManager
  fullName: System.AppDomainManager.HostExecutionContextManager
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得主應用程式管理的執行內容的流程的執行內容管理員。"
  remarks: "這個屬性可讓主機提供<xref:System.Threading.HostExecutionContextManager>可以參與流程的執行內容在非同步呼叫之間。</xref:System.Threading.HostExecutionContextManager>"
  syntax:
    content: public virtual System.Threading.HostExecutionContextManager HostExecutionContextManager { get; }
    return:
      type: System.Threading.HostExecutionContextManager
      description: "主機執行內容管理員。"
  overload: System.AppDomainManager.HostExecutionContextManager*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainManager.HostSecurityManager
  id: HostSecurityManager
  parent: System.AppDomainManager
  langs:
  - csharp
  name: HostSecurityManager
  nameWithType: AppDomainManager.HostSecurityManager
  fullName: System.AppDomainManager.HostSecurityManager
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得主機安全性管理員參與安全性決策的應用程式定義域。"
  remarks: "這個屬性可讓主機提供<xref:System.Security.HostSecurityManager>參與應用程式定義域的安全性決策。</xref:System.Security.HostSecurityManager>"
  example:
  - "The following example shows an override of the HostSecurityManager property for a custom application domain manager. This code example is part of a larger example provided for the <xref:System.AppDomainManager> class.  \n  \n [!code-vb[System.AppDomainManager#3](~/add/codesnippet/visualbasic/p-system.appdomainmanage_1.vb)]\n [!code-cs[System.AppDomainManager#3](~/add/codesnippet/csharp/p-system.appdomainmanage_1.cs)]"
  syntax:
    content: public virtual System.Security.HostSecurityManager HostSecurityManager { get; }
    return:
      type: System.Security.HostSecurityManager
      description: "主機安全性管理員。"
  overload: System.AppDomainManager.HostSecurityManager*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainManager.InitializationFlags
  id: InitializationFlags
  parent: System.AppDomainManager
  langs:
  - csharp
  name: InitializationFlags
  nameWithType: AppDomainManager.InitializationFlags
  fullName: System.AppDomainManager.InitializationFlags
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得自訂的應用程式定義域管理員初始化旗標。"
  syntax:
    content: public AppDomainManagerInitializationOptions InitializationFlags { get; set; }
    return:
      type: System.AppDomainManagerInitializationOptions
      description: "描述要執行的初始化動作的列舉值的位元組合。 預設值是<xref href=&quot;System.AppDomainManagerInitializationOptions&quot;> </xref>。"
  overload: System.AppDomainManager.InitializationFlags*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainManager.InitializeNewDomain(System.AppDomainSetup)
  id: InitializeNewDomain(System.AppDomainSetup)
  parent: System.AppDomainManager
  langs:
  - csharp
  name: InitializeNewDomain(AppDomainSetup)
  nameWithType: AppDomainManager.InitializeNewDomain(AppDomainSetup)
  fullName: System.AppDomainManager.InitializeNewDomain(AppDomainSetup)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "初始化新的應用程式定義域。"
  remarks: "> [!IMPORTANT]\n>  Do not use this method to initialize an application domain in ASP.NET. In ASP.NET, configuration must be handled by the host. If you use this method to initialize the application domain, the host throws <xref:System.InvalidOperationException> when it attempts to initialize the application domain. The exception message indicates that initialization has already occurred.  \n  \n This method is called immediately after the constructor. The default InitializeNewDomain implementation does nothing.  A custom implementation can set up internal classes and delegates, set up an interface with the unmanaged host interface, or set up event handlers for the new <xref:System.AppDomain>.  \n  \n Also, for add-in activations, a custom implementation could identify the current <xref:System.AppDomain> as the target application domain.  \n  \n Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], you can use this method to sandbox the default application domain at application startup, or to modify the sandbox of a new application domain. To do this, adjust the <xref:System.Security.Policy.ApplicationTrust.DefaultGrantSet%2A> and <xref:System.Security.Policy.ApplicationTrust.FullTrustAssemblies%2A> properties on the <xref:System.Security.Policy.ApplicationTrust> object that is assigned to the <xref:System.AppDomainSetup.ApplicationTrust%2A?displayProperty=fullName> property of `appDomainInfo`, before you initialize the application domain.  \n  \n> [!NOTE]\n>  Only assemblies granted `FullTrust`, such as assemblies in the global assembly cache or identified as `fullTrustAssemblies` in the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method can be loaded in the  <xref:System.AppDomainManager.%23ctor%2A> constructor and the InitializeNewDomain method."
  example:
  - "The following example shows an override of the InitializeNewDomain method for a custom application domain manager. This code example is part of a larger example provided for the <xref:System.AppDomainManager> class.  \n  \n [!code-vb[System.AppDomainManager#2](~/add/codesnippet/visualbasic/m-system.appdomainmanage_1.vb)]\n [!code-cs[System.AppDomainManager#2](~/add/codesnippet/csharp/m-system.appdomainmanage_1.cs)]"
  syntax:
    content: public virtual void InitializeNewDomain (AppDomainSetup appDomainInfo);
    parameters:
    - id: appDomainInfo
      type: System.AppDomainSetup
      description: "物件，包含應用程式定義域初始化資訊。"
  overload: System.AppDomainManager.InitializeNewDomain*
  exceptions: []
  platform:
  - net462
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.AppDomainManager.#ctor
  parent: System.AppDomainManager
  isExternal: false
  name: AppDomainManager()
  nameWithType: AppDomainManager.AppDomainManager()
  fullName: System.AppDomainManager.AppDomainManager()
- uid: System.AppDomainManager.ApplicationActivator
  parent: System.AppDomainManager
  isExternal: false
  name: ApplicationActivator
  nameWithType: AppDomainManager.ApplicationActivator
  fullName: System.AppDomainManager.ApplicationActivator
- uid: System.Runtime.Hosting.ApplicationActivator
  parent: System.Runtime.Hosting
  isExternal: false
  name: ApplicationActivator
  nameWithType: ApplicationActivator
  fullName: System.Runtime.Hosting.ApplicationActivator
- uid: System.AppDomainManager.CheckSecuritySettings(System.Security.SecurityState)
  parent: System.AppDomainManager
  isExternal: false
  name: CheckSecuritySettings(SecurityState)
  nameWithType: AppDomainManager.CheckSecuritySettings(SecurityState)
  fullName: System.AppDomainManager.CheckSecuritySettings(SecurityState)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.SecurityState
  parent: System.Security
  isExternal: false
  name: SecurityState
  nameWithType: SecurityState
  fullName: System.Security.SecurityState
- uid: System.AppDomainManager.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomainManager
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomainManager.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomainManager.CreateDomain(String,Evidence,AppDomainSetup)
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.AppDomainSetup
  parent: System
  isExternal: false
  name: AppDomainSetup
  nameWithType: AppDomainSetup
  fullName: System.AppDomainSetup
- uid: System.AppDomainManager.CreateDomainHelper(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomainManager
  isExternal: false
  name: CreateDomainHelper(String,Evidence,AppDomainSetup)
  nameWithType: AppDomainManager.CreateDomainHelper(String,Evidence,AppDomainSetup)
  fullName: System.AppDomainManager.CreateDomainHelper(String,Evidence,AppDomainSetup)
- uid: System.AppDomainManager.EntryAssembly
  parent: System.AppDomainManager
  isExternal: false
  name: EntryAssembly
  nameWithType: AppDomainManager.EntryAssembly
  fullName: System.AppDomainManager.EntryAssembly
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.AppDomainManager.HostExecutionContextManager
  parent: System.AppDomainManager
  isExternal: false
  name: HostExecutionContextManager
  nameWithType: AppDomainManager.HostExecutionContextManager
  fullName: System.AppDomainManager.HostExecutionContextManager
- uid: System.Threading.HostExecutionContextManager
  parent: System.Threading
  isExternal: false
  name: HostExecutionContextManager
  nameWithType: HostExecutionContextManager
  fullName: System.Threading.HostExecutionContextManager
- uid: System.AppDomainManager.HostSecurityManager
  parent: System.AppDomainManager
  isExternal: false
  name: HostSecurityManager
  nameWithType: AppDomainManager.HostSecurityManager
  fullName: System.AppDomainManager.HostSecurityManager
- uid: System.Security.HostSecurityManager
  parent: System.Security
  isExternal: false
  name: HostSecurityManager
  nameWithType: HostSecurityManager
  fullName: System.Security.HostSecurityManager
- uid: System.AppDomainManager.InitializationFlags
  parent: System.AppDomainManager
  isExternal: false
  name: InitializationFlags
  nameWithType: AppDomainManager.InitializationFlags
  fullName: System.AppDomainManager.InitializationFlags
- uid: System.AppDomainManagerInitializationOptions
  parent: System
  isExternal: false
  name: AppDomainManagerInitializationOptions
  nameWithType: AppDomainManagerInitializationOptions
  fullName: System.AppDomainManagerInitializationOptions
- uid: System.AppDomainManager.InitializeNewDomain(System.AppDomainSetup)
  parent: System.AppDomainManager
  isExternal: false
  name: InitializeNewDomain(AppDomainSetup)
  nameWithType: AppDomainManager.InitializeNewDomain(AppDomainSetup)
  fullName: System.AppDomainManager.InitializeNewDomain(AppDomainSetup)
- uid: System.AppDomainManager.#ctor*
  parent: System.AppDomainManager
  isExternal: false
  name: AppDomainManager
  nameWithType: AppDomainManager.AppDomainManager
- uid: System.AppDomainManager.ApplicationActivator*
  parent: System.AppDomainManager
  isExternal: false
  name: ApplicationActivator
  nameWithType: AppDomainManager.ApplicationActivator
- uid: System.AppDomainManager.CheckSecuritySettings*
  parent: System.AppDomainManager
  isExternal: false
  name: CheckSecuritySettings
  nameWithType: AppDomainManager.CheckSecuritySettings
- uid: System.AppDomainManager.CreateDomain*
  parent: System.AppDomainManager
  isExternal: false
  name: CreateDomain
  nameWithType: AppDomainManager.CreateDomain
- uid: System.AppDomainManager.CreateDomainHelper*
  parent: System.AppDomainManager
  isExternal: false
  name: CreateDomainHelper
  nameWithType: AppDomainManager.CreateDomainHelper
- uid: System.AppDomainManager.EntryAssembly*
  parent: System.AppDomainManager
  isExternal: false
  name: EntryAssembly
  nameWithType: AppDomainManager.EntryAssembly
- uid: System.AppDomainManager.HostExecutionContextManager*
  parent: System.AppDomainManager
  isExternal: false
  name: HostExecutionContextManager
  nameWithType: AppDomainManager.HostExecutionContextManager
- uid: System.AppDomainManager.HostSecurityManager*
  parent: System.AppDomainManager
  isExternal: false
  name: HostSecurityManager
  nameWithType: AppDomainManager.HostSecurityManager
- uid: System.AppDomainManager.InitializationFlags*
  parent: System.AppDomainManager
  isExternal: false
  name: InitializationFlags
  nameWithType: AppDomainManager.InitializationFlags
- uid: System.AppDomainManager.InitializeNewDomain*
  parent: System.AppDomainManager
  isExternal: false
  name: InitializeNewDomain
  nameWithType: AppDomainManager.InitializeNewDomain
