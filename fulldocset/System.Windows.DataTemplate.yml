### YamlMime:ManagedReference
items:
- uid: System.Windows.DataTemplate
  id: DataTemplate
  children:
  - System.Windows.DataTemplate.#ctor
  - System.Windows.DataTemplate.#ctor(System.Object)
  - System.Windows.DataTemplate.DataTemplateKey
  - System.Windows.DataTemplate.DataType
  - System.Windows.DataTemplate.Triggers
  - System.Windows.DataTemplate.ValidateTemplatedParent(System.Windows.FrameworkElement)
  langs:
  - csharp
  name: DataTemplate
  nameWithType: DataTemplate
  fullName: System.Windows.DataTemplate
  type: Class
  summary: "描述視覺化資料物件的結構。"
  remarks: "您可以使用 DataTemplate 來指定您的資料物件的視覺效果。 您要繫結時，會特別有用 DataTemplate 物件<xref:System.Windows.Controls.ItemsControl>例如<xref:System.Windows.Controls.ListBox>至整個集合。</xref:System.Windows.Controls.ListBox> </xref:System.Windows.Controls.ItemsControl> 沒有特定指示，<xref:System.Windows.Controls.ListBox>顯示集合中物件的字串表示法。</xref:System.Windows.Controls.ListBox> 在此情況下，您可以使用 DataTemplate 定義的資料物件的外觀。 您 DataTemplate 的內容會變成您的資料物件的視覺化結構。       如需深入的討論，請參閱[資料範本化概觀](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example shows how to create a DataTemplate inline. The DataTemplate specifies that each data item appears as three <xref:System.Windows.Controls.TextBlock> elements within a <xref:System.Windows.Controls.StackPanel>. In this example, the data object is a class called `Task`. Note that each <xref:System.Windows.Controls.TextBlock> element in this template is bound to a property of the `Task` class.  \n  \n [!code-xml[DataTemplatingIntro_snip#Inline](~/add/codesnippet/xaml/DataTemplatingSample/Window1.xaml#inline)]  \n  \n It is more common to define a DataTemplate in the resources section so it can be a reusable object, as in the following example:  \n  \n [!code-xml[DataTemplatingIntro_snip#R1](~/add/codesnippet/xaml/DataTemplatingSample/Window1.xaml#r1)]  \n[!code-xml[DataTemplatingIntro_snip#AsResource](~/add/codesnippet/xaml/DataTemplatingSample/Window1.xaml#asresource)]  \n[!code-xml[DataTemplatingIntro_snip#R2](~/add/codesnippet/xaml/DataTemplatingSample/Window1.xaml#r2)]  \n  \n Now you can use `myTaskTemplate` as a resource, as in the following example:  \n  \n [!code-xml[DataTemplatingIntro_snip#MyTaskTemplate](~/add/codesnippet/xaml/DataTemplatingSample/Window1.xaml#mytasktemplate)]  \n  \n For the complete sample, see [Introduction to Data Templating Sample](http://go.microsoft.com/fwlink/?LinkID=160009)."
  syntax:
    content: >-
      [System.Windows.Markup.DictionaryKeyProperty("DataTemplateKey")]

      public class DataTemplate : System.Windows.FrameworkTemplate
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.FrameworkTemplate
  implements: []
  inheritedMembers:
  - System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)
  - System.Windows.FrameworkTemplate.HasContent
  - System.Windows.FrameworkTemplate.IsSealed
  - System.Windows.FrameworkTemplate.LoadContent
  - System.Windows.FrameworkTemplate.RegisterName(System.String,System.Object)
  - System.Windows.FrameworkTemplate.Resources
  - System.Windows.FrameworkTemplate.Seal
  - System.Windows.FrameworkTemplate.ShouldSerializeResources(System.Windows.Markup.XamlDesignerSerializationManager)
  - System.Windows.FrameworkTemplate.ShouldSerializeVisualTree
  - System.Windows.FrameworkTemplate.System#Windows#Markup#INameScope#FindName(System.String)
  - System.Windows.FrameworkTemplate.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.FrameworkTemplate.Template
  - System.Windows.FrameworkTemplate.UnregisterName(System.String)
  - System.Windows.FrameworkTemplate.VisualTree
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.DataTemplate.#ctor
  id: '#ctor'
  parent: System.Windows.DataTemplate
  langs:
  - csharp
  name: DataTemplate()
  nameWithType: DataTemplate.DataTemplate()
  fullName: System.Windows.DataTemplate.DataTemplate()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.DataTemplate&quot;></xref>類別。"
  syntax:
    content: public DataTemplate ();
    parameters: []
  overload: System.Windows.DataTemplate.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DataTemplate.#ctor(System.Object)
  id: '#ctor(System.Object)'
  parent: System.Windows.DataTemplate
  langs:
  - csharp
  name: DataTemplate(Object)
  nameWithType: DataTemplate.DataTemplate(Object)
  fullName: System.Windows.DataTemplate.DataTemplate(Object)
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.DataTemplate&quot;></xref>類別具有指定<xref:System.Windows.DataTemplate.DataType*>屬性。</xref:System.Windows.DataTemplate.DataType*>"
  remarks: "若要參考類別的型別名稱，使用[X:type 標記延伸](~/add/includes/ajax-current-ext-md.md)。 如果範本用於[!INCLUDE[TLA#tla_xml](~/add/includes/tlasharptla-xml-md.md)]資料，這是代表資料的標記名稱的字串。"
  syntax:
    content: public DataTemplate (object dataType);
    parameters:
    - id: dataType
      type: System.Object
      description: "如果範本用於物件資料，這是資料物件的型別名稱。"
  overload: System.Windows.DataTemplate.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DataTemplate.DataTemplateKey
  id: DataTemplateKey
  parent: System.Windows.DataTemplate
  langs:
  - csharp
  name: DataTemplateKey
  nameWithType: DataTemplate.DataTemplateKey
  fullName: System.Windows.DataTemplate.DataTemplateKey
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得預設索引鍵<xref href=&quot;System.Windows.DataTemplate&quot;> </xref>。"
  remarks: "如果您未設定[X:key 指示詞](~/add/includes/ajax-current-ext-md.md)上<xref:System.Windows.DataTemplate>位於<xref:System.Windows.ResourceDictionary>，DataTemplateKey 當做索引鍵。</xref:System.Windows.ResourceDictionary> </xref:System.Windows.DataTemplate>"
  syntax:
    content: public object DataTemplateKey { get; }
    return:
      type: System.Object
      description: "預設索引鍵<xref href=&quot;System.Windows.DataTemplate&quot;> </xref>。"
  overload: System.Windows.DataTemplate.DataTemplateKey*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DataTemplate.DataType
  id: DataType
  parent: System.Windows.DataTemplate
  langs:
  - csharp
  name: DataType
  nameWithType: DataTemplate.DataType
  fullName: System.Windows.DataTemplate.DataType
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定這個型別<xref href=&quot;System.Windows.DataTemplate&quot;></xref>是。"
  remarks: "這個屬性是類別的非常類似於<xref:System.Windows.Style.TargetType%2A>屬性<xref:System.Windows.Style>類別。</xref:System.Windows.Style> </xref:System.Windows.Style.TargetType%2A> 當您設定此屬性的資料類型而不指定`x:Key`、<xref:System.Windows.DataTemplate>取得自動套用到該類型的資料物件。</xref:System.Windows.DataTemplate> 請注意，當您這麼做`x:Key`隱含設定。 因此，如果您指派這個<xref:System.Windows.DataTemplate>`x:Key`值，您會覆寫的隱含`x:Key`和<xref:System.Windows.DataTemplate>不會自動套用。</xref:System.Windows.DataTemplate> </xref:System.Windows.DataTemplate>       也請注意，如果您要繫結<xref:System.Windows.Controls.ContentControl>集合的`Task`物件<xref:System.Windows.Controls.ContentControl>不會使用<xref:System.Windows.DataTemplate>自動。</xref:System.Windows.DataTemplate> </xref:System.Windows.Controls.ContentControl> </xref:System.Windows.Controls.ContentControl> 這是因為在繫結<xref:System.Windows.Controls.ContentControl>需要區別您是否想要繫結至整個集合或個別物件的詳細資訊。</xref:System.Windows.Controls.ContentControl> 如果您<xref:System.Windows.Controls.ContentControl>正在追蹤的選取項目<xref:System.Windows.Controls.ItemsControl>類型，您可以設定<xref:System.Windows.Data.Binding.Path%2A>屬性<xref:System.Windows.Controls.ContentControl>繫結至 「`/`&quot;，表示您感興趣的目前項目。</xref:System.Windows.Controls.ContentControl> </xref:System.Windows.Data.Binding.Path%2A> </xref:System.Windows.Controls.ItemsControl> </xref:System.Windows.Controls.ContentControl> 如需範例，請參閱[How to︰ 繫結至集合並顯示選取項目基礎資訊](~/add/includes/ajax-current-ext-md.md)。 否則，您需要指定<xref:System.Windows.DataTemplate>明確地設定<xref:System.Windows.Controls.ContentControl.ContentTemplate%2A>屬性。</xref:System.Windows.Controls.ContentControl.ContentTemplate%2A> </xref:System.Windows.DataTemplate>       如果您有特別有用的 DataType 屬性，便<xref:System.Windows.Data.CompositeCollection>不同類型的資料物件。</xref:System.Windows.Data.CompositeCollection>       如果這個屬性的目標不在預設命名空間的 XML 項目，您必須在命名空間或命名空間指示項的項目名稱。 透過 LINQ 為公開 XML 命名空間會出現在大括號中的 xml 加上括號逸出序列︰ ```xaml   <DataTemplate DataType=&quot;{}{http://myNamespace}Details&quot;>   ``` For XML 公開會透過 XPath、 項目名稱前面會有一個執行個體所建立的命名空間指示項<xref:System.Windows.Data.XmlNamespaceMapping>: ```xaml   <DataTemplate DataType=&quot;mn:Details&quot;>   ``` <a name=&quot;xamlAttributeUsage_DataType&quot;> </a> # # XAML 屬性使用方式```   <object DataType=&quot;typeName&quot;/>   ``` <a name=&quot;xamlValues_DataType&quot;> </a> # # XAML 值*typeName*範本供物件資料，如果此屬性包含 （做為字串） 的資料物件的型別名稱。            </xref:System.Windows.Data.XmlNamespaceMapping> 若要參考類別的型別名稱，使用[X:type 標記延伸](~/add/includes/ajax-current-ext-md.md)。 如果範本用於[!INCLUDE[TLA#tla_xml](~/add/includes/tlasharptla-xml-md.md)]資料，這個屬性包含 XML 項目名稱。 請參閱文件註解如需詳細資訊，關於指定非預設命名空間的 XML 項目。"
  syntax:
    content: public object DataType { get; set; }
    return:
      type: System.Object
      description: "預設值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.DataTemplate.DataType*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DataTemplate.Triggers
  id: Triggers
  parent: System.Windows.DataTemplate
  langs:
  - csharp
  name: Triggers
  nameWithType: DataTemplate.Triggers
  fullName: System.Windows.DataTemplate.Triggers
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得套用屬性值，或根據一個或多個條件執行動作的觸發程序的集合。"
  remarks: "如果您要建立資料範本中的觸發程序，觸發程序 setter 應該設定資料範本的範圍內的屬性。 否則，它可能是更適合用來建立觸發程序使用包含資料的類型為目標的樣式。 例如，如果您要繫結<xref:System.Windows.Controls.ListBox>控制項，容器是<xref:System.Windows.Controls.ListBoxItem>物件。</xref:System.Windows.Controls.ListBoxItem> </xref:System.Windows.Controls.ListBox> 如果您使用觸發程序來設定屬性的範圍內<xref:System.Windows.DataTemplate>，則可能是更適合用來建立<xref:System.Windows.Controls.ListBoxItem>樣式，並建立該樣式中的觸發程序。</xref:System.Windows.Controls.ListBoxItem> </xref:System.Windows.DataTemplate> 如需詳細資訊，請參閱 < 什麼所屬 DataTemplate 中？在[資料範本化概觀](~/add/includes/ajax-current-ext-md.md)。      > [!NOTE] > 這個屬性只能在設定[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]集合語法所示，透過或存取的集合物件和使用的各種方法，例如 Add。 用來存取集合物件本身屬性是唯讀，集合本身為讀寫。      <a name=&quot;xamlPropertyElementUsage_Triggers&quot;></a># # XAML 屬性項目用法```   <object>     <object.Triggers>       OneOrMoreTriggers     </object.Triggers>   </object>   ``` <a name=&quot;xamlValues_Triggers&quot;> </a> # # XAML 值*OneOrMoreTriggers*零或多個<xref:System.Windows.TriggerBase>物件。</xref:System.Windows.TriggerBase>      "
  example:
  - "The following <xref:System.Windows.DataTemplate> demonstrates the use of the Triggers property.  \n  \n [!code-xml[DataBindingLab#AuctionItemDataTemplate](~/add/codesnippet/xaml/DataBindingLab/DataBindingLabApp.xaml#auctionitemdatatemplate)]  \n  \n For the complete sample, see [Data Binding Demo](http://go.microsoft.com/fwlink/?LinkID=163703)."
  syntax:
    content: public System.Windows.TriggerCollection Triggers { get; }
    return:
      type: System.Windows.TriggerCollection
      description: "觸發程序物件的集合。 預設值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.DataTemplate.Triggers*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.DataTemplate.ValidateTemplatedParent(System.Windows.FrameworkElement)
  id: ValidateTemplatedParent(System.Windows.FrameworkElement)
  parent: System.Windows.DataTemplate
  langs:
  - csharp
  name: ValidateTemplatedParent(FrameworkElement)
  nameWithType: DataTemplate.ValidateTemplatedParent(FrameworkElement)
  fullName: System.Windows.DataTemplate.ValidateTemplatedParent(FrameworkElement)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "請檢查樣板化的父代，針對一組規則。"
  remarks: "此方法會使用下列規則:-`templatedParent`必須為非 null <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement>      <xref:System.Windows.DataTemplate>必須套用至<xref:System.Windows.Controls.ContentPresenter>。</xref:System.Windows.Controls.ContentPresenter> </xref:System.Windows.DataTemplate> -"
  syntax:
    content: protected override void ValidateTemplatedParent (System.Windows.FrameworkElement templatedParent);
    parameters:
    - id: templatedParent
      type: System.Windows.FrameworkElement
      description: "此範本會套用到項目。"
  overload: System.Windows.DataTemplate.ValidateTemplatedParent*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.FrameworkTemplate
  isExternal: false
  name: System.Windows.FrameworkTemplate
- uid: System.Windows.DataTemplate.#ctor
  parent: System.Windows.DataTemplate
  isExternal: false
  name: DataTemplate()
  nameWithType: DataTemplate.DataTemplate()
  fullName: System.Windows.DataTemplate.DataTemplate()
- uid: System.Windows.DataTemplate.#ctor(System.Object)
  parent: System.Windows.DataTemplate
  isExternal: false
  name: DataTemplate(Object)
  nameWithType: DataTemplate.DataTemplate(Object)
  fullName: System.Windows.DataTemplate.DataTemplate(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.DataTemplate.DataTemplateKey
  parent: System.Windows.DataTemplate
  isExternal: false
  name: DataTemplateKey
  nameWithType: DataTemplate.DataTemplateKey
  fullName: System.Windows.DataTemplate.DataTemplateKey
- uid: System.Windows.DataTemplate.DataType
  parent: System.Windows.DataTemplate
  isExternal: false
  name: DataType
  nameWithType: DataTemplate.DataType
  fullName: System.Windows.DataTemplate.DataType
- uid: System.Windows.DataTemplate.Triggers
  parent: System.Windows.DataTemplate
  isExternal: false
  name: Triggers
  nameWithType: DataTemplate.Triggers
  fullName: System.Windows.DataTemplate.Triggers
- uid: System.Windows.TriggerCollection
  parent: System.Windows
  isExternal: false
  name: TriggerCollection
  nameWithType: TriggerCollection
  fullName: System.Windows.TriggerCollection
- uid: System.Windows.DataTemplate.ValidateTemplatedParent(System.Windows.FrameworkElement)
  parent: System.Windows.DataTemplate
  isExternal: false
  name: ValidateTemplatedParent(FrameworkElement)
  nameWithType: DataTemplate.ValidateTemplatedParent(FrameworkElement)
  fullName: System.Windows.DataTemplate.ValidateTemplatedParent(FrameworkElement)
- uid: System.Windows.FrameworkElement
  parent: System.Windows
  isExternal: false
  name: FrameworkElement
  nameWithType: FrameworkElement
  fullName: System.Windows.FrameworkElement
- uid: System.Windows.DataTemplate.#ctor*
  parent: System.Windows.DataTemplate
  isExternal: false
  name: DataTemplate
  nameWithType: DataTemplate.DataTemplate
- uid: System.Windows.DataTemplate.DataTemplateKey*
  parent: System.Windows.DataTemplate
  isExternal: false
  name: DataTemplateKey
  nameWithType: DataTemplate.DataTemplateKey
- uid: System.Windows.DataTemplate.DataType*
  parent: System.Windows.DataTemplate
  isExternal: false
  name: DataType
  nameWithType: DataTemplate.DataType
- uid: System.Windows.DataTemplate.Triggers*
  parent: System.Windows.DataTemplate
  isExternal: false
  name: Triggers
  nameWithType: DataTemplate.Triggers
- uid: System.Windows.DataTemplate.ValidateTemplatedParent*
  parent: System.Windows.DataTemplate
  isExternal: false
  name: ValidateTemplatedParent
  nameWithType: DataTemplate.ValidateTemplatedParent
