### YamlMime:ManagedReference
items:
- uid: System.Web.HttpServerUtility
  id: HttpServerUtility
  children:
  - System.Web.HttpServerUtility.ClearError
  - System.Web.HttpServerUtility.CreateObject(System.String)
  - System.Web.HttpServerUtility.CreateObject(System.Type)
  - System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)
  - System.Web.HttpServerUtility.Execute(System.String)
  - System.Web.HttpServerUtility.Execute(System.String,System.Boolean)
  - System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)
  - System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)
  - System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)
  - System.Web.HttpServerUtility.GetLastError
  - System.Web.HttpServerUtility.HtmlDecode(System.String)
  - System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)
  - System.Web.HttpServerUtility.HtmlEncode(System.String)
  - System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)
  - System.Web.HttpServerUtility.MachineName
  - System.Web.HttpServerUtility.MapPath(System.String)
  - System.Web.HttpServerUtility.ScriptTimeout
  - System.Web.HttpServerUtility.Transfer(System.String)
  - System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)
  - System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)
  - System.Web.HttpServerUtility.TransferRequest(System.String)
  - System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)
  - System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)
  - System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)
  - System.Web.HttpServerUtility.UrlDecode(System.String)
  - System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)
  - System.Web.HttpServerUtility.UrlEncode(System.String)
  - System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)
  - System.Web.HttpServerUtility.UrlPathEncode(System.String)
  - System.Web.HttpServerUtility.UrlTokenDecode(System.String)
  - System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])
  langs:
  - csharp
  name: HttpServerUtility
  nameWithType: HttpServerUtility
  fullName: System.Web.HttpServerUtility
  type: Class
  summary: "提供處理 Web 要求的 helper 方法。"
  remarks: "透過內建公開的方法和屬性的 HttpServerUtility 類別<xref:System.Web.HttpContext.Server%2A>ASP.NET 所提供的物件。</xref:System.Web.HttpContext.Server%2A>"
  example:
  - "A Visual Studio Web site project with source code is available to accompany this topic: [Download](http://go.microsoft.com/fwlink/?LinkId=192870).  \n  \n The following example demonstrates how to use the <xref:System.Web.HttpServerUtility.HtmlEncode%2A> method and the <xref:System.Web.HttpServerUtility.UrlEncode%2A> method of the HttpServerUtility class. The <xref:System.Web.HttpServerUtility.HtmlEncode%2A> method helps ensure that any user-supplied string input will be rendered as static text in browsers instead of executable script or HTML elements. The <xref:System.Web.HttpServerUtility.UrlEncode%2A> method encodes URLs so that they are correctly transmitted in the HTTP stream.  \n  \n [!code-cs[System.Web.HttpServerUtility1#1](~/add/codesnippet/csharp/t-system.web.httpserveru_1.aspx)]\n [!code-vb[System.Web.HttpServerUtility1#1](~/add/codesnippet/visualbasic/t-system.web.httpserveru_1.aspx)]"
  syntax:
    content: public sealed class HttpServerUtility
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.ClearError
  id: ClearError
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: ClearError()
  nameWithType: HttpServerUtility.ClearError()
  fullName: System.Web.HttpServerUtility.ClearError()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "清除前一個例外狀況。"
  remarks: ''
  example:
  - "The following example clears the last exception that was thrown.  \n  \n [!code-cs[Classic HttpServerUtility.ClearError Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_6_1.cs)]\n [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_6_1.vb)]"
  syntax:
    content: public void ClearError ();
    parameters: []
  overload: System.Web.HttpServerUtility.ClearError*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.CreateObject(System.String)
  id: CreateObject(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: CreateObject(String)
  nameWithType: HttpServerUtility.CreateObject(String)
  fullName: System.Web.HttpServerUtility.CreateObject(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "建立物件的程式設計識別項 (ProgID) 所識別的 COM 物件的伺服器執行個體。"
  remarks: ''
  example:
  - "The following example creates an object by using the object's ProgID.  \n  \n [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_4_1.vb)]\n [!code-cs[Classic HttpServerUtility.CreateObject Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_4_1.cs)]"
  syntax:
    content: public object CreateObject (string progID);
    parameters:
    - id: progID
      type: System.String
      description: "類別或要建立的執行個體的物件類型。"
    return:
      type: System.Object
      description: "新的物件。"
  overload: System.Web.HttpServerUtility.CreateObject*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "無法建立物件的執行個體。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.CreateObject(System.Type)
  id: CreateObject(System.Type)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: CreateObject(Type)
  nameWithType: HttpServerUtility.CreateObject(Type)
  fullName: System.Web.HttpServerUtility.CreateObject(Type)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "建立物件的類型識別之 COM 物件的伺服器執行個體。"
  syntax:
    content: public object CreateObject (Type type);
    parameters:
    - id: type
      type: System.Type
      description: "A<xref:System.Type>代表要建立的物件。</xref:System.Type>"
    return:
      type: System.Object
      description: "新的物件。"
  overload: System.Web.HttpServerUtility.CreateObject*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)
  id: CreateObjectFromClsid(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: CreateObjectFromClsid(String)
  nameWithType: HttpServerUtility.CreateObjectFromClsid(String)
  fullName: System.Web.HttpServerUtility.CreateObjectFromClsid(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "建立 COM 物件的物件類別識別項 (CLSID) 所識別的伺服器執行個體。"
  remarks: ''
  example:
  - "The following example demonstrates how to use the CreateObjectFromClsid method to create a server instance of a COM object.  \n  \n [!code-cs[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_2_1.cs)]\n [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_2_1.vb)]"
  syntax:
    content: public object CreateObjectFromClsid (string clsid);
    parameters:
    - id: clsid
      type: System.String
      description: "要建立的執行個體的物件類別識別項。"
    return:
      type: System.Object
      description: "新的物件。"
  overload: System.Web.HttpServerUtility.CreateObjectFromClsid*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "無法建立物件的執行個體。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Execute(System.String)
  id: Execute(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Execute(String)
  nameWithType: HttpServerUtility.Execute(String)
  fullName: System.Web.HttpServerUtility.Execute(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "目前要求的內容中執行指定虛擬路徑的處理常式。"
  remarks: "Execute 方法會在新網頁的執行完成之後，繼續執行原始頁面。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法無條件地將執行轉移至另一個處理常式。</xref:System.Web.HttpServerUtility.Transfer%2A>       ASP.NET 不會驗證目前使用者獲得授權檢視的 Execute 方法所傳遞的資源。 雖然 ASP.NET 授權和驗證邏輯會在呼叫原始資源的處理常式之前，ASP.NET 直接呼叫 Execute 方法所指定的處理常式，並不會重新執行驗證和授權邏輯，新的資源。 如果您的應用程式安全性原則需要有適當的權限可存取資源的用戶端，應用程式應該強制重新授權，或提供自訂的存取控制機制。       您可以使用強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法而不是執行方法。</xref:System.Web.HttpResponse.Redirect%2A> <xref:System.Web.HttpResponse.Redirect%2A>執行用戶端重新導向瀏覽器要求新的資源。</xref:System.Web.HttpResponse.Redirect%2A> 因為這個重新導向時輸入系統的新要求，所以必須網際網路資訊服務 (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。       您可以驗證使用者已透過加入自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>應用程式會呼叫執行方法之前的方法。</xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>"
  example:
  - "The following example displays the .aspx page \"Updateinfo.aspx\" in the current directory. Program execution returns to the starting page after the Updateinfo.aspx page is displayed.  \n  \n [!code-vb[Classic HttpServerUtility.Execute Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_15_1.vb)]\n [!code-cs[Classic HttpServerUtility.Execute Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_15_1.cs)]"
  syntax:
    content: public void Execute (string path);
    parameters:
    - id: path
      type: System.String
      description: "要執行的 URL 路徑。"
  overload: System.Web.HttpServerUtility.Execute*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "The current <xref href=\"System.Web.HttpContext\"></xref> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An error occurred while executing the handler specified by <code>path</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>path</code> is not a virtual path."
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Execute(System.String,System.Boolean)
  id: Execute(System.String,System.Boolean)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Execute(String,Boolean)
  nameWithType: HttpServerUtility.Execute(String,Boolean)
  fullName: System.Web.HttpServerUtility.Execute(String,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "目前要求的內容中執行指定虛擬路徑的處理常式，並指定是否要清除<> *> 和<> *> 集合。"
  remarks: ''
  example:
  - "The following example shows how to execute the .aspx page `Updateinfo.aspx` in the current request and preserve the <xref:System.Web.HttpRequest.QueryString%2A> and <xref:System.Web.HttpRequest.Form%2A> collections. Program execution returns to the starting page after `Updateinfo.aspx` is displayed.  \n  \n [!code-vb[HttpServerUtility.Execute#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_16_1.aspx)]\n [!code-cs[HttpServerUtility.Execute#1](~/add/codesnippet/csharp/m-system.web.httpserveru_16_1.aspx)]"
  syntax:
    content: public void Execute (string path, bool preserveForm);
    parameters:
    - id: path
      type: System.String
      description: "要執行的 URL 路徑。"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *> 和<> *> 集合。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref> to clear the <>*> and <>*> collections."
  overload: System.Web.HttpServerUtility.Execute*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "The current <xref href=\"System.Web.HttpContext\"></xref> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An error occurred while executing the handler specified by <code>path</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>path</code> is not a virtual path."
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)
  id: Execute(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Execute(String,TextWriter)
  nameWithType: HttpServerUtility.Execute(String,TextWriter)
  fullName: System.Web.HttpServerUtility.Execute(String,TextWriter)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "目前要求的內容中執行指定虛擬路徑的處理常式。 A<xref:System.IO.TextWriter>擷取從執行的處理常式的輸出。</xref:System.IO.TextWriter>"
  remarks: "指定的虛擬路徑的執行完成之後，執行方法就會繼續執行原始要求。 <xref:System.Web.HttpServerUtility.Transfer%2A>方法無條件地將執行轉移至另一個處理常式。</xref:System.Web.HttpServerUtility.Transfer%2A>       ASP.NET 不會驗證目前使用者獲得授權檢視的 Execute 方法所傳遞的資源。 雖然 ASP.NET 授權和驗證邏輯會在呼叫原始資源的處理常式之前，ASP.NET 直接呼叫 Execute 方法所指定的處理常式，並不會重新執行驗證和授權邏輯，新的資源。 如果您的應用程式安全性原則需要有適當的權限可存取資源的用戶端，應用程式應該強制重新授權，或提供自訂的存取控制機制。       您可以使用強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法而不是執行方法。</xref:System.Web.HttpResponse.Redirect%2A> <xref:System.Web.HttpResponse.Redirect%2A>執行用戶端重新導向瀏覽器要求新的資源。</xref:System.Web.HttpResponse.Redirect%2A> 因為這個重新導向時輸入系統的新要求，所以必須網際網路資訊服務 (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。       您可以驗證使用者已透過加入自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>應用程式會呼叫執行方法之前的方法。</xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>"
  example:
  - "The following example executes the `Login.aspx` page on the server in the current directory and receives the output from the page through the <xref:System.IO.StringWriter> object `writer`. It writes the HTML stream received from `writer` to the HTTP output stream.  \n  \n [!code-cs[Classic HttpServerUtility.Execute1 Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_12_1.cs)]\n [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_12_1.vb)]"
  syntax:
    content: public void Execute (string path, System.IO.TextWriter writer);
    parameters:
    - id: path
      type: System.String
      description: "要執行的 URL 路徑。"
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>要擷取輸出。</xref:System.IO.TextWriter>"
  overload: System.Web.HttpServerUtility.Execute*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "The current <xref href=\"System.Web.HttpContext\"></xref> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n An error occurred while executing the handler specified by <code>path</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code> is <xref uid=\"langword_csharp_null\" name=\"null\" href=\"\"></xref>.  \n  \n \\- or -  \n  \n <code>path</code> is not a virtual path."
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)
  id: Execute(System.String,System.IO.TextWriter,System.Boolean)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Execute(String,TextWriter,Boolean)
  nameWithType: HttpServerUtility.Execute(String,TextWriter,Boolean)
  fullName: System.Web.HttpServerUtility.Execute(String,TextWriter,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "目前要求的內容中執行指定虛擬路徑的處理常式。 A<xref:System.IO.TextWriter>擷取輸出的頁面和布林值參數會指定是否要清除<> *> 和<> *> 集合。</xref:System.IO.TextWriter>"
  remarks: "<xref:System.Web.HttpServerUtility.Execute%2A>方法指定的虛擬路徑的執行完成之後會繼續執行原始的要求。</xref:System.Web.HttpServerUtility.Execute%2A> <xref:System.Web.HttpServerUtility.Transfer%2A>方法無條件地將執行轉移至另一個處理常式。</xref:System.Web.HttpServerUtility.Transfer%2A>       ASP.NET 不會驗證目前使用者獲得授權檢視的 Execute 方法所傳遞的資源。 雖然 ASP.NET 授權和驗證邏輯會在呼叫原始資源的處理常式之前，ASP.NET 直接呼叫 Execute 方法所指定的處理常式，並不會重新執行驗證和授權邏輯，新的資源。 如果您的應用程式安全性原則需要有適當的權限可存取資源的用戶端，應用程式應該強制重新授權，或提供自訂的存取控制機制。       您可以使用強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法而不是執行方法。</xref:System.Web.HttpResponse.Redirect%2A> <xref:System.Web.HttpResponse.Redirect%2A>執行用戶端重新導向瀏覽器要求新的資源。</xref:System.Web.HttpResponse.Redirect%2A> 因為這個重新導向時輸入系統的新要求，所以必須網際網路資訊服務 (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。       您可以驗證使用者已透過加入自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>應用程式會呼叫執行方法之前的方法。</xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>"
  example:
  - "The following example executes the `Login.aspx` page on the server in the current directory and receives the output from the page through the <xref:System.IO.StringWriter> object `writer`. It writes the HTML stream received from `writer` to the HTTP output stream. The contents of the <xref:System.Web.HttpRequest.Form%2A> and <xref:System.Web.HttpRequest.QueryString%2A> collections are preserved.  \n  \n [!code-cs[HttpServerUtility.Execute02#1](~/add/codesnippet/csharp/0d13d28c-0070-4c47-b943-_1.aspx)]\n [!code-vb[HttpServerUtility.Execute02#1](~/add/codesnippet/visualbasic/0d13d28c-0070-4c47-b943-_1.aspx)]"
  syntax:
    content: public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);
    parameters:
    - id: path
      type: System.String
      description: "要執行的 URL 路徑。"
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>要擷取輸出。</xref:System.IO.TextWriter>"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *> 和<> *> 集合。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref> to clear the <>*> and <>*> collections."
  overload: System.Web.HttpServerUtility.Execute*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "The current <xref href=\"System.Web.HttpContext\"></xref> is a null reference (<xref uid=\"langword_csharp_Nothing\" name=\"Nothing\" href=\"\"></xref> in Visual Basic).  \n  \n \\- or -  \n  \n <code>path</code> ends with a period (.).  \n  \n \\- or -  \n  \n An error occurred while executing the handler specified by <code>path</code>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>不是虛擬路徑。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)
  id: Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Execute(IHttpHandler,TextWriter,Boolean)
  nameWithType: HttpServerUtility.Execute(IHttpHandler,TextWriter,Boolean)
  fullName: System.Web.HttpServerUtility.Execute(IHttpHandler,TextWriter,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "目前要求的內容中執行指定虛擬路徑的處理常式。 A<xref:System.IO.TextWriter>擷取輸出，從執行的處理常式和布林值參數會指定是否要清除<> *> 和<> *> 集合。</xref:System.IO.TextWriter>"
  remarks: "您可以撰寫自訂 HTTP 處理常式來處理 HTTP 要求中任何以 Common Language Specification (CLS) 相容的語言特定的預先定義的類型。 定義 HTTP 處理常式類別，而不是傳統 ASP (也稱為傳統 ASP) 網頁或 ASP.NET 網頁中的可執行程式碼回應這些特定的要求。 進行互動的低層級的要求和回應服務的 Web 伺服器正在執行網際網路資訊服務 (IIS) 允許 HTTP 處理常式，並且會提供類似功能的 ISAPI 擴充程式但更簡單的程式設計模型。       ASP.NET 不會驗證目前使用者獲得授權檢視 Execute 方法所傳遞的資源。 雖然 ASP.NET 授權和驗證邏輯會在呼叫原始資源的處理常式之前，ASP.NET 會直接呼叫此處理常式，會以執行方法並不會重新執行驗證和授權邏輯，新的資源。 如果您的應用程式的安全性原則需要用戶端具有適當的授權，才能存取資源，應用程式應該強制重新授權，或提供的自訂存取控制機制。       您可以使用強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法而不是執行方法。</xref:System.Web.HttpResponse.Redirect%2A> <xref:System.Web.HttpResponse.Redirect%2A>用戶端重新導向瀏覽器要求新的資源。</xref:System.Web.HttpResponse.Redirect%2A> 這個重新導向時輸入系統的新要求，因為它必須同時 IIS 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。       您可以驗證使用者已透過加入自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>應用程式會呼叫執行方法之前的方法。</xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>"
  syntax:
    content: public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);
    parameters:
    - id: handler
      type: System.Web.IHttpHandler
      description: "HTTP 處理常式實作<xref href=&quot;System.Web.IHttpHandler&quot;></xref>傳送目前的要求。"
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>要擷取輸出。</xref:System.IO.TextWriter>"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *> 和<> *> 集合。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref> to clear the <>*> and <>*> collections."
  overload: System.Web.HttpServerUtility.Execute*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "執行所指定的處理常式時發生錯誤<code> handler </code>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>handler</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Web.HttpServerUtility.GetLastError
  id: GetLastError
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: GetLastError()
  nameWithType: HttpServerUtility.GetLastError()
  fullName: System.Web.HttpServerUtility.GetLastError()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "傳回前一個例外狀況。"
  remarks: ''
  example:
  - "The following example prints a description of the application's last error to the HTTP output stream. It prints \"No Errors\" if no errors have been encountered.  \n  \n [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_8_1.vb)]\n [!code-cs[Classic HttpServerUtility.GetLastError Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_8_1.cs)]"
  syntax:
    content: public Exception GetLastError ();
    parameters: []
    return:
      type: System.Exception
      description: "擲回的先前例外狀況。"
  overload: System.Web.HttpServerUtility.GetLastError*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.HtmlDecode(System.String)
  id: HtmlDecode(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: HtmlDecode(String)
  nameWithType: HttpServerUtility.HtmlDecode(String)
  fullName: System.Web.HttpServerUtility.HtmlDecode(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "將 HTML 編碼字串解碼，並傳回解碼的字串。"
  remarks: "HTML encoding makes sure that text is displayed correctly in the browser and not interpreted by the browser as HTML. For example, if a text string contains a less than sign (\\<) or greater than sign (>), the browser would interpret these characters as the opening or closing bracket of an HTML tag. When the characters are HTML encoded, they are converted to the strings `<` and `>`, which causes the browser to display the less than sign and greater than sign correctly. HtmlDecode decodes text that has been transmitted to the server.  \n  \n This method is a convenient way to access the <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=fullName> method at run time from an ASP.NET application. Internally, this method uses <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=fullName> to decode strings.  \n  \n In the code-behind file for an ASP.NET web page, access an instance of the <xref:System.Web.HttpServerUtility> class through the `Server` property. In a class that is not in a code-behind file, use `HttpContext.Current.Server` to access an instance of the <xref:System.Web.HttpServerUtility> class.  \n  \n Outside of a web application, use the <xref:System.Net.WebUtility> class to encode or decode values."
  example:
  - "The following example contains the function `LoadDecodedFile`, which decodes the data from a file and copies it into one string.  \n  \n [!code-cs[Classic HttpServerUtility.HtmlDecode Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_14_1.aspx)]\n [!code-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_14_1.aspx)]"
  syntax:
    content: public string HtmlDecode (string s);
    parameters:
    - id: s
      type: System.String
      description: "要解碼的 HTML 字串。"
    return:
      type: System.String
      description: "解碼的文字。"
  overload: System.Web.HttpServerUtility.HtmlDecode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)
  id: HtmlDecode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: HtmlDecode(String,TextWriter)
  nameWithType: HttpServerUtility.HtmlDecode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.HtmlDecode(String,TextWriter)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "將 HTML 編碼字串解碼，並產生將輸出傳送到<xref:System.IO.TextWriter>輸出資料流。</xref:System.IO.TextWriter>"
  remarks: "HTML encoding makes sure that text is displayed correctly in the browser and not interpreted by the browser as HTML. For example, if a text string contains a less than sign (\\<) or greater than sign (>), the browser would interpret these characters as the opening or closing bracket of an HTML tag. When the characters are HTML encoded, they are converted to the strings `<` and `>`, which causes the browser to display the less than sign and greater than sign correctly.  \n  \n <xref:System.Web.HttpServerUtility.HtmlDecode%2A> decodes text that has been transmitted to the server.  \n  \n <xref:System.Web.HttpServerUtility.HtmlDecode%2A> is a convenient way to access the <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=fullName> method at run time from an ASP.NET application. Internally, <xref:System.Web.HttpServerUtility.HtmlDecode%2A> uses <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=fullName> to decode strings.  \n  \n To encode or decode values outside of a web application, use the <xref:System.Net.WebUtility> class."
  example:
  - "The following example decodes a string that has been HTML-encoded for transmission over HTTP. It decodes the supplied string named `EncodedString` which contains the text \"This is a &lt;Test String&gt;.\", and copies it into the string named `DecodedString` as \"This is a \\<Test String>.\".  \n  \n [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_1_1.vb)]\n [!code-cs[Classic HttpServerUtility.HtmlDecode1 Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_1_1.cs)]"
  syntax:
    content: public void HtmlDecode (string s, System.IO.TextWriter output);
    parameters:
    - id: s
      type: System.String
      description: "要解碼的 HTML 字串。"
    - id: output
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>輸出資料流，其中包含已解碼的字串。</xref:System.IO.TextWriter>"
  overload: System.Web.HttpServerUtility.HtmlDecode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.HtmlEncode(System.String)
  id: HtmlEncode(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: HtmlEncode(String)
  nameWithType: HttpServerUtility.HtmlEncode(String)
  fullName: System.Web.HttpServerUtility.HtmlEncode(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "HTML 編碼字串，並傳回編碼的字串。"
  remarks: "HTML encoding makes sure that text is displayed correctly in the browser and not interpreted by the browser as HTML. For example, if a text string contains a less than sign (\\<) or greater than sign (>), the browser would interpret these characters as the opening or closing bracket of an HTML tag. When the characters are HTML encoded, they are converted to the strings `<` and `>`, which causes the browser to display the less than sign and greater than sign correctly.  \n  \n This method is a convenient way to access the <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=fullName> method at run time from an ASP.NET application. Internally, this method uses <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=fullName> to encode strings.  \n  \n In the code-behind file for an ASP.NET web page, access an instance of the <xref:System.Web.HttpServerUtility> class through the `Server` property. In a class that is not in a code-behind file, use `HttpContext.Current.Server` to access an instance of the <xref:System.Web.HttpServerUtility> class.  \n  \n Outside of a web application, use the <xref:System.Net.WebUtility> class to encode or decode values."
  example:
  - "The following example shows how to HTML-encode a value that potentially codes unsafe code. The code resides in the code-behind file for a web page. The value to encode is hard-coded in this example only to simplify the example and show the type of value you might HTML-encode. Typically, you would HTML-encode a value that you received from the user or the request. `Result` refers to a `Literal` control.  \n  \n [!code-cs[System.Web.HttpServerUtility.HtmlEncode#1](~/add/codesnippet/csharp/m-system.web.httpserveru_10_1.cs)]\n [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_10_1.vb)]  \n  \n The next example is similar to the previous example except it shows how to HTML-encode a value from within a class that is not in the code-behind file.  \n  \n [!code-cs[System.Web.HttpServerUtility.HtmlEncode#2](~/add/codesnippet/csharp/m-system.web.httpserveru_10_2.cs)]\n [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/add/codesnippet/visualbasic/m-system.web.httpserveru_10_2.vb)]"
  syntax:
    content: public string HtmlEncode (string s);
    parameters:
    - id: s
      type: System.String
      description: "要編碼的文字字串。"
    return:
      type: System.String
      description: "HTML 編碼的文字。"
  overload: System.Web.HttpServerUtility.HtmlEncode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)
  id: HtmlEncode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: HtmlEncode(String,TextWriter)
  nameWithType: HttpServerUtility.HtmlEncode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.HtmlEncode(String,TextWriter)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "HTML 編碼字串，並將結果輸出至<xref:System.IO.TextWriter>輸出資料流。</xref:System.IO.TextWriter>"
  remarks: "HTML encoding ensures that text will be correctly displayed in the browser, not interpreted by the browser as HTML. For example, if a text string contains a less than sign (\\<) or greater than sign (>), the browser would interpret these characters as an opening or closing bracket of an HTML tag. The HTML encoding of these two characters is `<` and `>`, respectively, which causes the browser to display the less than sign and greater than sign correctly.  \n  \n <xref:System.Web.HttpServerUtility.HtmlEncode%2A> is a convenient way to access the <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=fullName> method at run time from an ASP.NET application. Internally, <xref:System.Web.HttpServerUtility.HtmlEncode%2A> uses <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=fullName> to encode strings.  \n  \n To encode or decode values outside of a web application, use the <xref:System.Net.WebUtility> class."
  example:
  - "The following example encodes a string for transmission by HTTP. It encodes the string named `TestString`, which contains the text \"This is a \\<Test String>.\", and copies it into the string named `EncodedString` as \"This is a &lt;Test String&gt;.\".  \n  \n [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_7_1.vb)]\n [!code-cs[Classic HttpServerUtility.HtmlEncode1 Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_7_1.cs)]"
  syntax:
    content: public void HtmlEncode (string s, System.IO.TextWriter output);
    parameters:
    - id: s
      type: System.String
      description: "要編碼的字串。"
    - id: output
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>輸出資料流，其中包含編碼的字串。</xref:System.IO.TextWriter>"
  overload: System.Web.HttpServerUtility.HtmlEncode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.MachineName
  id: MachineName
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: MachineName
  nameWithType: HttpServerUtility.MachineName
  fullName: System.Web.HttpServerUtility.MachineName
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得伺服器的電腦名稱。"
  remarks: ''
  example:
  - "The following example stores the server's computer name as a string variable.  \n  \n [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/add/codesnippet/visualbasic/p-system.web.httpserveru_0_1.vb)]\n [!code-cs[Classic HttpServerUtility.MachineName Example#1](~/add/codesnippet/csharp/p-system.web.httpserveru_0_1.cs)]"
  syntax:
    content: public string MachineName { get; }
    return:
      type: System.String
      description: "本機電腦的名稱。"
  overload: System.Web.HttpServerUtility.MachineName*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "找不到的電腦名稱。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.MapPath(System.String)
  id: MapPath(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: MapPath(String)
  nameWithType: HttpServerUtility.MapPath(String)
  fullName: System.Web.HttpServerUtility.MapPath(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "傳回指定的虛擬路徑對應的實體檔案路徑。"
  remarks: "If `path` is `null`, the MapPath method returns the full physical path of the directory that contains the current request for the path. The relative path does not need to specify an existing file or folder for this method to return a value. However, you cannot specify a path outside of the Web application.  \n  \n> [!IMPORTANT]\n>  The MapPath method potentially contains sensitive information about the hosting environment. The return value should not be displayed to users.  \n  \n A Web application that resides at `C:\\ExampleSites\\TestMapPath` would return the following results:  \n  \n|Request from|`path`|Returned value|  \n|------------------|------------|--------------------|  \n|RootLevelPage.aspx|`null`|C:\\ExampleSites\\TestMapPath|  \n|RootLevelPage.aspx|\"/DownOneLevel/DownLevelPage.aspx\"|C:\\ExampleSites\\TestMapPath\\DownOneLevel\\DownLevelPage.aspx|  \n|RootLevelPage.aspx|\"/NotRealFolder\"|C:\\ExampleSites\\TestMapPath\\NotRealFolder|  \n|RootLevelPage.aspx|\"../OutsideApplication\"|<xref:System.Web.HttpException>|  \n|/DownOneLevel/DownLevelPage.aspx|`null`|C:\\ExampleSites\\TestMapPath\\DownOneLevel|  \n|/DownOneLevel/DownLevelPage.aspx|\"../RootLevelPage.aspx\"|C:\\ExampleSites\\TestMapPath\\RootLevelPage.aspx|"
  example:
  - "The following example shows how to retrieve the physical file of a relative virtual path. The code resides in the code-behind file for a web page and utilizes the default `Server` object.  \n  \n [!code-cs[System.Web.HttpServerUtility.MapPath#1](~/add/codesnippet/csharp/m-system.web.httpserveru_5_1.cs)]\n [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_5_1.vb)]  \n  \n The next example is similar to the previous example except it shows how to retrieve a physical path from within a class that is not in the code-behind file.  \n  \n [!code-cs[System.Web.HttpServerUtility.MapPath#2](~/add/codesnippet/csharp/m-system.web.httpserveru_5_2.cs)]\n [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/add/codesnippet/visualbasic/m-system.web.httpserveru_5_2.vb)]"
  syntax:
    content: public string MapPath (string path);
    parameters:
    - id: path
      type: System.String
      description: "Web 應用程式中的虛擬路徑。"
    return:
      type: System.String
      description: "對應至 Web 伺服器上的實體檔案路徑<code> path </code>。"
  overload: System.Web.HttpServerUtility.MapPath*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "The current <xref href=&quot;System.Web.HttpContext&quot;></xref> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Web.HttpServerUtility.ScriptTimeout
  id: ScriptTimeout
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: ScriptTimeout
  nameWithType: HttpServerUtility.ScriptTimeout
  fullName: System.Web.HttpServerUtility.ScriptTimeout
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得和設定要求的逾時值，以秒為單位。"
  remarks: "ScriptTimeout 屬性可以在 Web.config 檔案中設定，藉由設定`executionTimeout`項目的屬性。 設定以程式設計方式使用 ScriptTimeout 屬性逾時的優先順序高於此 Web.config 設定。      > [!NOTE] > 如果您設定`debug`至項目的屬性`true`在 Web.config 檔案中，將忽略 ScriptTimeout 的值。"
  example:
  - "The following example sets the request time-out period to 60 seconds.  \n  \n [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/add/codesnippet/visualbasic/p-system.web.httpserveru_1_1.vb)]\n [!code-cs[Classic HttpServerUtility.ScriptTimeout Example#1](~/add/codesnippet/csharp/p-system.web.httpserveru_1_1.cs)]"
  syntax:
    content: public int ScriptTimeout { get; set; }
    return:
      type: System.Int32
      description: "要求逾時值設定。"
  overload: System.Web.HttpServerUtility.ScriptTimeout*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "The current <xref href=&quot;System.Web.HttpContext&quot;></xref> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "逾時期限是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>或否則無法設定。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Transfer(System.String)
  id: Transfer(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Transfer(String)
  nameWithType: HttpServerUtility.Transfer(String)
  fullName: System.Web.HttpServerUtility.Transfer(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "針對目前的要求結束執行目前的頁面，並開始執行新網頁使用指定的網頁 URL 路徑。"
  remarks: "傳送到網頁應該是另一個.aspx 網頁。 比方說，傳輸至.asp 或.asmx 頁面不正確。 傳輸方法會保留<xref:System.Web.HttpRequest.QueryString%2A>和<xref:System.Web.HttpRequest.Form%2A>集合。</xref:System.Web.HttpRequest.Form%2A> </xref:System.Web.HttpRequest.QueryString%2A>       傳送呼叫<xref:System.Web.HttpResponse.End%2A>，哪些則會擲回<xref:System.Threading.ThreadAbortException>完成時的例外狀況。</xref:System.Threading.ThreadAbortException> </xref:System.Web.HttpResponse.End%2A>       ASP.NET 不會驗證目前使用者獲得授權檢視的傳輸方法所傳遞的資源。 雖然 ASP.NET 授權和驗證邏輯會在呼叫原始資源的處理常式之前，ASP.NET 直接呼叫之傳送方法所指定的處理常式，並不會重新執行驗證和授權邏輯，新的資源。 如果您的應用程式安全性原則需要有適當的權限可存取資源的用戶端，應用程式應該強制重新授權，或提供自訂的存取控制機制。       您可以使用強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而不是傳輸方法。</xref:System.Web.HttpResponse.Redirect%2A> <xref:System.Web.HttpResponse.Redirect%2A>方法會執行用戶端重新導向瀏覽器要求新的資源。</xref:System.Web.HttpResponse.Redirect%2A> 因為這個重新導向時輸入系統的新要求，所以必須網際網路資訊服務 (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。       您可以驗證使用者已透過加入自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前，應用程式呼叫的傳輸方法。</xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>"
  syntax:
    content: public void Transfer (string path);
    parameters:
    - id: path
      type: System.String
      description: "要執行的伺服器上之新網頁 URL 路徑。"
  overload: System.Web.HttpServerUtility.Transfer*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)
  id: Transfer(System.String,System.Boolean)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Transfer(String,Boolean)
  nameWithType: HttpServerUtility.Transfer(String,Boolean)
  fullName: System.Web.HttpServerUtility.Transfer(String,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "結束目前網頁的執行，並使用指定的網頁 URL 路徑開始執行新網頁。 指定是否要清除<> *> 和<> *> 集合。"
  remarks: "傳送到網頁應該是另一個.aspx 網頁。 比方說，傳輸至.asp 或.asmx 頁面不正確。       傳送呼叫<xref:System.Web.HttpResponse.End%2A>，哪些則會擲回<xref:System.Threading.ThreadAbortException>完成時的例外狀況。</xref:System.Threading.ThreadAbortException> </xref:System.Web.HttpResponse.End%2A>       如果您設定`preserveForm`參數`true`，[目標] 頁面將能夠透過存取前一頁的檢視狀態<xref:System.Web.UI.Page.PreviousPage%2A>屬性。</xref:System.Web.UI.Page.PreviousPage%2A>       基於安全性目的，您應該保留`enableViewStateMac`屬性設為`true`。 ASP.NET 不會驗證目前使用者獲得授權檢視的傳輸方法所傳遞的資源。 雖然 ASP.NET 授權和驗證邏輯會在呼叫原始資源的處理常式之前，ASP.NET 直接呼叫之傳送方法所指定的處理常式，並不會重新執行驗證和授權邏輯，新的資源。 如果您的應用程式安全性原則需要有適當的權限可存取資源的用戶端，應用程式應該強制重新授權，或提供自訂的存取控制機制。       您可以使用強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而不是傳輸方法。</xref:System.Web.HttpResponse.Redirect%2A> <xref:System.Web.HttpResponse.Redirect%2A>方法會執行用戶端重新導向瀏覽器要求新的資源。</xref:System.Web.HttpResponse.Redirect%2A> 因為這個重新導向時輸入系統的新要求，所以必須網際網路資訊服務 (IIS) 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。       您可以驗證使用者已透過加入自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前，應用程式呼叫的傳輸方法。</xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>"
  example:
  - "The following example executes a new page in the same directory as the current page.  \n  \n [!code-cs[Classic HttpServerUtility.Transfer Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_3_1.cs)]\n [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_3_1.vb)]"
  syntax:
    content: public void Transfer (string path, bool preserveForm);
    parameters:
    - id: path
      type: System.String
      description: "要執行的伺服器上之新網頁 URL 路徑。"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *> 和<> *> 集合。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref> to clear the <>*> and <>*> collections."
  overload: System.Web.HttpServerUtility.Transfer*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "在目前網頁要求為回呼。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)
  id: Transfer(System.Web.IHttpHandler,System.Boolean)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: Transfer(IHttpHandler,Boolean)
  nameWithType: HttpServerUtility.Transfer(IHttpHandler,Boolean)
  fullName: System.Web.HttpServerUtility.Transfer(IHttpHandler,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "結束目前網頁的執行，並使用可實作自訂 HTTP 處理常式開始執行新要求<xref href=&quot;System.Web.IHttpHandler&quot;></xref>介面，並指定是否要清除<> *> 和<> *> 集合。"
  remarks: "您可以撰寫自訂 HTTP 處理常式來處理 HTTP 要求中任何以 Common Language Specification (CLS) 相容的語言特定的預先定義的類型。 定義 HTTP 處理常式類別，而不是傳統 ASP (也稱為傳統 ASP) 網頁或 ASP.NET 網頁中的可執行程式碼回應這些特定的要求。 進行互動的低層級的要求和回應服務的 Web 伺服器正在執行網際網路資訊服務 (IIS) 允許 HTTP 處理常式，並且會提供類似功能的 ISAPI 擴充程式但更簡單的程式設計模型。       如果您設定`preserveForm`參數`true`，[目標] 頁面將能夠透過存取前一頁的檢視狀態<xref:System.Web.UI.Page.PreviousPage%2A>屬性。</xref:System.Web.UI.Page.PreviousPage%2A>       基於安全性目的，您應該保留`enableViewStateMac`屬性設為`true`。 ASP.NET 不會驗證目前使用者是否獲得授權檢視所傳遞的資源<xref:System.Web.HttpServerUtility.Transfer%2A>方法。</xref:System.Web.HttpServerUtility.Transfer%2A> 雖然 ASP.NET 授權和驗證邏輯會在呼叫原始資源的處理常式之前，ASP.NET 直接呼叫之傳送方法，所指定的處理常式，並不會重新執行驗證和授權邏輯，新的資源。 如果您的應用程式的安全性原則需要有適當的權限可存取資源的用戶端，應該強制重新授權應用程式，或提供的自訂存取控制機制。       您可以使用強制重新授權<xref:System.Web.HttpResponse.Redirect%2A>方法，而不是傳輸方法。</xref:System.Web.HttpResponse.Redirect%2A> <xref:System.Web.HttpResponse.Redirect%2A>方法會執行用戶端重新導向瀏覽器要求新的資源。</xref:System.Web.HttpResponse.Redirect%2A> 這個重新導向時輸入系統的新要求，因為它必須同時 IIS 和 ASP.NET 的安全性原則的所有驗證和授權邏輯。       您可以驗證使用者已透過加入自訂授權使用的方法，檢視資源的權限<xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>方法之前，應用程式呼叫的傳輸方法。</xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A>"
  syntax:
    content: public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);
    parameters:
    - id: handler
      type: System.Web.IHttpHandler
      description: "HTTP 處理常式實作<xref href=&quot;System.Web.IHttpHandler&quot;></xref>傳送目前的要求。"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *> 和<> *> 集合。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref> to clear the <>*> and <>*> collections."
  overload: System.Web.HttpServerUtility.Transfer*
  exceptions:
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "在目前網頁要求為回呼。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.TransferRequest(System.String)
  id: TransferRequest(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: TransferRequest(String)
  nameWithType: HttpServerUtility.TransferRequest(String)
  fullName: System.Web.HttpServerUtility.TransferRequest(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "非同步執行指定的 URL。"
  remarks: "這個方法多載會呼叫<xref:System.Web.HttpServerUtility.TransferRequest%2A>多載`preserveForm`參數設定為`false`、`method`參數設定為`null`、`headers`參數設定為`null`，而`preserveUser`參數設定為`true`。</xref:System.Web.HttpServerUtility.TransferRequest%2A> 如需詳細資訊，請參閱 < 備註 > 一節<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>多載。</xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>"
  syntax:
    content: public void TransferRequest (string path);
    parameters:
    - id: path
      type: System.String
      description: "要執行的伺服器上之新網頁 URL 路徑。"
  overload: System.Web.HttpServerUtility.TransferRequest*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "要求需要整合式的管線模式[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]。"
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "伺服器不是可用來處理要求。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>參數無效。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)
  id: TransferRequest(System.String,System.Boolean)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: TransferRequest(String,Boolean)
  nameWithType: HttpServerUtility.TransferRequest(String,Boolean)
  fullName: System.Web.HttpServerUtility.TransferRequest(String,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "執行所指定 url 的非同步執行，並保留查詢字串參數。"
  remarks: "這個多載呼叫<xref:System.Web.HttpServerUtility.TransferRequest%2A>多載`preserveForm`參數設定中，傳遞的值為`method`參數設定為`null`、`headers`參數設定為`null`，而`preserveUser`參數設定為`true`。</xref:System.Web.HttpServerUtility.TransferRequest%2A> 如需詳細資訊，請參閱 < 備註 > 一節<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>。</xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>       TransferRequest.NET Framework 3.5 版中引進。  如需詳細資訊，請參閱[版本和相依性](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public void TransferRequest (string path, bool preserveForm);
    parameters:
    - id: path
      type: System.String
      description: "要執行的伺服器上之新網頁 URL 路徑。"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *> 集合。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>清除<> *> 集合。"
  overload: System.Web.HttpServerUtility.TransferRequest*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "要求需要整合式的管線模式[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]。"
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "伺服器不是可用來處理要求。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>參數無效。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)
  id: TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: TransferRequest(String,Boolean,String,NameValueCollection)
  nameWithType: HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection)
  fullName: System.Web.HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "非同步執行指定的 URL，使用指定的 HTTP 方法和標頭。"
  remarks: "使用的整合式的管線模式中執行時，這個方法用[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]允許從一個資源類型到另一個傳送執行正確的要求內容的目標要求時的要求處理。 例如，您可以使用 TransferRequest 方法 XML 網頁要求傳送 ASPX 頁面的要求。       TransferRequest 方法執行非同步的子系執行所指定的 url，使用以下條件:-如果`path`參數指定的查詢字串，它會當做新的查詢字串。 如果包含任何查詢字串，不則要求的查詢字串將會重複使用。      -如果`method`參數指定，則會使用它。 如果是`null`，將會使用原始要求的 HTTP 方法。      -如果`preserveForm`參數是`true`，目前實體的要求將提供給目標要求。 這可讓表單張貼，並上傳至傳輸。      -如果原始要求上目前設定的使用者身分識別，身分識別將轉移到新的要求。 這可讓已驗證的要求，重複使用的新要求的驗證結果。 如果您不想要傳送的使用者，將使用者設定為`null`之前在原始要求。      -如果`headers`參數指定，則新的要求將使用指定的標頭來執行。 這可以用來修改要求標頭和新的要求，cookie，或加入特殊的標頭，指定已在接收到原始要求。           這個方法會呼叫<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29>方法多載`preserveUser`參數設定為`true`。</xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29>"
  syntax:
    content: public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);
    parameters:
    - id: path
      type: System.String
      description: "要執行的伺服器上之新網頁 URL 路徑。"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *> 集合。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>清除<> *> 集合。"
    - id: method
      type: System.String
      description: "要用於執行新要求的 HTTP 方法。"
    - id: headers
      type: System.Collections.Specialized.NameValueCollection
      description: "A <xref href=&quot;System.Collections.Specialized.NameValueCollection&quot;> </xref>新要求的要求標頭。"
  overload: System.Web.HttpServerUtility.TransferRequest*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "要求需要[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]整合模式執行。"
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "伺服器不是可用來處理要求。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>參數無效。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)
  id: TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: TransferRequest(String,Boolean,String,NameValueCollection,Boolean)
  nameWithType: HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection,Boolean)
  fullName: System.Web.HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "非同步執行指定的 url 使用指定的 HTTP 方法、 標頭和路徑，並選擇性地保留表單值和使用者識別。"
  remarks: "如需詳細資訊，請參閱 < 備註 > 一節<xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>。</xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>"
  syntax:
    content: public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);
    parameters:
    - id: path
      type: System.String
      description: "路徑。"
    - id: preserveForm
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留<> *> 集合。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>清除<> *> 集合。"
    - id: method
      type: System.String
      description: "要在新的要求中使用的 HTTP 方法。"
    - id: headers
      type: System.Collections.Specialized.NameValueCollection
      description: "A <xref href=&quot;System.Collections.Specialized.NameValueCollection&quot;> </xref>物件，其中包含要求標頭的新要求。"
    - id: preserveUser
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留的使用者身分識別。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 這個方法的其他方法多載呼叫這個多載，且此參數設為<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.HttpServerUtility.TransferRequest*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "要求需要整合式的管線模式[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]。"
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "伺服器不是可用來處理要求。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>參數無效。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.UrlDecode(System.String)
  id: UrlDecode(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: UrlDecode(String)
  nameWithType: HttpServerUtility.UrlDecode(String)
  fullName: System.Web.HttpServerUtility.UrlDecode(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "URL 解碼的字串，並傳回解碼的字串。"
  remarks: "URL 編碼，可確保所有瀏覽器將會正確傳輸 URL 字串中的文字。 例如問號 （？） 字元，連字號 （&）、 斜線 （/），以及空格可能會被截斷或某些瀏覽器損毀。 如此一來，這些字元必須編碼在`<a>`標記，或在查詢字串的字串可以所要求之字串中的瀏覽器重新傳送。       這個方法是便利的方式來存取<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName>方法在執行階段從 ASP.NET 應用程式。</xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName> 就內部而言，這個方法會使用<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName>要解碼的字串。</xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName>       在 ASP.NET web 網頁的程式碼後置檔案中，存取的執行個體<xref:System.Web.HttpServerUtility>類別透過`Server`屬性。</xref:System.Web.HttpServerUtility> 在程式碼後置檔案中沒有類別中，使用`HttpContext.Current.Server`存取<xref:System.Web.HttpServerUtility>類別</xref:System.Web.HttpServerUtility>的執行個體       Web 應用程式之外使用<xref:System.Net.WebUtility>類別來編碼或解碼的值。</xref:System.Net.WebUtility>"
  example:
  - "The following example shows how to URL-decode a value that is retrieved from the query string. The code resides in the code-behind file for a web page. `ReturnPage` refers to a `HyperLink` control.  \n  \n [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_9_1.vb)]\n [!code-cs[System.Web.HttpServerUtility.UrlDecode#1](~/add/codesnippet/csharp/m-system.web.httpserveru_9_1.cs)]  \n  \n The next example is similar to the previous example except it shows how to URL-decode a value from within a class that is not in the code-behind file.  \n  \n [!code-cs[System.Web.HttpServerUtility.UrlDecode#2](~/add/codesnippet/csharp/m-system.web.httpserveru_9_2.cs)]\n [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/add/codesnippet/visualbasic/m-system.web.httpserveru_9_2.vb)]"
  syntax:
    content: public string UrlDecode (string s);
    parameters:
    - id: s
      type: System.String
      description: "要解碼的文字字串。"
    return:
      type: System.String
      description: "解碼的文字。"
  overload: System.Web.HttpServerUtility.UrlDecode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)
  id: UrlDecode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: UrlDecode(String,TextWriter)
  nameWithType: HttpServerUtility.UrlDecode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.UrlDecode(String,TextWriter)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "將 URL 中接收 HTML 字串解碼，並產生將輸出傳送到<xref:System.IO.TextWriter>輸出資料流。</xref:System.IO.TextWriter>"
  remarks: "URL 編碼，可確保所有瀏覽器將會正確傳輸 URL 字串中的文字。 例如問號 （？） 字元，連字號 （&）、 斜線 （/），以及空格可能會被截斷或某些瀏覽器損毀。 如此一來，這些字元必須編碼在`<a>`標記，或在查詢字串的字串可以所要求之字串中的瀏覽器重新傳送。       <xref:System.Web.HttpServerUtility.UrlDecode%2A>是方便的方式來存取<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName>方法在執行階段從 ASP.NET 應用程式。</xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName></xref:System.Web.HttpServerUtility.UrlDecode%2A> 就內部而言，<xref:System.Web.HttpServerUtility.UrlDecode%2A>使用<xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName>要解碼的字串。</xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=fullName> </xref:System.Web.HttpServerUtility.UrlDecode%2A>       若要編碼或解碼 web 應用程式之外的值，請使用<xref:System.Net.WebUtility>類別。</xref:System.Net.WebUtility>"
  example:
  - "The following example decodes the string named `EncodedString` (received in a URL) into the string named `DecodedString`.  \n  \n [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_11_1.vb)]\n [!code-cs[Classic HttpServerUtility.UrlDecode1 Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_11_1.cs)]"
  syntax:
    content: public void UrlDecode (string s, System.IO.TextWriter output);
    parameters:
    - id: s
      type: System.String
      description: "要解碼的 HTML 字串。"
    - id: output
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>輸出資料流，其中包含已解碼的字串。</xref:System.IO.TextWriter>"
  overload: System.Web.HttpServerUtility.UrlDecode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.UrlEncode(System.String)
  id: UrlEncode(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: UrlEncode(String)
  nameWithType: HttpServerUtility.UrlEncode(String)
  fullName: System.Web.HttpServerUtility.UrlEncode(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "URL 編碼字串，並傳回編碼的字串。"
  remarks: "URL 編碼，可確保所有瀏覽器將會正確傳輸 URL 字串中的文字。 例如問號 （？） 字元，連字號 （&）、 斜線 （/），以及空格可能會被截斷或某些瀏覽器損毀。 如此一來，這些字元必須編碼在`<a>`標記，或在查詢字串的字串可以所要求之字串中的瀏覽器重新傳送。       這個方法是便利的方式來存取<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName>方法在執行階段從 ASP.NET 應用程式。</xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName> 就內部而言，這個方法會使用<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName>編碼字串。</xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName>       在 ASP.NET web 網頁的程式碼後置檔案中，存取的執行個體<xref:System.Web.HttpServerUtility>類別透過`Server`屬性。</xref:System.Web.HttpServerUtility> 在程式碼後置檔案中沒有類別中，使用`HttpContext.Current.Server`存取<xref:System.Web.HttpServerUtility>類別</xref:System.Web.HttpServerUtility>的執行個體       Web 應用程式之外使用<xref:System.Net.WebUtility>類別來編碼或解碼的值。</xref:System.Net.WebUtility>"
  example:
  - "The following example shows how to URL-encode a value that is used as a query string value of a hyperlink. The code resides in the code-behind file for a web page. The value to encode is hard-coded in this example only to simplify the example and show the type of value you might URL-encode. Typically, you would URL-encode a value that you received from the user or the request. `NextPage` refers to a `HyperLink` control.  \n  \n [!code-cs[System.Web.HttpServerUtility.UrlEncode#1](~/add/codesnippet/csharp/m-system.web.httpserveru_0_1.cs)]\n [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_0_1.vb)]  \n  \n The next example is similar to the previous example except it shows how to URL-encode a value from within a class that is not in the code-behind file.  \n  \n [!code-cs[System.Web.HttpServerUtility.UrlEncode#2](~/add/codesnippet/csharp/m-system.web.httpserveru_0_2.cs)]\n [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/add/codesnippet/visualbasic/m-system.web.httpserveru_0_2.vb)]"
  syntax:
    content: public string UrlEncode (string s);
    parameters:
    - id: s
      type: System.String
      description: "要作 URL 編碼的文字。"
    return:
      type: System.String
      description: "URL 編碼的文字。"
  overload: System.Web.HttpServerUtility.UrlEncode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)
  id: UrlEncode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: UrlEncode(String,TextWriter)
  nameWithType: HttpServerUtility.UrlEncode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.UrlEncode(String,TextWriter)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "URL 編碼字串，並將結果輸出至<xref:System.IO.TextWriter>輸出資料流。</xref:System.IO.TextWriter>"
  remarks: "URL 編碼，可確保所有瀏覽器將會正確傳輸 URL 字串中的文字。 例如問號 （？） 字元，連字號 （&）、 斜線 （/），以及空格可能會被截斷或某些瀏覽器損毀。 如此一來，這些字元必須編碼在`<a>`標記，或在查詢字串的字串可以所要求之字串中的瀏覽器重新傳送。       <xref:System.Web.HttpServerUtility.UrlEncode%2A>是方便的方式來存取<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName>方法在執行階段從 ASP.NET 應用程式。</xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName></xref:System.Web.HttpServerUtility.UrlEncode%2A> 就內部而言，<xref:System.Web.HttpServerUtility.UrlEncode%2A>使用<xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName>編碼字串。</xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=fullName> </xref:System.Web.HttpServerUtility.UrlEncode%2A>       若要編碼或解碼 web 應用程式之外的值，請使用<xref:System.Net.WebUtility>類別。</xref:System.Net.WebUtility>"
  example:
  - "The following example encodes a string for transmission by HTTP. It encodes the string named `TestString`, which contains the text \"This is a \\<Test String>.\", and copies it into the string named `EncodedString` as \"This+is+a+%3cTest+String%3e.\".  \n  \n [!code-cs[Classic HttpServerUtility.UrlEncode1 Example#1](~/add/codesnippet/csharp/m-system.web.httpserveru_13_1.cs)]\n [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/add/codesnippet/visualbasic/m-system.web.httpserveru_13_1.vb)]"
  syntax:
    content: public void UrlEncode (string s, System.IO.TextWriter output);
    parameters:
    - id: s
      type: System.String
      description: "要編碼的文字字串。"
    - id: output
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>輸出資料流，其中包含編碼的字串。</xref:System.IO.TextWriter>"
  overload: System.Web.HttpServerUtility.UrlEncode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.UrlPathEncode(System.String)
  id: UrlPathEncode(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: UrlPathEncode(String)
  nameWithType: HttpServerUtility.UrlPathEncode(String)
  fullName: System.Web.HttpServerUtility.UrlPathEncode(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "請勿使用;只適用於瀏覽器相容性。 使用<xref:System.Web.HttpServerUtility.UrlEncode*>.</xref:System.Web.HttpServerUtility.UrlEncode*>"
  syntax:
    content: public string UrlPathEncode (string s);
    parameters:
    - id: s
      type: System.String
      description: "要作 URL 編碼的文字。"
    return:
      type: System.String
      description: "URL 編碼的文字。"
  overload: System.Web.HttpServerUtility.UrlPathEncode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpServerUtility.UrlTokenDecode(System.String)
  id: UrlTokenDecode(System.String)
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: UrlTokenDecode(String)
  nameWithType: HttpServerUtility.UrlTokenDecode(String)
  fullName: System.Web.HttpServerUtility.UrlTokenDecode(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "將解碼 URL 字串語彙基元使用 base 64 數字其對應的位元組陣列。"
  remarks: "UrlTokenDecode 方法會將 URL 字串語彙基元，二進位資料編碼為 base 64 數字，轉換為其對應的位元組陣列表示。 要解碼語彙基元在 URL 上傳輸和編碼使用<xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>.</xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>使用 UrlTokenDecode 方法       UrlTokenDecode 方法會傳回空的位元組陣列，如果`input`參數的長度小於&1;。"
  syntax:
    content: public static byte[] UrlTokenDecode (string input);
    parameters:
    - id: input
      type: System.String
      description: "要解碼的 URL 字串語彙基元。"
    return:
      type: System.Byte[]
      description: "位元組陣列，包含已解碼的 URL 字串語彙基元。"
  overload: System.Web.HttpServerUtility.UrlTokenDecode*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "值<code> input </code>參數是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])
  id: UrlTokenEncode(System.Byte[])
  parent: System.Web.HttpServerUtility
  langs:
  - csharp
  name: UrlTokenEncode(Byte[])
  nameWithType: HttpServerUtility.UrlTokenEncode(Byte[])
  fullName: System.Web.HttpServerUtility.UrlTokenEncode(Byte[])
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "將位元組陣列編碼成使用 base 64 數字，也就可在 URL 上傳輸的相等字串表示。"
  remarks: "UrlTokenEncode 方法會將位元組陣列轉換成以 base 64 數字編碼的相等字串表示。 可以在 URL 上傳輸產生的字串語彙基元。       UrlTokenEncode 會傳回空字串，如果`input`參數的長度小於&1;。"
  syntax:
    content: public static string UrlTokenEncode (byte[] input);
    parameters:
    - id: input
      type: System.Byte[]
      description: "要編碼的位元組陣列。"
    return:
      type: System.String
      description: "字串，包含的位元組陣列編碼語彙基元 if*長度*大於&1;，否則為空字串 (&quot;&quot;)。"
  overload: System.Web.HttpServerUtility.UrlTokenEncode*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "值<code> input </code>參數是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Web.HttpException
  parent: System.Web
  isExternal: false
  name: HttpException
  nameWithType: HttpException
  fullName: System.Web.HttpException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.Web.HttpServerUtility.ClearError
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: ClearError()
  nameWithType: HttpServerUtility.ClearError()
  fullName: System.Web.HttpServerUtility.ClearError()
- uid: System.Web.HttpServerUtility.CreateObject(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: CreateObject(String)
  nameWithType: HttpServerUtility.CreateObject(String)
  fullName: System.Web.HttpServerUtility.CreateObject(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Web.HttpServerUtility.CreateObject(System.Type)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: CreateObject(Type)
  nameWithType: HttpServerUtility.CreateObject(Type)
  fullName: System.Web.HttpServerUtility.CreateObject(Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: CreateObjectFromClsid(String)
  nameWithType: HttpServerUtility.CreateObjectFromClsid(String)
  fullName: System.Web.HttpServerUtility.CreateObjectFromClsid(String)
- uid: System.Web.HttpServerUtility.Execute(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Execute(String)
  nameWithType: HttpServerUtility.Execute(String)
  fullName: System.Web.HttpServerUtility.Execute(String)
- uid: System.Web.HttpServerUtility.Execute(System.String,System.Boolean)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Execute(String,Boolean)
  nameWithType: HttpServerUtility.Execute(String,Boolean)
  fullName: System.Web.HttpServerUtility.Execute(String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Execute(String,TextWriter)
  nameWithType: HttpServerUtility.Execute(String,TextWriter)
  fullName: System.Web.HttpServerUtility.Execute(String,TextWriter)
- uid: System.IO.TextWriter
  parent: System.IO
  isExternal: true
  name: TextWriter
  nameWithType: TextWriter
  fullName: System.IO.TextWriter
- uid: System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Execute(String,TextWriter,Boolean)
  nameWithType: HttpServerUtility.Execute(String,TextWriter,Boolean)
  fullName: System.Web.HttpServerUtility.Execute(String,TextWriter,Boolean)
- uid: System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Execute(IHttpHandler,TextWriter,Boolean)
  nameWithType: HttpServerUtility.Execute(IHttpHandler,TextWriter,Boolean)
  fullName: System.Web.HttpServerUtility.Execute(IHttpHandler,TextWriter,Boolean)
- uid: System.Web.IHttpHandler
  parent: System.Web
  isExternal: false
  name: IHttpHandler
  nameWithType: IHttpHandler
  fullName: System.Web.IHttpHandler
- uid: System.Web.HttpServerUtility.GetLastError
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: GetLastError()
  nameWithType: HttpServerUtility.GetLastError()
  fullName: System.Web.HttpServerUtility.GetLastError()
- uid: System.Exception
  parent: System
  isExternal: true
  name: Exception
  nameWithType: Exception
  fullName: System.Exception
- uid: System.Web.HttpServerUtility.HtmlDecode(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: HtmlDecode(String)
  nameWithType: HttpServerUtility.HtmlDecode(String)
  fullName: System.Web.HttpServerUtility.HtmlDecode(String)
- uid: System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: HtmlDecode(String,TextWriter)
  nameWithType: HttpServerUtility.HtmlDecode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.HtmlDecode(String,TextWriter)
- uid: System.Web.HttpServerUtility.HtmlEncode(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: HtmlEncode(String)
  nameWithType: HttpServerUtility.HtmlEncode(String)
  fullName: System.Web.HttpServerUtility.HtmlEncode(String)
- uid: System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: HtmlEncode(String,TextWriter)
  nameWithType: HttpServerUtility.HtmlEncode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.HtmlEncode(String,TextWriter)
- uid: System.Web.HttpServerUtility.MachineName
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: MachineName
  nameWithType: HttpServerUtility.MachineName
  fullName: System.Web.HttpServerUtility.MachineName
- uid: System.Web.HttpServerUtility.MapPath(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: MapPath(String)
  nameWithType: HttpServerUtility.MapPath(String)
  fullName: System.Web.HttpServerUtility.MapPath(String)
- uid: System.Web.HttpServerUtility.ScriptTimeout
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: ScriptTimeout
  nameWithType: HttpServerUtility.ScriptTimeout
  fullName: System.Web.HttpServerUtility.ScriptTimeout
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Web.HttpServerUtility.Transfer(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Transfer(String)
  nameWithType: HttpServerUtility.Transfer(String)
  fullName: System.Web.HttpServerUtility.Transfer(String)
- uid: System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Transfer(String,Boolean)
  nameWithType: HttpServerUtility.Transfer(String,Boolean)
  fullName: System.Web.HttpServerUtility.Transfer(String,Boolean)
- uid: System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Transfer(IHttpHandler,Boolean)
  nameWithType: HttpServerUtility.Transfer(IHttpHandler,Boolean)
  fullName: System.Web.HttpServerUtility.Transfer(IHttpHandler,Boolean)
- uid: System.Web.HttpServerUtility.TransferRequest(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: TransferRequest(String)
  nameWithType: HttpServerUtility.TransferRequest(String)
  fullName: System.Web.HttpServerUtility.TransferRequest(String)
- uid: System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: TransferRequest(String,Boolean)
  nameWithType: HttpServerUtility.TransferRequest(String,Boolean)
  fullName: System.Web.HttpServerUtility.TransferRequest(String,Boolean)
- uid: System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: TransferRequest(String,Boolean,String,NameValueCollection)
  nameWithType: HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection)
  fullName: System.Web.HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection)
- uid: System.Collections.Specialized.NameValueCollection
  parent: System.Collections.Specialized
  isExternal: false
  name: NameValueCollection
  nameWithType: NameValueCollection
  fullName: System.Collections.Specialized.NameValueCollection
- uid: System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: TransferRequest(String,Boolean,String,NameValueCollection,Boolean)
  nameWithType: HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection,Boolean)
  fullName: System.Web.HttpServerUtility.TransferRequest(String,Boolean,String,NameValueCollection,Boolean)
- uid: System.Web.HttpServerUtility.UrlDecode(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlDecode(String)
  nameWithType: HttpServerUtility.UrlDecode(String)
  fullName: System.Web.HttpServerUtility.UrlDecode(String)
- uid: System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlDecode(String,TextWriter)
  nameWithType: HttpServerUtility.UrlDecode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.UrlDecode(String,TextWriter)
- uid: System.Web.HttpServerUtility.UrlEncode(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlEncode(String)
  nameWithType: HttpServerUtility.UrlEncode(String)
  fullName: System.Web.HttpServerUtility.UrlEncode(String)
- uid: System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlEncode(String,TextWriter)
  nameWithType: HttpServerUtility.UrlEncode(String,TextWriter)
  fullName: System.Web.HttpServerUtility.UrlEncode(String,TextWriter)
- uid: System.Web.HttpServerUtility.UrlPathEncode(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlPathEncode(String)
  nameWithType: HttpServerUtility.UrlPathEncode(String)
  fullName: System.Web.HttpServerUtility.UrlPathEncode(String)
- uid: System.Web.HttpServerUtility.UrlTokenDecode(System.String)
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlTokenDecode(String)
  nameWithType: HttpServerUtility.UrlTokenDecode(String)
  fullName: System.Web.HttpServerUtility.UrlTokenDecode(String)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlTokenEncode(Byte[])
  nameWithType: HttpServerUtility.UrlTokenEncode(Byte[])
  fullName: System.Web.HttpServerUtility.UrlTokenEncode(Byte[])
- uid: System.Web.HttpServerUtility.ClearError*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: ClearError
  nameWithType: HttpServerUtility.ClearError
- uid: System.Web.HttpServerUtility.CreateObject*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: CreateObject
  nameWithType: HttpServerUtility.CreateObject
- uid: System.Web.HttpServerUtility.CreateObjectFromClsid*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: CreateObjectFromClsid
  nameWithType: HttpServerUtility.CreateObjectFromClsid
- uid: System.Web.HttpServerUtility.Execute*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Execute
  nameWithType: HttpServerUtility.Execute
- uid: System.Web.HttpServerUtility.GetLastError*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: GetLastError
  nameWithType: HttpServerUtility.GetLastError
- uid: System.Web.HttpServerUtility.HtmlDecode*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: HtmlDecode
  nameWithType: HttpServerUtility.HtmlDecode
- uid: System.Web.HttpServerUtility.HtmlEncode*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: HtmlEncode
  nameWithType: HttpServerUtility.HtmlEncode
- uid: System.Web.HttpServerUtility.MachineName*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: MachineName
  nameWithType: HttpServerUtility.MachineName
- uid: System.Web.HttpServerUtility.MapPath*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: MapPath
  nameWithType: HttpServerUtility.MapPath
- uid: System.Web.HttpServerUtility.ScriptTimeout*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: ScriptTimeout
  nameWithType: HttpServerUtility.ScriptTimeout
- uid: System.Web.HttpServerUtility.Transfer*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: Transfer
  nameWithType: HttpServerUtility.Transfer
- uid: System.Web.HttpServerUtility.TransferRequest*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: TransferRequest
  nameWithType: HttpServerUtility.TransferRequest
- uid: System.Web.HttpServerUtility.UrlDecode*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlDecode
  nameWithType: HttpServerUtility.UrlDecode
- uid: System.Web.HttpServerUtility.UrlEncode*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlEncode
  nameWithType: HttpServerUtility.UrlEncode
- uid: System.Web.HttpServerUtility.UrlPathEncode*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlPathEncode
  nameWithType: HttpServerUtility.UrlPathEncode
- uid: System.Web.HttpServerUtility.UrlTokenDecode*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlTokenDecode
  nameWithType: HttpServerUtility.UrlTokenDecode
- uid: System.Web.HttpServerUtility.UrlTokenEncode*
  parent: System.Web.HttpServerUtility
  isExternal: false
  name: UrlTokenEncode
  nameWithType: HttpServerUtility.UrlTokenEncode
