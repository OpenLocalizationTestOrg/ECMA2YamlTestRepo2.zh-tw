### YamlMime:ManagedReference
items:
- uid: System.Windows.Input.CanExecuteRoutedEventHandler
  id: CanExecuteRoutedEventHandler
  langs:
  - csharp
  name: CanExecuteRoutedEventHandler
  nameWithType: CanExecuteRoutedEventHandler
  fullName: System.Windows.Input.CanExecuteRoutedEventHandler
  type: Delegate
  summary: "代表將處理的方法<xref href=&quot;System.Windows.Input.CommandBinding.CanExecute&quot;></xref>事件。"
  remarks: "CanExecuteRoutedEventHandler 判斷事件來源相關聯的命令是否可以在命令目標上執行。 命令的命令來源，指定的目標，則可以透過取得目標資訊`sender`。 如果<xref:System.Windows.Input.ICommandSource.CommandTarget%2A>未設定，具有鍵盤焦點的項目是目標，且您也可以透過取得`sender`。</xref:System.Windows.Input.ICommandSource.CommandTarget%2A>  如果它由決定命令可以在目標上執行則<xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=fullName>屬性應該設定為`true`; 否則，請將它設定為`false`。</xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=fullName>       您不需要依賴事件資料，以判斷命令、 來源和目標。 雖然這是更難完成如果命令結構依賴廣泛的命令路由，後續的潛在目標，在事件路由上執行相同的命令，您可以限制為已知的可能命令引動過程，處理常式的使用方式。"
  example:
  - "The following example shows a CanExecuteRoutedEventHandler that sets <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A> to `true`.  \n  \n [!code-cs[commandwithhandler#CommandHandlerCanExecuteHandler](~/add/codesnippet/csharp/commandWithHandler/Window1.xaml.cs#commandhandlercanexecutehandler)]\n [!code-vb[commandwithhandler#CommandHandlerCanExecuteHandler](~/add/codesnippet/visualbasic/commandWithHandler/Window1.xaml.vb#commandhandlercanexecutehandler)]"
  syntax:
    content: public delegate void CanExecuteRoutedEventHandler(object sender, CanExecuteRoutedEventArgs e);
  inheritance:
  - System.Delegate
  platform:
  - net462
references:
- uid: System.Delegate
  isExternal: false
  name: System.Delegate
