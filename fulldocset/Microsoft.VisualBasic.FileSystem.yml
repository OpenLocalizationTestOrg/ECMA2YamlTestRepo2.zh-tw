### YamlMime:ManagedReference
items:
- uid: Microsoft.VisualBasic.FileSystem
  id: FileSystem
  children:
  - Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  - Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  - Microsoft.VisualBasic.FileSystem.CurDir
  - Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  - Microsoft.VisualBasic.FileSystem.Dir
  - Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  - Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  - Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  - Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  - Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  - Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.FreeFile
  - Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  - Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  - Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  - Microsoft.VisualBasic.FileSystem.Kill(System.String)
  - Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  - Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  - Microsoft.VisualBasic.FileSystem.Reset
  - Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  - Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  - Microsoft.VisualBasic.FileSystem.TAB
  - Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  - Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  - Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  langs:
  - csharp
  name: FileSystem
  nameWithType: FileSystem
  fullName: Microsoft.VisualBasic.FileSystem
  type: Class
  summary: "<xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;> </xref>模組包含可用來執行檔案、 目錄或資料夾，以及系統作業的程序。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能比使用檔案 I/O 作業中<xref uid=&quot;langword_csharp_FileSystem&quot; name=&quot;FileSystem&quot; href=&quot;&quot;></xref>模組。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "這個模組支援的 Visual Basic 語言關鍵字和存取檔案和資料夾的執行階段程式庫成員。"
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/t-microsoft.visualbasic._17_1.vb)]"
  syntax:
    content: >-
      [Microsoft.VisualBasic.CompilerServices.StandardModule]

      [System.Security.SecurityCritical]

      public sealed class FileSystem
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  id: ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "變更目前的目錄或資料夾。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_ChDir &quot; name=&quot;ChDir &quot; href=&quot;&quot;></xref>函式。 如需詳細資訊，請參閱<xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: "`ChDir`函式會變更預設目錄，但未預設磁碟機。 例如，如果預設磁碟機 C，下列陳述式會變更磁碟機 D 上的預設目錄 C 則保持預設磁碟機，但︰ [!code-vb [VbVbalrCatRef&#39;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_1.vb) ]進行相對目錄變更為輸入兩個句號，如下所示︰ [!code-vb [VbVbalrCatRef&#40;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_2.vb) ]       >  [!IMPORTANT] >`ChDir`函式需要 unmanaged 程式碼權限，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱<xref:System.Security.Permissions.SecurityPermission>和。</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDir` function to change the current directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#41](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._177_3.vb)]"
  syntax:
    content: public static void ChDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "必要。 A <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;> </xref>識別哪個目錄或資料夾的運算式變成新的預設目錄或資料夾。 `Path`可能包含磁碟機。 如果未不指定任何磁碟機，則<xref uid=&quot;langword_csharp_ChDir&quot; name=&quot;ChDir&quot; href=&quot;&quot;></xref>變更預設的目錄或目前的磁碟機上的資料夾。"
  overload: Microsoft.VisualBasic.FileSystem.ChDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>是空的。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "指定無效的磁碟機，或磁碟機無法使用。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  id: ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "變更目前的磁碟機。"
  remarks: "`ChDrive`函式需要 unmanaged 程式碼權限，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱<xref:System.Security.Permissions.SecurityPermission>和[程式碼存取權限](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)。</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._181_1.vb)]"
  syntax:
    content: public static void ChDrive (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "必要。 指定現有的磁碟機的字串運算式。 如果您提供零長度字串 (&quot;&quot;)，不會變更目前的磁碟機。 如果`Drive`引數是多個字元字串， <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref>使用只有第一個字母。"
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定無效的磁碟機，或磁碟機無法使用。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  id: ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "變更目前的磁碟機。"
  remarks: "`ChDrive`函式需要 unmanaged 程式碼權限，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱<xref:System.Security.Permissions.SecurityPermission>和[程式碼存取權限](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)。</xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "This example uses the `ChDrive` function to change the current drive. The function throws an exception if the drive does not exist.  \n  \n [!code-vb[VbVbalrCatRef#32](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._225_1.vb)]"
  syntax:
    content: public static void ChDrive (string Drive);
    parameters:
    - id: Drive
      type: System.String
      description: "必要。 指定現有的磁碟機的字串運算式。 如果您提供零長度字串 (&quot;&quot;)，不會變更目前的磁碟機。 如果`Drive`引數是多個字元字串， <xref uid=&quot;langword_csharp_ChDrive&quot; name=&quot;ChDrive&quot; href=&quot;&quot;> </xref>使用只有第一個字母。"
  overload: Microsoft.VisualBasic.FileSystem.ChDrive*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "指定無效的磁碟機，或磁碟機無法使用。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  id: CurDir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回表示目前路徑的字串。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._123_1.vb)]"
  syntax:
    content: public static string CurDir ();
    parameters: []
    return:
      type: System.String
      description: "字串，表示目前的路徑。"
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  id: CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回表示目前路徑的字串。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory*>"
  remarks: ''
  example:
  - "This example uses the `CurDir` function to return the current path.  \n  \n [!code-vb[VbVbalrCatRef#65](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._203_1.vb)]"
  syntax:
    content: public static string CurDir (char Drive);
    parameters:
    - id: Drive
      type: System.Char
      description: "選擇性。 <xref uid=&quot;langword_csharp_Char&quot; name=&quot;Char&quot; href=&quot;&quot;></xref>指定現有的磁碟機的運算式。 如果未不指定任何磁碟機，或如果`Drive`為零長度字串 (&quot;&quot;)， <xref uid=&quot;langword_csharp_CurDir&quot; name=&quot;CurDir&quot; href=&quot;&quot;> </xref>傳回目前的磁碟機的路徑。"
    return:
      type: System.String
      description: "字串，表示目前的路徑。"
  overload: Microsoft.VisualBasic.FileSystem.CurDir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir
  id: Dir
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回字串，代表檔案、 目錄或資料夾中符合指定之模式或檔案屬性的名稱或磁碟機的磁碟區標籤。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;></xref>函式。 請參閱<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>如需詳細資訊。</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "`Dir`函式支援使用多個字元 (`*`) 和單一字元 (`?`) 萬用字元來指定多個檔案。       `VbVolume`傳回而不是特定的檔案名稱的磁碟機的磁碟區標籤。       您必須提供`PathName`第一次，讓您呼叫`Dir`函式。 若要擷取下一個項目，您可以進行後續呼叫`Dir`不含參數的函式。      > [!IMPORTANT] > 才能正常運作，`Dir`函式需要<xref:System.Security.Permissions.FileIOPermissionAccess>和<xref:System.Security.Permissions.FileIOPermissionAccess>旗標<xref:System.Security.Permissions.FileIOPermission>要執行的程式碼授與。</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，和[程式碼存取權限](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)。</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       `Attributes`引數的列舉值如下: | | |  |-|-|-|  |值 |常數 |描述 |  |`Normal`|`vbnormal`|預設值。 指定不含屬性的檔案。 |  |`ReadOnly`|`vbReadOnly`|指定唯讀檔案，以及不含屬性的檔案。 |  |`Hidden`|`vbHidden`|隱藏的檔案，檔案也指定沒有屬性。 |  |`System`|`vbSystem`|系統檔案，檔案也指定沒有屬性。 |  |`Volume`|`vbVolume`|指定磁碟區標籤。如果未指定任何其他屬性，則`vbVolume`會被忽略。 |  |`Directory`|`vbDirectory`|指定目錄或資料夾，並也沒有屬性的檔案。 |  |`Archive`|`vbArchive`|自上次備份之後已變更的檔案。 |  |`Alias`|`vbAlias`|檔案有不同的名稱。 |     > [!NOTE] > 這些列舉型別由 Visual Basic 語言，以及可用於您的程式碼，而非實際值的任何位置。"
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._44_1.vb)]"
  syntax:
    content: public static string Dir ();
    parameters: []
    return:
      type: System.String
      description: "字串，代表檔案、 目錄或資料夾中符合指定之模式或檔案屬性的名稱或磁碟機的磁碟區標籤。"
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  id: Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回字串，代表檔案、 目錄或資料夾中符合指定之模式或檔案屬性的名稱或磁碟機的磁碟區標籤。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;></xref>函式。 請參閱<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>如需詳細資訊。</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo*>"
  remarks: "`Dir`函式支援使用多個字元 (`*`) 和單一字元 (`?`) 萬用字元來指定多個檔案。       `VbVolume`傳回而不是特定的檔案名稱的磁碟機的磁碟區標籤。       您必須提供`PathName`第一次，讓您呼叫`Dir`函式。 若要擷取下一個項目，您可以進行後續呼叫`Dir`不含任何參數的函式。      > [!IMPORTANT] > 才能正常運作，`Dir`函式需要<xref:System.Security.Permissions.FileIOPermissionAccess>和<xref:System.Security.Permissions.FileIOPermissionAccess>旗標<xref:System.Security.Permissions.FileIOPermission>要執行的程式碼授與。</xref:System.Security.Permissions.FileIOPermission> </xref:System.Security.Permissions.FileIOPermissionAccess> </xref:System.Security.Permissions.FileIOPermissionAccess> 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，和[程式碼存取權限](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)。</xref:System.Security.SecurityException> </xref:System.Security.Permissions.FileIOPermission>       `Attributes`引數的列舉值如下: | | |  |-|-|-|  |值 |常數 |描述 |  |`Normal`|`vbnormal`|預設值。 指定不含任何屬性的檔案。 |  |`ReadOnly`|`vbReadOnly`|指定唯讀檔案，除了沒有任何屬性的檔案。 |  |`Hidden`|`vbHidden`|指定隱藏的檔案，除了沒有任何屬性的檔案。 |  |`System`|`vbSystem`|指定系統檔案，除了沒有任何屬性的檔案。 |  |`Volume`|`vbVolume`|指定磁碟區標籤。如果未指定任何其他屬性，則`vbVolume`會被忽略。 |  |`Directory`|`vbDirectory`|指定目錄或資料夾，此外沒有任何屬性的檔案。 |  |`Archive`|`vbArchive`|自上次備份之後已變更的檔案。 |  |`Alias`|`vbAlias`|檔案有不同的名稱。 |     > [!NOTE] > 這些列舉型別由 Visual Basic 語言，以及可用於您的程式碼，用來取代實際值的任何位置。"
  example:
  - "This example uses the `Dir` function to check if certain files and directories exist.  \n  \n [!code-vb[VbVbalrCatRef#3](~/add/codesnippet/visualbasic/0bb37160-d621-482a-af3b-_1.vb)]"
  syntax:
    content: public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);
    parameters:
    - id: PathName
      type: System.String
      description: "選擇性。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定檔案名稱、 目錄或資料夾名稱或磁碟機的磁碟區標籤的運算式。 零長度字串 (<xref uid=&quot;langword_csharp_&quot;&quot;&quot; name=&quot;&quot;&quot;&quot; href=&quot;&quot;></xref>) 會傳回`PathName`找不到。"
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "選擇性。 列舉型別或數值運算式，其值會指定檔案屬性。 如果省略， <xref uid=&quot;langword_csharp_Dir&quot; name=&quot;Dir&quot; href=&quot;&quot;> </xref>傳回檔案符合之`PathName`但不含任何屬性。"
    return:
      type: System.String
      description: "字串，代表檔案、 目錄或資料夾中符合指定之模式或檔案屬性的名稱或磁碟機的磁碟區標籤。"
  overload: Microsoft.VisualBasic.FileSystem.Dir*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  id: EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回布林值<xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;></xref>當檔案結尾開啟以供<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>或循序<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>已達到。"
  remarks: "使用`EOF`以避免嘗試取得輸入超過檔案結尾所產生的錯誤。       `EOF`函式會傳回`False`直到已到達檔案結尾。 開啟的檔案與`Random`或`Binary`存取`EOF`傳回`False`直到最後一個執行`FileGet`函式不能讀取整個記錄。       開啟的檔案與`Binary`存取，嘗試讀取檔案使用透過`Input`函式，直到`EOF`傳回`True`會產生錯誤。 使用`LOF`和`Loc`函式，而不是`EOF`讀取二進位檔案時`Input`，或使用`Get`時使用`EOF`函式。 開啟的檔案與`Output`，`EOF`一律會傳回`True`。"
  example:
  - "This example uses the `EOF` function to detect the end of a file. This example assumes that `Testfile` is a text file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#62](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._184_1.vb)]"
  syntax:
    content: public static bool EOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>中包含任何有效的檔案數目。"
    return:
      type: System.Boolean
      description: "傳回布林值<xref uid=&quot;langword_csharp_True&quot; name=&quot;True&quot; href=&quot;&quot;></xref>當檔案結尾開啟以供<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>或循序<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>已達到。"
  overload: Microsoft.VisualBasic.FileSystem.EOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  id: FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回代表使用開啟的檔案模式列舉<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函式。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileAttr &quot; name=&quot;FileAttr &quot; href=&quot;&quot;></xref>函式。 請參閱<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>如需詳細資訊。</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "此函數會傳回代表使用開啟的檔案模式列舉`FileOpen`函式。"
  example:
  - "This example uses the `FileAttr` function to return the file mode of an open file.  \n  \n [!code-vb[VbVbalrCatRef#46](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._147_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>. 任何有效的檔案數目。"
    return:
      type: Microsoft.VisualBasic.OpenMode
      description: "下列的列舉值表示檔案存取模式︰       <table><tbody><tr><td> 值       </td><td> 模式       </td></tr><tr><td> 1       </td><td><xref uid=&quot;langword_csharp_OpenMode.Input&quot; name=&quot;OpenMode.Input&quot; href=&quot;&quot;></xref></td></tr><tr><td> 2       </td><td><xref uid=&quot;langword_csharp_OpenMode.Output&quot; name=&quot;OpenMode.Output&quot; href=&quot;&quot;></xref></td></tr><tr><td> 4       </td><td><xref uid=&quot;langword_csharp_OpenMode.Random&quot; name=&quot;OpenMode.Random&quot; href=&quot;&quot;></xref></td></tr><tr><td> 8       </td><td><xref uid=&quot;langword_csharp_OpenMode.Append&quot; name=&quot;OpenMode.Append&quot; href=&quot;&quot;></xref></td></tr><tr><td> 32       </td><td><xref uid=&quot;langword_csharp_OpenMode.Binary&quot; name=&quot;OpenMode.Binary&quot; href=&quot;&quot;></xref></td></tr></tbody></table>"
  overload: Microsoft.VisualBasic.FileSystem.FileAttr*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  id: FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "若要使用開啟的檔案結束輸入/輸出 (I/O) <xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>函式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;></xref>可讓您更佳的產能和效能的檔案 I/O 作業。 請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>如需詳細資訊。"
  remarks: "`FileClose`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[如何︰ 以 StreamReader 從檔案讀取文字](~/add/includes/ajax-current-ext-md.md)，[How to︰ 將文字寫入檔案以 StreamWriter](~/add/includes/ajax-current-ext-md.md)，和[逐步解說︰ Visual Basic 中管理檔案和目錄](~/add/includes/ajax-current-ext-md.md)。       如果您省略`FileNumbers`，所有使用中的檔案開啟`FileOpen`函式會關閉。       當您關閉已開啟的檔案`Output`或`Append`，該檔案的作業系統緩衝區寫入輸出的最後的緩衝區。 所有的緩衝區空間的封閉型相關聯檔案發行。       當`FileClose`函式執行，其檔案的檔案關聯數字結尾。"
  example:
  - "This example uses the `FileClose`function to close a file opened for `Input`.  \n  \n [!code-vb[VbVbalrCatRef#69](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._41_1.vb)]"
  syntax:
    content: public static void FileClose (int[] FileNumbers);
    parameters:
    - id: FileNumbers
      type: System.Int32[]
      description: "選擇性。 0 或多個通道會關閉參數陣列。"
  overload: Microsoft.VisualBasic.FileSystem.FileClose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>不存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  id: FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "複製檔案。 <xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileCopy&quot; name=&quot;FileCopy&quot; href=&quot;&quot;> </xref>。 請參閱<xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>如需詳細資訊。</xref:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile*>"
  remarks: "如果您嘗試使用`FileCopy`函式在目前開啟的檔案，就會發生錯誤。       `FileCopy`需要完全信任，才能在本機磁碟機。"
  example:
  - "This example uses the `FileCopy` function to copy one file to another. For purposes of this example, assume that `SrcFile` is a file that contains data.  \n  \n [!code-vb[VbVbalrCatRef#2](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._96_1.vb)]"
  syntax:
    content: public static void FileCopy (string Source, string Destination);
    parameters:
    - id: Source
      type: System.String
      description: "必要。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定要複製的檔案名稱的運算式。 `Source`可能包含目錄或資料夾，以及原始程式檔的磁碟機。"
    - id: Destination
      type: System.String
      description: "必要。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定的目的地檔案名稱的運算式。 `Destination`可能包含目錄或資料夾，以及磁碟機、 目的地檔案。"
  overload: Microsoft.VisualBasic.FileSystem.FileCopy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Source</code>或<code>Destination</code>無效或不指定。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案已經開啟。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "檔案不存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  id: FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回<xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;></xref>表示的日期和時間的檔案寫入的值。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileDateTime&quot; name=&quot;FileDateTime&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*></xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: ''
  example:
  - "This example uses the `FileDateTime` function to determine the date and time a file was created or last modified. The format of the date and time displayed is based on the locale settings of the system.  \n  \n [!code-vb[VbVbalrCatRef#34](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._22_1.vb)]"
  syntax:
    content: public static DateTime FileDateTime (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "必要。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定的檔案名稱的運算式。 `PathName`可能包含目錄或資料夾，以及磁碟機。"
    return:
      type: System.DateTime
      description: "<xref uid=&quot;langword_csharp_Date&quot; name=&quot;Date&quot; href=&quot;&quot;></xref>建立或上次修改值，表示日期和時間的檔案。"
  overload: Microsoft.VisualBasic.FileSystem.FileDateTime*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>PathName</code>無效或包含萬用字元。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "目標檔案不存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  id: FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的磁碟檔案將資料讀入變數。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;></xref>"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/ad6628f8-6ae5-47af-a394-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Boolean
      description: "必要。 讀取資料的有效變數名稱。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的讀取開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  id: FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的磁碟檔案將資料讀入變數。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used. Then the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/9daa1fad-0f67-40af-bac0-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Byte
      description: "必要。 讀取資料的有效變數名稱。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的讀取開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  id: FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的磁碟檔案將資料讀入變數。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/31a532e9-297f-48c8-a186-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Char
      description: "必要。 讀取資料的有效變數名稱。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的讀取開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  id: FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的磁碟檔案將資料讀入變數。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file with `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/d9877ddb-692f-47fe-8c26-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.DateTime
      description: "必要。 讀取資料的有效變數名稱。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的讀取開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  id: FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的磁碟檔案將資料讀入變數。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/3d9f416d-1287-4566-b3fa-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Decimal
      description: "必要。 讀取資料的有效變數名稱。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的讀取開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  id: FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的磁碟檔案將資料讀入變數。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/184fee0e-b744-4669-8fdf-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Double
      description: "必要。 讀取資料的有效變數名稱。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的讀取開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  id: FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的磁碟檔案將資料讀入變數。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic`parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/45e0fdff-455b-4fd4-a7c2-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Int16
      description: "必要。 讀取資料的有效變數名稱。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的讀取開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  id: FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的磁碟檔案將資料讀入變數。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/7db3ee1c-ee17-457b-bd2d-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Int32
      description: "必要。 讀取資料的有效變數名稱。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的讀取開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  id: FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的磁碟檔案將資料讀入變數。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/bd48d1ef-82ea-4239-8c9b-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Int64
      description: "必要。 讀取資料的有效變數名稱。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的讀取開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  id: FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的磁碟檔案將資料讀入變數。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/79f9948f-e0d0-41fe-a7b5-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Single
      description: "必要。 讀取資料的有效變數名稱。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的讀取開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  id: FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的磁碟檔案將資料讀入變數。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/f351f02c-d919-4d73-938f-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen`function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.ValueType
      description: "必要。 讀取資料的有效變數名稱。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的讀取開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  id: FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的磁碟檔案將資料讀入變數。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/cefffea4-17eb-455d-be3e-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.String
      description: "必要。 讀取資料的有效變數名稱。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的讀取開始的位置。"
    - id: StringIsFixedLength
      type: System.Boolean
      description: "選擇性。 將字串寫入時，才適用。 指定是否要寫入的字串，描述長度的兩個位元組描述元。 預設值是<xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  id: FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的磁碟檔案將資料讀入變數。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileGet&quot; name=&quot;FileGet&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileGet` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGet` is usually written to a file by using `FilePut`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file that is named Form1.vb may not be a Visual Basic source file.  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries. The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.  \n  \n-   By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array. To write the descriptor, set the `ArrayIsDynamic` parameter to `True`. When reading the array, you have to match the way the array was written. If it was written with the descriptor, you have to read the descriptor. If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.  \n  \n     The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 218 bytes when the array is written to disk.  \n  \n     [!code-vb[VbVbalrCatRef#21](~/add/codesnippet/visualbasic/c053ec00-d593-49bf-a3cb-_1.vb)]  \n  \n     The 218 bytes are distributed as follows:  \n  \n    -   18 bytes for the descriptor: (2 + 8 * 2)  \n  \n    -   200 bytes for the data: (5 * 10 \\* 4).  \n  \n-   If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.  \n  \n-   `FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions). The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements. This includes any arrays and their descriptors. The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions. The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGet` reads all variables from disk contiguously; that is, without padding between records.  \n  \n-   For any array other than an array in a structure, `FileGet` reads only the data. No descriptor is read.  \n  \n-   `FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n    > [!IMPORTANT]\n    >  Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration."
  syntax:
    content: public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Array
      description: "必要。 讀取資料的有效變數名稱。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的讀取開始的位置。"
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "選擇性。 撰寫陣列時，才適用。 指定是否陣列視為動態及描述大小和陣列界限的陣列描述元是否必要。"
    - id: StringIsFixedLength
      type: System.Boolean
      description: "選擇性。 將字串寫入時，才適用。 指定是否要寫入的字串，描述長度的兩個位元組描述元。 預設值是<xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>。"
  overload: Microsoft.VisualBasic.FileSystem.FileGet*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  id: FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的磁碟檔案將資料讀入變數。  <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileGetObject&quot; name=&quot;FileGetObject&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.  \n  \n If you intend to write out the `Variant` type, `FileGetObject` is required. When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.  \n  \n `FileGetObject` is valid only in `Random` and `Binary` mode.  \n  \n Data read with `FileGetObject` is usually written with `FilePutObject`.  \n  \n The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).  \n  \n## Random Mode  \n For files opened in `Random` mode, the following rules apply:  \n  \n-   If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.  \n  \n-   If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string. Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written. If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.  \n  \n-   If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. The descriptor specifies the rank of the array, the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.  \n  \n     For example, the following array declaration requires 218 bytes when the array is written to disk:  \n  \n     [!code-vb[VbVbalrCatRef#27](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_1.vb)]  \n  \n     The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 \\* 10 \\* 4).  \n  \n-   `FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions. The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.  \n  \n## Binary Mode  \n For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:  \n  \n-   The `RecordLength` clause in the `FileOpen` function has no effect. `FileGetObject`reads all variables from disk contiguously, that is, with no padding between records.  \n  \n-   For any array other than an array in a structure, `FileGetObject` reads only the data. No descriptor is read.  \n  \n `FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor. The number of bytes read equals the number of characters already in the string.  \n  \n> [!IMPORTANT]\n>  When reading from files, do not make decisions about the contents of a file based on the file name extension. For example, a file named Form1.vb may not be a Visual Basic source file."
  example:
  - "The following example reads a record into a test file and then retrieves it.  \n  \n [!code-vb[VbVbalrCatRef#26](~/add/codesnippet/visualbasic/16450c3e-87c4-4606-9e31-_2.vb)]"
  syntax:
    content: public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Object
      description: "必要。 讀取資料的有效變數名稱。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的讀取開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FileGetObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  id: FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>值，指定檔案的長度，以位元組為單位。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileLen&quot; name=&quot;FileLen&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo*>"
  remarks: "如果指定的檔案時，開啟`FileLen`函式呼叫，傳回的值代表在它已開啟檔案的大小。      > [!NOTE] > 取得目前已開啟的檔案的長度，請使用`LOF`函式。"
  example:
  - "This example uses the `FileLen` function to return the length of a file in bytes. For purposes of this example, assume that `TestFile` is a file that contains some data.  \n  \n [!code-vb[VbVbalrCatRef#1](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._122_1.vb)]"
  syntax:
    content: public static long FileLen (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "必要。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定檔案的運算式。 `PathName`可能包含目錄或資料夾，以及磁碟機。"
    return:
      type: System.Int64
      description: "<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>值，指定檔案的長度，以位元組為單位。"
  overload: Microsoft.VisualBasic.FileSystem.FileLen*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "檔案不存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  id: FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "開啟檔案以輸入或輸出。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FileOpen`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       您必須先開啟檔案，才能在其上執行任何的 I/O 作業。 `FileOpen`會針對 I/O 配置緩衝區至檔案，並判斷要使用之緩衝區的存取模式。      > [!IMPORTANT] > 時寫入檔案時，應用程式可能必須建立檔案，如果嘗試寫入的檔案不存在。 若要這樣做，需要的權限的 建立檔案的目錄。 不過，如果所指定的檔案`FileName`確實存在，應用程式需求`Write`權限只檔案本身。 盡量，以協助改善安全性，在部署和授與建立檔案的任一處`Write`該檔案的權限唯一的而不是整個目錄。 若要改善安全性，請將資料寫入使用者目錄而不是根目錄或 Program Files 目錄。       若要開啟頻道可以找到使用`FreeFile()`函式。      > [!IMPORTANT] >`FileOpen`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別，這可能會影響在部分信任情況下執行。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example illustrates various uses of the `FileOpen` function to enable input and output to a file.  \n  \n The following code opens the file `TestFile` in `Input` mode.  \n  \n [!code-vb[VbVbalrCatRef#5](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_1.vb)]  \n  \n This example opens the file in `Binary` mode for writing operations only.  \n  \n [!code-vb[VbVbalrCatRef#6](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_2.vb)]  \n  \n The following example opens the file in `Random` mode. The file contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#7](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_3.vb)]  \n  \n This code example opens the file in `Output` mode; any process can read or write to file.  \n  \n [!code-vb[VbVbalrCatRef#8](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_4.vb)]  \n  \n This code example opens the file in `Binary` mode for reading; other processes cannot read file.  \n  \n [!code-vb[VbVbalrCatRef#9](~/add/codesnippet/visualbasic/ebe0f421-4483-4c55-8150-_5.vb)]"
  syntax:
    content: public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。 使用<xref uid=&quot;langword_csharp_FreeFile&quot; name=&quot;FreeFile&quot; href=&quot;&quot;></xref>函數來取得下一個可用的檔案數目。"
    - id: FileName
      type: System.String
      description: "必要。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定的檔案名稱的運算式，可能包含目錄或資料夾和磁碟機。"
    - id: Mode
      type: Microsoft.VisualBasic.OpenMode
      description: '必要。 Enumeration specifying the file mode: <xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>, <xref uid=&quot;langword_csharp_Output&quot; name=&quot;Output&quot; href=&quot;&quot;></xref>, or <xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;></xref>. 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.OpenMode&quot;> </xref> 。'
    - id: Access
      type: Microsoft.VisualBasic.OpenAccess
      description: '選擇性。 列舉指定之作業允許開啟檔案︰ <xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>， <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>，或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>。 預設為<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.OpenAccess&quot;> </xref> 。'
    - id: Share
      type: Microsoft.VisualBasic.OpenShare
      description: '選擇性。 指定的作業不允許其他處理序所開啟的檔案列舉型別︰ <xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>， <xref uid=&quot;langword_csharp_Lock Read&quot; name=&quot;Lock Read&quot; href=&quot;&quot;> </xref>， <xref uid=&quot;langword_csharp_Lock Write&quot; name=&quot;Lock Write&quot; href=&quot;&quot;> </xref>，和<xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>。 預設為<xref uid=&quot;langword_csharp_Lock Read Write&quot; name=&quot;Lock Read Write&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.OpenShare&quot;> </xref> 。'
    - id: RecordLength
      type: System.Int32
      description: "選擇性。 數字小於或等於 32767 （位元組）。 針對隨機存取所開啟的檔案，這個值會是資料錄長度。 針對循序檔案，這個值會是經過緩衝處理的字元數。"
  overload: Microsoft.VisualBasic.FileSystem.FileOpen*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "資料錄長度是負數 （且不等於-1）。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileName</code>已經開啟，或<code>FileName</code>無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  id: FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePut`通常會從檔案讀取使用`FileGet`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。      -如果寫入的變數是一個字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。      -如果正在寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_1.vb) ] -如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。      -`FilePut`寫入結構的項目，如同寫入每個個別，只是沒有任何項目之間的填補。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。          > [!NOTE] > 字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，# # 二進位模式的檔案中開啟`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。      -若為在結構中，陣列以外的任何陣列`FilePut`寫入的資料。 會不寫入任何描述項。      -`FilePut`寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 下列陳述式，例如 11 個位元組寫入檔案編號 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_2.vb) ] -寫入至檔案，以使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b684b977-357d-4475-a2d0-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Boolean
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  id: FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePut`通常會從檔案讀取使用`FileGet`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。      -如果寫入的變數是一個字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。      -如果正在寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_1.vb) ] -如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。      -`FilePut`寫入結構的項目，如同寫入每個個別，只是沒有任何項目之間的填補。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。          > [!NOTE] > 字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，# # 二進位模式的檔案中開啟`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。      -若為在結構中，陣列以外的任何陣列`FilePut`寫入的資料。 會不寫入任何描述項。      -`FilePut`寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 下列陳述式，例如 11 個位元組寫入檔案編號 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_2.vb) ] -寫入至檔案，以使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/2a393bee-4ca7-4317-bbe9-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Byte
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  id: FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePut`通常會從檔案讀取使用`FileGet`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。      -如果寫入的變數是一個字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。      -如果正在寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_1.vb) ] -如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。      -`FilePut`寫入結構的項目，如同寫入每個個別，只是沒有任何項目之間的填補。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。          > [!NOTE] > 字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，# # 二進位模式的檔案中開啟`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。      -若為在結構中，陣列以外的任何陣列`FilePut`寫入的資料。 會不寫入任何描述項。      -`FilePut`寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 下列陳述式，例如 11 個位元組寫入檔案編號 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_2.vb) ] -寫入至檔案，以使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/f7dbd668-3841-4860-9fe2-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Char
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  id: FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePut`通常會從檔案讀取使用`FileGet`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。      -如果寫入的變數是一個字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。      -如果正在寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_1.vb) ] -如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。      -`FilePut`寫入結構的項目，如同寫入每個個別，只是沒有任何項目之間的填補。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。          > [!NOTE] > 字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，# # 二進位模式的檔案中開啟`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。      -若為在結構中，陣列以外的任何陣列`FilePut`寫入的資料。 會不寫入任何描述項。      -`FilePut`寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 下列陳述式，例如 11 個位元組寫入檔案編號 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_2.vb) ] -寫入至檔案，以使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/30fdf8e5-a84c-499e-8f20-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.DateTime
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  id: FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePut`通常會從檔案讀取使用`FileGet`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。      -如果寫入的變數是一個字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。      -如果正在寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_1.vb) ] -如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。      -`FilePut`寫入結構的項目，如同寫入每個個別，只是沒有任何項目之間的填補。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。          > [!NOTE] > 字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，# # 二進位模式的檔案中開啟`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。      -若為在結構中，陣列以外的任何陣列`FilePut`寫入的資料。 會不寫入任何描述項。      -`FilePut`寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 下列陳述式，例如 11 個位元組寫入檔案編號 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_2.vb) ] -寫入至檔案，以使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/9cb41843-0b02-4bad-b757-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Decimal
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  id: FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePut`通常會從檔案讀取使用`FileGet`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。      -如果寫入的變數是一個字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。      -如果正在寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_1.vb) ] -如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。      -`FilePut`寫入結構的項目，如同寫入每個個別，只是沒有任何項目之間的填補。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。          > [!NOTE] > 字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，# # 二進位模式的檔案中開啟`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。      -若為在結構中，陣列以外的任何陣列`FilePut`寫入的資料。 會不寫入任何描述項。      -`FilePut`寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 下列陳述式，例如 11 個位元組寫入檔案編號 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_2.vb) ] -寫入至檔案，以使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/59c5b768-6732-40e5-a205-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Double
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  id: FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePut`通常會從檔案讀取使用`FileGet`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。      -如果寫入的變數是一個字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。      -如果正在寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_1.vb) ] -如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。      -`FilePut`寫入結構的項目，如同寫入每個個別，只是沒有任何項目之間的填補。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。          > [!NOTE] > 字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，# # 二進位模式的檔案中開啟`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。      -若為在結構中，陣列以外的任何陣列`FilePut`寫入的資料。 會不寫入任何描述項。      -`FilePut`寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 下列陳述式，例如 11 個位元組寫入檔案編號 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_2.vb) ] -寫入至檔案，以使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/835229db-b7e7-4e50-86a7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Int16
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  id: FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePut`通常會從檔案讀取使用`FileGet`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。      -如果寫入的變數是一個字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。      -如果正在寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_1.vb) ] -如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。      -`FilePut`寫入結構的項目，如同寫入每個個別，只是沒有任何項目之間的填補。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。          > [!NOTE] > 字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，# # 二進位模式的檔案中開啟`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。      -若為在結構中，陣列以外的任何陣列`FilePut`寫入的資料。 會不寫入任何描述項。      -`FilePut`寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 下列陳述式，例如 11 個位元組寫入檔案編號 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_2.vb) ] -寫入至檔案，以使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6a50d289-6d85-4fc1-99f7-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Int32
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  id: FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePut`通常會從檔案讀取使用`FileGet`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。      -如果寫入的變數是一個字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。      -如果正在寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_1.vb) ] -如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。      -`FilePut`寫入結構的項目，如同寫入每個個別，只是沒有任何項目之間的填補。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。          > [!NOTE] > 字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，# # 二進位模式的檔案中開啟`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。      -若為在結構中，陣列以外的任何陣列`FilePut`寫入的資料。 會不寫入任何描述項。      -`FilePut`寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 下列陳述式，例如 11 個位元組寫入檔案編號 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_2.vb) ] -寫入至檔案，以使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/90087c6f-a92b-4ccb-88f5-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Int64
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  id: FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePut`通常會從檔案讀取使用`FileGet`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。      -如果寫入的變數是一個字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。      -如果正在寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_1.vb) ] -如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。      -`FilePut`寫入結構的項目，如同寫入每個個別，只是沒有任何項目之間的填補。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。          > [!NOTE] > 字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，# # 二進位模式的檔案中開啟`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。      -若為在結構中，陣列以外的任何陣列`FilePut`寫入的資料。 會不寫入任何描述項。      -`FilePut`寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 下列陳述式，例如 11 個位元組寫入檔案編號 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_2.vb) ] -寫入至檔案，以使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/67fd8601-6772-45be-87ee-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Single
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  id: FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePut`通常會從檔案讀取使用`FileGet`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。      -如果寫入的變數是一個字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。      -如果正在寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_1.vb) ] -如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。      -`FilePut`寫入結構的項目，如同寫入每個個別，只是沒有任何項目之間的填補。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。          > [!NOTE] > 字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，# # 二進位模式的檔案中開啟`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。      -若為在結構中，陣列以外的任何陣列`FilePut`寫入的資料。 會不寫入任何描述項。      -`FilePut`寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 下列陳述式，例如 11 個位元組寫入檔案編號 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_2.vb) ] -寫入至檔案，以使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/814bf35d-de00-4bf6-9dca-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.ValueType
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  id: FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePut`通常會從檔案讀取使用`FileGet`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。      -如果寫入的變數是一個字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。      -如果正在寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_1.vb) ] -如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。      -`FilePut`寫入結構的項目，如同寫入每個個別，只是沒有任何項目之間的填補。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。          > [!NOTE] > 字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，# # 二進位模式的檔案中開啟`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。      -若為在結構中，陣列以外的任何陣列`FilePut`寫入的資料。 會不寫入任何描述項。      -`FilePut`寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 下列陳述式，例如 11 個位元組寫入檔案編號 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_2.vb) ] -寫入至檔案，以使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/b8a1d844-c860-47f2-9311-_3.vb)]"
  syntax:
    content: public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Object
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Object
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Object
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  id: FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>..."
  remarks: "`FilePut`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePut`通常會從檔案讀取使用`FileGet`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。      -如果寫入的變數是一個字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。      -如果正在寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_1.vb) ] -如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。      -`FilePut`寫入結構的項目，如同寫入每個個別，只是沒有任何項目之間的填補。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。          > [!NOTE] > 字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，# # 二進位模式的檔案中開啟`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。      -若為在結構中，陣列以外的任何陣列`FilePut`寫入的資料。 會不寫入任何描述項。      -`FilePut`寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 下列陳述式，例如 11 個位元組寫入檔案編號 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_2.vb) ] -寫入至檔案，以使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/6bdd614c-e459-4fef-9c10-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.String
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
    - id: StringIsFixedLength
      type: System.Boolean
      description: "選擇性。 將字串寫入時，才適用。 指定是否要寫入檔案的兩個位元組的字串長度的描述元字串。 預設值是<xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  id: FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePut&quot; name=&quot;FilePut&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePut`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePut`通常會從檔案讀取使用`FileGet`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`下, 一個記錄或最後一個之後位元組`FileGet`或`FilePut`函式，或指向最後一個`Seek`撰寫函式。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePut`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePut`，您必須執行相同的`FileGet`，而且您必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePut`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為無法判斷填補資料的數量，與任何確定性，通常是最好的是有相符的資料寫入的記錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式，將會擲回例外狀況。      -如果寫入的變數是一個字串，`FilePut`寫入兩個位元組描述項，其中包含字串長度，並再寫入變數的資料。 因此，所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須至少在兩個位元組大於字串的實際長度。      -如果正在寫入的變數是物件，包含數值的型別，`FilePut`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePut`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePut`寫入兩個位元組的描述元識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，您必須選擇要寫入的大小和陣列維度的描述元。 Visual Basic 6.0 及舊版撰寫為動態陣列，但不是會為固定大小陣列的檔案描述項。 Visual Basic 2005 預設為不寫入描述元。 若要撰寫的描述元，設定`ArrayIsDynamic`參數`True`。 當寫入陣列，您必須符合的方式，將會讀取陣列;如果將讀取與描述元，您必須撰寫的描述元。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 例如，下列陣列宣告需要 218 位元組陣列寫入時寫入磁碟。           [!code-vb[VbVbalrCatRef&#43;](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_1.vb) ] -如果正在寫入的變數是任何其他類型的變數 （不可變長度字串或物件）`FilePut`寫入變數的資料。 所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於寫入資料的長度。      -`FilePut`寫入結構的項目，如同寫入每個個別，只是沒有任何項目之間的填補。 `VBFixedString`屬性可以套用至字串欄位的結構，表示字串寫入時的大小到磁碟。          > [!NOTE] > 字串有更多的位元組，超過所指定的欄位`VBFixedString`屬性會被截斷時寫入至磁碟，# # 二進位模式的檔案中開啟`Binary`模式中，大部分的`Random`模式會套用規則，但有些例外狀況。 在中開啟檔案的下列規則`Binary`模式不同的規則`Random`模式:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePut`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。      -若為在結構中，陣列以外的任何陣列`FilePut`寫入的資料。 會不寫入任何描述項。      -`FilePut`寫入可變長度的字串不是雙位元組長度描述項的結構的項目。 寫入的位元組數目等於字串中的字元數。 下列陳述式，例如 11 個位元組寫入檔案編號 1: [!code-vb [VbVbalrCatRef #44](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_2.vb) ] -寫入至檔案，以使用`FilePut`函式需要`Write`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `FilePut` function to write data to a file. Five records of the structure `Person` are written to the file.  \n  \n [!code-vb[VbVbalrCatRef#42](~/add/codesnippet/visualbasic/34008b69-543f-4e9e-add6-_3.vb)]"
  syntax:
    content: public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Array
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
    - id: ArrayIsDynamic
      type: System.Boolean
      description: "選擇性。 撰寫陣列時，才適用。 指定陣列是否將視為動態，以及是否要寫入的字串，描述長度陣列描述項。"
    - id: StringIsFixedLength
      type: System.Boolean
      description: "選擇性。 將字串寫入時，才適用。 指定是否要寫入檔案的兩個位元組的字串長度的描述元字串。 預設值是<xref uid=&quot;langword_csharp_False&quot; name=&quot;False&quot; href=&quot;&quot;> </xref>。"
  overload: Microsoft.VisualBasic.FileSystem.FilePut*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>RecordNumber</code>&lt; 1 和不等於-1。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  id: FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從變數將資料寫入磁碟檔案。  <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FilePutObject&quot; name=&quot;FilePutObject&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`FilePutObject`而不是使用函式`FilePut`若要避免模稜兩可在編譯時期，如果型別`Object`傳遞，而另一個類型，例如`Integer`， `Long`， `Short`，依此類推。       `FilePutObject`寫入，並讀取描述物件的描述元。 如果您想要寫出`Variant`型別，`FilePutObject`需要。 有疑問，如果您使用物件的第二個參數，我們建議一律使用`FilePutObject`和`FileGetObject`。       `FilePutObject`只能在有效`Random`和`Binary`模式。       資料寫入與`FilePutObject`通常會從檔案讀取使用`FileGetObject`。       第一個記錄或檔案中的位元組是在位置 1，第二個記錄或位元組是在位置 2，以此類推。 如果您省略`RecordNumber`，`FilePutObject`寫入最後一個之後的下一個記錄或位元組`FileGetObject`或`FilePutObject`函式 (或資料錄或位元組指向最後一個`Seek`函式)。       `StringIsFixedLength`引數可讓您控制是否函式會將字串解譯為變數或固定長度。 `FilePutObject`引數時，不會寫入長度描述元`True`。 如果您使用`StringIsFixedLength`  =  `True`與`FilePutObject`，您必須執行相同的`FileGetObject`，和您也必須確定該字串會初始化為預期的長度。      ## 隨機模式的檔案中開啟`Random`模式中，則適用下列規則:-寫入資料的長度是否在指定的長度小於`RecordLength`子句`FileOpen`函式，`FilePutObject`將後續的記錄寫入的資料錄長度界限上。 以現有的內容，將檔案緩衝區的填補一筆記錄的結尾與下一筆記錄的開始之間的空間。 因為填補資料的數量無法精確判斷，所以通常最好是有相符的資料寫入的資料錄長度。 如果正在寫入資料的長度大於指定的長度`RecordLength`子句`FileOpen`函式擲回例外狀況。      -如果正在寫入的變數是物件，包含數值的型別，`FilePutObject`寫入兩個位元組，識別`VarType`的物件，然後將變數。 例如，寫入物件時，包含整數，`FilePutObject`寫入&6; 個位元組︰ 識別做為物件的兩個位元組`VarType(`3`)` (`Integer`) 以及包含資料的四個位元組。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須至少在兩個位元組大於實際儲存變數所需的位元組數目。      -如果正在寫入的變數是物件，包含字串，`FilePutObject`寫入兩個位元組的描述項，識別`VarType(`8`)`的物件，表示字串，然後再寫入字串資料的長度的兩個位元組描述元。 所指定的資料錄長度`RecordLength`中的參數`FileOpen`函式必須為至少四個位元組大於字串的實際長度。 如果您想要將描述項的字串，您應該將`True`至`StringIsFixedLength`參數，且您讀入應該是正確的長度的字串。      -如果寫入的變數是陣列，則所指定的資料錄長度`RecordLength`中的子句`FileOpen`函式必須是大於或等於撰寫陣列資料和陣列描述項所需的所有位元組的總和。 描述元指定陣列大小及每個陣序規範下限的陣序。 其長度等於 2 加上 8 時間維度的數目: (2 + 8 * NumberOfDimensions)。      ## 二進位模式的檔案中開啟`Binary`模式中，所有`Random`模式規則將套用，除了:-`RecordLength`中的子句`FileOpen`函式沒有任何作用。 `FilePutObject`將所有的變數，連續寫入磁碟，也就是沒有記錄之間的填補。"
  example:
  - "This example uses the `FilePutObject` function to write a string to a file.  \n  \n [!code-vb[VbVbalrCatRef#54](~/add/codesnippet/visualbasic/69f8d8bb-169c-4dec-b805-_1.vb)]"
  syntax:
    content: public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Object
      description: "必要。 有效的變數名稱，其中包含寫入資料到磁碟。"
    - id: RecordNumber
      type: System.Int64
      description: "選擇性。 記錄數目 (<xref uid=&quot;langword_csharp_Random&quot; name=&quot;Random&quot; href=&quot;&quot;> </xref>模式的檔案) 或位元組數字 (<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;> </xref>模式的檔案) 的寫入開始的位置。"
  overload: Microsoft.VisualBasic.FileSystem.FilePutObject*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  id: FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "指派給使用開啟的檔案的輸出行寬<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函式。"
  remarks: ''
  example:
  - "This example uses the `FileWidth` function to set the output line width for a file.  \n  \n [!code-vb[VbVbalrCatRef#10](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._187_1.vb)]"
  syntax:
    content: public static void FileWidth (int FileNumber, int RecordWidth);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: RecordWidth
      type: System.Int32
      description: "必要。 數值運算式在範圍 0-255 之間，含表示該行開始新行之前，先出現的字元數。 如果`RecordWidth`等於 0，行的長度沒有限制。 預設值為`RecordWidth`為 0。"
  overload: Microsoft.VisualBasic.FileSystem.FileWidth*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  id: FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回<xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>值，表示可供使用的下一個檔案編號<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函式。"
  remarks: "使用`FreeFile`提供尚未使用的檔案數字。"
  example:
  - "This example uses the `FreeFile` function to return the next available file number. Five files are opened for output within the loop, and some sample data is written to each.  \n  \n [!code-vb[VbVbalrCatRef#55](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._104_1.vb)]"
  syntax:
    content: public static int FreeFile ();
    parameters: []
    return:
      type: System.Int32
      description: "傳回<xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>值，表示可供使用的下一個檔案編號<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函式。"
  overload: Microsoft.VisualBasic.FileSystem.FreeFile*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "超過 255 個檔案正在使用中。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  id: GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回<xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;></xref>代表的檔案、 目錄或資料夾屬性的值。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_FileAttribute&quot; name=&quot;FileAttribute&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "若要判斷設定了哪些屬性，請使用`And`運算子來執行所傳回的值的位元比較`GetAttr`函式和您想要個別的檔案屬性的值。 如果結果不是零，該屬性會設定命名的檔案。 例如，下列的傳回值`And`運算式是如果`Archive`未設定屬性︰```vb#   Result = GetAttr(FName) And vbArchive   ```如果，則會傳回非零值`Archive`屬性設定。"
  example:
  - "This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.  \n  \n [!code-vb[VbVbalrCatRef#25](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._13_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "必要。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定的檔案、 目錄或資料夾名稱的運算式。 `PathName`可以包含目錄或資料夾，以及磁碟機。"
    return:
      type: Microsoft.VisualBasic.FileAttribute
      description: "所傳回的值<xref uid=&quot;langword_csharp_GetAttr&quot; name=&quot;GetAttr&quot; href=&quot;&quot;></xref>是下列的列舉值的總和︰       <table><tbody><tr><td> 值       </td><td> 常數的說明       </td></tr><tr><td><xref uid=&quot;langword_csharp_Normal&quot; name=&quot;Normal&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbNormal&quot; name=&quot;vbNormal&quot; href=&quot;&quot;></xref>標準模式。       </td></tr><tr><td><xref uid=&quot;langword_csharp_ReadOnly&quot; name=&quot;ReadOnly&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbReadOnly&quot; name=&quot;vbReadOnly&quot; href=&quot;&quot;></xref>唯讀的。       </td></tr><tr><td><xref uid=&quot;langword_csharp_Hidden&quot; name=&quot;Hidden&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbHidden&quot; name=&quot;vbHidden&quot; href=&quot;&quot;></xref>隱藏。       </td></tr><tr><td><xref uid=&quot;langword_csharp_System&quot; name=&quot;System&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbSystem&quot; name=&quot;vbSystem&quot; href=&quot;&quot;></xref>系統檔案。       </td></tr><tr><td><xref uid=&quot;langword_csharp_Directory&quot; name=&quot;Directory&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbDirectory&quot; name=&quot;vbDirectory&quot; href=&quot;&quot;></xref>目錄或資料夾。       </td></tr><tr><td><xref uid=&quot;langword_csharp_Archive&quot; name=&quot;Archive&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbArchive&quot; name=&quot;vbArchive&quot; href=&quot;&quot;></xref>最後一個備份之後變更檔案。       </td></tr><tr><td><xref uid=&quot;langword_csharp_Alias&quot; name=&quot;Alias&quot; href=&quot;&quot;></xref></td><td><xref uid=&quot;langword_csharp_vbAlias&quot; name=&quot;vbAlias&quot; href=&quot;&quot;></xref>檔案有不同的名稱。       </td></tr></tbody></table><div class=&quot;alert NOTE&quot;>    Visual Basic 語言會指定這些列舉型別。 名稱可以用來取代實際值的程式碼中任何位置使用。      </div>"
  overload: Microsoft.VisualBasic.FileSystem.GetAttr*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>Pathname</code>無效或包含萬用字元。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "目標檔案不存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  id: Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的循序檔案讀取資料，並將資料指派給變數。"
  remarks: "`Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。      > [!IMPORTANT] > 時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。       讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。      |||  |-|-|  |資料 |指派給變數的值 |  |用來分隔逗號或空白行 |空白 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間 |  |#ERROR `errornumber` #| `errornumber` （變數會是標記為錯誤的物件） |      如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。      > [!NOTE] >`Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。      > [!IMPORTANT] > 從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._237_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref bool Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Boolean
      description: "必要。 變數指派的值是從檔案讀取，不能是陣列或物件變數。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  id: Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的循序檔案讀取資料，並將資料指派給變數。"
  remarks: "`Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。      > [!IMPORTANT] > 時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。       讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。      |||  |-|-|  |資料 |指派給變數的值 |  |用來分隔逗號或空白行 |空白 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間 |  |#ERROR `errornumber` #| `errornumber` （變數會是標記為錯誤的物件） |      如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。      > [!NOTE] >`Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。      > [!IMPORTANT] > 從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._73_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref byte Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Byte
      description: "必要。 變數指派的值是從檔案讀取，不能是陣列或物件變數。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  id: Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的循序檔案讀取資料，並將資料指派給變數。"
  remarks: "`Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。      > [!IMPORTANT] > 時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。       讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。      |||  |-|-|  |資料 |指派給變數的值 |  |用來分隔逗號或空白行 |空白 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間 |  |#ERROR `errornumber` #| `errornumber` （變數會是標記為錯誤的物件） |      如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。      > [!NOTE] >`Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。      > [!IMPORTANT] > 從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._91_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref char Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Char
      description: "必要。 變數指派的值是從檔案讀取，不能是陣列或物件變數。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  id: Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的循序檔案讀取資料，並將資料指派給變數。"
  remarks: "`Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。      > [!IMPORTANT] > 時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。       讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。      |||  |-|-|  |資料 |指派給變數的值 |  |用來分隔逗號或空白行 |空白 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間 |  |#ERROR `errornumber` #| `errornumber` （變數會是標記為錯誤的物件） |      如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。      > [!NOTE] >`Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。      > [!IMPORTANT] > 從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._169_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref DateTime Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.DateTime
      description: "必要。 變數指派的值是從檔案讀取，不能是陣列或物件變數。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  id: Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的循序檔案讀取資料，並將資料指派給變數。"
  remarks: "`Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。      > [!IMPORTANT] > 時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。       讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。      |||  |-|-|  |資料 |指派給變數的值 |  |用來分隔逗號或空白行 |空白 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間 |  |#ERROR `errornumber` #| `errornumber` （變數會是標記為錯誤的物件） |      如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。      > [!NOTE] >`Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。      > [!IMPORTANT] > 從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._46_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref decimal Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Decimal
      description: "必要。 變數指派的值是從檔案讀取，不能是陣列或物件變數。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  id: Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的循序檔案讀取資料，並將資料指派給變數。"
  remarks: "`Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。      > [!IMPORTANT] > 時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。       讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。      |||  |-|-|  |資料 |指派給變數的值 |  |用來分隔逗號或空白行 |空白 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間 |  |#ERROR `errornumber` #| `errornumber` （變數會是標記為錯誤的物件） |      如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。      > [!NOTE] >`Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。      > [!IMPORTANT] > 從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._204_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref double Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Double
      description: "必要。 變數指派的值是從檔案讀取，不能是陣列或物件變數。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  id: Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的循序檔案讀取資料，並將資料指派給變數。"
  remarks: "`Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。      > [!IMPORTANT] > 時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。       讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。      |||  |-|-|  |資料 |指派給變數的值 |  |用來分隔逗號或空白行 |空白 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間 |  |#ERROR `errornumber` #| `errornumber` （變數會是標記為錯誤的物件） |      如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。      > [!NOTE] >`Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。      > [!IMPORTANT] > 從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._81_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref short Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Int16
      description: "必要。 變數指派的值是從檔案讀取，不能是陣列或物件變數。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  id: Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的循序檔案讀取資料，並將資料指派給變數。"
  remarks: "`Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。      > [!IMPORTANT] > 時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。       讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。      |||  |-|-|  |資料 |指派給變數的值 |  |用來分隔逗號或空白行 |空白 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間 |  |#ERROR `errornumber` #| `errornumber` （變數會是標記為錯誤的物件） |      如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。      > [!NOTE] >`Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。      > [!IMPORTANT] > 從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._207_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref int Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Int32
      description: "必要。 變數指派的值是從檔案讀取，不能是陣列或物件變數。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  id: Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的循序檔案讀取資料，並將資料指派給變數。"
  remarks: "`Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。      > [!IMPORTANT] > 時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。       讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。      |||  |-|-|  |資料 |指派給變數的值 |  |用來分隔逗號或空白行 |空白 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間 |  |#ERROR `errornumber` #| `errornumber` （變數會是標記為錯誤的物件） |      如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。      > [!NOTE] >`Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。      > [!IMPORTANT] > 從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._31_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref long Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Int64
      description: "必要。 變數指派的值是從檔案讀取，不能是陣列或物件變數。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  id: Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的循序檔案讀取資料，並將資料指派給變數。"
  remarks: "`Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。      > [!IMPORTANT] > 時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。       讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。      |||  |-|-|  |資料 |指派給變數的值 |  |用來分隔逗號或空白行 |空白 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間 |  |#ERROR `errornumber` #| `errornumber` （變數會是標記為錯誤的物件） |      如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。      > [!NOTE] >`Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。      > [!IMPORTANT] > 從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._244_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref object Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Object
      description: "必要。 變數指派的值是從檔案讀取，不能是陣列或物件變數。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  id: Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的循序檔案讀取資料，並將資料指派給變數。"
  remarks: "`Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。      > [!IMPORTANT] > 時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。       讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。      |||  |-|-|  |資料 |指派給變數的值 |  |用來分隔逗號或空白行 |空白 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間 |  |#ERROR `errornumber` #| `errornumber` （變數會是標記為錯誤的物件） |      如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。      > [!NOTE] >`Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。      > [!IMPORTANT] > 從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._115_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref float Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.Single
      description: "必要。 變數指派的值是從檔案讀取，不能是陣列或物件變數。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  id: Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的循序檔案讀取資料，並將資料指派給變數。"
  remarks: "`Input`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       資料讀取`Input`通常會先寫入至檔案使用`Write`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。      > [!IMPORTANT] > 時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法在 Visual Basic 2005 原始程式檔。       讀取時，標準字串或數值資料會指派給變數，而不修改。 下表將說明如何處理其他輸入的資料。      |||  |-|-|  |資料 |指派給變數的值 |  |用來分隔逗號或空白行 |空白 |  | #NULL #|`DBNull`|  | #TRUE # 或 #FALSE #|`True` or `False`|  |#`yyyy-mm-dd hh:mm:ss`#|日期和/或運算式所表示的時間 |  |#ERROR `errornumber` #| `errornumber` （變數會是標記為錯誤的物件） |      如果在輸入資料的項目時，您會到達檔案結尾，輸入將停止，並發生錯誤。      > [!NOTE] >`Input`函式不會進行當地語系化。 例如，在德文版中，如果輸入 3,14159，它只會傳回 3，因為逗號會被視為變數做為小數點分隔符號而不是。      > [!IMPORTANT] > 從檔案讀取使用`Input`函式需要`Read`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Input` function to read data from a file into two variables. This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: (\"Hello\", 234).  \n  \n [!code-vb[VbVbalrCatRef#35](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._140_1.vb)]"
  syntax:
    content: public static void Input (int FileNumber, ref string Value);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Value
      type: System.String
      description: "必要。 變數指派的值是從檔案讀取，不能是陣列或物件變數。"
  overload: Microsoft.VisualBasic.FileSystem.Input*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  id: InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>中的值，包含字元從檔案開啟<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>模式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`InputString`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       資料讀取`InputString`函式通常會寫入至檔案使用`Print`或`FilePut`。 此函式只適用於開啟的檔案`Input`或`Binary`模式。       不同於`Input`函式，`InputString`函式會傳回讀取的字元。 這包括逗號、 換行字元、 換、 引號和前置空格。       開啟的檔案與`Binary`存取，嘗試讀取整個檔案使用`InputString`函式，直到`EOF`傳回`True`會產生錯誤。 使用`LOF`和`Loc`函式，而不是`EOF`使用讀取二進位檔案時`InputString`，或使用`FileGet`當您使用`EOF`函式。      > [!NOTE] > 時自檔案讀取，請勿根據檔案名稱副檔名的檔案內容的安全性決策。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。"
  example:
  - "This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#33](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._220_1.vb)]"
  syntax:
    content: public static string InputString (int FileNumber, int CharCount);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: CharCount
      type: System.Int32
      description: "必要。 任何有效的數值運算式，指定要讀取的字元數。"
    return:
      type: System.String
      description: "傳回<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>中的值，包含字元從檔案開啟<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_Binary&quot; name=&quot;Binary&quot; href=&quot;&quot;></xref>模式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_InputString&quot; name=&quot;InputString&quot; href=&quot;&quot;> </xref>。"
  overload: Microsoft.VisualBasic.FileSystem.InputString*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>不存在。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>CharCount</code>&lt; 0 or &gt; 214."
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  id: Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從磁碟刪除檔案。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_Kill&quot; name=&quot;Kill&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref> 。"
  remarks: "`Kill`支援使用多個字元 (`*`) 和單一字元 (`?`) 萬用字元來指定多個檔案。       **安全性注意事項**才能執行，`Kill`函式需要`Read`和`PathDiscovery`旗標<xref:System.Security.Permissions.FileIOPermission>要執行的程式碼授與。</xref:System.Security.Permissions.FileIOPermission> 如需詳細資訊，請參閱<xref:System.Security.SecurityException>[程式碼存取權限](http://msdn.microsoft.com/en-us/e5ae402f-6dda-4732-bbe8-77296630f675)</xref:System.Security.SecurityException>"
  example:
  - "This example uses the `Kill` function to delete a file from a disk.  \n  \n [!code-vb[VbVbalrCatRef#60](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._250_1.vb)]"
  syntax:
    content: public static void Kill (string PathName);
    parameters:
    - id: PathName
      type: System.String
      description: "必要。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定要刪除的一或多個檔案名稱的運算式。 `PathName`可以包含目錄或資料夾，以及磁碟機。"
  overload: Microsoft.VisualBasic.FileSystem.Kill*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "目標檔案已開啟。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到的目標檔案。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "拒絕權限。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  id: LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "從開啟的循序檔案中讀取單一行，並將其指派給<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>變數。"
  remarks: "`LineInput`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       資料讀取`LineInput`通常會先寫入至檔案使用`Print`。      > [!IMPORTANT] > 時自檔案讀取，請勿根據檔案名稱副檔名的檔案來判斷內容。 例如，名為 Form1.vb 檔案可能無法 Visual Basic 來源檔案。       `LineInput`函式會從檔案的一個字元讀取一次直到它遇到歸位字元 (`Chr(`13`)`) 或歸位字元/換 (`Chr(`13`)` + `Chr(`10`)`) 序列。 歸位字元 / 換行字元循序會略過而不是附加的字元字串。      > [!IMPORTANT] > 從檔案讀取使用`LineInput`函式需要`Read`從存取<xref:System.Security.Permissions.FileIOPermissionAccess>列舉型別。</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable. This example assumes that `TestFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#19](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._158_1.vb)]"
  syntax:
    content: public static string LineInput (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    return:
      type: System.String
      description: "從開啟的循序檔案中讀取單一行，並將其指派給<xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>變數。"
  overload: Microsoft.VisualBasic.FileSystem.LineInput*
  exceptions:
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "已到達檔案結尾。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code>FileNumber</code>不存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  id: Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>值，指定在開啟的檔案目前的讀取/寫入位置。"
  remarks: "`Loc`函式是以零為起始，則使用它來擷取檔案中的第一個位元組，則會傳回 0。       `Loc`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       以下描述的傳回值為每個檔案存取模式: | | |  |-|-|  |模式 |傳回值 |  |`Random`|最後一筆記錄中讀取或寫入至檔案的數目。 |  |`Sequential`|除以 128 檔案中的目前位元組位置。 不過，所傳回資訊`Loc`循序檔案尚未使用或必要的。 |  |`Binary`|讀取或寫入的最後一個位元組的位置。 |"
  example:
  - "This example uses the `Loc` function to return the current read/write position in an open file. This example assumes that `MyFile` is a text file that has several lines of sample data.  \n  \n [!code-vb[VbVbalrCatRef#17](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._178_1.vb)]"
  syntax:
    content: public static long Loc (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效<xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;></xref>檔案數目。"
    return:
      type: System.Int64
      description: "傳回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>值，指定在開啟的檔案目前的讀取/寫入位置。"
  overload: Microsoft.VisualBasic.FileSystem.Loc*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  id: Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "全部或部分檔案，使用開啟的其他處理程序來控制存取<xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;></xref>函式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。       `Lock`和`Unlock`函式一律會以配對。 引數`Lock`和`Unlock`必須相同。       如果`Record`，或`FromRecord`和`ToRecord`所未提供，鎖定將會是整個檔案。 如果`Record`單獨指定的單一資料錄將會鎖定/解除鎖定。       如果已開啟檔案的循序輸入或輸出，`Lock`和`Unlock`會影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._243_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  id: Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "全部或部分檔案，使用開啟的其他處理程序來控制存取<xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;></xref>函式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。       `Lock`和`Unlock`函式一律會以配對。 引數`Lock`和`Unlock`必須相同。       如果`Record`，或`FromRecord`和`ToRecord`所未提供，鎖定將會是整個檔案。 如果`Record`單獨指定的單一資料錄將會鎖定/解除鎖定。       如果已開啟檔案的循序輸入或輸出，`Lock`和`Unlock`會影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._38_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Record
      type: System.Int64
      description: "選擇性。 唯一的記錄或鎖定或解除鎖定的位元組"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  id: Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "全部或部分檔案，使用開啟的其他處理程序來控制存取<xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;></xref>函式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。       `Lock`和`Unlock`函式一律會以配對。 引數`Lock`和`Unlock`必須相同。       如果`Record`，或`FromRecord`和`ToRecord`所未提供，鎖定將會是整個檔案。 如果`Record`單獨指定的單一資料錄將會鎖定/解除鎖定。       如果已開啟檔案的循序輸入或輸出，`Lock`和`Unlock`會影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._116_1.vb)]"
  syntax:
    content: public static void Lock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: FromRecord
      type: System.Int64
      description: "選擇性。 第一個記錄或鎖定或解除鎖定的位元組數目。"
    - id: ToRecord
      type: System.Int64
      description: "選擇性。 最後一個記錄或鎖定或解除鎖定的位元組數目。"
  overload: Microsoft.VisualBasic.FileSystem.Lock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  id: LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>代表的大小，以位元組為單位的檔案開啟使用<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "使用`FileLen`函式可取得不是開啟的檔案的長度。"
  example:
  - "This example uses the `LOF` function to determine the size of an open file. This example assumes that `TestFile` is a text file that contains sample data.  \n  \n [!code-vb[VbVbalrCatRef#23](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._83_1.vb)]"
  syntax:
    content: public static long LOF (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>中包含有效的檔案數目。"
    return:
      type: System.Int64
      description: "傳回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>代表的大小，以位元組為單位的檔案開啟使用<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_LOF&quot; name=&quot;LOF&quot; href=&quot;&quot;> </xref>。"
  overload: Microsoft.VisualBasic.FileSystem.LOF*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  id: MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "建立新的目錄。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory*>"
  remarks: "此函式會建立新的目錄。"
  example:
  - "This example uses the `MkDir` function to create a directory. If the drive is not specified, the new directory is created on the current drive.  \n  \n [!code-vb[VbVbalrCatRef#38](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._246_1.vb)]"
  syntax:
    content: public static void MkDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "必要。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>運算式，可識別要建立的目錄。 `Path`可能包括磁碟機。 如果未不指定任何磁碟機，則<xref uid=&quot;langword_csharp_MkDir&quot; name=&quot;MkDir&quot; href=&quot;&quot;></xref>目前的磁碟機上建立新的目錄。"
  overload: Microsoft.VisualBasic.FileSystem.MkDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>未指定，或為空白。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "拒絕權限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "目錄已經存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  id: Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "將顯示格式化資料寫入循序檔案。"
  remarks: "`Print`和`PrintLine`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       `Print`不包含行結尾處換行字元不過，`PrintLine`包含換行字元。       資料寫入與`Print`通常會從檔案讀取使用`LineInput`或`Input`。       如果您省略`Output`如`PrintLine`，列印一行空白行檔案; 以取得`Print`，沒有輸出。 以逗號分隔的多個運算式將會對齊索引標籤的界限，而混合逗號和`TAB`可能會造成不一致的結果。       如`Boolean`資料，在`True`或`False`列印。 `True`和`False`未經翻譯關鍵字，不論地區設定為何。       日期資料寫入檔案中，使用您的系統能辨識的標準的簡短日期格式。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。       不寫入至檔案如果`Output`是空的資料。 不過，如果`Output`清單資料是`DBNull`，`Null`寫入檔案。       如`Error`資料，輸出會顯示為`Error errorcode`。 `Error`不論地區設定為何不會轉譯關鍵字。       寫入檔案中使用的所有資料`Print`是國際感知; 也就是資料已正確地格式化使用適當的十進位分隔符號。 如果使用者想要使用多個地區設定，輸出資料，`Write`應使用。       寫入檔案，使用`Print`或`PrintLine`函式需要`Write`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._146_1.vb)]"
  syntax:
    content: public static void Print (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Output
      type: System.Object[]
      description: "選擇性。 要寫入至檔案中的零或多個以逗號分隔的運算式。       `Output`引數設定不︰ <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>︰ 檔案的模式無效。       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>:`FileNumber`不存在。"
  overload: Microsoft.VisualBasic.FileSystem.Print*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  id: PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "將顯示格式化資料寫入循序檔案。"
  remarks: "`Print`和`PrintLine`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       `Print`不包含行結尾處換行字元不過，`PrintLine`包含換行字元。       資料寫入與`Print`通常會從檔案讀取使用`LineInput`或`Input`。       如果您省略`Output`如`PrintLine`，列印一行空白行檔案; 以取得`Print`，沒有輸出。 以逗號分隔的多個運算式將會對齊索引標籤的界限，而混合逗號和`TAB`可能會造成不一致的結果。       如`Boolean`資料，在`True`或`False`列印。 `True`和`False`未經翻譯關鍵字，不論地區設定為何。       日期資料寫入檔案中，使用系統所能辨識的標準的簡短日期格式。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。       不寫入至檔案如果`Output`是空的資料。 不過，如果`Output`清單資料是`DBNull`，`Null`寫入檔案。       如`Error`資料，輸出會顯示為`Error errorcode`。 `Error`不論地區設定為何不會轉譯關鍵字。       寫入檔案中使用的所有資料`Print`是國際感知; 也就是資料已正確地格式化使用適當的十進位分隔符號。 如果使用者想要使用多個地區設定，輸出資料，`Write`應使用。       寫入檔案，使用`Print`或`PrintLine`函式需要`Write`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Print` and `PrintLine` functions to write data to a file.  \n  \n [!code-vb[VbVbalrCatRef#53](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._245_1.vb)]"
  syntax:
    content: public static void PrintLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Output
      type: System.Object[]
      description: "選擇性。 要寫入至檔案中的零或多個以逗號分隔的運算式。       `Output`引數設定不︰ <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;> </xref>︰ 檔案的模式無效。       <xref uid=&quot;langword_csharp_T:System.IO.IOException&quot; name=&quot;T:System.IO.IOException&quot; href=&quot;&quot;></xref>:`FileNumber`不存在。"
  overload: Microsoft.VisualBasic.FileSystem.PrintLine*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  id: Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "重新命名磁碟檔案或目錄。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_Rename&quot; name=&quot;Rename&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Rename`函式重新命名的檔案，並將它移到不同的目錄，如有必要。 `Rename`函式可以將檔案移到磁碟機，但它只能重新命名現有的目錄時同時`NewPath`和`OldPath`位於相同的磁碟機上。 `Rename`無法建立新檔案或目錄。       使用`Rename`開啟的檔案的函式會產生錯誤。 您必須關閉開啟的檔案再重新命名它。 `Rename`引數不能包含多個字元 （*） 和單一字元 （？） 的萬用字元。      > [!IMPORTANT] > 時使用`Rename`將從受保護的位置將檔案複製到受保護的位置，檔案會保留較不受限的權限。 請檢查並確定沒有引入可能的安全性風險。"
  example:
  - "This example uses the `Rename` function to rename a file. For purposes of this example, assume that the directories that are specified already exist.  \n  \n [!code-vb[VbVbalrCatRef#30](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._97_1.vb)]"
  syntax:
    content: public static void Rename (string OldPath, string NewPath);
    parameters:
    - id: OldPath
      type: System.String
      description: "必要。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定現有的檔案名稱和位置的運算式。 `OldPath`可能包含目錄和檔案的磁碟機。"
    - id: NewPath
      type: System.String
      description: "必要。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定新的檔案名稱和位置的運算式。 `NewPath`可能包括目錄和目的地位置的磁碟機。 所指定的檔案名稱`NewPath`不存在。"
  overload: Microsoft.VisualBasic.FileSystem.Rename*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "路徑無效。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>OldPath</code>檔案不存在。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法重新命名為不同的裝置。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Reset
  id: Reset
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "關閉所有磁碟所使用開啟的檔案<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_Reset&quot; name=&quot;Reset&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Reset`函式會關閉所有開啟的作用中的檔案`FileOpen`函式，並擁有的相同功能與`FileClose()`不含任何參數。"
  example:
  - "This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk. Note the use of the `Object` variable `FileNumber` as both a string and a number.  \n  \n [!code-vb[VbVbalrCatRef#12](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._117_1.vb)]"
  syntax:
    content: public static void Reset ();
    parameters: []
  overload: Microsoft.VisualBasic.FileSystem.Reset*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  id: RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "移除現有的目錄。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>.</xref:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory*>"
  remarks: "如果您嘗試使用，就會發生錯誤`RmDir`包含檔案的目錄上。 使用`Kill`函式來刪除所有檔案，然後再移除目錄。"
  example:
  - "This example uses the `RmDir` function to remove an existing directory.  \n  \n [!code-vb[VbVbalrCatRef#31](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._20_1.vb)]"
  syntax:
    content: public static void RmDir (string Path);
    parameters:
    - id: Path
      type: System.String
      description: "必要。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>識別要移除資料夾的目錄的運算式。 `Path`可以包括磁碟機。 如果未不指定任何磁碟機，則<xref uid=&quot;langword_csharp_RmDir&quot; name=&quot;RmDir&quot; href=&quot;&quot;></xref>移除目前的磁碟機上的目錄。"
  overload: Microsoft.VisualBasic.FileSystem.RmDir*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Path</code>未指定，或為空白。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "目標目錄包含檔案。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "目錄不存在。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  id: Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>藉由指定檔案中目前的讀取/寫入位置開啟<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函式或設定使用的下一個讀取/寫入作業中檔案的位置開啟<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Seek`傳回介於 1 到 2147483647 之間的值 (相當於 2 ^31-1) 之間，內含。       以下描述的傳回值，每個檔案存取模式: | | |  |-|-|  |模式 |傳回值 |  |`Random`|下一個記錄讀取或寫入數 |  |`Binary`, `Input`, `Output`, `Append`|下一項作業就會發生的位元組位置。 在檔案中的第一個位元組位於位置 1，第二個位元組是在位置 2，以此類推。 |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._100_4.vb)]"
  syntax:
    content: public static long Seek (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>中包含有效的檔案數目。"
    return:
      type: System.Int64
      description: "傳回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>藉由指定檔案中目前的讀取/寫入位置開啟<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函式或設定使用的下一個讀取/寫入作業中檔案的位置開啟<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函式。"
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  id: Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "傳回<xref uid=&quot;langword_csharp_Long&quot; name=&quot;Long&quot; href=&quot;&quot;></xref>藉由指定檔案中目前的讀取/寫入位置開啟<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函式或設定使用的下一個讀取/寫入作業中檔案的位置開啟<xref uid=&quot;langword_csharp_FileOpen&quot; name=&quot;FileOpen&quot; href=&quot;&quot;></xref>函式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_Seek&quot; name=&quot;Seek&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Seek`傳回介於 1 到 2147483647 之間的值 (相當於 2 ^31-1) 之間，內含。       以下描述的傳回值，每個檔案存取模式: | | |  |-|-|  |模式 |傳回值 |  |`Random`|下一個記錄讀取或寫入數 |  |`Binary`, `Input`, `Output`, `Append`|下一項作業就會發生的位元組位置。 在檔案中的第一個位元組位於位置 1，第二個位元組是在位置 2，以此類推。 |"
  example:
  - "This example uses the `Seek` function to return the current file position. The example assumes `TestFile` is a file that contains records of the structure `Record`.  \n  \n [!code-vb[VbVbalrCatRef#47](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_1.vb)]  \n  \n For files opened in `Random` mode, `Seek` returns the number of next record.  \n  \n [!code-vb[VbVbalrCatRef#48](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_2.vb)]  \n  \n For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#49](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_3.vb)]  \n  \n This example uses the `Seek` function to set the position for the next read or write in a file.  \n  \n For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs. Assume `TestFile` is a file that contains several lines of text.  \n  \n [!code-vb[VbVbalrCatRef#52](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._51_4.vb)]"
  syntax:
    content: public static void Seek (int FileNumber, long Position);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>中包含有效的檔案數目。"
    - id: Position
      type: System.Int64
      description: "必要。 應該會發生範圍 1 – 2147483647，在內的數字表示下一個讀取/寫入作業的位置。"
  overload: Microsoft.VisualBasic.FileSystem.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  id: SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "設定此屬性的檔案資訊。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_SetAttr&quot; name=&quot;SetAttr&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "如果您嘗試設定開啟檔案的屬性，就會發生執行階段錯誤。       `Attributes`引數的列舉值如下: | | |  |-|-|-|  |值 |常數 |描述 |  |`Normal`|`vbNormal`|標準 （預設值）。 |  |`ReadOnly`|`vbReadOnly`|唯讀狀態。 |  |`Hidden`|`vbHidden`|隱藏。 |  |`System`|`vbSystem`|系統檔案。 |  |`Volume`|`vbVolume`|磁碟區標籤 |  |`Directory`|`vbDirectory`|目錄或資料夾。 |  |`Archive`|`vbArchive`|自上次備份之後已變更的檔案。 |  |`Alias`|`vbAlias`|檔案有不同的名稱。 |     > [!NOTE] > 這些列舉型別 Visual Basic 語言所指定。 名稱可以用在您的程式碼，而非實際值的處。"
  example:
  - "This example uses the `SetAttr` function to set attributes for a file.  \n  \n [!code-vb[VbVbalrCatRef#14](~/add/codesnippet/visualbasic/7c37826d-7b37-4e2d-b69a-_1.vb)]"
  syntax:
    content: public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);
    parameters:
    - id: PathName
      type: System.String
      description: "必要。 <xref uid=&quot;langword_csharp_String&quot; name=&quot;String&quot; href=&quot;&quot;></xref>指定的檔案名稱的運算式。 `PathName`可以包含目錄或資料夾和磁碟機。"
    - id: Attributes
      type: Microsoft.VisualBasic.FileAttribute
      description: "必要。 常數或數值運算式，其總和的指定檔案屬性。"
  overload: Microsoft.VisualBasic.FileSystem.SetAttr*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>Attribute</code>型別無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  id: SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "搭配<xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>將輸出的函式。"
  remarks: "如果`Count`少於輸出線條寬度下, 一個列印位置立即遵循的列印的空格數目。 如果`Count`大於輸出的行寬，`SPC`計算下一步的列印位置，使用的公式︰ `currentprintposition`(+ (`Count``Mod``width`)) 例如，如果目前的列印位置為 24，輸出線條寬度為 80，而且您指定`SPC(`90`)`下, 一個列印將會開始於位置 34 （目前的列印位置 + 90/80 的餘數）。 如果目前的列印位置而輸出線條的寬度之間的差異小於`Count`(或`Count` `Mod` *寬度*)、`SPC`函式會跳到下一行的開頭，並產生空間等於`Count`– (*寬度*– *currentprintposition*)。      > [!NOTE] > 請確定您的表格式資料行的寬度不足以容納寬字母。"
  example:
  - "This example uses the `SPC` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#16](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._222_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.SpcInfo SPC (short Count);
    parameters:
    - id: Count
      type: System.Int16
      description: "必要。 顯示或列印在清單中的下一個運算式之前插入的空格數目。"
    return:
      type: Microsoft.VisualBasic.SpcInfo
      description: "搭配<xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>將輸出的函式。"
  overload: Microsoft.VisualBasic.FileSystem.SPC*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB
  id: TAB
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "搭配<xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>將輸出的函式。"
  remarks: "如果目前的行上目前的列印位置大於`Column`，`TAB`會跳到資料行的值等於`Column`在下一行中輸出。 如果`Column`小於 1，`TAB`的列印位置移至資料行 1。 如果`Column`大於輸出的行寬，`TAB`計算下一步的列印位置，使用的公式︰ 資料行 Mod 寬度，例如，如果*寬度*為 80，而且您指定`TAB(`90`)`下, 一個列印將會在資料行 10 （90/80 的餘數） 啟動。 如果`Column`小於目前的列印位置，列印在下一行導出的位置開始。 如果導出的列印位置大於目前的列印位置，列印會在導出列印位置在同一行。       在輸出行上最左邊的列印位置永遠為 1。 當您使用`Print`或`PrintLine`函數來列印至檔案，最右邊的列印位置是您可以使用設定輸出檔的目前寬度`FileWidth`函式。       `TAB`函式也可用以`WriteLine`函式。 它不能與<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName><xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName>或</xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > 請確定您的表格式資料行的寬度不足以包含寬的字母。"
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._165_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB ();
    parameters: []
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "搭配<xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>將輸出的函式。"
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  id: TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "搭配<xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>將輸出的函式。"
  remarks: "如果目前的行上目前的列印位置大於`Column`，`TAB`會跳到資料行的值等於`Column`在下一行中輸出。 如果`Column`小於 1，`TAB`的列印位置移至資料行 1。 如果`Column`大於輸出的行寬，`TAB`計算下一步的列印位置，使用的公式︰ 資料行 Mod 寬度，例如，如果*寬度*為 80，而且您指定`TAB(`90`)`下, 一個列印將會在資料行 10 （90/80 的餘數） 啟動。 如果`Column`小於目前的列印位置，列印在下一行導出的位置開始。 如果導出的列印位置大於目前的列印位置，列印會在導出列印位置在同一行。       在輸出行上最左邊的列印位置永遠為 1。 當您使用`Print`或`PrintLine`函數來列印至檔案，最右邊的列印位置是您可以使用設定輸出檔的目前寬度`FileWidth`函式。       `TAB`函式也可用以`WriteLine`函式。 它不能與<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName><xref:System.Console.WriteLine%2A?displayProperty=fullName>.</xref:System.Console.WriteLine%2A?displayProperty=fullName>或</xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=fullName>      > [!NOTE] > 請確定您的表格式資料行的寬度不足以包含寬的字母。"
  example:
  - "This example uses the `TAB` function to position output in a file and in the **Output** window.  \n  \n [!code-vb[VbVbalrCatRef#37](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._125_1.vb)]"
  syntax:
    content: public static Microsoft.VisualBasic.TabInfo TAB (short Column);
    parameters:
    - id: Column
      type: System.Int16
      description: "選擇性。 顯示或列印在清單中的下一個運算式之前，來移動資料行數。 如果省略， <xref uid=&quot;langword_csharp_TAB&quot; name=&quot;TAB&quot; href=&quot;&quot;> </xref>將插入點移至下一個的列印區域的開頭。"
    return:
      type: Microsoft.VisualBasic.TabInfo
      description: "搭配<xref uid=&quot;langword_csharp_Print&quot; name=&quot;Print&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_PrintLine&quot; name=&quot;PrintLine&quot; href=&quot;&quot;></xref>將輸出的函式。"
  overload: Microsoft.VisualBasic.FileSystem.TAB*
  exceptions: []
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  id: Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "全部或部分檔案，使用開啟的其他處理程序來控制存取<xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;></xref>函式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。       `Lock`和`Unlock`函式一律會以配對。 引數`Lock`和`Unlock`必須相同。       如果`Record`，或`FromRecord`和`ToRecord`所未提供，鎖定將會是整個檔案。 如果`Record`單獨指定的單一資料錄將會鎖定/解除鎖定。       如果已開啟檔案的循序輸入或輸出，`Lock`和`Unlock`會影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._26_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  id: Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "全部或部分檔案，使用開啟的其他處理程序來控制存取<xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;></xref>函式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。       `Lock`和`Unlock`函式一律會以配對。 引數`Lock`和`Unlock`必須相同。       如果`Record`，或`FromRecord`和`ToRecord`所未提供，鎖定將會是整個檔案。 如果`Record`單獨指定的單一資料錄將會鎖定/解除鎖定。       如果已開啟檔案的循序輸入或輸出，`Lock`和`Unlock`會影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._210_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long Record);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: Record
      type: System.Int64
      description: "選擇性。 唯一的記錄或鎖定或解除鎖定的位元組"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  id: Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "全部或部分檔案，使用開啟的其他處理程序來控制存取<xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;></xref>函式。 <xref uid=&quot;langword_csharp_My&quot; name=&quot;My&quot; href=&quot;&quot;> </xref>功能可讓您更佳的產能和效能的檔案 I/O 作業於<xref uid=&quot;langword_csharp_Lock&quot; name=&quot;Lock&quot; href=&quot;&quot;></xref>和<xref uid=&quot;langword_csharp_Unlock&quot; name=&quot;Unlock&quot; href=&quot;&quot;> </xref>。 如需詳細資訊，請參閱<xref href=&quot;Microsoft.VisualBasic.FileIO.FileSystem&quot;> </xref>。"
  remarks: "`Lock`和`Unlock`函式適用於環境中，數個程序可能需要存取相同的檔案。       `Lock`和`Unlock`函式一律會以配對。 引數`Lock`和`Unlock`必須相同。       如果`Record`，或`FromRecord`和`ToRecord`所未提供，鎖定將會是整個檔案。 如果`Record`單獨指定的單一資料錄將會鎖定/解除鎖定。       如果已開啟檔案的循序輸入或輸出，`Lock`和`Unlock`會影響整個檔案，而不論所指定的範圍`FromRecord`和`ToRecord`。"
  example:
  - "This example illustrates the use of the `Lock` and `Unlock` functions. This example assumes that `People.txt` is a file that contains records of the structure `Person`.  \n  \n [!code-vb[VbVbalrCatRef#13](~/add/codesnippet/visualbasic/93b8910d-5e06-4d09-8b8b-_1.vb)]"
  syntax:
    content: public static void Unlock (int FileNumber, long FromRecord, long ToRecord);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 任何有效的檔案數目。"
    - id: FromRecord
      type: System.Int64
      description: "選擇性。 第一個記錄或鎖定或解除鎖定的位元組數目。"
    - id: ToRecord
      type: System.Int64
      description: "選擇性。 最後一個記錄或鎖定或解除鎖定的位元組數目。"
  overload: Microsoft.VisualBasic.FileSystem.Unlock*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  id: Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "將資料寫入循序檔案。 資料寫入與<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>通常會從檔案讀取使用<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>。"
  remarks: "`Write`和`WriteLine`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       如果您省略`Output`，空白的線條會列印到檔案。 可以以逗號分隔的多個運算式。       不同於`Print`函式，`Write`函式插入項目和引號括住的字串之間的逗號，當寫入檔案。 您沒有在清單中放置明確的分隔符號。 當`Write`用來將資料寫入至檔案，只是數值， `Boolean`，日期、 null、 和`Error`資料格式都受到支援。 因此資料一律可以讀取並正確解譯使用，會遵循下列通用假設`Input`，而不論地區設定:-數字的資料一律會寫入做為小數點使用期限。      -若為`Boolean`資料，在`#TRUE#`或`#FALSE#`列印。 `True`和`False`未經翻譯關鍵字，不論地區設定為何。      -日期資料寫入時使用通用的日期格式的檔案。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。      -不寫入至檔案如果`Output`是空的資料。 不過，對於 null 的資料，`#NULL#`寫入。      -若為`Error`資料，輸出會顯示為`#ERROR errorcode#`。 `Error`關鍵字不會轉譯，不論地區設定為何。       `WriteLine`插入新行字元 (也就是歸位字元/換，或`Chr(13) + Chr(10)`)、 撰寫最後一個字元之後`Output`檔案。       您也可以使用雙引號括住，在字串中內嵌引號或&quot;&quot;。 例如， [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_1.vb) ]傳回值是字串`Double quotation marks aren&quot;t &quot;difficult&quot; to handle`。       寫入檔案，使用`Write`或`WriteLine`函式需要`Append`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._145_2.vb)]"
  syntax:
    content: public static void Write (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>包含任何有效的檔案數目的運算式。"
    - id: Output
      type: System.Object[]
      description: "選擇性。 要寫入至檔案中的一或多個以逗號分隔的運算式。"
  overload: Microsoft.VisualBasic.FileSystem.Write*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案模式無效。"
  platform:
  - net462
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  id: WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  langs:
  - csharp
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
  type: Method
  assemblies:
  - Microsoft.VisualBasic
  namespace: Microsoft.VisualBasic
  summary: "將資料寫入循序檔案。 資料寫入與<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>通常會從檔案讀取使用<xref uid=&quot;langword_csharp_Input&quot; name=&quot;Input&quot; href=&quot;&quot;> </xref>。"
  remarks: "`Write`和`WriteLine`函式提供回溯相容性，而且可能會影響效能。 對於非傳統應用程式，`My.Computer.FileSystem`物件提供更佳的效能。 如需詳細資訊，請參閱[使用 Visual Basic 檔案存取](~/add/includes/ajax-current-ext-md.md)。       如果您省略`Output`，空白的線條會列印到檔案。 可以以逗號分隔的多個運算式。       不同於`Print`函式，`Write`函式插入項目和引號括住的字串之間的逗號，當寫入檔案。 您沒有在清單中放置明確的分隔符號。 當`Write`用來將資料寫入至檔案，只是數值， `Boolean`，日期、 null、 和`Error`資料格式都受到支援。 因此資料一律可以讀取並正確解譯使用，會遵循下列通用假設`Input`，而不論地區設定:-數字的資料一律會寫入做為小數點使用期限。      -若為`Boolean`資料，在`#TRUE#`或`#FALSE#`列印。 `True`和`False`未經翻譯關鍵字，不論地區設定為何。      -日期資料寫入時使用通用的日期格式的檔案。 當日期或時間的元件遺失或為零時，只提供部分寫入至檔案。      -不寫入至檔案如果`Output`是空的資料。 不過，對於 null 的資料，`#NULL#`寫入。      -若為`Error`資料，輸出會顯示為`#ERROR errorcode#`。 `Error`關鍵字不會轉譯，不論地區設定為何。       `WriteLine`插入新行字元 (也就是歸位字元/換，或`Chr(13) + Chr(10)`)、 撰寫最後一個字元之後`Output`檔案。       您也可以使用雙引號括住，在字串中內嵌引號或&quot;&quot;。 例如， [!code-vb [VbVbalrCatRef&#63;](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_1.vb) ]傳回值是字串`Double quotation marks aren&quot;t &quot;difficult&quot; to handle`。       寫入檔案，使用`Write`或`WriteLine`函式需要`Append`從存取`FileIOPermissionAccess`列舉型別。 如需詳細資訊，請參閱<xref:System.Security.Permissions.FileIOPermissionAccess>.</xref:System.Security.Permissions.FileIOPermissionAccess>"
  example:
  - "This example uses the `Write` function to write raw data to a sequential file.  \n  \n [!code-vb[VbVbalrCatRef#64](~/add/codesnippet/visualbasic/m-microsoft.visualbasic._172_2.vb)]"
  syntax:
    content: public static void WriteLine (int FileNumber, object[] Output);
    parameters:
    - id: FileNumber
      type: System.Int32
      description: "必要。 <xref uid=&quot;langword_csharp_Integer&quot; name=&quot;Integer&quot; href=&quot;&quot;> </xref>包含任何有效的檔案數目的運算式。"
    - id: Output
      type: System.Object[]
      description: "選擇性。 要寫入至檔案中的一或多個以逗號分隔的運算式。"
  overload: Microsoft.VisualBasic.FileSystem.WriteLine*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: Microsoft.VisualBasic.FileSystem.ChDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir(String)
  nameWithType: FileSystem.ChDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDir(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(Char)
  nameWithType: FileSystem.ChDrive(Char)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(Char)
- uid: System.Char
  parent: System
  isExternal: true
  name: Char
  nameWithType: Char
  fullName: System.Char
- uid: Microsoft.VisualBasic.FileSystem.ChDrive(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive(String)
  nameWithType: FileSystem.ChDrive(String)
  fullName: Microsoft.VisualBasic.FileSystem.ChDrive(String)
- uid: Microsoft.VisualBasic.FileSystem.CurDir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir()
  nameWithType: FileSystem.CurDir()
  fullName: Microsoft.VisualBasic.FileSystem.CurDir()
- uid: Microsoft.VisualBasic.FileSystem.CurDir(System.Char)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir(Char)
  nameWithType: FileSystem.CurDir(Char)
  fullName: Microsoft.VisualBasic.FileSystem.CurDir(Char)
- uid: Microsoft.VisualBasic.FileSystem.Dir
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir()
  nameWithType: FileSystem.Dir()
  fullName: Microsoft.VisualBasic.FileSystem.Dir()
- uid: Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir(String,FileAttribute)
  nameWithType: FileSystem.Dir(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.Dir(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileAttribute
  parent: Microsoft.VisualBasic
  isExternal: false
  name: FileAttribute
  nameWithType: FileAttribute
  fullName: Microsoft.VisualBasic.FileAttribute
- uid: Microsoft.VisualBasic.FileSystem.EOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF(Int32)
  nameWithType: FileSystem.EOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.EOF(Int32)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr(Int32)
  nameWithType: FileSystem.FileAttr(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileAttr(Int32)
- uid: Microsoft.VisualBasic.OpenMode
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenMode
  nameWithType: OpenMode
  fullName: Microsoft.VisualBasic.OpenMode
- uid: Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose(Int32[])
  nameWithType: FileSystem.FileClose(Int32[])
  fullName: Microsoft.VisualBasic.FileSystem.FileClose(Int32[])
- uid: System.Int32[]
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32[]
  spec.csharp:
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy(String,String)
  nameWithType: FileSystem.FileCopy(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.FileCopy(String,String)
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime(String)
  nameWithType: FileSystem.FileDateTime(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileDateTime(String)
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Boolean,Int64)
  nameWithType: FileSystem.FileGet(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Boolean,Int64)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Byte,Int64)
  nameWithType: FileSystem.FileGet(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Byte,Int64)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Char,Int64)
  nameWithType: FileSystem.FileGet(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,DateTime,Int64)
  nameWithType: FileSystem.FileGet(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Decimal,Int64)
  nameWithType: FileSystem.FileGet(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Decimal,Int64)
- uid: System.Decimal
  parent: System
  isExternal: true
  name: Decimal
  nameWithType: Decimal
  fullName: System.Decimal
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Double,Int64)
  nameWithType: FileSystem.FileGet(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Double,Int64)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int16,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int16,Int64)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int32,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Int64,Int64)
  nameWithType: FileSystem.FileGet(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Single,Int64)
  nameWithType: FileSystem.FileGet(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Single,Int64)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,ValueType,Int64)
  nameWithType: FileSystem.FileGet(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,ValueType,Int64)
- uid: System.ValueType
  parent: System
  isExternal: true
  name: ValueType
  nameWithType: ValueType
  fullName: System.ValueType
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FileGet(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FileGet(Int32,Array,Int64,Boolean,Boolean)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject(Int32,Object,Int64)
  nameWithType: FileSystem.FileGetObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FileGetObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileLen(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen(String)
  nameWithType: FileSystem.FileLen(String)
  fullName: Microsoft.VisualBasic.FileSystem.FileLen(String)
- uid: Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  nameWithType: FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileOpen(Int32,String,OpenMode,OpenAccess,OpenShare,Int32)
- uid: Microsoft.VisualBasic.OpenAccess
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenAccess
  nameWithType: OpenAccess
  fullName: Microsoft.VisualBasic.OpenAccess
- uid: Microsoft.VisualBasic.OpenShare
  parent: Microsoft.VisualBasic
  isExternal: false
  name: OpenShare
  nameWithType: OpenShare
  fullName: Microsoft.VisualBasic.OpenShare
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Boolean,Int64)
  nameWithType: FileSystem.FilePut(Int32,Boolean,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Boolean,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Byte,Int64)
  nameWithType: FileSystem.FilePut(Int32,Byte,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Byte,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Char,Int64)
  nameWithType: FileSystem.FilePut(Int32,Char,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Char,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,DateTime,Int64)
  nameWithType: FileSystem.FilePut(Int32,DateTime,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,DateTime,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Decimal,Int64)
  nameWithType: FileSystem.FilePut(Int32,Decimal,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Decimal,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Double,Int64)
  nameWithType: FileSystem.FilePut(Int32,Double,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Double,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int16,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int16,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int16,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int32,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Int64,Int64)
  nameWithType: FileSystem.FilePut(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Single,Int64)
  nameWithType: FileSystem.FilePut(Int32,Single,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Single,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,ValueType,Int64)
  nameWithType: FileSystem.FilePut(Int32,ValueType,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,ValueType,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Object,Object,Object)
  nameWithType: FileSystem.FilePut(Object,Object,Object)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Object,Object,Object)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,String,Int64,Boolean)
  nameWithType: FileSystem.FilePut(Int32,String,Int64,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,String,Int64,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut(Int32,Array,Int64,Boolean,Boolean)
  nameWithType: FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.FilePut(Int32,Array,Int64,Boolean,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject(Int32,Object,Int64)
  nameWithType: FileSystem.FilePutObject(Int32,Object,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.FilePutObject(Int32,Object,Int64)
- uid: Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth(Int32,Int32)
  nameWithType: FileSystem.FileWidth(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.FileWidth(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.FreeFile
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile()
  nameWithType: FileSystem.FreeFile()
  fullName: Microsoft.VisualBasic.FileSystem.FreeFile()
- uid: Microsoft.VisualBasic.FileSystem.GetAttr(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr(String)
  nameWithType: FileSystem.GetAttr(String)
  fullName: Microsoft.VisualBasic.FileSystem.GetAttr(String)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Boolean)
  nameWithType: FileSystem.Input(Int32,Boolean)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Boolean)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Byte)
  nameWithType: FileSystem.Input(Int32,Byte)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Byte)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Char)
  nameWithType: FileSystem.Input(Int32,Char)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Char)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,DateTime)
  nameWithType: FileSystem.Input(Int32,DateTime)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,DateTime)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Decimal)
  nameWithType: FileSystem.Input(Int32,Decimal)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Decimal)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Double)
  nameWithType: FileSystem.Input(Int32,Double)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Double)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int16)
  nameWithType: FileSystem.Input(Int32,Int16)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int16)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int32)
  nameWithType: FileSystem.Input(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Int64)
  nameWithType: FileSystem.Input(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Object)
  nameWithType: FileSystem.Input(Int32,Object)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Object)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,Single)
  nameWithType: FileSystem.Input(Int32,Single)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,Single)
- uid: Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input(Int32,String)
  nameWithType: FileSystem.Input(Int32,String)
  fullName: Microsoft.VisualBasic.FileSystem.Input(Int32,String)
- uid: Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString(Int32,Int32)
  nameWithType: FileSystem.InputString(Int32,Int32)
  fullName: Microsoft.VisualBasic.FileSystem.InputString(Int32,Int32)
- uid: Microsoft.VisualBasic.FileSystem.Kill(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill(String)
  nameWithType: FileSystem.Kill(String)
  fullName: Microsoft.VisualBasic.FileSystem.Kill(String)
- uid: Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput(Int32)
  nameWithType: FileSystem.LineInput(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LineInput(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Loc(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc(Int32)
  nameWithType: FileSystem.Loc(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Loc(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32)
  nameWithType: FileSystem.Lock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock(Int32,Int64,Int64)
  nameWithType: FileSystem.Lock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Lock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.LOF(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF(Int32)
  nameWithType: FileSystem.LOF(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.LOF(Int32)
- uid: Microsoft.VisualBasic.FileSystem.MkDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir(String)
  nameWithType: FileSystem.MkDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.MkDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print(Int32,Object[])
  nameWithType: FileSystem.Print(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Print(Int32,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine(Int32,Object[])
  nameWithType: FileSystem.PrintLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.PrintLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename(String,String)
  nameWithType: FileSystem.Rename(String,String)
  fullName: Microsoft.VisualBasic.FileSystem.Rename(String,String)
- uid: Microsoft.VisualBasic.FileSystem.Reset
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset()
  nameWithType: FileSystem.Reset()
  fullName: Microsoft.VisualBasic.FileSystem.Reset()
- uid: Microsoft.VisualBasic.FileSystem.RmDir(System.String)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir(String)
  nameWithType: FileSystem.RmDir(String)
  fullName: Microsoft.VisualBasic.FileSystem.RmDir(String)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32)
  nameWithType: FileSystem.Seek(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek(Int32,Int64)
  nameWithType: FileSystem.Seek(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Seek(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr(String,FileAttribute)
  nameWithType: FileSystem.SetAttr(String,FileAttribute)
  fullName: Microsoft.VisualBasic.FileSystem.SetAttr(String,FileAttribute)
- uid: Microsoft.VisualBasic.FileSystem.SPC(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC(Int16)
  nameWithType: FileSystem.SPC(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.SPC(Int16)
- uid: Microsoft.VisualBasic.SpcInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: SpcInfo
  nameWithType: SpcInfo
  fullName: Microsoft.VisualBasic.SpcInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB()
  nameWithType: FileSystem.TAB()
  fullName: Microsoft.VisualBasic.FileSystem.TAB()
- uid: Microsoft.VisualBasic.TabInfo
  parent: Microsoft.VisualBasic
  isExternal: false
  name: TabInfo
  nameWithType: TabInfo
  fullName: Microsoft.VisualBasic.TabInfo
- uid: Microsoft.VisualBasic.FileSystem.TAB(System.Int16)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB(Int16)
  nameWithType: FileSystem.TAB(Int16)
  fullName: Microsoft.VisualBasic.FileSystem.TAB(Int16)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32)
  nameWithType: FileSystem.Unlock(Int32)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock(Int32,Int64,Int64)
  nameWithType: FileSystem.Unlock(Int32,Int64,Int64)
  fullName: Microsoft.VisualBasic.FileSystem.Unlock(Int32,Int64,Int64)
- uid: Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write(Int32,Object[])
  nameWithType: FileSystem.Write(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.Write(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine(Int32,Object[])
  nameWithType: FileSystem.WriteLine(Int32,Object[])
  fullName: Microsoft.VisualBasic.FileSystem.WriteLine(Int32,Object[])
- uid: Microsoft.VisualBasic.FileSystem.ChDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDir
  nameWithType: FileSystem.ChDir
- uid: Microsoft.VisualBasic.FileSystem.ChDrive*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: ChDrive
  nameWithType: FileSystem.ChDrive
- uid: Microsoft.VisualBasic.FileSystem.CurDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: CurDir
  nameWithType: FileSystem.CurDir
- uid: Microsoft.VisualBasic.FileSystem.Dir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Dir
  nameWithType: FileSystem.Dir
- uid: Microsoft.VisualBasic.FileSystem.EOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: EOF
  nameWithType: FileSystem.EOF
- uid: Microsoft.VisualBasic.FileSystem.FileAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileAttr
  nameWithType: FileSystem.FileAttr
- uid: Microsoft.VisualBasic.FileSystem.FileClose*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileClose
  nameWithType: FileSystem.FileClose
- uid: Microsoft.VisualBasic.FileSystem.FileCopy*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileCopy
  nameWithType: FileSystem.FileCopy
- uid: Microsoft.VisualBasic.FileSystem.FileDateTime*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileDateTime
  nameWithType: FileSystem.FileDateTime
- uid: Microsoft.VisualBasic.FileSystem.FileGet*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGet
  nameWithType: FileSystem.FileGet
- uid: Microsoft.VisualBasic.FileSystem.FileGetObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileGetObject
  nameWithType: FileSystem.FileGetObject
- uid: Microsoft.VisualBasic.FileSystem.FileLen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileLen
  nameWithType: FileSystem.FileLen
- uid: Microsoft.VisualBasic.FileSystem.FileOpen*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileOpen
  nameWithType: FileSystem.FileOpen
- uid: Microsoft.VisualBasic.FileSystem.FilePut*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePut
  nameWithType: FileSystem.FilePut
- uid: Microsoft.VisualBasic.FileSystem.FilePutObject*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FilePutObject
  nameWithType: FileSystem.FilePutObject
- uid: Microsoft.VisualBasic.FileSystem.FileWidth*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FileWidth
  nameWithType: FileSystem.FileWidth
- uid: Microsoft.VisualBasic.FileSystem.FreeFile*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: FreeFile
  nameWithType: FileSystem.FreeFile
- uid: Microsoft.VisualBasic.FileSystem.GetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: GetAttr
  nameWithType: FileSystem.GetAttr
- uid: Microsoft.VisualBasic.FileSystem.Input*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Input
  nameWithType: FileSystem.Input
- uid: Microsoft.VisualBasic.FileSystem.InputString*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: InputString
  nameWithType: FileSystem.InputString
- uid: Microsoft.VisualBasic.FileSystem.Kill*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Kill
  nameWithType: FileSystem.Kill
- uid: Microsoft.VisualBasic.FileSystem.LineInput*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LineInput
  nameWithType: FileSystem.LineInput
- uid: Microsoft.VisualBasic.FileSystem.Loc*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Loc
  nameWithType: FileSystem.Loc
- uid: Microsoft.VisualBasic.FileSystem.Lock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Lock
  nameWithType: FileSystem.Lock
- uid: Microsoft.VisualBasic.FileSystem.LOF*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: LOF
  nameWithType: FileSystem.LOF
- uid: Microsoft.VisualBasic.FileSystem.MkDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: MkDir
  nameWithType: FileSystem.MkDir
- uid: Microsoft.VisualBasic.FileSystem.Print*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Print
  nameWithType: FileSystem.Print
- uid: Microsoft.VisualBasic.FileSystem.PrintLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: PrintLine
  nameWithType: FileSystem.PrintLine
- uid: Microsoft.VisualBasic.FileSystem.Rename*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Rename
  nameWithType: FileSystem.Rename
- uid: Microsoft.VisualBasic.FileSystem.Reset*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Reset
  nameWithType: FileSystem.Reset
- uid: Microsoft.VisualBasic.FileSystem.RmDir*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: RmDir
  nameWithType: FileSystem.RmDir
- uid: Microsoft.VisualBasic.FileSystem.Seek*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Seek
  nameWithType: FileSystem.Seek
- uid: Microsoft.VisualBasic.FileSystem.SetAttr*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SetAttr
  nameWithType: FileSystem.SetAttr
- uid: Microsoft.VisualBasic.FileSystem.SPC*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: SPC
  nameWithType: FileSystem.SPC
- uid: Microsoft.VisualBasic.FileSystem.TAB*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: TAB
  nameWithType: FileSystem.TAB
- uid: Microsoft.VisualBasic.FileSystem.Unlock*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Unlock
  nameWithType: FileSystem.Unlock
- uid: Microsoft.VisualBasic.FileSystem.Write*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: Write
  nameWithType: FileSystem.Write
- uid: Microsoft.VisualBasic.FileSystem.WriteLine*
  parent: Microsoft.VisualBasic.FileSystem
  isExternal: false
  name: WriteLine
  nameWithType: FileSystem.WriteLine
