### YamlMime:ManagedReference
items:
- uid: System.Net.Security.SslStream
  id: SslStream
  children:
  - System.Net.Security.SslStream.#ctor(System.IO.Stream)
  - System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean)
  - System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback)
  - System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)
  - System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback,System.Net.Security.EncryptionPolicy)
  - System.Net.Security.SslStream.AuthenticateAsClient(System.String)
  - System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)
  - System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String)
  - System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)
  - System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)
  - System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)
  - System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)
  - System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)
  - System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)
  - System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)
  - System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)
  - System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)
  - System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Security.SslStream.CanRead
  - System.Net.Security.SslStream.CanSeek
  - System.Net.Security.SslStream.CanTimeout
  - System.Net.Security.SslStream.CanWrite
  - System.Net.Security.SslStream.CheckCertRevocationStatus
  - System.Net.Security.SslStream.CipherAlgorithm
  - System.Net.Security.SslStream.CipherStrength
  - System.Net.Security.SslStream.Dispose(System.Boolean)
  - System.Net.Security.SslStream.EndAuthenticateAsClient(System.IAsyncResult)
  - System.Net.Security.SslStream.EndAuthenticateAsServer(System.IAsyncResult)
  - System.Net.Security.SslStream.EndRead(System.IAsyncResult)
  - System.Net.Security.SslStream.EndWrite(System.IAsyncResult)
  - System.Net.Security.SslStream.Flush
  - System.Net.Security.SslStream.HashAlgorithm
  - System.Net.Security.SslStream.HashStrength
  - System.Net.Security.SslStream.IsAuthenticated
  - System.Net.Security.SslStream.IsEncrypted
  - System.Net.Security.SslStream.IsMutuallyAuthenticated
  - System.Net.Security.SslStream.IsServer
  - System.Net.Security.SslStream.IsSigned
  - System.Net.Security.SslStream.KeyExchangeAlgorithm
  - System.Net.Security.SslStream.KeyExchangeStrength
  - System.Net.Security.SslStream.Length
  - System.Net.Security.SslStream.LocalCertificate
  - System.Net.Security.SslStream.Position
  - System.Net.Security.SslStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.Net.Security.SslStream.ReadTimeout
  - System.Net.Security.SslStream.RemoteCertificate
  - System.Net.Security.SslStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Net.Security.SslStream.SetLength(System.Int64)
  - System.Net.Security.SslStream.SslProtocol
  - System.Net.Security.SslStream.TransportContext
  - System.Net.Security.SslStream.Write(System.Byte[])
  - System.Net.Security.SslStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.Net.Security.SslStream.WriteTimeout
  langs:
  - csharp
  name: SslStream
  nameWithType: SslStream
  fullName: System.Net.Security.SslStream
  type: Class
  summary: "提供用來驗證伺服器與 （選擇性） 用戶端使用安全通訊端層 (SSL) 安全性通訊協定的用戶端與伺服器通訊的資料流。"
  remarks: "SSL 通訊協定協助提供機密性和完整性檢查使用 SslStream 傳輸的訊息。 SSL 連接，例如提供的 SslStream，應該用於通訊的用戶端與伺服器之間的機密資訊時。 使用 SslStream 有助於防止任何人讀取和竄改時它是在網路上傳輸的資訊。       使用資料流時建立 SslStream 所提供的資料傳輸 SslStream 執行個體。 當您提供此基礎資料流時，您會有此選項可指定是否關閉 SslStream 也會關閉基礎資料流。 一般而言，SslStream 類別用於<xref:System.Net.Sockets.TcpClient>和<xref:System.Net.Sockets.TcpListener>類別。</xref:System.Net.Sockets.TcpListener> </xref:System.Net.Sockets.TcpClient> <xref:System.Net.Sockets.TcpClient.GetStream%2A>方法會提供<xref:System.Net.Sockets.NetworkStream>適用於搭配 SslStream 類別。</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.TcpClient.GetStream%2A>       在建立之後 SslStream，就必須驗證伺服器和 （選擇性） 用戶端。 伺服器必須提供 X509 憑證，會建立其識別身分的證明，並可以要求的用戶端也會如此。 傳輸使用 SslStream 資訊前，必須執行驗證。 用戶端會起始驗證使用同步<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>方法會封鎖，直到完成驗證，或非同步<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>方法，不會封鎖等候完成驗證。</xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> 伺服器會起始驗證使用同步<xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>或非同步<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> 用戶端和伺服器都必須初始化驗證。       驗證是由安全性支援提供者 (SSPI) 通道提供者處理。 用戶端被賦予控制藉由指定之伺服器的憑證驗證的機會<xref:System.Net.Security.RemoteCertificateValidationCallback>委派建立 SslStream 時。</xref:System.Net.Security.RemoteCertificateValidationCallback> 伺服器也可以藉由提供控制驗證<xref:System.Net.Security.RemoteCertificateValidationCallback>委派。</xref:System.Net.Security.RemoteCertificateValidationCallback> 委派所參考的方法包括遠端合作對象憑證和 SSPI 驗證憑證時所發生的任何錯誤。 請注意，是否伺服器指定委派，委派的方法會叫用不論伺服器要求用戶端驗證。 如果伺服器未要求用戶端驗證，伺服器的委派方法，會收到 null 憑證及憑證錯誤的空陣列。       如果伺服器需要用戶端驗證，用戶端必須指定一個或多個憑證進行驗證。 如果用戶端有一個以上的憑證，可以提供用戶端<xref:System.Net.Security.LocalCertificateSelectionCallback>選取正確的憑證伺服器的委派。</xref:System.Net.Security.LocalCertificateSelectionCallback> 用戶端的憑證必須位於目前使用者的&quot;My&quot;憑證存放區。 不支援透過憑證的用戶端驗證<xref:System.Security.Authentication.SslProtocols>(第 2 版 SSL) 通訊協定。</xref:System.Security.Authentication.SslProtocols>       如果驗證失敗時，您會收到<xref:System.Security.Authentication.AuthenticationException>，且不再能 SslStream。</xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。       當驗證程序，也稱為 SSL 交握，成功時，伺服器 （和 （選擇性） 用戶端） 的身分識別已建立，且 SslStream 可以由用戶端和伺服器用來交換訊息。 之前傳送或接收資訊時，用戶端和伺服器應該檢查以判斷通訊協定、 演算法和優勢選取符合其需求的完整性與機密性 SslStream 所提供的層級與安全性服務。 如果目前的設定不足時，必須先關閉資料流。 您可以檢查 SslStream 使用所提供的安全性服務<xref:System.Net.Security.SslStream.IsEncrypted%2A>和<xref:System.Net.Security.SslStream.IsSigned%2A>屬性。</xref:System.Net.Security.SslStream.IsSigned%2A> </xref:System.Net.Security.SslStream.IsEncrypted%2A> 下表顯示報告用於驗證、 加密和資料簽章的密碼編譯設定的項目。      |項目 |成員 |  |-------------|-------------|  |用來驗證伺服器和 （選擇性） 用戶端的安全性通訊協定。 |<xref:System.Net.Security.SslStream.SslProtocol%2A>屬性和相關聯的<xref:System.Security.Authentication.SslProtocols>列舉型別。 |  |金鑰交換演算法。 |<xref:System.Net.Security.SslStream.KeyExchangeAlgorithm%2A>屬性和相關聯的<xref:System.Security.Authentication.ExchangeAlgorithmType>列舉型別。 |  |訊息完整性演算法。 |<xref:System.Net.Security.SslStream.HashAlgorithm%2A>屬性和相關聯的<xref:System.Security.Authentication.HashAlgorithmType>列舉型別。 |  |訊息機密性演算法。 |<xref:System.Net.Security.SslStream.CipherAlgorithm%2A>屬性和相關聯的<xref:System.Security.Authentication.CipherAlgorithmType>列舉型別。 |  |選取演算法的強度。 |<xref:System.Net.Security.SslStream.KeyExchangeStrength%2A> <xref:System.Net.Security.SslStream.HashStrength%2A>，和<xref:System.Net.Security.SslStream.CipherStrength%2A>屬性。 |      成功驗證之後，您可以傳送資料，使用同步<xref:System.Net.Security.SslStream.Write%2A>或非同步<xref:System.Net.Security.SslStream.BeginWrite%2A>方法。</xref:System.Net.Security.SslStream.BeginWrite%2A> </xref:System.Net.Security.SslStream.Write%2A> </xref:System.Net.Security.SslStream.CipherStrength%2A> </xref:System.Net.Security.SslStream.HashStrength%2A> </xref:System.Net.Security.SslStream.KeyExchangeStrength%2A> </xref:System.Security.Authentication.CipherAlgorithmType> </xref:System.Net.Security.SslStream.CipherAlgorithm%2A> </xref:System.Security.Authentication.HashAlgorithmType> </xref:System.Net.Security.SslStream.HashAlgorithm%2A> </xref:System.Security.Authentication.ExchangeAlgorithmType> </xref:System.Net.Security.SslStream.KeyExchangeAlgorithm%2A> </xref:System.Security.Authentication.SslProtocols> </xref:System.Net.Security.SslStream.SslProtocol%2A> 您可以接收其資料同步使用<xref:System.Net.Security.SslStream.Read%2A>或非同步<xref:System.Net.Security.SslStream.BeginRead%2A>方法。</xref:System.Net.Security.SslStream.BeginRead%2A> </xref:System.Net.Security.SslStream.Read%2A>       如果您指定以<xref:System.Net.Security.SslStream.%23ctor%2A>，基礎資料流應該保持開啟狀態，您必須負責完成時關閉資料流中使用它。</xref:System.Net.Security.SslStream.%23ctor%2A>      > [!NOTE] > 建立 SslStream 物件的應用程式以一般使用者的認證執行，如果應用程式將無法存取憑證安裝在本機電腦存放區中，除非權限已經明確提供給使用者若要這樣做。       SslStream 假設逾時以及任何其他<xref:System.IO.IOException>當其中一個會擲回，從內部資料流將被視為嚴重由其呼叫端。</xref:System.IO.IOException> 逾時將會傳回記憶體回收之後，重複使用 SslStream 執行個體。 應用程式應該<xref:System.IO.Stream.Close%2A>SslStream 和擲回例外狀況在這些情況下。</xref:System.IO.Stream.Close%2A>       .NET Framework 4.6 包含新的安全性功能會封鎖不安全的加密與雜湊演算法的連線。 使用 TLS/SSL 透過例如 HttpClient、 HttpWebRequest、 FTPClient、 SmtpClient、 SslStream 」 等的 Api，並以.NET Framework 4.6 為目標的應用程式預設會取得更安全的行為。       開發人員可能想要取消這個行為，以維護與 RC4 服務以其現有 SSL3 服務或 TLS 的互通性。 [這篇文章](https://support.microsoft.com/kb/3069494)說明如何修改您的程式碼，讓新的行為會停用。       .NET Framework 4.6.3 加入新的驗證 SslStreams 未指定 TLS 版本，但改為使用 TLS 版本定義中的系統預設值為方法的多載[SCHANNEL](https://msdn.microsoft.com/library/windows/desktop/aa380123.aspx)。 在您的應用程式中使用這些方法，以便可以稍後修改預設值為 TLS 版本最佳作法是變更一段時間，而不需要重建並重新部署您的應用程式。"
  example:
  - "The following code example demonstrates creating an <xref:System.Net.Sockets.TcpListener> that uses the SslStream class to communicate with clients.  \n  \n [!code-cpp[NclSslServerSync#0](~/add/codesnippet/cpp/t-system.net.security.ss_1.cpp)]\n [!code-cs[NclSslServerSync#0](~/add/codesnippet/csharp/t-system.net.security.ss_1.cs)]  \n  \n The following code example demonstrates creating a <xref:System.Net.Sockets.TcpClient> that uses the SslStream class to communicate with a server.  \n  \n [!code-cpp[NclSslClientSync#0](~/add/codesnippet/cpp/t-system.net.security.ss_2.cpp)]\n [!code-cs[NclSslClientSync#0](~/add/codesnippet/csharp/t-system.net.security.ss_2.cs)]"
  syntax:
    content: 'public class SslStream : System.Net.Security.AuthenticatedStream'
  inheritance:
  - System.IO.Stream
  - System.Net.Security.AuthenticatedStream
  implements: []
  inheritedMembers:
  - System.Net.Security.AuthenticatedStream.InnerStream
  - System.Net.Security.AuthenticatedStream.LeaveInnerStreamOpen
  platform:
  - net462
- uid: System.Net.Security.SslStream.#ctor(System.IO.Stream)
  id: '#ctor(System.IO.Stream)'
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: SslStream(Stream)
  nameWithType: SslStream.SslStream(Stream)
  fullName: System.Net.Security.SslStream.SslStream(Stream)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "初始化的新執行個體<xref href=&quot;System.Net.Security.SslStream&quot;></xref>指定<xref:System.IO.Stream>.</xref:System.IO.Stream>類別"
  remarks: "如果 encryptionpolicy，組態檔中未指定值<xref:System.Net.Security.EncryptionPolicy>預設為<xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName>如<xref:System.Net.Security.SslStream>建構的執行個體。</xref:System.Net.Security.SslStream> </xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName> </xref:System.Net.Security.EncryptionPolicy>       使用 Null 編碼器時，需要為<xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName>。</xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName>設定加密原則"
  syntax:
    content: public SslStream (System.IO.Stream innerStream);
    parameters:
    - id: innerStream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>物件所使用<xref href=&quot;System.Net.Security.SslStream&quot;></xref>來傳送和接收資料。</xref:System.IO.Stream>"
  overload: System.Net.Security.SslStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>innerStream</code>為不可讀取。       -或-<code>innerStream</code>不是可寫入。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>innerStream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -<code>innerStream</code>等於<xref:System.IO.Stream.Null>。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean)
  id: '#ctor(System.IO.Stream,System.Boolean)'
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: SslStream(Stream,Boolean)
  nameWithType: SslStream.SslStream(Stream,Boolean)
  fullName: System.Net.Security.SslStream.SslStream(Stream,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "初始化的新執行個體<xref href=&quot;System.Net.Security.SslStream&quot;></xref>類別使用指定<xref:System.IO.Stream>並串流終止行為。</xref:System.IO.Stream>"
  remarks: "當您指定`true`如`leaveStreamOpen`參數，關閉<xref:System.Net.Security.SslStream>沒有任何作用`innerStream`串流處理; 您必須明確地關閉`innerStream`當您不再需要該</xref:System.Net.Security.SslStream>       如果 encryptionpolicy，組態檔中未指定值<xref:System.Net.Security.EncryptionPolicy>預設為<xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName>如<xref:System.Net.Security.SslStream>建構的執行個體。</xref:System.Net.Security.SslStream> </xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName> </xref:System.Net.Security.EncryptionPolicy>       使用 Null 編碼器時，需要為<xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName>。</xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName>設定加密原則"
  example:
  - "The following code example demonstrates calling this constructor.  \n  \n [!code-cpp[NclSslServerSync#1](~/add/codesnippet/cpp/m-system.net.security.ss_5_1.cpp)]\n [!code-cs[NclSslServerSync#1](~/add/codesnippet/csharp/m-system.net.security.ss_5_1.cs)]"
  syntax:
    content: public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen);
    parameters:
    - id: innerStream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>物件所使用<xref href=&quot;System.Net.Security.SslStream&quot;></xref>來傳送和接收資料。</xref:System.IO.Stream>"
    - id: leaveInnerStreamOpen
      type: System.Boolean
      description: "布林值，表示終止行為<xref:System.IO.Stream>物件所使用<xref href=&quot;System.Net.Security.SslStream&quot;></xref>來傳送和接收資料。</xref:System.IO.Stream> 這個參數會指出是否內部資料流處於開啟狀態。"
  overload: System.Net.Security.SslStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>innerStream</code>為不可讀取。       -或-<code>innerStream</code>不是可寫入。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>innerStream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -<code>innerStream</code>等於<xref:System.IO.Stream.Null>。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback)
  id: '#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback)'
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: SslStream(Stream,Boolean,RemoteCertificateValidationCallback)
  nameWithType: SslStream.SslStream(Stream,Boolean,RemoteCertificateValidationCallback)
  fullName: System.Net.Security.SslStream.SslStream(Stream,Boolean,RemoteCertificateValidationCallback)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "初始化的新執行個體<xref href=&quot;System.Net.Security.SslStream&quot;></xref>類別使用指定<xref:System.IO.Stream>、 資料流關閉行為和憑證驗證委派。</xref:System.IO.Stream>"
  remarks: "當您指定`true`如`leaveStreamOpen`參數，關閉<xref:System.Net.Security.SslStream>沒有任何作用`innerStream`串流處理; 您必須明確地關閉`innerStream`當您不再需要該</xref:System.Net.Security.SslStream>       `userCertificateValidationCallback`代理人`certificateErrors`引數包含通道安全性支援提供者介面 (SSPI) 所傳回的任何 Windows 錯誤碼。 叫用之方法的傳回值`userCertificateValidationCallback`委派可讓您判斷驗證是否成功。       安全性通訊協定和密碼編譯演算法已時選取`userCertificateValidationCallback`叫用委派的方法。 您可以使用此方法來判斷是否滿足您的應用程式選取密碼編譯演算法和優點。 如果不是，這個方法應傳回`false`防止<xref:System.Net.Security.SslStream>建立。</xref:System.Net.Security.SslStream>       如果 encryptionpolicy，組態檔中未指定值<xref:System.Net.Security.EncryptionPolicy>預設為<xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName>如<xref:System.Net.Security.SslStream>建構的執行個體。</xref:System.Net.Security.SslStream> </xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName> </xref:System.Net.Security.EncryptionPolicy>       使用 Null 編碼器時，需要為<xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName>。</xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName>設定加密原則      > [!NOTE] > 的 Framework 它們建立時，會快取的 SSL 工作階段，並嘗試盡可能重複使用快取的工作階段為新的要求。 當嘗試重複使用的 SSL 工作階段，架構會使用第一個項目<xref:System.Net.HttpWebRequest.ClientCertificates%2A>（如果有一個），或嘗試重複使用匿名的工作階段，如果<xref:System.Net.HttpWebRequest.ClientCertificates%2A>是空的。</xref:System.Net.HttpWebRequest.ClientCertificates%2A> </xref:System.Net.HttpWebRequest.ClientCertificates%2A>      > [!NOTE] > 中的 SSL 版本 2 通訊協定不支援用戶端憑證。"
  example:
  - "The following code example creates an <xref:System.Net.Security.SslStream> and initiates the client portion of the authentication.  \n  \n [!code-cpp[NclSslClientSync#4](~/add/codesnippet/cpp/9eaa69b2-6619-41cf-8f97-_1.cpp)]\n [!code-cs[NclSslClientSync#4](~/add/codesnippet/csharp/9eaa69b2-6619-41cf-8f97-_1.cs)]"
  syntax:
    content: public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback);
    parameters:
    - id: innerStream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>物件所使用<xref href=&quot;System.Net.Security.SslStream&quot;></xref>來傳送和接收資料。</xref:System.IO.Stream>"
    - id: leaveInnerStreamOpen
      type: System.Boolean
      description: "布林值，表示終止行為<xref:System.IO.Stream>物件所使用<xref href=&quot;System.Net.Security.SslStream&quot;></xref>來傳送和接收資料。</xref:System.IO.Stream> 這個參數會指出是否內部資料流處於開啟狀態。"
    - id: userCertificateValidationCallback
      type: System.Net.Security.RemoteCertificateValidationCallback
      description: "A <xref href=&quot;System.Net.Security.RemoteCertificateValidationCallback&quot;> </xref>委派負責驗證遠端合作對象所提供的憑證。"
  overload: System.Net.Security.SslStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>innerStream</code>為不可讀取。       -或-<code>innerStream</code>不是可寫入。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>innerStream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -<code>innerStream</code>等於<xref:System.IO.Stream.Null>。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)
  id: '#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)'
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: SslStream(Stream,Boolean,RemoteCertificateValidationCallback,LocalCertificateSelectionCallback)
  nameWithType: SslStream.SslStream(Stream,Boolean,RemoteCertificateValidationCallback,LocalCertificateSelectionCallback)
  fullName: System.Net.Security.SslStream.SslStream(Stream,Boolean,RemoteCertificateValidationCallback,LocalCertificateSelectionCallback)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "初始化的新執行個體<xref href=&quot;System.Net.Security.SslStream&quot;></xref>類別使用指定<xref:System.IO.Stream>，串流處理終止行為、 憑證驗證委派與憑證的選取項目委派。</xref:System.IO.Stream>"
  remarks: "當您指定`true`如`leaveStreamOpen`參數，關閉<xref:System.Net.Security.SslStream>沒有任何作用`innerStream`串流處理; 您必須明確地關閉`innerStream`當您不再需要該</xref:System.Net.Security.SslStream>       `userCertificateValidationCallback`代理人`certificateErrors`引數包含通道安全性支援提供者介面 (SSPI) 所傳回的任何 Windows 錯誤碼。 叫用之方法的傳回值`userCertificateValidationCallback`委派可讓您判斷驗證是否成功。       安全性通訊協定和密碼編譯演算法已時選取`userCertificateValidationCallback`叫用委派的方法。 您可以使用此方法來判斷是否滿足您的應用程式選取密碼編譯演算法和優點。 如果不是，這個方法應傳回`false`防止<xref:System.Net.Security.SslStream>建立。</xref:System.Net.Security.SslStream>       `userCertificateSelectionCallback`委派在您的應用程式有多個憑證，而且必須以動態方式選擇憑證時相當實用。 在&quot;MY&quot;存放區中的憑證會傳遞至委派所叫用的方法。       如果 encryptionpolicy，組態檔中未指定值<xref:System.Net.Security.EncryptionPolicy>預設為<xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName>如<xref:System.Net.Security.SslStream>建構的執行個體。</xref:System.Net.Security.SslStream> </xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName> </xref:System.Net.Security.EncryptionPolicy>       使用 Null 編碼器時，需要為<xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName>。</xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName>設定加密原則      > [!NOTE] > 的 Framework 它們建立時，會快取的 SSL 工作階段，並嘗試盡可能重複使用快取的工作階段為新的要求。 嘗試重複使用的 SSL 工作階段，架構會使用第一個元素的 P:System.Net.HttpWebRequest.ClientCertificates （如果有的話），或嘗試重複使用匿名的工作階段，如果 P:System.Net.HttpWebRequest.ClientCertificates 是空的。"
  example:
  - "The following code example demonstrates calling this constructor. This example is part of a larger example provided for the <xref:System.Net.Security.SslStream> class.  \n  \n [!code-cpp[NclSslClientAsync#6](~/add/codesnippet/cpp/dc8fc9af-8c2a-4c30-be77-_1.cpp)]\n [!code-cs[NclSslClientAsync#6](~/add/codesnippet/csharp/dc8fc9af-8c2a-4c30-be77-_1.cs)]"
  syntax:
    content: public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback);
    parameters:
    - id: innerStream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>物件所使用<xref href=&quot;System.Net.Security.SslStream&quot;></xref>來傳送和接收資料。</xref:System.IO.Stream>"
    - id: leaveInnerStreamOpen
      type: System.Boolean
      description: "布林值，表示終止行為<xref:System.IO.Stream>物件所使用<xref href=&quot;System.Net.Security.SslStream&quot;></xref>來傳送和接收資料。</xref:System.IO.Stream> 這個參數會指出是否內部資料流處於開啟狀態。"
    - id: userCertificateValidationCallback
      type: System.Net.Security.RemoteCertificateValidationCallback
      description: "A <xref href=&quot;System.Net.Security.RemoteCertificateValidationCallback&quot;> </xref>委派負責驗證遠端合作對象所提供的憑證。"
    - id: userCertificateSelectionCallback
      type: System.Net.Security.LocalCertificateSelectionCallback
      description: "A <xref href=&quot;System.Net.Security.LocalCertificateSelectionCallback&quot;> </xref>委派負責選取用於驗證的憑證。"
  overload: System.Net.Security.SslStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>innerStream</code>為不可讀取。       -或-<code>innerStream</code>不是可寫入。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>innerStream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -<code>innerStream</code>等於<xref:System.IO.Stream.Null>。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback,System.Net.Security.EncryptionPolicy)
  id: '#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback,System.Net.Security.EncryptionPolicy)'
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: SslStream(Stream,Boolean,RemoteCertificateValidationCallback,LocalCertificateSelectionCallback,EncryptionPolicy)
  nameWithType: SslStream.SslStream(Stream,Boolean,RemoteCertificateValidationCallback,LocalCertificateSelectionCallback,EncryptionPolicy)
  fullName: System.Net.Security.SslStream.SslStream(Stream,Boolean,RemoteCertificateValidationCallback,LocalCertificateSelectionCallback,EncryptionPolicy)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "初始化的新執行個體<xref href=&quot;System.Net.Security.SslStream&quot;></xref>使用指定的類別<xref:System.IO.Stream></xref:System.IO.Stream>"
  remarks: "使用 Null 編碼器時，需要`encryptionPolicy`參數設定為<xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName>.</xref:System.Net.Security.EncryptionPolicy?displayProperty=fullName>"
  syntax:
    content: public SslStream (System.IO.Stream innerStream, bool leaveInnerStreamOpen, System.Net.Security.RemoteCertificateValidationCallback userCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback userCertificateSelectionCallback, System.Net.Security.EncryptionPolicy encryptionPolicy);
    parameters:
    - id: innerStream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>物件所使用<xref href=&quot;System.Net.Security.SslStream&quot;></xref>來傳送和接收資料。</xref:System.IO.Stream>"
    - id: leaveInnerStreamOpen
      type: System.Boolean
      description: "布林值，表示終止行為<xref:System.IO.Stream>物件所使用<xref href=&quot;System.Net.Security.SslStream&quot;></xref>來傳送和接收資料。</xref:System.IO.Stream> 這個參數會指出是否內部資料流處於開啟狀態。"
    - id: userCertificateValidationCallback
      type: System.Net.Security.RemoteCertificateValidationCallback
      description: "A <xref href=&quot;System.Net.Security.RemoteCertificateValidationCallback&quot;> </xref>委派負責驗證遠端合作對象所提供的憑證。"
    - id: userCertificateSelectionCallback
      type: System.Net.Security.LocalCertificateSelectionCallback
      description: "A <xref href=&quot;System.Net.Security.LocalCertificateSelectionCallback&quot;> </xref>委派負責選取用於驗證的憑證。"
    - id: encryptionPolicy
      type: System.Net.Security.EncryptionPolicy
      description: "The <xref href=&quot;System.Net.Security.EncryptionPolicy&quot;></xref> to use."
  overload: System.Net.Security.SslStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>innerStream</code>為不可讀取。       -或-<code>innerStream</code>不是可寫入。       -或-<code>encryptionPolicy</code>不正確。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>innerStream</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -<code>innerStream</code>等於<xref:System.IO.Stream.Null>。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.AuthenticateAsClient(System.String)
  id: AuthenticateAsClient(System.String)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: AuthenticateAsClient(String)
  nameWithType: SslStream.AuthenticateAsClient(String)
  fullName: System.Net.Security.SslStream.AuthenticateAsClient(String)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "用戶端驗證伺服器和 （選擇性） 中的用戶端伺服器連接的用戶端呼叫。"
  remarks: "這個方法會驗證使用<xref:System.Security.Authentication.SslProtocols>.</xref:System.Security.Authentication.SslProtocols> 任何用戶端憑證不用於驗證。 在驗證期間，不會檢查憑證撤銷清單。 指定的值`targetHost`必須符合伺服器憑證的名稱。       當驗證成功時，您必須檢查<xref:System.Net.Security.SslStream.IsEncrypted%2A>與<xref:System.Net.Security.SslStream.IsSigned%2A>屬性，以判斷有哪些安全性服務由<xref:System.Net.Security.SslStream>.</xref:System.Net.Security.SslStream> </xref:System.Net.Security.SslStream.IsSigned%2A> </xref:System.Net.Security.SslStream.IsEncrypted%2A> 請檢查<xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>屬性來判斷是否發生過相互驗證。</xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>       如果驗證失敗時，您會收到<xref:System.Security.Authentication.AuthenticationException>，而這<xref:System.Net.Security.SslStream>是無法再使用。</xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。"
  syntax:
    content: public virtual void AuthenticateAsClient (string targetHost);
    parameters:
    - id: targetHost
      type: System.String
      description: "此共用的伺服器名稱<xref href=&quot;System.Net.Security.SslStream&quot;> </xref>。"
  overload: System.Net.Security.SslStream.AuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetHost</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "驗證失敗，此物件處於不穩定的狀態。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已經發生驗證。       -或-使用這項功能的伺服器驗證<xref href=&quot;System.Net.Security.SslStream&quot;></xref>先前已經嘗試。       -或者-驗證已在進行中。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)
  id: AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: AuthenticateAsClient(String,X509CertificateCollection,SslProtocols,Boolean)
  nameWithType: SslStream.AuthenticateAsClient(String,X509CertificateCollection,SslProtocols,Boolean)
  fullName: System.Net.Security.SslStream.AuthenticateAsClient(String,X509CertificateCollection,SslProtocols,Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "用戶端驗證伺服器和 （選擇性） 中的用戶端伺服器連接的用戶端呼叫。 在驗證程序會使用指定的憑證集合和 SSL 通訊協定。"
  remarks: "當驗證成功時，您必須檢查<xref:System.Net.Security.SslStream.IsEncrypted%2A>與<xref:System.Net.Security.SslStream.IsSigned%2A>屬性，以判斷有哪些安全性服務由<xref:System.Net.Security.SslStream>.</xref:System.Net.Security.SslStream> </xref:System.Net.Security.SslStream.IsSigned%2A> </xref:System.Net.Security.SslStream.IsEncrypted%2A> 請檢查<xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>屬性來判斷是否發生過相互驗證。</xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>       如果驗證失敗時，您會收到<xref:System.Security.Authentication.AuthenticationException>，而這<xref:System.Net.Security.SslStream>是無法再使用。</xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。      > [!NOTE] > 中的 SSL 版本 2 通訊協定不支援用戶端憑證。"
  syntax:
    content: public virtual void AuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    parameters:
    - id: targetHost
      type: System.String
      description: "此共用的伺服器名稱<xref href=&quot;System.Net.Security.SslStream&quot;> </xref>。"
    - id: clientCertificates
      type: System.Security.Cryptography.X509Certificates.X509CertificateCollection
      description: "<xref href=&quot;System.Security.Cryptography.X509Certificates.X509CertificateCollection&quot;> </xref> ，其中包含用戶端憑證。"
    - id: enabledSslProtocols
      type: System.Security.Authentication.SslProtocols
      description: "<xref:System.Security.Authentication.SslProtocols>值，表示用於驗證的通訊協定。</xref:System.Security.Authentication.SslProtocols>"
    - id: checkCertificateRevocation
      type: System.Boolean
      description: "A<xref:System.Boolean>值，指定是否在驗證期間檢查憑證撤銷清單。</xref:System.Boolean>"
  overload: System.Net.Security.SslStream.AuthenticateAsClient*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String)
  id: AuthenticateAsClientAsync(System.String)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: AuthenticateAsClientAsync(String)
  nameWithType: SslStream.AuthenticateAsClientAsync(String)
  fullName: System.Net.Security.SslStream.AuthenticateAsClientAsync(String)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "用戶端驗證伺服器和 （選擇性） 中以非同步作業的用戶端伺服器連接的用戶端呼叫。"
  remarks: "這個方法會驗證使用<xref:System.Security.Authentication.SslProtocols>.</xref:System.Security.Authentication.SslProtocols> 任何用戶端憑證不用於驗證。 在驗證期間，不會檢查憑證撤銷清單。 指定的值`targetHost`必須符合伺服器憑證的名稱。       當驗證成功時，您必須檢查<xref:System.Net.Security.SslStream.IsEncrypted%2A>與<xref:System.Net.Security.SslStream.IsSigned%2A>屬性，以判斷有哪些安全性服務由<xref:System.Net.Security.SslStream>.</xref:System.Net.Security.SslStream> </xref:System.Net.Security.SslStream.IsSigned%2A> </xref:System.Net.Security.SslStream.IsEncrypted%2A> 請檢查<xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>屬性來判斷是否發生過相互驗證。</xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>       如果驗證失敗時，您會收到<xref:System.Security.Authentication.AuthenticationException>，而這<xref:System.Net.Security.SslStream>是無法再使用。</xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost);
    parameters:
    - id: targetHost
      type: System.String
      description: "此共用的伺服器名稱<xref href=&quot;System.Net.Security.SslStream&quot;> </xref>。"
    return:
      type: System.Threading.Tasks.Task
      description: "傳回<xref:System.Threading.Tasks.Task>工作物件，表示非同步作業。</xref:System.Threading.Tasks.Task>"
  overload: System.Net.Security.SslStream.AuthenticateAsClientAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetHost</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "驗證失敗，此物件處於不穩定的狀態。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已經發生驗證。       -或-使用這項功能的伺服器驗證<xref href=&quot;System.Net.Security.SslStream&quot;></xref>先前已經嘗試。       -或者-驗證已在進行中。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)
  id: AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: AuthenticateAsClientAsync(String,X509CertificateCollection,SslProtocols,Boolean)
  nameWithType: SslStream.AuthenticateAsClientAsync(String,X509CertificateCollection,SslProtocols,Boolean)
  fullName: System.Net.Security.SslStream.AuthenticateAsClientAsync(String,X509CertificateCollection,SslProtocols,Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "用戶端驗證伺服器和 （選擇性） 中以非同步作業的用戶端伺服器連接的用戶端呼叫。 在驗證程序會使用指定的憑證集合和 SSL 通訊協定。"
  remarks: "當驗證成功時，您必須檢查<xref:System.Net.Security.SslStream.IsEncrypted%2A>與<xref:System.Net.Security.SslStream.IsSigned%2A>屬性，以判斷有哪些安全性服務由<xref:System.Net.Security.SslStream>.</xref:System.Net.Security.SslStream> </xref:System.Net.Security.SslStream.IsSigned%2A> </xref:System.Net.Security.SslStream.IsEncrypted%2A> 請檢查<xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>屬性來判斷是否發生過相互驗證。</xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>       如果驗證失敗時，您會收到<xref:System.Security.Authentication.AuthenticationException>，而這<xref:System.Net.Security.SslStream>是無法再使用。</xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。      > [!NOTE] > 中的 SSL 版本 2 通訊協定不支援用戶端憑證。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsClientAsync (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    parameters:
    - id: targetHost
      type: System.String
      description: "此共用的伺服器名稱<xref href=&quot;System.Net.Security.SslStream&quot;> </xref>。"
    - id: clientCertificates
      type: System.Security.Cryptography.X509Certificates.X509CertificateCollection
      description: "<xref href=&quot;System.Security.Cryptography.X509Certificates.X509CertificateCollection&quot;> </xref> ，其中包含用戶端憑證。"
    - id: enabledSslProtocols
      type: System.Security.Authentication.SslProtocols
      description: "<xref:System.Security.Authentication.SslProtocols>值，表示用於驗證的通訊協定。</xref:System.Security.Authentication.SslProtocols>"
    - id: checkCertificateRevocation
      type: System.Boolean
      description: "A<xref:System.Boolean>值，指定是否在驗證期間檢查憑證撤銷清單。</xref:System.Boolean>"
    return:
      type: System.Threading.Tasks.Task
      description: "傳回<xref:System.Threading.Tasks.Task>工作物件，表示非同步作業。</xref:System.Threading.Tasks.Task>"
  overload: System.Net.Security.SslStream.AuthenticateAsClientAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)
  id: AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: AuthenticateAsServer(X509Certificate)
  nameWithType: SslStream.AuthenticateAsServer(X509Certificate)
  fullName: System.Net.Security.SslStream.AuthenticateAsServer(X509Certificate)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "呼叫伺服器來驗證伺服器與 （選擇性） 中使用指定的憑證的用戶端伺服器連接的用戶端。"
  remarks: "這個方法會驗證使用<xref:System.Security.Authentication.SslProtocols>.</xref:System.Security.Authentication.SslProtocols> 在驗證期間，不會檢查憑證撤銷清單。 用戶端不是需要提供憑證進行驗證。       這個方法會封鎖直到作業完成為止。 若要防止封鎖直到作業完成為止，使用其中一種<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法多載。</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>       如果驗證失敗時，您會收到<xref:System.Security.Authentication.AuthenticationException>，而這<xref:System.Net.Security.SslStream>是無法再使用。</xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。"
  syntax:
    content: public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);
    parameters:
    - id: serverCertificate
      type: System.Security.Cryptography.X509Certificates.X509Certificate
      description: "用來驗證伺服器憑證。"
  overload: System.Net.Security.SslStream.AuthenticateAsServer*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>serverCertificate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "驗證失敗，此物件處於不穩定的狀態。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已經發生驗證。       -或-使用這項功能的用戶端驗證<xref href=&quot;System.Net.Security.SslStream&quot;></xref>先前已經嘗試。       -或者-驗證已在進行中。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref:System.Net.Security.SslStream.AuthenticateAsServer*>方法不支援 Windows 95、 Windows 98 或 Windows Millennium。</xref:System.Net.Security.SslStream.AuthenticateAsServer*>"
  platform:
  - net462
- uid: System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)
  id: AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: AuthenticateAsServer(X509Certificate,Boolean,SslProtocols,Boolean)
  nameWithType: SslStream.AuthenticateAsServer(X509Certificate,Boolean,SslProtocols,Boolean)
  fullName: System.Net.Security.SslStream.AuthenticateAsServer(X509Certificate,Boolean,SslProtocols,Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "呼叫伺服器來驗證伺服器與 （選擇性） 中使用指定的憑證、 需求和安全性通訊協定的用戶端伺服器連接的用戶端。"
  remarks: "這個方法會封鎖直到作業完成為止。 若要防止封鎖直到作業完成為止，使用其中一種<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法多載。</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>       如果驗證失敗時，您會收到<xref:System.Security.Authentication.AuthenticationException>，而這<xref:System.Net.Security.SslStream>是無法再使用。</xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。"
  syntax:
    content: public virtual void AuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    parameters:
    - id: serverCertificate
      type: System.Security.Cryptography.X509Certificates.X509Certificate
      description: "在 X509Certificate 用來驗證伺服器。"
    - id: clientCertificateRequired
      type: System.Boolean
      description: "A<xref:System.Boolean>值，指定是否要求憑證，以進行驗證的用戶端。</xref:System.Boolean> 請注意，這只是要求-如果沒有憑證提供伺服器仍然接受連接要求。"
    - id: enabledSslProtocols
      type: System.Security.Authentication.SslProtocols
      description: "<xref:System.Security.Authentication.SslProtocols>值，表示用於驗證的通訊協定。</xref:System.Security.Authentication.SslProtocols>"
    - id: checkCertificateRevocation
      type: System.Boolean
      description: "A<xref:System.Boolean>值，指定是否在驗證期間檢查憑證撤銷清單。</xref:System.Boolean>"
  overload: System.Net.Security.SslStream.AuthenticateAsServer*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>serverCertificate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>enabledSslProtocols</code>不是有效<xref:System.Security.Authentication.SslProtocols>值。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "驗證失敗，此物件處於不穩定的狀態。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已經發生驗證。       -或-使用這項功能的用戶端驗證<xref href=&quot;System.Net.Security.SslStream&quot;></xref>先前已經嘗試。       -或者-驗證已在進行中。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref:System.Net.Security.SslStream.AuthenticateAsServer*>方法不支援 Windows 95、 Windows 98 或 Windows Millennium。</xref:System.Net.Security.SslStream.AuthenticateAsServer*>"
  platform:
  - net462
- uid: System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)
  id: AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: AuthenticateAsServerAsync(X509Certificate)
  nameWithType: SslStream.AuthenticateAsServerAsync(X509Certificate)
  fullName: System.Net.Security.SslStream.AuthenticateAsServerAsync(X509Certificate)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "呼叫伺服器來驗證伺服器與 （選擇性） 中使用指定的憑證，以非同步作業的用戶端伺服器連接的用戶端。"
  remarks: "這個方法會驗證使用<xref:System.Security.Authentication.SslProtocols>.</xref:System.Security.Authentication.SslProtocols> 在驗證期間，不會檢查憑證撤銷清單。 用戶端不是需要提供憑證進行驗證。       如果驗證失敗時，您會收到<xref:System.Security.Authentication.AuthenticationException>，而這<xref:System.Net.Security.SslStream>是無法再使用。</xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate);
    parameters:
    - id: serverCertificate
      type: System.Security.Cryptography.X509Certificates.X509Certificate
      description: "用來驗證伺服器憑證。"
    return:
      type: System.Threading.Tasks.Task
      description: "傳回<xref:System.Threading.Tasks.Task>工作物件，表示非同步作業。</xref:System.Threading.Tasks.Task>"
  overload: System.Net.Security.SslStream.AuthenticateAsServerAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>serverCertificate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "驗證失敗，此物件處於不穩定的狀態。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已經發生驗證。       -或-使用這項功能的用戶端驗證<xref href=&quot;System.Net.Security.SslStream&quot;></xref>先前已經嘗試。       -或者-驗證已在進行中。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref:System.Net.Security.SslStream.AuthenticateAsServerAsync*>方法不支援 Windows 95、 Windows 98 或 Windows Millennium。</xref:System.Net.Security.SslStream.AuthenticateAsServerAsync*>"
  platform:
  - net462
- uid: System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)
  id: AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: AuthenticateAsServerAsync(X509Certificate,Boolean,SslProtocols,Boolean)
  nameWithType: SslStream.AuthenticateAsServerAsync(X509Certificate,Boolean,SslProtocols,Boolean)
  fullName: System.Net.Security.SslStream.AuthenticateAsServerAsync(X509Certificate,Boolean,SslProtocols,Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "呼叫伺服器來驗證伺服器與 （選擇性） 中使用指定的憑證、 需求和安全性通訊協定，以非同步作業的用戶端伺服器連接的用戶端。"
  remarks: "如果驗證失敗時，您會收到<xref:System.Security.Authentication.AuthenticationException>，而這<xref:System.Net.Security.SslStream>是無法再使用。</xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。"
  syntax:
    content: public virtual System.Threading.Tasks.Task AuthenticateAsServerAsync (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    parameters:
    - id: serverCertificate
      type: System.Security.Cryptography.X509Certificates.X509Certificate
      description: "在 X509Certificate 用來驗證伺服器。"
    - id: clientCertificateRequired
      type: System.Boolean
      description: "A<xref:System.Boolean>值，指定是否要求憑證，以進行驗證的用戶端。</xref:System.Boolean> 請注意，這只是要求-如果沒有憑證提供伺服器仍然接受連接要求。"
    - id: enabledSslProtocols
      type: System.Security.Authentication.SslProtocols
      description: "<xref:System.Security.Authentication.SslProtocols>值，表示用於驗證的通訊協定。</xref:System.Security.Authentication.SslProtocols>"
    - id: checkCertificateRevocation
      type: System.Boolean
      description: "A<xref:System.Boolean>值，指定是否在驗證期間檢查憑證撤銷清單。</xref:System.Boolean>"
    return:
      type: System.Threading.Tasks.Task
      description: "傳回<xref:System.Threading.Tasks.Task>工作物件，表示非同步作業。</xref:System.Threading.Tasks.Task>"
  overload: System.Net.Security.SslStream.AuthenticateAsServerAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: BeginAuthenticateAsClient(String,AsyncCallback,Object)
  nameWithType: SslStream.BeginAuthenticateAsClient(String,AsyncCallback,Object)
  fullName: System.Net.Security.SslStream.BeginAuthenticateAsClient(String,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "開始非同步作業，來驗證伺服器的用戶端和 （選擇性） 用戶端呼叫。"
  remarks: "這個方法會驗證使用<xref:System.Security.Authentication.SslProtocols>.</xref:System.Security.Authentication.SslProtocols> 任何用戶端憑證不用於驗證。 在驗證期間，不會檢查憑證撤銷清單。       指定的值`targetHost`必須符合伺服器憑證的名稱。       完成非同步的驗證作業，藉由呼叫<xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A>方法。</xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> 一般而言，方法由叫用`asyncCallback`委派。       在作業完成時，這個方法不會封鎖。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>方法多載。</xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>       如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/add/includes/ajax-current-ext-md.md)如果您收到<xref:System.Security.Authentication.AuthenticationException>，這個<xref:System.Net.Security.SslStream>是無法再使用。</xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: targetHost
      type: System.String
      description: "此共用的伺服器名稱<xref href=&quot;System.Net.Security.SslStream&quot;> </xref>。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>委派，參考要叫用驗證完成時的方法。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "使用者定義的物件，其中包含作業的相關資訊。 這個物件傳遞至`asyncCallback`委派作業完成時。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>物件，表示非同步作業的狀態。</xref:System.IAsyncResult>"
  overload: System.Net.Security.SslStream.BeginAuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetHost</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "驗證失敗，此物件處於不穩定的狀態。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已經發生驗證。       -或-使用這項功能的伺服器驗證<xref href=&quot;System.Net.Security.SslStream&quot;></xref>先前已經嘗試。       -或者-驗證已在進行中。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: BeginAuthenticateAsClient(String,X509CertificateCollection,SslProtocols,Boolean,AsyncCallback,Object)
  nameWithType: SslStream.BeginAuthenticateAsClient(String,X509CertificateCollection,SslProtocols,Boolean,AsyncCallback,Object)
  fullName: System.Net.Security.SslStream.BeginAuthenticateAsClient(String,X509CertificateCollection,SslProtocols,Boolean,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "開始非同步作業，來驗證伺服器的用戶端和選擇性地使用指定的憑證和安全性通訊協定的用戶端呼叫。"
  remarks: "指定的值`targetHost`必須符合伺服器憑證的名稱。       完成非同步的驗證作業，藉由呼叫<xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A>方法。</xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> 一般而言，方法由叫用`asyncCallback`委派。       在作業完成時，這個方法不會封鎖。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>方法多載。</xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>       如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/add/includes/ajax-current-ext-md.md)如果您收到<xref:System.Security.Authentication.AuthenticationException>，這個<xref:System.Net.Security.SslStream>是無法再使用。</xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。      > [!NOTE] > 中的 SSL 版本 2 通訊協定不支援用戶端憑證。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsClient (string targetHost, System.Security.Cryptography.X509Certificates.X509CertificateCollection clientCertificates, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: targetHost
      type: System.String
      description: "此共用的伺服器名稱<xref href=&quot;System.Net.Security.SslStream&quot;> </xref>。"
    - id: clientCertificates
      type: System.Security.Cryptography.X509Certificates.X509CertificateCollection
      description: "<xref href=&quot;System.Security.Cryptography.X509Certificates.X509CertificateCollection&quot;> </xref>包含 用戶端憑證。"
    - id: enabledSslProtocols
      type: System.Security.Authentication.SslProtocols
      description: "<xref:System.Security.Authentication.SslProtocols>值，表示用於驗證的通訊協定。</xref:System.Security.Authentication.SslProtocols>"
    - id: checkCertificateRevocation
      type: System.Boolean
      description: "A<xref:System.Boolean>值，指定是否在驗證期間檢查憑證撤銷清單。</xref:System.Boolean>"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>委派，參考要叫用驗證完成時的方法。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "使用者定義的物件，其中包含作業的相關資訊。 這個物件傳遞至`asyncCallback`委派作業完成時。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>物件，表示非同步作業的狀態。</xref:System.IAsyncResult>"
  overload: System.Net.Security.SslStream.BeginAuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>targetHost</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>enabledSslProtocols</code>不是有效<xref:System.Security.Authentication.SslProtocols>值。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "驗證失敗，此物件處於不穩定的狀態。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已經發生驗證。       -或-使用這項功能的伺服器驗證<xref href=&quot;System.Net.Security.SslStream&quot;></xref>先前已經嘗試。       -或者-驗證已在進行中。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: BeginAuthenticateAsServer(X509Certificate,AsyncCallback,Object)
  nameWithType: SslStream.BeginAuthenticateAsServer(X509Certificate,AsyncCallback,Object)
  fullName: System.Net.Security.SslStream.BeginAuthenticateAsServer(X509Certificate,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "呼叫伺服器，開始非同步作業以驗證用戶端也可以在用戶端伺服器連接的伺服器。"
  remarks: "這個方法會驗證使用<xref:System.Security.Authentication.SslProtocols>.</xref:System.Security.Authentication.SslProtocols> 在驗證期間，不會檢查憑證撤銷清單。 用戶端不是需要提供憑證進行驗證。       完成非同步的驗證作業，藉由呼叫<xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A>方法。</xref:System.Net.Security.SslStream.EndAuthenticateAsClient%2A> 一般而言，方法由叫用`asyncCallback`委派。       在作業完成時，這個方法不會封鎖。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>方法多載。</xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>       如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/add/includes/ajax-current-ext-md.md)如果您收到<xref:System.Security.Authentication.AuthenticationException>，這個<xref:System.Net.Security.SslStream>是無法再使用。</xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: serverCertificate
      type: System.Security.Cryptography.X509Certificates.X509Certificate
      description: "在 X509Certificate 用來驗證伺服器。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>委派，參考要叫用驗證完成時的方法。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "使用者定義的物件，其中包含作業的相關資訊。 這個物件傳遞至`asyncCallback`委派作業完成時。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>物件，表示非同步作業的狀態。</xref:System.IAsyncResult>"
  overload: System.Net.Security.SslStream.BeginAuthenticateAsServer*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>serverCertificate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "驗證失敗，此物件處於不穩定的狀態。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已經發生驗證。       -或-使用這項功能的用戶端驗證<xref href=&quot;System.Net.Security.SslStream&quot;></xref>先前已經嘗試。       -或者-驗證已在進行中。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer*>方法不支援 Windows 95、 Windows 98 或 Windows Millennium。</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer*>"
  platform:
  - net462
- uid: System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)
  id: BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: BeginAuthenticateAsServer(X509Certificate,Boolean,SslProtocols,Boolean,AsyncCallback,Object)
  nameWithType: SslStream.BeginAuthenticateAsServer(X509Certificate,Boolean,SslProtocols,Boolean,AsyncCallback,Object)
  fullName: System.Net.Security.SslStream.BeginAuthenticateAsServer(X509Certificate,Boolean,SslProtocols,Boolean,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "由 [伺服器]，開始非同步作業以驗證伺服器與 （選擇性） 使用指定的憑證、 需求和安全性通訊協定的用戶端呼叫。"
  remarks: "完成非同步的驗證作業，藉由呼叫<xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A>方法。</xref:System.Net.Security.SslStream.EndAuthenticateAsServer%2A> 一般而言，方法由叫用`asyncCallback`委派。       在作業完成時，這個方法不會封鎖。 若要封鎖直到作業完成為止，使用其中一種<xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>方法多載。</xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>       如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/add/includes/ajax-current-ext-md.md)如果您收到<xref:System.Security.Authentication.AuthenticationException>，這個<xref:System.Net.Security.SslStream>是無法再使用。</xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。"
  syntax:
    content: public virtual IAsyncResult BeginAuthenticateAsServer (System.Security.Cryptography.X509Certificates.X509Certificate serverCertificate, bool clientCertificateRequired, System.Security.Authentication.SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: serverCertificate
      type: System.Security.Cryptography.X509Certificates.X509Certificate
      description: "在 X509Certificate 用來驗證伺服器。"
    - id: clientCertificateRequired
      type: System.Boolean
      description: "A<xref:System.Boolean>值，指定是否要求憑證，以進行驗證的用戶端。</xref:System.Boolean> 請注意，這只是要求-如果沒有憑證提供伺服器仍然接受連接要求。"
    - id: enabledSslProtocols
      type: System.Security.Authentication.SslProtocols
      description: "<xref:System.Security.Authentication.SslProtocols>值，表示用於驗證的通訊協定。</xref:System.Security.Authentication.SslProtocols>"
    - id: checkCertificateRevocation
      type: System.Boolean
      description: "A<xref:System.Boolean>值，指定是否在驗證期間檢查憑證撤銷清單。</xref:System.Boolean>"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>委派，參考要叫用驗證完成時的方法。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "使用者定義的物件，其中包含作業的相關資訊。 這個物件傳遞至`asyncCallback`委派作業完成時。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>物件，表示非同步作業的狀態。</xref:System.IAsyncResult>"
  overload: System.Net.Security.SslStream.BeginAuthenticateAsServer*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>serverCertificate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>enabledSslProtocols</code>不是有效<xref:System.Security.Authentication.SslProtocols>值。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "驗證失敗，此物件處於不穩定的狀態。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已經發生驗證。       -或-使用這項功能的伺服器驗證<xref href=&quot;System.Net.Security.SslStream&quot;></xref>先前已經嘗試。       -或者-驗證已在進行中。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer*>方法不支援 Windows 95、 Windows 98 或 Windows Millennium。</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer*>"
  platform:
  - net462
- uid: System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: SslStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Security.SslStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "開始非同步讀取的作業會從資料流讀取資料，並將它儲存在指定的陣列。"
  remarks: "如果已啟用加密，或簽章，讀取的作業會從基礎資料流讀取資料、 檢查資料完整性及/或加以解密。 非同步讀取的作業必須完成呼叫<xref:System.Net.Security.SslStream.EndRead%2A>方法。</xref:System.Net.Security.SslStream.EndRead%2A> 一般而言，方法由叫用`asyncCallback`委派。       在作業完成時，這個方法不會封鎖。 若要封鎖的作業完成之前，請使用<xref:System.Net.Security.SslStream.Read%2A>方法。</xref:System.Net.Security.SslStream.Read%2A>       如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/add/includes/ajax-current-ext-md.md)<xref:System.Net.Security.SslStream>類別不支援多個同時進行讀取作業。</xref:System.Net.Security.SslStream>       已成功驗證之前，無法呼叫此方法。 若要驗證的呼叫其中一個<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>，或<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>，<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>"
  example:
  - "The following code example demonstrates starting an asynchronous read operation.  \n  \n [!code-cpp[NclSslClientAsync#8](~/add/codesnippet/cpp/97989688-3a5b-49ee-9639-_1.cpp)]\n [!code-cs[NclSslClientAsync#8](~/add/codesnippet/csharp/97989688-3a5b-49ee-9639-_1.cs)]  \n  \n [!code-cpp[NclSslClientAsync#4](~/add/codesnippet/cpp/97989688-3a5b-49ee-9639-_2.cpp)]\n [!code-cs[NclSslClientAsync#4](~/add/codesnippet/csharp/97989688-3a5b-49ee-9639-_2.cs)]  \n  \n The following method is called when the read completes.  \n  \n [!code-cpp[NclSslClientAsync#5](~/add/codesnippet/cpp/97989688-3a5b-49ee-9639-_3.cpp)]\n [!code-cs[NclSslClientAsync#5](~/add/codesnippet/csharp/97989688-3a5b-49ee-9639-_3.cs)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A<xref:System.Byte>接收位元組的陣列讀取資料流。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "中以零為起始的位置`buffer`中要開始將資料儲存讀取自這個資料流。"
    - id: count
      type: System.Int32
      description: "要從資料流讀取的位元組數目上限。"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>參考讀取的作業完成時叫用方法的委派。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "使用者定義的物件，包含讀取作業的相關資訊。 這個物件傳遞至`asyncCallback`委派作業完成時。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>物件，表示非同步作業的狀態。</xref:System.IAsyncResult>"
  overload: System.Net.Security.SslStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>     <code>&lt;</code>     <code>0</code>.       <code>-or-</code><code>offset</code>&gt;長度<code>buffer</code>。       -or-       <code>offset</code> + count &gt; the length of <code>buffer</code>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "讀取的作業失敗。       -或-加密正在使用中，但無法解密資料。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "已經有進行中的讀取的作業。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "驗證不會發生。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: SslStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Security.SslStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "開始非同步寫入作業，寫入<xref:System.Byte>s 從指定的緩衝區資料流。</xref:System.Byte>"
  remarks: ''
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[NclSslServerAsync#5](~/add/codesnippet/csharp/7192cc61-a256-4249-aafa-_1.cs)]\n [!code-cpp[NclSslServerAsync#5](~/add/codesnippet/cpp/7192cc61-a256-4249-aafa-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A <xref:System.Byte>，提供要寫入資料流的位元組陣列。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "中以零為起始的位置`buffer`中要開始讀取的位元組寫入資料流。"
    - id: count
      type: System.Int32
      description: "<xref:System.Int32>值，指定要讀取的位元組數目`buffer`。</xref:System.Int32>"
    - id: asyncCallback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>參考寫入作業已完成時要叫用方法的委派。</xref:System.AsyncCallback>"
    - id: asyncState
      type: System.Object
      description: "使用者定義的物件，包含寫入作業的相關資訊。 這個物件傳遞至`asyncCallback`委派作業完成時。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>物件，表示非同步作業的狀態。</xref:System.IAsyncResult>"
  overload: System.Net.Security.SslStream.BeginWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>     <code>&lt;</code>     <code>0</code>.       <code>-or-</code><code>offset</code>&gt;長度<code>buffer</code>。       -or-       <code>offset</code> + count &gt; the length of <code>buffer</code>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入作業失敗。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "已經有進行中的寫入作業。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "驗證不會發生。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.CanRead
  id: CanRead
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: CanRead
  nameWithType: SslStream.CanRead
  fullName: System.Net.Security.SslStream.CanRead
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得<xref:System.Boolean>值，指出是否可讀取基礎資料流。</xref:System.Boolean>"
  remarks: "如果驗證成功，這個屬性會傳回所叫用傳回的值<xref:System.IO.Stream.CanRead%2A>在基礎資料流。</xref:System.IO.Stream.CanRead%2A>       當您建立的<xref:System.Net.Security.SslStream>類別</xref:System.Net.Security.SslStream>執行個體時，指定基礎資料流"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cpp[NclSslServerSync#5](~/add/codesnippet/cpp/p-system.net.security.ss_14_1.cpp)]\n [!code-cs[NclSslServerSync#5](~/add/codesnippet/csharp/p-system.net.security.ss_14_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果發生驗證，而且基礎資料流可讀取;否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.SslStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.CanSeek
  id: CanSeek
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: SslStream.CanSeek
  fullName: System.Net.Security.SslStream.CanSeek
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得<xref:System.Boolean>值，指出是否為可搜尋的基礎資料流。</xref:System.Boolean>"
  remarks: "請勿嘗試設定的位置<xref:System.Net.Security.SslStream>物件或其基礎資料流。</xref:System.Net.Security.SslStream>       當您建立的<xref:System.Net.Security.SslStream>類別</xref:System.Net.Security.SslStream>執行個體時，指定基礎資料流"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "這個屬性永遠傳回<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.SslStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.CanTimeout
  id: CanTimeout
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: CanTimeout
  nameWithType: SslStream.CanTimeout
  fullName: System.Net.Security.SslStream.CanTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得<xref:System.Boolean>值，指出基礎資料流是否支援逾時。</xref:System.Boolean>"
  remarks: "這個屬性會傳回所叫用傳回的值<xref:System.IO.Stream.CanTimeout%2A>在基礎資料流。</xref:System.IO.Stream.CanTimeout%2A>       當您建立的<xref:System.Net.Security.SslStream>類別</xref:System.Net.Security.SslStream>執行個體時，指定基礎資料流"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cpp[NclSslServerSync#5](~/add/codesnippet/cpp/p-system.net.security.ss_8_1.cpp)]\n [!code-cs[NclSslServerSync#5](~/add/codesnippet/csharp/p-system.net.security.ss_8_1.cs)]"
  syntax:
    content: public override bool CanTimeout { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果基礎資料流支援逾時。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.SslStream.CanTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.CanWrite
  id: CanWrite
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: SslStream.CanWrite
  fullName: System.Net.Security.SslStream.CanWrite
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得<xref:System.Boolean>值，指出是否可寫入基礎資料流。</xref:System.Boolean>"
  remarks: "如果驗證成功，這個屬性會傳回所叫用傳回的值<xref:System.IO.Stream.CanWrite%2A>在基礎資料流。</xref:System.IO.Stream.CanWrite%2A>       當您建立的<xref:System.Net.Security.SslStream>類別</xref:System.Net.Security.SslStream>執行個體時，指定基礎資料流"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cpp[NclSslServerSync#5](~/add/codesnippet/cpp/p-system.net.security.ss_17_1.cpp)]\n [!code-cs[NclSslServerSync#5](~/add/codesnippet/csharp/p-system.net.security.ss_17_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果發生驗證，並且基礎資料流為可寫入;否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.SslStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.CheckCertRevocationStatus
  id: CheckCertRevocationStatus
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: CheckCertRevocationStatus
  nameWithType: SslStream.CheckCertRevocationStatus
  fullName: System.Net.Security.SslStream.CheckCertRevocationStatus
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得<xref:System.Boolean>值，指出是否要將憑證撤銷清單檢查憑證的驗證程序期間。</xref:System.Boolean>"
  remarks: "憑證撤銷清單會包含簽發者已撤銷的憑證。 檢查清單產生負面效能影響，但可改善應用程式的安全性。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cpp[NclSslServerSync#5](~/add/codesnippet/cpp/p-system.net.security.ss_4_1.cpp)]\n [!code-cs[NclSslServerSync#5](~/add/codesnippet/csharp/p-system.net.security.ss_4_1.cs)]"
  syntax:
    content: public virtual bool CheckCertRevocationStatus { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果檢查憑證撤銷清單。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.SslStream.CheckCertRevocationStatus*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.CipherAlgorithm
  id: CipherAlgorithm
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: CipherAlgorithm
  nameWithType: SslStream.CipherAlgorithm
  fullName: System.Net.Security.SslStream.CipherAlgorithm
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得值，識別所使用的大量加密演算法<xref href=&quot;System.Net.Security.SslStream&quot;> </xref>。"
  remarks: "值為<xref:System.Security.Authentication.CipherAlgorithmType>CipherAlgorithm 屬性時<xref:System.Net.Security.EncryptionPolicy>列舉值用來建構<xref:System.Net.Security.SslStream>執行個體。</xref:System.Net.Security.SslStream> </xref:System.Net.Security.EncryptionPolicy> </xref:System.Security.Authentication.CipherAlgorithmType>       [!INCLUDE[winxpsvr](~/add/includes/winxpsvr-md.md)]和[!INCLUDE[winxp](~/add/includes/winxp-md.md)]不支援<xref:System.Security.Authentication.CipherAlgorithmType>值。</xref:System.Security.Authentication.CipherAlgorithmType> 因此，即使<xref:System.Security.Authentication.CipherAlgorithmType>值用來建構的<xref:System.Net.Security.SslStream>執行個體、<xref:System.Net.Security.EncryptionPolicy>將<xref:System.Security.Authentication.CipherAlgorithmType>.</xref:System.Security.Authentication.CipherAlgorithmType>屬性。</xref:System.Net.Security.EncryptionPolicy> </xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.CipherAlgorithmType> <xref:System.Security.Authentication.CipherAlgorithmType>Windows Vista 和更新版本，才會傳回值。</xref:System.Security.Authentication.CipherAlgorithmType>"
  example:
  - "The following code example displays the cryptography settings for the specified stream.  \n  \n [!code-cpp[NclSslServerSync#3](~/add/codesnippet/cpp/p-system.net.security.ss_10_1.cpp)]\n [!code-cs[NclSslServerSync#3](~/add/codesnippet/csharp/p-system.net.security.ss_10_1.cs)]"
  syntax:
    content: public virtual System.Security.Authentication.CipherAlgorithmType CipherAlgorithm { get; }
    return:
      type: System.Security.Authentication.CipherAlgorithmType
      description: "A<xref:System.Security.Authentication.CipherAlgorithmType>值。</xref:System.Security.Authentication.CipherAlgorithmType>"
  overload: System.Net.Security.SslStream.CipherAlgorithm*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法完成驗證程序或在驗證程序之前，已存取 CipherAlgorithm 屬性。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.CipherStrength
  id: CipherStrength
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: CipherStrength
  nameWithType: SslStream.CipherStrength
  fullName: System.Net.Security.SslStream.CipherStrength
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得值，識別所使用的加密演算法的強度<xref href=&quot;System.Net.Security.SslStream&quot;> </xref>。"
  remarks: "這個屬性的值為零，直到執行驗證。       這個屬性會傳回下列值之一:-0-40-56-80 128-168 192-256"
  example:
  - "The following code example displays the cryptography settings for the specified stream.  \n  \n [!code-cpp[NclSslServerSync#3](~/add/codesnippet/cpp/p-system.net.security.ss_6_1.cpp)]\n [!code-cs[NclSslServerSync#3](~/add/codesnippet/csharp/p-system.net.security.ss_6_1.cs)]"
  syntax:
    content: public virtual int CipherStrength { get; }
    return:
      type: System.Int32
      description: "<xref:System.Int32>值，指定以位元的演算法的強度。</xref:System.Int32>"
  overload: System.Net.Security.SslStream.CipherStrength*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: SslStream.Dispose(Boolean)
  fullName: System.Net.Security.SslStream.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "所使用的 unmanaged 的資源釋出<xref href=&quot;System.Net.Security.SslStream&quot;></xref>並選擇性釋放 managed 的資源。"
  remarks: "這個方法會呼叫公用`Dispose()`方法和<xref:System.Object.Finalize%2A>方法。</xref:System.Object.Finalize%2A> `Dispose()`叫用受保護`Dispose(Boolean)`方法`disposing`參數設定為`true`。 <xref:System.Object.Finalize%2A>叫用`Dispose`與`disposing`設`false`。</xref:System.Object.Finalize%2A>       當`disposing`參數為 true，這個方法的任何 managed 物件所持有的資源全部釋出這個<xref:System.Net.Security.SslStream>參考。</xref:System.Net.Security.SslStream> 這個方法會叫用`Dispose()`每個參考物件的方法。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示釋放 managed 和 unmanaged 資源，<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示只釋放 unmanaged 的資源。"
  overload: System.Net.Security.SslStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.EndAuthenticateAsClient(System.IAsyncResult)
  id: EndAuthenticateAsClient(System.IAsyncResult)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: EndAuthenticateAsClient(IAsyncResult)
  nameWithType: SslStream.EndAuthenticateAsClient(IAsyncResult)
  fullName: System.Net.Security.SslStream.EndAuthenticateAsClient(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "結束入門<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer*>.</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer*>先前呼叫暫止的非同步伺服器驗證作業"
  remarks: "如果作業尚未完成，這個方法會封鎖，直到它執行。 當驗證成功時，您必須檢查<xref:System.Net.Security.SslStream.IsEncrypted%2A>與<xref:System.Net.Security.SslStream.IsSigned%2A>屬性，以判斷有哪些安全性服務由<xref:System.Net.Security.SslStream>.</xref:System.Net.Security.SslStream> </xref:System.Net.Security.SslStream.IsSigned%2A> </xref:System.Net.Security.SslStream.IsEncrypted%2A> 請檢查<xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>屬性來判斷是否發生過相互驗證。</xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>       如果驗證失敗時，您會收到<xref:System.Security.Authentication.AuthenticationException>，而這<xref:System.Net.Security.SslStream>是無法再使用。</xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。       若要以同步方式執行這項作業，請使用其中一種<xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>方法。</xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>"
  syntax:
    content: public virtual void EndAuthenticateAsClient (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>執行個體的呼叫所傳回至<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer*>。</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer*> </xref:System.IAsyncResult>"
  overload: System.Net.Security.SslStream.EndAuthenticateAsClient*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>不是由呼叫<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer*>。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "驗證失敗，此物件處於不穩定的狀態。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "沒有完成任何擱置中的伺服器驗證。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.EndAuthenticateAsServer(System.IAsyncResult)
  id: EndAuthenticateAsServer(System.IAsyncResult)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: EndAuthenticateAsServer(IAsyncResult)
  nameWithType: SslStream.EndAuthenticateAsServer(IAsyncResult)
  fullName: System.Net.Security.SslStream.EndAuthenticateAsServer(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "結束入門<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient*>.</xref:System.Net.Security.SslStream.BeginAuthenticateAsClient*>先前呼叫暫止的非同步用戶端驗證作業"
  remarks: "如果作業尚未完成，這個方法會封鎖，直到它執行。 當驗證成功時，您必須檢查<xref:System.Net.Security.SslStream.IsEncrypted%2A>與<xref:System.Net.Security.SslStream.IsSigned%2A>屬性，以判斷有哪些安全性服務由<xref:System.Net.Security.SslStream>.</xref:System.Net.Security.SslStream> </xref:System.Net.Security.SslStream.IsSigned%2A> </xref:System.Net.Security.SslStream.IsEncrypted%2A> 請檢查<xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>屬性來判斷是否發生過相互驗證。</xref:System.Net.Security.SslStream.IsMutuallyAuthenticated%2A>       如果驗證失敗時，您會收到<xref:System.Security.Authentication.AuthenticationException>，而這<xref:System.Net.Security.SslStream>是無法再使用。</xref:System.Net.Security.SslStream> </xref:System.Security.Authentication.AuthenticationException> 您應該關閉這個物件，並移除所有參考，讓它可以收集在記憶體回收行程。       若要以同步方式執行這項作業，請使用其中一種<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>方法。</xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>"
  syntax:
    content: public virtual void EndAuthenticateAsServer (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>執行個體的呼叫所傳回至<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient*>。</xref:System.Net.Security.SslStream.BeginAuthenticateAsClient*> </xref:System.IAsyncResult>"
  overload: System.Net.Security.SslStream.EndAuthenticateAsServer*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>不是由呼叫<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient*>。"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "驗證失敗，此物件處於不穩定的狀態。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "沒有完成任何擱置中的用戶端驗證。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: SslStream.EndRead(IAsyncResult)
  fullName: System.Net.Security.SslStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "結束非同步的讀取的作業入門<xref:System.Net.Security.SslStream.BeginRead*>.</xref:System.Net.Security.SslStream.BeginRead*>先前呼叫"
  remarks: "如果作業尚未完成，這個方法會封鎖，直到它執行。       若要以同步方式執行這項作業，使用<xref:System.Net.Security.SslStream.Read%2A>方法。</xref:System.Net.Security.SslStream.Read%2A>       已成功驗證之前，無法呼叫此方法。 若要驗證的呼叫其中一個<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>，或<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>，<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>"
  example:
  - "The following code example demonstrates ending an asynchronous read operation.  \n  \n [!code-cpp[NclSslClientAsync#5](~/add/codesnippet/cpp/m-system.net.security.ss_0_1.cpp)]\n [!code-cs[NclSslClientAsync#5](~/add/codesnippet/csharp/m-system.net.security.ss_0_1.cs)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>呼叫所傳回的執行個體<xref:System.Net.Security.SslStream.BeginRead*></xref:System.Net.Security.SslStream.BeginRead*></xref:System.IAsyncResult>"
    return:
      type: System.Int32
      description: "A<xref:System.Int32>從基礎資料流讀取指定的位元組數目的值。</xref:System.Int32>"
  overload: System.Net.Security.SslStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>不是由呼叫<xref:System.Net.Security.SslStream.BeginRead*>。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "驗證不會發生。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "讀取的作業失敗。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: SslStream.EndWrite(IAsyncResult)
  fullName: System.Net.Security.SslStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "結束非同步寫入作業入門<xref:System.Net.Security.SslStream.BeginWrite*>.</xref:System.Net.Security.SslStream.BeginWrite*>先前呼叫"
  remarks: "如果作業尚未完成，這個方法會封鎖，直到它執行。       應用程式無法呼叫此方法，直到順利完成驗證。 若要驗證，請呼叫其中一個<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>，或<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>，<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>       若要以同步方式執行這項作業，使用<xref:System.Net.Security.SslStream.Write%2A>方法。</xref:System.Net.Security.SslStream.Write%2A>"
  example:
  - "The following code example demonstrates ending an asynchronous write operation.  \n  \n [!code-cs[NclSslServerAsync#4](~/add/codesnippet/csharp/m-system.net.security.ss_1_1.cs)]\n [!code-cpp[NclSslServerAsync#4](~/add/codesnippet/cpp/m-system.net.security.ss_1_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>呼叫所傳回的執行個體<xref:System.Net.Security.SslStream.BeginWrite*></xref:System.Net.Security.SslStream.BeginWrite*></xref:System.IAsyncResult>"
  overload: System.Net.Security.SslStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>不是由呼叫<xref:System.Net.Security.SslStream.BeginWrite*>。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "驗證不會發生。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入作業失敗。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.Flush
  id: Flush
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: Flush()
  nameWithType: SslStream.Flush()
  fullName: System.Net.Security.SslStream.Flush()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "會造成任何緩衝的資料都寫入基礎裝置。"
  remarks: "這個方法會叫用<xref:System.IO.Stream.Flush%2A>在基礎資料流。</xref:System.IO.Stream.Flush%2A>"
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cpp[NclSslClientSync#5](~/add/codesnippet/cpp/m-system.net.security.ss_4_1.cpp)]\n [!code-cs[NclSslClientSync#5](~/add/codesnippet/csharp/m-system.net.security.ss_4_1.cs)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.Net.Security.SslStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.HashAlgorithm
  id: HashAlgorithm
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: HashAlgorithm
  nameWithType: SslStream.HashAlgorithm
  fullName: System.Net.Security.SslStream.HashAlgorithm
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得用來產生訊息驗證碼 (Mac) 演算法。"
  remarks: "訊息驗證的演算法產生訊息雜湊和簽章可用來偵測竄改和偽造。"
  example:
  - "The following code example displays the cryptography settings for the specified stream.  \n  \n [!code-cpp[NclSslServerSync#3](~/add/codesnippet/cpp/p-system.net.security.ss_9_1.cpp)]\n [!code-cs[NclSslServerSync#3](~/add/codesnippet/csharp/p-system.net.security.ss_9_1.cs)]"
  syntax:
    content: public virtual System.Security.Authentication.HashAlgorithmType HashAlgorithm { get; }
    return:
      type: System.Security.Authentication.HashAlgorithmType
      description: "A<xref:System.Security.Authentication.HashAlgorithmType>值。</xref:System.Security.Authentication.HashAlgorithmType>"
  overload: System.Net.Security.SslStream.HashAlgorithm*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法完成驗證程序或在驗證程序之前，已存取 HashAlgorithm 屬性。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.HashStrength
  id: HashStrength
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: HashStrength
  nameWithType: SslStream.HashStrength
  fullName: System.Net.Security.SslStream.HashStrength
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得值，識別這個執行個體所使用的雜湊演算法的強度。"
  remarks: "這個屬性的值為零，直到執行驗證。"
  example:
  - "The following code example displays the cryptography settings for the specified stream.  \n  \n [!code-cpp[NclSslServerSync#3](~/add/codesnippet/cpp/p-system.net.security.ss_2_1.cpp)]\n [!code-cs[NclSslServerSync#3](~/add/codesnippet/csharp/p-system.net.security.ss_2_1.cs)]"
  syntax:
    content: public virtual int HashStrength { get; }
    return:
      type: System.Int32
      description: "<xref:System.Int32>值，指定的強度<xref:System.Security.Authentication.HashAlgorithmType>演算法，以位元。</xref:System.Security.Authentication.HashAlgorithmType> </xref:System.Int32> 有效的值為 128 或 160。"
  overload: System.Net.Security.SslStream.HashStrength*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.IsAuthenticated
  id: IsAuthenticated
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: IsAuthenticated
  nameWithType: SslStream.IsAuthenticated
  fullName: System.Net.Security.SslStream.IsAuthenticated
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得<xref:System.Boolean>值，指出驗證是否成功。</xref:System.Boolean>"
  remarks: "用戶端驗證，藉由呼叫<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>或<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>方法。</xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.SslStream.AuthenticateAsClient%2A> 伺服器驗證，藉由呼叫<xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>或<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cpp[NclSslServerSync#4](~/add/codesnippet/cpp/p-system.net.security.ss_3_1.cpp)]\n [!code-cs[NclSslServerSync#4](~/add/codesnippet/csharp/p-system.net.security.ss_3_1.cs)]"
  syntax:
    content: public override bool IsAuthenticated { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果發生驗證成功。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.SslStream.IsAuthenticated*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.IsEncrypted
  id: IsEncrypted
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: IsEncrypted
  nameWithType: SslStream.IsEncrypted
  fullName: System.Net.Security.SslStream.IsEncrypted
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得<xref:System.Boolean>值，指出是否此<xref href=&quot;System.Net.Security.SslStream&quot;></xref>會使用資料加密。</xref:System.Boolean>"
  remarks: "加密可幫助保護資料的隱私，也就是它可以協助確保，在傳輸資料時，它無法進行解譯第三方。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cpp[NclSslServerSync#4](~/add/codesnippet/cpp/p-system.net.security.ss_0_1.cpp)]\n [!code-cs[NclSslServerSync#4](~/add/codesnippet/csharp/p-system.net.security.ss_0_1.cs)]"
  syntax:
    content: public override bool IsEncrypted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果資料在網路上傳輸之前加密及解密它何時到達遠端端點。否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.SslStream.IsEncrypted*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.IsMutuallyAuthenticated
  id: IsMutuallyAuthenticated
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: IsMutuallyAuthenticated
  nameWithType: SslStream.IsMutuallyAuthenticated
  fullName: System.Net.Security.SslStream.IsMutuallyAuthenticated
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得<xref:System.Boolean>值，指出是否針對伺服器和用戶端已通過驗證。</xref:System.Boolean>"
  remarks: "相互驗證是由伺服器當伺服器想要指定用戶端提供的憑證進行驗證。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cpp[NclSslServerSync#4](~/add/codesnippet/cpp/p-system.net.security.ss_11_1.cpp)]\n [!code-cs[NclSslServerSync#4](~/add/codesnippet/csharp/p-system.net.security.ss_11_1.cs)]"
  syntax:
    content: public override bool IsMutuallyAuthenticated { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果驗證的伺服器。否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.SslStream.IsMutuallyAuthenticated*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.IsServer
  id: IsServer
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: IsServer
  nameWithType: SslStream.IsServer
  fullName: System.Net.Security.SslStream.IsServer
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得<xref:System.Boolean>值，指出是否所使用之連接的本機端<xref href=&quot;System.Net.Security.SslStream&quot;></xref>已與伺服器驗證。</xref:System.Boolean>"
  remarks: "如果驗證失敗，或未執行，這個屬性會傳回`false`。       若要與伺服器進行驗證，呼叫<xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>或<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cpp[NclSslServerSync#4](~/add/codesnippet/cpp/p-system.net.security.ss_13_1.cpp)]\n [!code-cs[NclSslServerSync#4](~/add/codesnippet/csharp/p-system.net.security.ss_13_1.cs)]"
  syntax:
    content: public override bool IsServer { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果順利驗證當做驗證連接的伺服器端的本機端點否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.SslStream.IsServer*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.IsSigned
  id: IsSigned
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: IsSigned
  nameWithType: SslStream.IsSigned
  fullName: System.Net.Security.SslStream.IsSigned
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得<xref:System.Boolean>值，指出是否使用此資料流傳送的資料已經過簽署。</xref:System.Boolean>"
  remarks: "資料簽章協助保護資料的完整性，也就是它會協助判斷是否資料已遭竄改傳輸中的收件者。"
  example:
  - "The following code example demonstrates displaying the value of this property.  \n  \n [!code-cpp[NclSslServerSync#4](~/add/codesnippet/cpp/p-system.net.security.ss_19_1.cpp)]\n [!code-cs[NclSslServerSync#4](~/add/codesnippet/csharp/p-system.net.security.ss_19_1.cs)]"
  syntax:
    content: public override bool IsSigned { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果傳輸; 之前簽署的資料否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Security.SslStream.IsSigned*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.KeyExchangeAlgorithm
  id: KeyExchangeAlgorithm
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: KeyExchangeAlgorithm
  nameWithType: SslStream.KeyExchangeAlgorithm
  fullName: System.Net.Security.SslStream.KeyExchangeAlgorithm
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得所使用的金鑰交換演算法<xref href=&quot;System.Net.Security.SslStream&quot;> </xref>。"
  remarks: "這個屬性的值是<xref:System.Security.Authentication.ExchangeAlgorithmType>直到執行驗證。</xref:System.Security.Authentication.ExchangeAlgorithmType>       金鑰交換演算法會保護用來產生共用的金鑰的資訊。"
  example:
  - "The following code example displays the cryptography settings for the specified stream.  \n  \n [!code-cpp[NclSslServerSync#3](~/add/codesnippet/cpp/p-system.net.security.ss_16_1.cpp)]\n [!code-cs[NclSslServerSync#3](~/add/codesnippet/csharp/p-system.net.security.ss_16_1.cs)]"
  syntax:
    content: public virtual System.Security.Authentication.ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
    return:
      type: System.Security.Authentication.ExchangeAlgorithmType
      description: "<xref:System.Security.Authentication.ExchangeAlgorithmType>值。</xref:System.Security.Authentication.ExchangeAlgorithmType>"
  overload: System.Net.Security.SslStream.KeyExchangeAlgorithm*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.KeyExchangeStrength
  id: KeyExchangeStrength
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: KeyExchangeStrength
  nameWithType: SslStream.KeyExchangeStrength
  fullName: System.Net.Security.SslStream.KeyExchangeStrength
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得值，識別這個執行個體所使用的金鑰交換演算法的強度。"
  remarks: "這個屬性的值為零，直到執行驗證。       在一般情況下，這個屬性的值是下列其中之一︰ 512 768-1024年 2048年-"
  example:
  - "The following code example displays the cryptography settings for the specified stream.  \n  \n [!code-cpp[NclSslServerSync#3](~/add/codesnippet/cpp/p-system.net.security.ss_5_1.cpp)]\n [!code-cs[NclSslServerSync#3](~/add/codesnippet/csharp/p-system.net.security.ss_5_1.cs)]"
  syntax:
    content: public virtual int KeyExchangeStrength { get; }
    return:
      type: System.Int32
      description: "<xref:System.Int32>值，指定的強度<xref:System.Security.Authentication.ExchangeAlgorithmType>演算法，以位元。</xref:System.Security.Authentication.ExchangeAlgorithmType> </xref:System.Int32>"
  overload: System.Net.Security.SslStream.KeyExchangeStrength*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.Length
  id: Length
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: Length
  nameWithType: SslStream.Length
  fullName: System.Net.Security.SslStream.Length
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得基礎資料流的長度。"
  remarks: "這個屬性會傳回所叫用傳回的值<xref:System.IO.Stream.Length%2A>在基礎資料流。</xref:System.IO.Stream.Length%2A> 如果基礎資料流不是可搜尋，這個方法通常就會擲回例外狀況。 基礎資料流的執行階段類型會決定執行階段類型，就會擲回的例外狀況。"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "A <xref:System.Int64>.</xref:System.Int64>       基礎資料流的長度。"
  overload: System.Net.Security.SslStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "取得這個屬性的值時，不支援基礎資料流<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.LocalCertificate
  id: LocalCertificate
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: LocalCertificate
  nameWithType: SslStream.LocalCertificate
  fullName: System.Net.Security.SslStream.LocalCertificate
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得用來驗證的本機端點的憑證。"
  remarks: ''
  example:
  - "The following code example demonstrates displaying the certificate returned by this property.  \n  \n [!code-cpp[NclSslServerSync#6](~/add/codesnippet/cpp/p-system.net.security.ss_1_1.cpp)]\n [!code-cs[NclSslServerSync#6](~/add/codesnippet/csharp/p-system.net.security.ss_1_1.cs)]"
  syntax:
    content: public virtual System.Security.Cryptography.X509Certificates.X509Certificate LocalCertificate { get; }
    return:
      type: System.Security.Cryptography.X509Certificates.X509Certificate
      description: "X509Certificate 物件，表示提供給驗證的憑證或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果已不提供任何憑證。"
  overload: System.Net.Security.SslStream.LocalCertificate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "驗證失敗，或不會發生。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.Position
  id: Position
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: Position
  nameWithType: SslStream.Position
  fullName: System.Net.Security.SslStream.Position
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得或設定基礎資料流中目前的位置。"
  remarks: "這個屬性會傳回所叫用傳回的值<xref:System.IO.Stream.Position%2A>在基礎資料流。</xref:System.IO.Stream.Position%2A> 如果基礎資料流不是可搜尋，這個方法通常就會擲回例外狀況。 基礎資料流的執行階段類型會決定執行階段類型，就會擲回的例外狀況。"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "A <xref:System.Int64>.</xref:System.Int64>       在基礎資料流中目前的位置。"
  overload: System.Net.Security.SslStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支援設定此屬性。       -或-取得這個屬性的值時，不支援基礎資料流<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: SslStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Security.SslStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "從這個資料流讀取資料，並將它儲存在指定的陣列。"
  remarks: "此方法會讀取最多`count`從資料流的位元組並將其儲存在`buffer`開始`offset`。 您無法執行多個同時進行讀取的作業。       已成功驗證之前，無法呼叫此方法。 若要驗證的呼叫其中一個<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>，或<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>，<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>       若要以非同步方式執行此操作，使用<xref:System.Net.Security.SslStream.BeginRead%2A>方法。</xref:System.Net.Security.SslStream.BeginRead%2A>"
  example:
  - "The following code example demonstrates reading from an <xref:System.Net.Security.SslStream>.  \n  \n [!code-cpp[NclSslClientSync#6](~/add/codesnippet/cpp/m-system.net.security.ss_2_1.cpp)]\n [!code-cs[NclSslClientSync#6](~/add/codesnippet/csharp/m-system.net.security.ss_2_1.cs)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A<xref:System.Byte>從這個資料流讀取的接收位元組的陣列。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "A<xref:System.Int32>其中包含以零為起始的位置中`buffer`中要開始將資料儲存讀取自這個資料流。</xref:System.Int32>"
    - id: count
      type: System.Int32
      description: "A <xref:System.Int32>，其中包含要從這個資料流讀取的位元組數目上限。</xref:System.Int32>"
    return:
      type: System.Int32
      description: "A<xref:System.Int32>值，指定讀取的位元組數目。</xref:System.Int32> 其他要讀取的資料時，會傳回 0。"
  overload: System.Net.Security.SslStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>     <code>&lt;</code>     <code>0</code>.       <code>-or-</code><code>offset</code>&gt;長度<code>buffer</code>。       -or-       <code>offset</code> + count &gt; the length of <code>buffer</code>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "讀取的作業失敗。 如果有的話，判斷失敗的原因，請檢查內部例外狀況。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "已經有進行中的讀取的作業。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "驗證不會發生。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.ReadTimeout
  id: ReadTimeout
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: ReadTimeout
  nameWithType: SslStream.ReadTimeout
  fullName: System.Net.Security.SslStream.ReadTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得或設定讀取的作業封鎖等待資料的時間長度。"
  remarks: "這個屬性會傳回所叫用傳回的值<xref:System.IO.Stream.ReadTimeout%2A>在基礎資料流。</xref:System.IO.Stream.ReadTimeout%2A> 當您設定此屬性，<xref:System.IO.Stream.ReadTimeout%2A>基礎資料流上的值設定為指定的值。</xref:System.IO.Stream.ReadTimeout%2A>       如果基礎資料流<xref:System.Net.Sockets.NetworkStream>，ReadTimeout 以毫秒為單位，並設定為<xref:System.Threading.Timeout.Infinite>依預設，讓讀取作業並不會逾時。</xref:System.Threading.Timeout.Infinite> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example demonstrates setting the value of this property.  \n  \n [!code-cpp[NclSslServerSync#1](~/add/codesnippet/cpp/p-system.net.security.ss_18_1.cpp)]\n [!code-cs[NclSslServerSync#1](~/add/codesnippet/csharp/p-system.net.security.ss_18_1.cs)]"
  syntax:
    content: public override int ReadTimeout { get; set; }
    return:
      type: System.Int32
      description: "A<xref:System.Int32>指定同步讀取作業失敗之前所經過的時間量。</xref:System.Int32>"
  overload: System.Net.Security.SslStream.ReadTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.RemoteCertificate
  id: RemoteCertificate
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: RemoteCertificate
  nameWithType: SslStream.RemoteCertificate
  fullName: System.Net.Security.SslStream.RemoteCertificate
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得用來驗證遠端端點的憑證。"
  remarks: ''
  example:
  - "The following code example demonstrates displaying the certificate returned by this property.  \n  \n [!code-cpp[NclSslServerSync#6](~/add/codesnippet/cpp/p-system.net.security.ss_15_1.cpp)]\n [!code-cs[NclSslServerSync#6](~/add/codesnippet/csharp/p-system.net.security.ss_15_1.cs)]"
  syntax:
    content: public virtual System.Security.Cryptography.X509Certificates.X509Certificate RemoteCertificate { get; }
    return:
      type: System.Security.Cryptography.X509Certificates.X509Certificate
      description: "X509Certificate 物件，表示提供給驗證的憑證或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果已不提供任何憑證。"
  overload: System.Net.Security.SslStream.RemoteCertificate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "驗證失敗，或不會發生。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: SslStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Security.SslStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  remarks: "請勿呼叫這個方法。 它繼承的但不是支援的<xref:System.Net.Security.SslStream>類別。</xref:System.Net.Security.SslStream>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "會忽略此值。"
    - id: origin
      type: System.IO.SeekOrigin
      description: "會忽略此值。"
    return:
      type: System.Int64
      description: "一律會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  overload: System.Net.Security.SslStream.Seek*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "搜尋不支援<xref href=&quot;System.Net.Security.SslStream&quot;></xref>物件。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: SslStream.SetLength(Int64)
  fullName: System.Net.Security.SslStream.SetLength(Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "設定基礎資料流的長度。"
  remarks: "這個方法會叫用<xref:System.IO.Stream.SetLength%2A?displayProperty=fullName>上時，指定基礎資料流這<xref:System.Net.Security.SslStream>所建立。</xref:System.Net.Security.SslStream> </xref:System.IO.Stream.SetLength%2A?displayProperty=fullName>"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "<xref:System.Int64>值，指定資料流的長度。</xref:System.Int64>"
  overload: System.Net.Security.SslStream.SetLength*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.SslProtocol
  id: SslProtocol
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: SslProtocol
  nameWithType: SslStream.SslProtocol
  fullName: System.Net.Security.SslStream.SslProtocol
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得值，指出用來驗證此連線的安全性通訊協定。"
  remarks: "指定受支援的安全性通訊協定時<xref:System.Net.Security.SslStream>建立。</xref:System.Net.Security.SslStream> 如果沒有任何安全性通訊協定傳遞給建構函式，建立執行個體是使用<xref:System.Security.Authentication.SslProtocols>.</xref:System.Security.Authentication.SslProtocols> 實際的通訊協定用於驗證用戶端和伺服器所支援的通訊協定為基礎選取。"
  example:
  - "The following example displays the security properties of the specified stream.  \n  \n [!code-cpp[NclSslServerSync#3](~/add/codesnippet/cpp/p-system.net.security.ss_7_1.cpp)]\n [!code-cs[NclSslServerSync#3](~/add/codesnippet/csharp/p-system.net.security.ss_7_1.cs)]"
  syntax:
    content: public virtual System.Security.Authentication.SslProtocols SslProtocol { get; }
    return:
      type: System.Security.Authentication.SslProtocols
      description: "<xref:System.Security.Authentication.SslProtocols>值，表示用於驗證的通訊協定。</xref:System.Security.Authentication.SslProtocols>"
  overload: System.Net.Security.SslStream.SslProtocol*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.TransportContext
  id: TransportContext
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: TransportContext
  nameWithType: SslStream.TransportContext
  fullName: System.Net.Security.SslStream.TransportContext
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得<xref:System.Net.TransportContext>用於驗證擴充保護。</xref:System.Net.TransportContext>"
  syntax:
    content: public System.Net.TransportContext TransportContext { get; }
    return:
      type: System.Net.TransportContext
      description: "<xref:System.Net.TransportContext>物件，其中包含延伸保護所使用的通道繫結權杖 (CBT)。</xref:System.Net.TransportContext>"
  overload: System.Net.Security.SslStream.TransportContext*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Security.SslStream.Write(System.Byte[])
  id: Write(System.Byte[])
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: Write(Byte[])
  nameWithType: SslStream.Write(Byte[])
  fullName: System.Net.Security.SslStream.Write(Byte[])
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "將指定的資料寫入此資料流。"
  remarks: "這個方法會封鎖在作業完成時。 若要防止封鎖在作業完成時，使用<xref:System.Net.Security.SslStream.BeginWrite%2A>方法。</xref:System.Net.Security.SslStream.BeginWrite%2A>       已成功驗證之前，無法呼叫此方法。 若要驗證的呼叫其中一個<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>，或<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>，<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>       <xref:System.Net.Security.SslStream>類別不支援多個同時進行寫入作業。</xref:System.Net.Security.SslStream>"
  example:
  - "The following code example demonstrates writing to an authenticated <xref:System.Net.Security.SslStream>.  \n  \n [!code-cpp[NclSslServerSync#1](~/add/codesnippet/cpp/m-system.net.security.ss_3_1.cpp)]\n [!code-cs[NclSslServerSync#1](~/add/codesnippet/csharp/m-system.net.security.ss_3_1.cs)]"
  syntax:
    content: public void Write (byte[] buffer);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A <xref:System.Byte>，提供寫入資料流的位元組陣列。</xref:System.Byte>"
  overload: System.Net.Security.SslStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入作業失敗。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "已經有進行中的寫入作業。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "驗證不會發生。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: SslStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Security.SslStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "寫入指定的數目<xref:System.Byte>s 基礎資料流使用指定的緩衝區和位移。</xref:System.Byte>"
  remarks: "這個方法會封鎖在作業完成時。 若要防止封鎖在作業完成的作業時完成，請使用<xref:System.Net.Security.SslStream.BeginWrite%2A>方法。</xref:System.Net.Security.SslStream.BeginWrite%2A>       已成功驗證之前，無法呼叫此方法。 若要驗證的呼叫其中一個<xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>，或<xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A>， <xref:System.Net.Security.SslStream.AuthenticateAsServer%2A>，<xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A>方法。</xref:System.Net.Security.SslStream.BeginAuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.AuthenticateAsServer%2A> </xref:System.Net.Security.SslStream.BeginAuthenticateAsClient%2A> </xref:System.Net.Security.SslStream.AuthenticateAsClient%2A>       <xref:System.Net.Security.SslStream>類別不支援多個同時進行寫入作業。</xref:System.Net.Security.SslStream>"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "A <xref:System.Byte>，提供寫入資料流的位元組陣列。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "A<xref:System.Int32>其中包含以零為起始的位置中`buffer`中要開始讀取寫入資料流的位元組。</xref:System.Int32>"
    - id: count
      type: System.Int32
      description: "A <xref:System.Int32>，其中包含要讀取的位元組數目`buffer`。</xref:System.Int32>"
  overload: System.Net.Security.SslStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>     <code>&lt;</code>     <code>0</code>.       <code>-or-</code><code>offset</code>&gt;長度<code>buffer</code>。       -or-       <code>offset</code> + count &gt; the length of <code>buffer</code>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入作業失敗。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "已經有進行中的寫入作業。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "驗證不會發生。"
  platform:
  - net462
- uid: System.Net.Security.SslStream.WriteTimeout
  id: WriteTimeout
  parent: System.Net.Security.SslStream
  langs:
  - csharp
  name: WriteTimeout
  nameWithType: SslStream.WriteTimeout
  fullName: System.Net.Security.SslStream.WriteTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Security
  summary: "取得或設定寫入作業封鎖等待資料的時間長度。"
  remarks: "這個屬性會傳回所叫用傳回的值<xref:System.IO.Stream.WriteTimeout%2A>在基礎資料流。</xref:System.IO.Stream.WriteTimeout%2A> 指定的值設定為設定作業，<xref:System.IO.Stream.WriteTimeout%2A>基礎資料流上的值。</xref:System.IO.Stream.WriteTimeout%2A>       如果基礎資料流<xref:System.Net.Sockets.NetworkStream>，WriteTimeout 以毫秒為單位，並設定為<xref:System.Threading.Timeout.Infinite>依預設，寫入作業並不會逾時。</xref:System.Threading.Timeout.Infinite> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example demonstrates setting the value of this property.  \n  \n [!code-cpp[NclSslServerSync#1](~/add/codesnippet/cpp/p-system.net.security.ss_12_1.cpp)]\n [!code-cs[NclSslServerSync#1](~/add/codesnippet/csharp/p-system.net.security.ss_12_1.cs)]"
  syntax:
    content: public override int WriteTimeout { get; set; }
    return:
      type: System.Int32
      description: "A<xref:System.Int32>指定同步寫入作業失敗之前所經過的時間量。</xref:System.Int32>"
  overload: System.Net.Security.SslStream.WriteTimeout*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Net.Security.AuthenticatedStream
  isExternal: false
  name: System.Net.Security.AuthenticatedStream
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Security.Authentication.AuthenticationException
  parent: System.Security.Authentication
  isExternal: false
  name: AuthenticationException
  nameWithType: AuthenticationException
  fullName: System.Security.Authentication.AuthenticationException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Net.Security.SslStream.#ctor(System.IO.Stream)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: SslStream(Stream)
  nameWithType: SslStream.SslStream(Stream)
  fullName: System.Net.Security.SslStream.SslStream(Stream)
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: SslStream(Stream,Boolean)
  nameWithType: SslStream.SslStream(Stream,Boolean)
  fullName: System.Net.Security.SslStream.SslStream(Stream,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: SslStream(Stream,Boolean,RemoteCertificateValidationCallback)
  nameWithType: SslStream.SslStream(Stream,Boolean,RemoteCertificateValidationCallback)
  fullName: System.Net.Security.SslStream.SslStream(Stream,Boolean,RemoteCertificateValidationCallback)
- uid: System.Net.Security.RemoteCertificateValidationCallback
  parent: System.Net.Security
  isExternal: false
  name: RemoteCertificateValidationCallback
  nameWithType: RemoteCertificateValidationCallback
  fullName: System.Net.Security.RemoteCertificateValidationCallback
- uid: System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: SslStream(Stream,Boolean,RemoteCertificateValidationCallback,LocalCertificateSelectionCallback)
  nameWithType: SslStream.SslStream(Stream,Boolean,RemoteCertificateValidationCallback,LocalCertificateSelectionCallback)
  fullName: System.Net.Security.SslStream.SslStream(Stream,Boolean,RemoteCertificateValidationCallback,LocalCertificateSelectionCallback)
- uid: System.Net.Security.LocalCertificateSelectionCallback
  parent: System.Net.Security
  isExternal: false
  name: LocalCertificateSelectionCallback
  nameWithType: LocalCertificateSelectionCallback
  fullName: System.Net.Security.LocalCertificateSelectionCallback
- uid: System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback,System.Net.Security.EncryptionPolicy)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: SslStream(Stream,Boolean,RemoteCertificateValidationCallback,LocalCertificateSelectionCallback,EncryptionPolicy)
  nameWithType: SslStream.SslStream(Stream,Boolean,RemoteCertificateValidationCallback,LocalCertificateSelectionCallback,EncryptionPolicy)
  fullName: System.Net.Security.SslStream.SslStream(Stream,Boolean,RemoteCertificateValidationCallback,LocalCertificateSelectionCallback,EncryptionPolicy)
- uid: System.Net.Security.EncryptionPolicy
  parent: System.Net.Security
  isExternal: false
  name: EncryptionPolicy
  nameWithType: EncryptionPolicy
  fullName: System.Net.Security.EncryptionPolicy
- uid: System.Net.Security.SslStream.AuthenticateAsClient(System.String)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: AuthenticateAsClient(String)
  nameWithType: SslStream.AuthenticateAsClient(String)
  fullName: System.Net.Security.SslStream.AuthenticateAsClient(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: AuthenticateAsClient(String,X509CertificateCollection,SslProtocols,Boolean)
  nameWithType: SslStream.AuthenticateAsClient(String,X509CertificateCollection,SslProtocols,Boolean)
  fullName: System.Net.Security.SslStream.AuthenticateAsClient(String,X509CertificateCollection,SslProtocols,Boolean)
- uid: System.Security.Cryptography.X509Certificates.X509CertificateCollection
  parent: System.Security.Cryptography.X509Certificates
  isExternal: false
  name: X509CertificateCollection
  nameWithType: X509CertificateCollection
  fullName: System.Security.Cryptography.X509Certificates.X509CertificateCollection
- uid: System.Security.Authentication.SslProtocols
  parent: System.Security.Authentication
  isExternal: true
  name: SslProtocols
  nameWithType: SslProtocols
  fullName: System.Security.Authentication.SslProtocols
- uid: System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: AuthenticateAsClientAsync(String)
  nameWithType: SslStream.AuthenticateAsClientAsync(String)
  fullName: System.Net.Security.SslStream.AuthenticateAsClientAsync(String)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: AuthenticateAsClientAsync(String,X509CertificateCollection,SslProtocols,Boolean)
  nameWithType: SslStream.AuthenticateAsClientAsync(String,X509CertificateCollection,SslProtocols,Boolean)
  fullName: System.Net.Security.SslStream.AuthenticateAsClientAsync(String,X509CertificateCollection,SslProtocols,Boolean)
- uid: System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: AuthenticateAsServer(X509Certificate)
  nameWithType: SslStream.AuthenticateAsServer(X509Certificate)
  fullName: System.Net.Security.SslStream.AuthenticateAsServer(X509Certificate)
- uid: System.Security.Cryptography.X509Certificates.X509Certificate
  parent: System.Security.Cryptography.X509Certificates
  isExternal: false
  name: X509Certificate
  nameWithType: X509Certificate
  fullName: System.Security.Cryptography.X509Certificates.X509Certificate
- uid: System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: AuthenticateAsServer(X509Certificate,Boolean,SslProtocols,Boolean)
  nameWithType: SslStream.AuthenticateAsServer(X509Certificate,Boolean,SslProtocols,Boolean)
  fullName: System.Net.Security.SslStream.AuthenticateAsServer(X509Certificate,Boolean,SslProtocols,Boolean)
- uid: System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: AuthenticateAsServerAsync(X509Certificate)
  nameWithType: SslStream.AuthenticateAsServerAsync(X509Certificate)
  fullName: System.Net.Security.SslStream.AuthenticateAsServerAsync(X509Certificate)
- uid: System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: AuthenticateAsServerAsync(X509Certificate,Boolean,SslProtocols,Boolean)
  nameWithType: SslStream.AuthenticateAsServerAsync(X509Certificate,Boolean,SslProtocols,Boolean)
  fullName: System.Net.Security.SslStream.AuthenticateAsServerAsync(X509Certificate,Boolean,SslProtocols,Boolean)
- uid: System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: BeginAuthenticateAsClient(String,AsyncCallback,Object)
  nameWithType: SslStream.BeginAuthenticateAsClient(String,AsyncCallback,Object)
  fullName: System.Net.Security.SslStream.BeginAuthenticateAsClient(String,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: BeginAuthenticateAsClient(String,X509CertificateCollection,SslProtocols,Boolean,AsyncCallback,Object)
  nameWithType: SslStream.BeginAuthenticateAsClient(String,X509CertificateCollection,SslProtocols,Boolean,AsyncCallback,Object)
  fullName: System.Net.Security.SslStream.BeginAuthenticateAsClient(String,X509CertificateCollection,SslProtocols,Boolean,AsyncCallback,Object)
- uid: System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: BeginAuthenticateAsServer(X509Certificate,AsyncCallback,Object)
  nameWithType: SslStream.BeginAuthenticateAsServer(X509Certificate,AsyncCallback,Object)
  fullName: System.Net.Security.SslStream.BeginAuthenticateAsServer(X509Certificate,AsyncCallback,Object)
- uid: System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: BeginAuthenticateAsServer(X509Certificate,Boolean,SslProtocols,Boolean,AsyncCallback,Object)
  nameWithType: SslStream.BeginAuthenticateAsServer(X509Certificate,Boolean,SslProtocols,Boolean,AsyncCallback,Object)
  fullName: System.Net.Security.SslStream.BeginAuthenticateAsServer(X509Certificate,Boolean,SslProtocols,Boolean,AsyncCallback,Object)
- uid: System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: SslStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Security.SslStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: SslStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Security.SslStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Net.Security.SslStream.CanRead
  parent: System.Net.Security.SslStream
  isExternal: false
  name: CanRead
  nameWithType: SslStream.CanRead
  fullName: System.Net.Security.SslStream.CanRead
- uid: System.Net.Security.SslStream.CanSeek
  parent: System.Net.Security.SslStream
  isExternal: false
  name: CanSeek
  nameWithType: SslStream.CanSeek
  fullName: System.Net.Security.SslStream.CanSeek
- uid: System.Net.Security.SslStream.CanTimeout
  parent: System.Net.Security.SslStream
  isExternal: false
  name: CanTimeout
  nameWithType: SslStream.CanTimeout
  fullName: System.Net.Security.SslStream.CanTimeout
- uid: System.Net.Security.SslStream.CanWrite
  parent: System.Net.Security.SslStream
  isExternal: false
  name: CanWrite
  nameWithType: SslStream.CanWrite
  fullName: System.Net.Security.SslStream.CanWrite
- uid: System.Net.Security.SslStream.CheckCertRevocationStatus
  parent: System.Net.Security.SslStream
  isExternal: false
  name: CheckCertRevocationStatus
  nameWithType: SslStream.CheckCertRevocationStatus
  fullName: System.Net.Security.SslStream.CheckCertRevocationStatus
- uid: System.Net.Security.SslStream.CipherAlgorithm
  parent: System.Net.Security.SslStream
  isExternal: false
  name: CipherAlgorithm
  nameWithType: SslStream.CipherAlgorithm
  fullName: System.Net.Security.SslStream.CipherAlgorithm
- uid: System.Security.Authentication.CipherAlgorithmType
  parent: System.Security.Authentication
  isExternal: true
  name: CipherAlgorithmType
  nameWithType: CipherAlgorithmType
  fullName: System.Security.Authentication.CipherAlgorithmType
- uid: System.Net.Security.SslStream.CipherStrength
  parent: System.Net.Security.SslStream
  isExternal: false
  name: CipherStrength
  nameWithType: SslStream.CipherStrength
  fullName: System.Net.Security.SslStream.CipherStrength
- uid: System.Net.Security.SslStream.Dispose(System.Boolean)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: SslStream.Dispose(Boolean)
  fullName: System.Net.Security.SslStream.Dispose(Boolean)
- uid: System.Net.Security.SslStream.EndAuthenticateAsClient(System.IAsyncResult)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: EndAuthenticateAsClient(IAsyncResult)
  nameWithType: SslStream.EndAuthenticateAsClient(IAsyncResult)
  fullName: System.Net.Security.SslStream.EndAuthenticateAsClient(IAsyncResult)
- uid: System.Net.Security.SslStream.EndAuthenticateAsServer(System.IAsyncResult)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: EndAuthenticateAsServer(IAsyncResult)
  nameWithType: SslStream.EndAuthenticateAsServer(IAsyncResult)
  fullName: System.Net.Security.SslStream.EndAuthenticateAsServer(IAsyncResult)
- uid: System.Net.Security.SslStream.EndRead(System.IAsyncResult)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: SslStream.EndRead(IAsyncResult)
  fullName: System.Net.Security.SslStream.EndRead(IAsyncResult)
- uid: System.Net.Security.SslStream.EndWrite(System.IAsyncResult)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: SslStream.EndWrite(IAsyncResult)
  fullName: System.Net.Security.SslStream.EndWrite(IAsyncResult)
- uid: System.Net.Security.SslStream.Flush
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Flush()
  nameWithType: SslStream.Flush()
  fullName: System.Net.Security.SslStream.Flush()
- uid: System.Net.Security.SslStream.HashAlgorithm
  parent: System.Net.Security.SslStream
  isExternal: false
  name: HashAlgorithm
  nameWithType: SslStream.HashAlgorithm
  fullName: System.Net.Security.SslStream.HashAlgorithm
- uid: System.Security.Authentication.HashAlgorithmType
  parent: System.Security.Authentication
  isExternal: true
  name: HashAlgorithmType
  nameWithType: HashAlgorithmType
  fullName: System.Security.Authentication.HashAlgorithmType
- uid: System.Net.Security.SslStream.HashStrength
  parent: System.Net.Security.SslStream
  isExternal: false
  name: HashStrength
  nameWithType: SslStream.HashStrength
  fullName: System.Net.Security.SslStream.HashStrength
- uid: System.Net.Security.SslStream.IsAuthenticated
  parent: System.Net.Security.SslStream
  isExternal: false
  name: IsAuthenticated
  nameWithType: SslStream.IsAuthenticated
  fullName: System.Net.Security.SslStream.IsAuthenticated
- uid: System.Net.Security.SslStream.IsEncrypted
  parent: System.Net.Security.SslStream
  isExternal: false
  name: IsEncrypted
  nameWithType: SslStream.IsEncrypted
  fullName: System.Net.Security.SslStream.IsEncrypted
- uid: System.Net.Security.SslStream.IsMutuallyAuthenticated
  parent: System.Net.Security.SslStream
  isExternal: false
  name: IsMutuallyAuthenticated
  nameWithType: SslStream.IsMutuallyAuthenticated
  fullName: System.Net.Security.SslStream.IsMutuallyAuthenticated
- uid: System.Net.Security.SslStream.IsServer
  parent: System.Net.Security.SslStream
  isExternal: false
  name: IsServer
  nameWithType: SslStream.IsServer
  fullName: System.Net.Security.SslStream.IsServer
- uid: System.Net.Security.SslStream.IsSigned
  parent: System.Net.Security.SslStream
  isExternal: false
  name: IsSigned
  nameWithType: SslStream.IsSigned
  fullName: System.Net.Security.SslStream.IsSigned
- uid: System.Net.Security.SslStream.KeyExchangeAlgorithm
  parent: System.Net.Security.SslStream
  isExternal: false
  name: KeyExchangeAlgorithm
  nameWithType: SslStream.KeyExchangeAlgorithm
  fullName: System.Net.Security.SslStream.KeyExchangeAlgorithm
- uid: System.Security.Authentication.ExchangeAlgorithmType
  parent: System.Security.Authentication
  isExternal: true
  name: ExchangeAlgorithmType
  nameWithType: ExchangeAlgorithmType
  fullName: System.Security.Authentication.ExchangeAlgorithmType
- uid: System.Net.Security.SslStream.KeyExchangeStrength
  parent: System.Net.Security.SslStream
  isExternal: false
  name: KeyExchangeStrength
  nameWithType: SslStream.KeyExchangeStrength
  fullName: System.Net.Security.SslStream.KeyExchangeStrength
- uid: System.Net.Security.SslStream.Length
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Length
  nameWithType: SslStream.Length
  fullName: System.Net.Security.SslStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Net.Security.SslStream.LocalCertificate
  parent: System.Net.Security.SslStream
  isExternal: false
  name: LocalCertificate
  nameWithType: SslStream.LocalCertificate
  fullName: System.Net.Security.SslStream.LocalCertificate
- uid: System.Net.Security.SslStream.Position
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Position
  nameWithType: SslStream.Position
  fullName: System.Net.Security.SslStream.Position
- uid: System.Net.Security.SslStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: SslStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Security.SslStream.Read(Byte[],Int32,Int32)
- uid: System.Net.Security.SslStream.ReadTimeout
  parent: System.Net.Security.SslStream
  isExternal: false
  name: ReadTimeout
  nameWithType: SslStream.ReadTimeout
  fullName: System.Net.Security.SslStream.ReadTimeout
- uid: System.Net.Security.SslStream.RemoteCertificate
  parent: System.Net.Security.SslStream
  isExternal: false
  name: RemoteCertificate
  nameWithType: SslStream.RemoteCertificate
  fullName: System.Net.Security.SslStream.RemoteCertificate
- uid: System.Net.Security.SslStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: SslStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Security.SslStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.Net.Security.SslStream.SetLength(System.Int64)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: SslStream.SetLength(Int64)
  fullName: System.Net.Security.SslStream.SetLength(Int64)
- uid: System.Net.Security.SslStream.SslProtocol
  parent: System.Net.Security.SslStream
  isExternal: false
  name: SslProtocol
  nameWithType: SslStream.SslProtocol
  fullName: System.Net.Security.SslStream.SslProtocol
- uid: System.Net.Security.SslStream.TransportContext
  parent: System.Net.Security.SslStream
  isExternal: false
  name: TransportContext
  nameWithType: SslStream.TransportContext
  fullName: System.Net.Security.SslStream.TransportContext
- uid: System.Net.TransportContext
  parent: System.Net
  isExternal: true
  name: TransportContext
  nameWithType: TransportContext
  fullName: System.Net.TransportContext
- uid: System.Net.Security.SslStream.Write(System.Byte[])
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Write(Byte[])
  nameWithType: SslStream.Write(Byte[])
  fullName: System.Net.Security.SslStream.Write(Byte[])
- uid: System.Net.Security.SslStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: SslStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Security.SslStream.Write(Byte[],Int32,Int32)
- uid: System.Net.Security.SslStream.WriteTimeout
  parent: System.Net.Security.SslStream
  isExternal: false
  name: WriteTimeout
  nameWithType: SslStream.WriteTimeout
  fullName: System.Net.Security.SslStream.WriteTimeout
- uid: System.Net.Security.SslStream.#ctor*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: SslStream
  nameWithType: SslStream.SslStream
- uid: System.Net.Security.SslStream.AuthenticateAsClient*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: AuthenticateAsClient
  nameWithType: SslStream.AuthenticateAsClient
- uid: System.Net.Security.SslStream.AuthenticateAsClientAsync*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: AuthenticateAsClientAsync
  nameWithType: SslStream.AuthenticateAsClientAsync
- uid: System.Net.Security.SslStream.AuthenticateAsServer*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: AuthenticateAsServer
  nameWithType: SslStream.AuthenticateAsServer
- uid: System.Net.Security.SslStream.AuthenticateAsServerAsync*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: AuthenticateAsServerAsync
  nameWithType: SslStream.AuthenticateAsServerAsync
- uid: System.Net.Security.SslStream.BeginAuthenticateAsClient*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: BeginAuthenticateAsClient
  nameWithType: SslStream.BeginAuthenticateAsClient
- uid: System.Net.Security.SslStream.BeginAuthenticateAsServer*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: BeginAuthenticateAsServer
  nameWithType: SslStream.BeginAuthenticateAsServer
- uid: System.Net.Security.SslStream.BeginRead*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: BeginRead
  nameWithType: SslStream.BeginRead
- uid: System.Net.Security.SslStream.BeginWrite*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: BeginWrite
  nameWithType: SslStream.BeginWrite
- uid: System.Net.Security.SslStream.CanRead*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: CanRead
  nameWithType: SslStream.CanRead
- uid: System.Net.Security.SslStream.CanSeek*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: CanSeek
  nameWithType: SslStream.CanSeek
- uid: System.Net.Security.SslStream.CanTimeout*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: CanTimeout
  nameWithType: SslStream.CanTimeout
- uid: System.Net.Security.SslStream.CanWrite*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: CanWrite
  nameWithType: SslStream.CanWrite
- uid: System.Net.Security.SslStream.CheckCertRevocationStatus*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: CheckCertRevocationStatus
  nameWithType: SslStream.CheckCertRevocationStatus
- uid: System.Net.Security.SslStream.CipherAlgorithm*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: CipherAlgorithm
  nameWithType: SslStream.CipherAlgorithm
- uid: System.Net.Security.SslStream.CipherStrength*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: CipherStrength
  nameWithType: SslStream.CipherStrength
- uid: System.Net.Security.SslStream.Dispose*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Dispose
  nameWithType: SslStream.Dispose
- uid: System.Net.Security.SslStream.EndAuthenticateAsClient*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: EndAuthenticateAsClient
  nameWithType: SslStream.EndAuthenticateAsClient
- uid: System.Net.Security.SslStream.EndAuthenticateAsServer*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: EndAuthenticateAsServer
  nameWithType: SslStream.EndAuthenticateAsServer
- uid: System.Net.Security.SslStream.EndRead*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: EndRead
  nameWithType: SslStream.EndRead
- uid: System.Net.Security.SslStream.EndWrite*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: EndWrite
  nameWithType: SslStream.EndWrite
- uid: System.Net.Security.SslStream.Flush*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Flush
  nameWithType: SslStream.Flush
- uid: System.Net.Security.SslStream.HashAlgorithm*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: HashAlgorithm
  nameWithType: SslStream.HashAlgorithm
- uid: System.Net.Security.SslStream.HashStrength*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: HashStrength
  nameWithType: SslStream.HashStrength
- uid: System.Net.Security.SslStream.IsAuthenticated*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: IsAuthenticated
  nameWithType: SslStream.IsAuthenticated
- uid: System.Net.Security.SslStream.IsEncrypted*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: IsEncrypted
  nameWithType: SslStream.IsEncrypted
- uid: System.Net.Security.SslStream.IsMutuallyAuthenticated*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: IsMutuallyAuthenticated
  nameWithType: SslStream.IsMutuallyAuthenticated
- uid: System.Net.Security.SslStream.IsServer*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: IsServer
  nameWithType: SslStream.IsServer
- uid: System.Net.Security.SslStream.IsSigned*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: IsSigned
  nameWithType: SslStream.IsSigned
- uid: System.Net.Security.SslStream.KeyExchangeAlgorithm*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: KeyExchangeAlgorithm
  nameWithType: SslStream.KeyExchangeAlgorithm
- uid: System.Net.Security.SslStream.KeyExchangeStrength*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: KeyExchangeStrength
  nameWithType: SslStream.KeyExchangeStrength
- uid: System.Net.Security.SslStream.Length*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Length
  nameWithType: SslStream.Length
- uid: System.Net.Security.SslStream.LocalCertificate*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: LocalCertificate
  nameWithType: SslStream.LocalCertificate
- uid: System.Net.Security.SslStream.Position*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Position
  nameWithType: SslStream.Position
- uid: System.Net.Security.SslStream.Read*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Read
  nameWithType: SslStream.Read
- uid: System.Net.Security.SslStream.ReadTimeout*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: ReadTimeout
  nameWithType: SslStream.ReadTimeout
- uid: System.Net.Security.SslStream.RemoteCertificate*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: RemoteCertificate
  nameWithType: SslStream.RemoteCertificate
- uid: System.Net.Security.SslStream.Seek*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Seek
  nameWithType: SslStream.Seek
- uid: System.Net.Security.SslStream.SetLength*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: SetLength
  nameWithType: SslStream.SetLength
- uid: System.Net.Security.SslStream.SslProtocol*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: SslProtocol
  nameWithType: SslStream.SslProtocol
- uid: System.Net.Security.SslStream.TransportContext*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: TransportContext
  nameWithType: SslStream.TransportContext
- uid: System.Net.Security.SslStream.Write*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: Write
  nameWithType: SslStream.Write
- uid: System.Net.Security.SslStream.WriteTimeout*
  parent: System.Net.Security.SslStream
  isExternal: false
  name: WriteTimeout
  nameWithType: SslStream.WriteTimeout
