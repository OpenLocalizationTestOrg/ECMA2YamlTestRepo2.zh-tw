### YamlMime:ManagedReference
items:
- uid: System.Net.Sockets.NetworkStream
  id: NetworkStream
  children:
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  - System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  - System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.Net.Sockets.NetworkStream.CanRead
  - System.Net.Sockets.NetworkStream.CanSeek
  - System.Net.Sockets.NetworkStream.CanTimeout
  - System.Net.Sockets.NetworkStream.CanWrite
  - System.Net.Sockets.NetworkStream.Close(System.Int32)
  - System.Net.Sockets.NetworkStream.DataAvailable
  - System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  - System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  - System.Net.Sockets.NetworkStream.Finalize
  - System.Net.Sockets.NetworkStream.Flush
  - System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  - System.Net.Sockets.NetworkStream.Length
  - System.Net.Sockets.NetworkStream.Position
  - System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Readable
  - System.Net.Sockets.NetworkStream.ReadTimeout
  - System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  - System.Net.Sockets.NetworkStream.Socket
  - System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.Net.Sockets.NetworkStream.Writeable
  - System.Net.Sockets.NetworkStream.WriteTimeout
  langs:
  - csharp
  name: NetworkStream
  nameWithType: NetworkStream
  fullName: System.Net.Sockets.NetworkStream
  type: Class
  summary: "提供網路存取資料的基礎資料流。"
  remarks: "NetworkStream 類別提供方法來傳送和接收資料透過<xref:System.Net.Sockets.SocketType>封鎖模式通訊端。</xref:System.Net.Sockets.SocketType> 如需有關封鎖與封鎖<xref:System.Net.Sockets.Socket>s，請參閱[使用非同步用戶端通訊端](~/add/includes/ajax-current-ext-md.md)。</xref:System.Net.Sockets.Socket> 您可以使用 NetworkStream 類別，這兩個同步和非同步資料傳輸。 如需有關同步和非同步通訊的詳細資訊，請參閱[通訊端](~/add/includes/ajax-current-ext-md.md)。       若要建立 NetworkStream，您必須提供連接的<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> 您也可以指定哪些<xref:System.IO.FileAccess>權限 NetworkStream 高於提供<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.IO.FileAccess> 根據預設，關閉 NetworkStream 不會關閉提供<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> 如果您想要有權限，以關閉提供 NetworkStream <xref:System.Net.Sockets.Socket>，您必須指定`true`值的`ownsSocket`參數。</xref:System.Net.Sockets.Socket>       使用<xref:System.Net.Sockets.NetworkStream.Write%2A>和<xref:System.Net.Sockets.NetworkStream.Read%2A>方法來簡單的單一執行緒同步鎖定的 I/O。</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream.Write%2A> 如果您想要處理您使用個別執行緒的 I/O，請考慮使用<xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>和<xref:System.Net.Sockets.NetworkStream.EndWrite%2A>方法，或<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>和<xref:System.Net.Sockets.NetworkStream.EndRead%2A>方法進行通訊。</xref:System.Net.Sockets.NetworkStream.EndRead%2A> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>       NetworkStream 不支援隨機存取的網路資料流。 值<xref:System.Net.Sockets.NetworkStream.CanSeek%2A>屬性，指出資料流是否支援搜尋，永遠是`false`; 讀取<xref:System.Net.Sockets.NetworkStream.Position%2A>屬性中讀取的<xref:System.Net.Sockets.NetworkStream.Length%2A>屬性，或呼叫的<xref:System.Net.Sockets.NetworkStream.Seek%2A>方法會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Net.Sockets.NetworkStream.Seek%2A> </xref:System.Net.Sockets.NetworkStream.Length%2A> </xref:System.Net.Sockets.NetworkStream.Position%2A> </xref:System.Net.Sockets.NetworkStream.CanSeek%2A>       讀取和寫入作業可以同時執行，而不需要同步處理 NetworkStream 類別的執行個體上。 只要沒有 「 寫入 」 操作專用的執行緒和一個唯一的執行緒，用於讀取作業，讀取之間會有互相干擾，並寫入執行緒無同步處理不需要。"
  example:
  - "The following code example demonstrates how to create a NetworkStream from a connected <xref:System.Net.Sockets.SocketType><xref:System.Net.Sockets.Socket> and perform basic synchronous blocking I/O.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/t-system.net.sockets.net_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/t-system.net.sockets.net_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/t-system.net.sockets.net_1.cs)]"
  syntax:
    content: 'public class NetworkStream : System.IO.Stream'
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  id: '#ctor(System.Net.Sockets.Socket)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "建立的新執行個體<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>指定<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket>類別"
  remarks: "<xref:System.Net.Sockets.NetworkStream>建立具有讀取/寫入至指定<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket>的存取權</xref:System.Net.Sockets.NetworkStream> <xref:System.Net.Sockets.NetworkStream>未擁有的基礎<xref:System.Net.Sockets.Socket>，因此呼叫的<xref:System.Net.Sockets.NetworkStream.Close%2A>方法不會關閉<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example illustrates how to create a <xref:System.Net.Sockets.NetworkStream> with a <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/m-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/m-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/m-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>， <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>將用於傳送和接收資料。</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code>參數未連線。       -或-<xref:System.Net.Sockets.Socket.SocketType*>屬性<code> socket </code>參數不是&lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;。</xref:System.Net.Sockets.Socket.SocketType*>       -或- <code> socket </code>參數處於封鎖狀態。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "初始化的新執行個體<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>類別指定<xref:System.Net.Sockets.Socket>具有指定<xref:System.Net.Sockets.Socket>擁有權。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>建立具有讀取/寫入至指定<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket>的存取權</xref:System.Net.Sockets.NetworkStream> 如果值`ownsSocket`參數是`true`、<xref:System.Net.Sockets.NetworkStream>接管基礎<xref:System.Net.Sockets.Socket>，和呼叫的<xref:System.Net.Sockets.NetworkStream.Close%2A>方法也會關閉基礎<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with ownership of the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/visualbasic/59c93a1c-9c9b-46b2-a872-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/cpp/59c93a1c-9c9b-46b2-a872-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#2](~/add/codesnippet/csharp/59c93a1c-9c9b-46b2-a872-_1.cs)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>， <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>將用於傳送和接收資料。</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "設定為<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>將取得的擁有權<xref:System.Net.Sockets.Socket>，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code>參數未連線。       -的值<xref:System.Net.Sockets.Socket.SocketType*>屬性<code> socket </code>參數不是&lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;。</xref:System.Net.Sockets.Socket.SocketType*>       -或- <code> socket </code>參數處於封鎖狀態。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "建立的新執行個體<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>類別指定<xref:System.Net.Sockets.Socket>具有所指定的存取權限。</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>建立指定的存取權，以指定<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> 使用這個建構函式，<xref:System.Net.Sockets.NetworkStream>並未擁有的基礎<xref:System.Net.Sockets.Socket>，因此呼叫的<xref:System.Net.Sockets.NetworkStream.Close%2A>方法不會關閉基礎<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       `access`參數設定<xref:System.Net.Sockets.NetworkStream.CanRead%2A>的<xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream>和<xref:System.Net.Sockets.NetworkStream.CanWrite%2A>屬性</xref:System.Net.Sockets.NetworkStream.CanWrite%2A></xref:System.Net.Sockets.NetworkStream.CanRead%2A> 如果您指定<xref:System.IO.FileAccess>，然後在<xref:System.Net.Sockets.NetworkStream>允許呼叫<xref:System.Net.Sockets.NetworkStream.Write%2A>方法。</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> 如果您指定<xref:System.IO.FileAccess>，然後在<xref:System.Net.Sockets.NetworkStream>允許呼叫<xref:System.Net.Sockets.NetworkStream.Read%2A>方法。</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> 如果您指定<xref:System.IO.FileAccess>，允許使用這兩個方法呼叫。</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/586c6962-cd9c-4b70-aa3e-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/586c6962-cd9c-4b70-aa3e-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/586c6962-cd9c-4b70-aa3e-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>， <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>將用於傳送和接收資料。</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "位元組合<xref href=&quot;System.IO.FileAccess&quot;></xref>值，指定類型的存取權提供給<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>透過提供<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code>參數未連線。       -或-<xref:System.Net.Sockets.Socket.SocketType*>屬性<code> socket </code>參數不是&lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;。</xref:System.Net.Sockets.Socket.SocketType*>       -或- <code> socket </code>參數處於封鎖狀態。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)'
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "建立的新執行個體<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>類別指定<xref:System.Net.Sockets.Socket>與指定的存取權限和指定<xref:System.Net.Sockets.Socket>擁有權。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.NetworkStream>建立具有讀取/寫入至指定<xref:System.Net.Sockets.Socket>。</xref:System.Net.Sockets.Socket>的存取權</xref:System.Net.Sockets.NetworkStream> 如果值`ownsSocket`參數是`true`、<xref:System.Net.Sockets.NetworkStream>接管基礎<xref:System.Net.Sockets.Socket>，和呼叫的<xref:System.Net.Sockets.NetworkStream.Close%2A>方法也會關閉基礎<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream.Close%2A> </xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       `access`參數設定<xref:System.Net.Sockets.NetworkStream.CanRead%2A>的<xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream>和<xref:System.Net.Sockets.NetworkStream.CanWrite%2A>屬性</xref:System.Net.Sockets.NetworkStream.CanWrite%2A></xref:System.Net.Sockets.NetworkStream.CanRead%2A> 如果您指定<xref:System.IO.FileAccess>，然後在<xref:System.Net.Sockets.NetworkStream>允許呼叫<xref:System.Net.Sockets.NetworkStream.Write%2A>方法。</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> 如果您指定<xref:System.IO.FileAccess>，然後在<xref:System.Net.Sockets.NetworkStream>允許呼叫<xref:System.Net.Sockets.NetworkStream.Read%2A>方法。</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> </xref:System.IO.FileAccess> 如果您指定<xref:System.IO.FileAccess>，允許使用這兩個方法呼叫。</xref:System.IO.FileAccess>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.NetworkStream> with the ability to read and write to the <xref:System.Net.Sockets.Socket>. Ownership of the <xref:System.Net.Sockets.Socket> is given to this <xref:System.Net.Sockets.NetworkStream> by specifying `true` for the `ownsSocket` parameter.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/visualbasic/db34d484-28c0-47ef-b5ca-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/csharp/db34d484-28c0-47ef-b5ca-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#1](~/add/codesnippet/cpp/db34d484-28c0-47ef-b5ca-_1.cpp)]"
  syntax:
    content: public NetworkStream (System.Net.Sockets.Socket socket, System.IO.FileAccess access, bool ownsSocket);
    parameters:
    - id: socket
      type: System.Net.Sockets.Socket
      description: "<xref:System.Net.Sockets.Socket>， <xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>將用於傳送和接收資料。</xref:System.Net.Sockets.Socket>"
    - id: access
      type: System.IO.FileAccess
      description: "位元組合<xref href=&quot;System.IO.FileAccess&quot;></xref>值，指定類型的存取權提供給<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>透過提供<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
    - id: ownsSocket
      type: System.Boolean
      description: "設定為<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>將取得的擁有權<xref:System.Net.Sockets.Socket>，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>socket</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<code> socket </code>參數未連線。       -或-<xref:System.Net.Sockets.Socket.SocketType*>屬性<code> socket </code>參數不是&lt;xref:System.Net.Sockets.SocketType?displayProperty=fullName&gt;。</xref:System.Net.Sockets.Socket.SocketType*>       -或- <code> socket </code>參數處於封鎖狀態。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "開始非同步讀取從<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  remarks: "BeginRead 方法開始以非同步方式從傳入的網路緩衝區中讀取資料。 呼叫的 BeginRead 方法，讓您能夠接收不同的執行緒中的資料。       您必須建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞給的 BeginRead 方法。</xref:System.AsyncCallback> 在最起碼您`state`參數必須包含<xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> 因為您會想要取得已接收的資料，您的回呼方法中，您應該建立的小型類別或結構來保留讀取的緩衝區和其他有用的資訊。 結構或類別的執行個體傳遞給的 BeginRead 方法，透過`state`參數。       回呼方法應該呼叫<xref:System.Net.Sockets.NetworkStream.EndRead%2A>方法。</xref:System.Net.Sockets.NetworkStream.EndRead%2A> 當您的應用程式呼叫 BeginRead 時，系統會等到收到資料或發生錯誤，然後系統會使用另一個執行緒來執行指定的回呼方法和上的區塊<xref:System.Net.Sockets.NetworkStream.EndRead%2A>直到提供<xref:System.Net.Sockets.NetworkStream>擲回例外狀況或讀取資料。</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndRead%2A> 如果您想要呼叫的 BeginRead 方法之後，封鎖原始執行緒時，使用<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</xref:System.Threading.WaitHandle.WaitOne%2A> 呼叫<xref:System.Threading.EventWaitHandle.Set%2A>在回呼方法，當您想要繼續執行原始的執行緒。</xref:System.Threading.EventWaitHandle.Set%2A> 如需有關撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/add/includes/ajax-current-ext-md.md)。       BeginRead 方法讀取可供使用，最多為指定的位元組數目的資料量`size`參數。      > [!NOTE] > 如果您收到<xref:System.IO.IOException>，請檢查<xref:System.Exception.InnerException%2A>屬性來判斷如果起因<xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> 如果是，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>屬性來取得特定的錯誤碼，並請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件 MSDN 中錯誤的詳細描述。</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       讀取和寫入作業可以同時執行的執行個體上<xref:System.Net.Sockets.NetworkStream>類別，而不需要同步處理。</xref:System.Net.Sockets.NetworkStream> 只要沒有 「 寫入 」 操作專用的執行緒和一個唯一的執行緒，用於讀取作業，讀取之間會有互相干擾，並寫入執行緒無同步處理不需要。"
  example:
  - "The following code example uses BeginRead to read data asynchronously from the network stream. The `myReadCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginRead returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/visualbasic/b2716ae9-7520-4d87-8b97-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/csharp/b2716ae9-7520-4d87-8b97-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#3](~/add/codesnippet/cpp/b2716ae9-7520-4d87-8b97-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "類型的陣列<xref:System.Byte>也就是在記憶體中，將讀取的資料儲存位置<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "中的位置`buffer`來開始儲存資料。"
    - id: size
      type: System.Int32
      description: "要讀取的位元組數目<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>BeginRead 完成時執行的委派。</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "物件，包含任何其他使用者定義資料。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表非同步呼叫。</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code>參數小於 0。       -或- <code> offset </code>參數的長度大於<code> buffer </code>數參數。       -或- <code> size </code>小於 0。       -或- <code> size </code>大於的長度<code> buffer </code>的值減掉<code> offset </code>參數。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "基礎<xref:System.Net.Sockets.Socket>已關閉。</xref:System.Net.Sockets.Socket>       -或者-從網路讀取時失敗。       -或者-存取通訊端時發生錯誤。 請參閱 < 備註 > 一節，如需詳細資訊。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>已關閉。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "開始非同步寫入的資料流。"
  remarks: "BeginWrite 方法開始遠端主機的非同步傳送作業。 呼叫的 BeginWrite 方法，讓您能夠傳送不同的執行緒中的資料。       您必須建立實作的回呼方法<xref:System.AsyncCallback>委派，並將其名稱傳遞給的 BeginWrite 方法。</xref:System.AsyncCallback> 在最起碼您`state`參數必須包含<xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> 如果您的回呼需要詳細資訊，您可以建立小型類別或結構來保留<xref:System.Net.Sockets.NetworkStream>以及其他必要的資訊。</xref:System.Net.Sockets.NetworkStream> 結構或類別的執行個體傳遞給 BeginWrite 方法，透過`state`參數。       回呼方法應該實作<xref:System.Net.Sockets.NetworkStream.EndWrite%2A>方法。</xref:System.Net.Sockets.NetworkStream.EndWrite%2A> 當您的應用程式呼叫 BeginWrite 時，系統會使用個別的執行緒來執行指定的回呼方法，並封鎖<xref:System.Net.Sockets.NetworkStream.EndWrite%2A>直到<xref:System.Net.Sockets.NetworkStream>傳送要求的位元組數目，或擲回例外狀況。</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.NetworkStream.EndWrite%2A> 如果您想要呼叫的 BeginWrite 方法之後，封鎖原始執行緒時，使用<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</xref:System.Threading.WaitHandle.WaitOne%2A> 呼叫<xref:System.Threading.EventWaitHandle.Set%2A>在回呼方法，當您想要繼續執行原始的執行緒。</xref:System.Threading.EventWaitHandle.Set%2A> 如需有關撰寫回呼方法的詳細資訊，請參閱[封送處理做為回呼方法的委派](~/add/includes/ajax-current-ext-md.md)。      > [!NOTE] > 如果您收到<xref:System.IO.IOException>，請檢查<xref:System.Exception.InnerException%2A>屬性來判斷如果起因<xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> 如果是，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>屬性來取得特定的錯誤碼，並請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件 MSDN 中錯誤的詳細描述。</xref:System.Net.Sockets.SocketException.ErrorCode%2A>       讀取和寫入作業可以同時執行的執行個體上<xref:System.Net.Sockets.NetworkStream>類別，而不需要同步處理。</xref:System.Net.Sockets.NetworkStream> 只要沒有 「 寫入 」 操作專用的執行緒和一個唯一的執行緒，用於讀取作業，讀取之間會有互相干擾，並寫入執行緒無同步處理不需要。"
  example:
  - "The following code example uses BeginWrite to write data asynchronously to a network stream. The `myWriteCallBack` method implements the <xref:System.AsyncCallback> delegate and is called by the system when BeginWrite returns.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/visualbasic/d3b03755-0183-42fc-98c1-_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/csharp/d3b03755-0183-42fc-98c1-_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#2](~/add/codesnippet/cpp/d3b03755-0183-42fc-98c1-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "類型的陣列<xref:System.Byte>，其中包含要寫入至資料<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "中的位置`buffer`開始傳送資料。"
    - id: size
      type: System.Int32
      description: "要寫入的位元組數目<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>BeginWrite 完成時執行的委派。</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "物件，包含任何其他使用者定義資料。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表非同步呼叫。</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.BeginWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code>參數小於 0。       -或- <code> offset </code>參數的長度大於<code> buffer </code>。       -或- <code> size </code>參數小於 0。       -或- <code> size </code>參數的長度大於<code> buffer </code>的值減掉<code> offset </code>參數。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "基礎<xref:System.Net.Sockets.Socket>已關閉。</xref:System.Net.Sockets.Socket>       -或者-寫入網路時發生失敗。       -或者-存取通訊端時發生錯誤。 請參閱 < 備註 > 一節，如需詳細資訊。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>已關閉。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanRead
  id: CanRead
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得值，指出是否<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>支援讀取。"
  remarks: "如果是 CanRead `true`，<xref:System.Net.Sockets.NetworkStream>允許呼叫<xref:System.Net.Sockets.NetworkStream.Read%2A>方法。</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> 提供<xref:System.IO.FileAccess>列舉值來設定可讀性和可寫性<xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream>的建構函式中</xref:System.IO.FileAccess>的適當 CanRead 屬性時，會設定<xref:System.Net.Sockets.NetworkStream>已初始化。</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanRead to verify that the <xref:System.Net.Sockets.NetworkStream> is readable. It then performs a read operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_6_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_6_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_6_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果可以讀取資料，從資料流。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanSeek
  id: CanSeek
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得值，指出資料流是否支援搜尋。 目前不支援這個屬性。這個屬性永遠傳回<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>在所有情況下，以指出<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>無法搜尋資料流中的特定位置。"
  overload: System.Net.Sockets.NetworkStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  id: CanTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "指出是否可供逾時屬性<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  remarks: "這個屬性是存在，因為它繼承自<xref:System.IO.Stream>.</xref:System.IO.Stream>"
  syntax:
    content: public override bool CanTimeout { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>在所有情況下。"
  overload: System.Net.Sockets.NetworkStream.CanTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.CanWrite
  id: CanWrite
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得值，指出是否<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>支援寫入。"
  remarks: "如果 CanWrite `true`，<xref:System.Net.Sockets.NetworkStream>允許呼叫<xref:System.Net.Sockets.NetworkStream.Write%2A>方法。</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> 提供<xref:System.IO.FileAccess>列舉值來設定可讀性和可寫性<xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream>的建構函式中</xref:System.IO.FileAccess>的適當 CanWrite 屬性時，會設定<xref:System.Net.Sockets.NetworkStream>已初始化。</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "The following code example checks CanWrite to verify that the <xref:System.Net.Sockets.NetworkStream> is writable. It then performs a write operation on the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/p-system.net.sockets.net_0_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/p-system.net.sockets.net_0_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/p-system.net.sockets.net_0_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果資料可以寫入<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  id: Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "關閉<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>之後等候指定的時間，以允許資料傳送。"
  remarks: "Close 方法會釋放 unmanaged 和 managed <xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream>相關聯的資源 如果<xref:System.Net.Sockets.NetworkStream>擁有基礎<xref:System.Net.Sockets.Socket>，它也會關閉。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream>       如果<xref:System.Net.Sockets.NetworkStream>a <xref:System.Net.Sockets.TcpClient>、 Close 方法將會關閉 TCP 連接，但不是相關聯的<xref:System.Net.Sockets.TcpClient>.</xref:System.Net.Sockets.TcpClient>處置</xref:System.Net.Sockets.TcpClient>與相關聯</xref:System.Net.Sockets.NetworkStream>"
  syntax:
    content: public void Close (int timeout);
    parameters:
    - id: timeout
      type: System.Int32
      description: "32 位元帶正負號的整數，指定要傳送任何剩餘的資料，在關閉前等候的毫秒數。"
  overload: System.Net.Sockets.NetworkStream.Close*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> timeout </code>參數為小於-1。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  id: DataAvailable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得值，指出資料是否可在<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>讀取。"
  remarks: "使用 DataAvailable 屬性來判斷資料是否可供讀取。 如果是 DataAvailable `true`，呼叫<xref:System.Net.Sockets.NetworkStream.Read%2A>會立即傳回。</xref:System.Net.Sockets.NetworkStream.Read%2A> 如果遠端主機關機或關閉連接，DataAvailable 可能會擲回<xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException>"
  example:
  - "The following code example reads from the <xref:System.Net.Sockets.NetworkStream> as long as data is available.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/p-system.net.sockets.net_2_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/p-system.net.sockets.net_2_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/p-system.net.sockets.net_2_1.cs)]"
  syntax:
    content: public virtual bool DataAvailable { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果資料可使用的資料流讀取;否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.DataAvailable*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>已關閉。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "基礎<xref:System.Net.Sockets.Socket>已關閉。</xref:System.Net.Sockets.Socket>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "使用&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;屬性來取得特定的錯誤碼，並請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件 MSDN 中錯誤的詳細描述。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "所使用的 unmanaged 的資源釋出<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>並選擇性釋放 managed 的資源。"
  remarks: "這個方法會呼叫公用`Dispose`方法和<xref:System.Object.Finalize%2A>方法。</xref:System.Object.Finalize%2A> `Dispose`叫用受保護`Dispose(Boolean)`方法`disposing`參數設定為`true`。 <xref:System.Object.Finalize%2A>叫用`Dispose`與`disposing`設`false`。</xref:System.Object.Finalize%2A>       當`disposing`參數是`true`，這個方法的任何 managed 物件所持有的資源全部釋出這個<xref:System.Net.Sockets.NetworkStream>參考。</xref:System.Net.Sockets.NetworkStream> 這個方法會叫用`Dispose`每個參考物件的方法。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示釋放 managed 和 unmanaged 資源，<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示只釋放 unmanaged 的資源。"
  overload: System.Net.Sockets.NetworkStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "處理非同步讀取的結束。"
  remarks: "EndRead 方法完成非同步的讀取的作業，以啟動<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>方法。</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>       然後再呼叫<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginRead%2A> 不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>傳回。</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> 回呼方法必須接受<xref:System.IAsyncResult>從傳回<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>做為參數的方法。</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult>       在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>屬性<xref:System.IAsyncResult>取得狀態物件傳遞至<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>方法。</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> </xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A> 擷取接收<xref:System.Net.Sockets.NetworkStream>從這個狀態物件。</xref:System.Net.Sockets.NetworkStream> 取得之後<xref:System.Net.Sockets.NetworkStream>，呼叫 EndRead 方法，以成功地完成讀取的作業，並傳回讀取的位元組數目。</xref:System.Net.Sockets.NetworkStream>       EndRead 方法會封鎖直到資料為止。 EndRead 方法會讀取位於最高達指定的位元組數目的資料量`size`參數<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>方法。</xref:System.Net.Sockets.NetworkStream.BeginRead%2A> 如果遠端主機關機<xref:System.Net.Sockets.Socket>已接收連線並將所有可用的資料、 EndRead 方法立即完成，且傳回零個位元組。</xref:System.Net.Sockets.Socket>       若要取得已接收的資料，請呼叫<xref:System.IAsyncResult.AsyncState%2A>屬性<xref:System.IAsyncResult>，然後將解壓縮所產生的狀態物件中包含的緩衝區。</xref:System.IAsyncResult> </xref:System.IAsyncResult.AsyncState%2A>      > [!NOTE] > 如果您收到<xref:System.IO.IOException>，請檢查<xref:System.Exception.InnerException%2A>屬性來判斷如果起因<xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> 如果是，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>屬性來取得特定的錯誤碼，並請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件 MSDN 中錯誤的詳細描述。</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myReadCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginRead%2A> as the callback method. EndRead is implemented in `myReadCallback` to complete the asynchronous read call started by <xref:System.Net.Sockets.NetworkStream.BeginRead%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/visualbasic/m-system.net.sockets.net_2_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/csharp/m-system.net.sockets.net_2_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#5](~/add/codesnippet/cpp/m-system.net.sockets.net_2_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>代表的非同步呼叫。</xref:System.IAsyncResult>"
    return:
      type: System.Int32
      description: "從讀取的位元組數<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.EndRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "基礎<xref:System.Net.Sockets.Socket>已關閉。</xref:System.Net.Sockets.Socket>       -或者-存取通訊端時發生錯誤。 請參閱 < 備註 > 一節，如需詳細資訊。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>已關閉。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "處理非同步寫入結束。"
  remarks: "EndWrite 完成啟動<xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>。</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>非同步傳送作業       然後再呼叫<xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>，您需要建立回呼方法，實作<xref:System.AsyncCallback>委派。</xref:System.AsyncCallback> </xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> 不同的執行緒中執行這個回呼方法，以及之後系統便會呼叫<xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>傳回。</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> 回呼方法必須接受<xref:System.IAsyncResult>從傳回<xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>做為參數的方法。</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> </xref:System.IAsyncResult>       在回呼方法中呼叫<xref:System.IAsyncResult.AsyncState%2A>屬性`IAsyncResult`參數來取得<xref:System.Net.Sockets.NetworkStream>.</xref:System.Net.Sockets.NetworkStream> </xref:System.IAsyncResult.AsyncState%2A> 取得之後<xref:System.Net.Sockets.NetworkStream>，您可以呼叫 EndWrite 方法已成功完成傳送作業，並傳回傳送的位元組數目。</xref:System.Net.Sockets.NetworkStream>       EndWrite 方法會封鎖直到傳送要求的位元組數目。      > [!NOTE] > 如果您收到<xref:System.IO.IOException>，請檢查<xref:System.Exception.InnerException%2A>屬性來判斷如果起因<xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> 如果是，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>屬性來取得特定的錯誤碼，並請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件 MSDN 中錯誤的詳細描述。</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "In the following code example, `myWriteCallback` is provided to <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A> as the callback method. EndWrite is implemented in `myWriteCallback` to complete the asynchronous write call started by <xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>.  \n  \n [!code-vb[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_3_1.vb)]\n [!code-cs[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_3_1.cs)]\n [!code-cpp[NetworkStream_Async_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_3_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表非同步呼叫。</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.NetworkStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "基礎<xref:System.Net.Sockets.Socket>已關閉。</xref:System.Net.Sockets.Socket>       -或者-寫入網路時發生錯誤。       -或者-存取通訊端時發生錯誤。 請參閱 < 備註 > 一節，如需詳細資訊。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>已關閉。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Finalize
  id: Finalize
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "所使用的資源全部釋出<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  remarks: "這個方法會覆寫<xref:System.Object.Finalize%2A?displayProperty=fullName>.</xref:System.Object.Finalize%2A?displayProperty=fullName> 應用程式程式碼不應該呼叫這個方法。物件的<xref:System.Object.Finalize%2A>方法會自動叫用記憶體回收期間，除非已停用記憶體回收行程的最終處理的呼叫所<xref:System.GC.SuppressFinalize%2A?displayProperty=fullName>方法。</xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> </xref:System.Object.Finalize%2A>       如需使用 Finalize 方法的詳細資訊，請參閱[Finalize 方法和解構函式](http://msdn.microsoft.com/en-us/fd376774-1643-499b-869e-9546a3aeea70)，[清除 Unmanaged 資源上](~/add/includes/ajax-current-ext-md.md)，和[覆寫 Finalize 方法](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)。"
  syntax:
    content: ~NetworkStream ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Flush
  id: Flush
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "排清資料流的資料。 這個方法被保留供未來使用。"
  remarks: "Flush 方法實作<xref:System.IO.Stream.Flush%2A?displayProperty=fullName>方法; 不過，因為<xref:System.Net.Sockets.NetworkStream>是未緩衝處理，它會有任何作用網路資料流。</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.Stream.Flush%2A?displayProperty=fullName> 呼叫 Flush 方法不會擲回例外狀況。"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.Net.Sockets.NetworkStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "以非同步作業會排清資料流的資料。"
  remarks: "這項作業不會封鎖。 傳回<xref:System.Threading.Tasks.Task>物件已從資料流排清資料之後，會完成<xref:System.Net.Sockets.NetworkStream>執行個體。</xref:System.Net.Sockets.NetworkStream> </xref:System.Threading.Tasks.Task>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "取消語彙基元用來傳播應該取消這項作業的通知。"
    return:
      type: System.Threading.Tasks.Task
      description: "傳回<xref:System.Threading.Tasks.Task>.</xref:System.Threading.Tasks.Task>       工作物件，表示非同步作業。"
  overload: System.Net.Sockets.NetworkStream.FlushAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Length
  id: Length
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得資料流上的可用資料的長度。 這個屬性目前不支援，而且一律會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "資料流上的可用資料的長度。"
  overload: System.Net.Sockets.NetworkStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "任何使用此屬性。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Position
  id: Position
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得或設定資料流中目前的位置。 這個屬性目前不支援，而且一律會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "資料流中目前的位置。"
  overload: System.Net.Sockets.NetworkStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "任何使用此屬性。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "讀取資料，從<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  remarks: "這個方法會讀取資料到`buffer`參數，並傳回成功讀取的位元組數目。 如果沒有資料可供讀取，則 Read 方法會傳回 0。 「 讀取 」 操作會讀取可供使用，最多為指定的位元組數目的資料量`size`參數。 如果遠端主機關閉連接，而且已經收到所有可用的資料，Read 方法會立即完成，並傳回零個位元組。      > [!NOTE] >，查看<xref:System.Net.Sockets.NetworkStream>藉由呼叫是否可讀取<xref:System.Net.Sockets.NetworkStream.CanRead%2A>屬性。</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream> 如果您嘗試從<xref:System.Net.Sockets.NetworkStream>無法讀取，您會收到<xref:System.IO.IOException>.</xref:System.IO.IOException></xref:System.Net.Sockets.NetworkStream>讀取      > [!NOTE] > 如果您收到<xref:System.IO.IOException>，請檢查<xref:System.Exception.InnerException%2A>屬性來判斷如果起因<xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException> 如果是，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A>屬性來取得特定的錯誤碼，並請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件 MSDN 中錯誤的詳細描述。</xref:System.Net.Sockets.SocketException.ErrorCode%2A>"
  example:
  - "The following code example uses <xref:System.Net.Sockets.NetworkStream.DataAvailable%2A> to determine if data is available to be read. If data is available, it reads from the <xref:System.Net.Sockets.NetworkStream>.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/visualbasic/m-system.net.sockets.net_1_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/cpp/m-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#4](~/add/codesnippet/csharp/m-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "類型的陣列<xref:System.Byte>也就是在記憶體中，將讀取的資料儲存位置<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "中的位置`buffer`來開始儲存的資料。"
    - id: size
      type: System.Int32
      description: "要讀取的位元組數目<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
    return:
      type: System.Int32
      description: "從讀取的位元組數<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code>參數小於 0。       -或- <code> offset </code>參數的長度大於<code> buffer </code>。       -或- <code> size </code>參數小於 0。       -或- <code> size </code>參數的長度大於<code> buffer </code>的值減掉<code> offset </code>參數。       -或者-存取通訊端時發生錯誤。 請參閱 < 備註 > 一節，如需詳細資訊。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "基礎<xref:System.Net.Sockets.Socket>已關閉。</xref:System.Net.Sockets.Socket>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>已關閉。       -或者-從網路讀取失敗。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Readable
  id: Readable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得或設定值，指出是否<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>可以讀取。"
  remarks: "您必須衍生自<xref:System.Net.Sockets.NetworkStream>類別來使用可讀取的屬性。</xref:System.Net.Sockets.NetworkStream> 如果可讀取為`true`，<xref:System.Net.Sockets.NetworkStream>允許呼叫<xref:System.Net.Sockets.NetworkStream.Read%2A>方法。</xref:System.Net.Sockets.NetworkStream.Read%2A> </xref:System.Net.Sockets.NetworkStream> 您也可以判斷是否<xref:System.Net.Sockets.NetworkStream>是藉由檢查可公開存取的可讀取<xref:System.Net.Sockets.NetworkStream.CanRead%2A>屬性。</xref:System.Net.Sockets.NetworkStream.CanRead%2A> </xref:System.Net.Sockets.NetworkStream>       可讀取的屬性時，會設定<xref:System.Net.Sockets.NetworkStream>已初始化。</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Readable property to determine if the <xref:System.Net.Sockets.NetworkStream> is readable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_7_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_7_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_7_1.vb)]"
  syntax:
    content: protected bool Readable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>可讀取，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.Readable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  id: ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得或設定讀取的作業封鎖，等待資料的時間量。"
  remarks: "如果這個屬性所指定的時間內讀取的作業未完成，讀取的作業會擲回<xref:System.IO.IOException>.</xref:System.IO.IOException>      > [!NOTE] > 這個屬性會影響只同步呼叫來執行的讀取<xref:System.Net.Sockets.NetworkStream.Read%2A>方法。</xref:System.Net.Sockets.NetworkStream.Read%2A> 這個屬性不會影響執行呼叫的非同步讀取<xref:System.Net.Sockets.NetworkStream.BeginRead%2A>方法。</xref:System.Net.Sockets.NetworkStream.BeginRead%2A>"
  example:
  - "The following code example sets the read time-out for a network stream to 10 milliseconds.  \n  \n [!code-cs[NCLTcpClientSync#2](~/add/codesnippet/csharp/p-system.net.sockets.net_4_1.cs)]"
  syntax:
    content: public override int ReadTimeout { get; set; }
    return:
      type: System.Int32
      description: "A <xref:System.Int32>，指定的時間，以毫秒為單位，讀取的作業失敗之前等候。</xref:System.Int32> 預設值， <xref:System.Threading.Timeout.Infinite>，指定讀取的作業不會逾時。</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.ReadTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "指定的值小於或等於零，且不是<xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "將資料流的目前位置設定指定的值。 這個方法目前不支援，一律會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "未使用此參數。"
    - id: origin
      type: System.IO.SeekOrigin
      description: "未使用此參數。"
    return:
      type: System.Int64
      description: "資料流中的位置。"
  overload: System.Net.Sockets.NetworkStream.Seek*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "任何使用此屬性。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "設定資料流的長度。 這個方法一律會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException>"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "未使用此參數。"
  overload: System.Net.Sockets.NetworkStream.SetLength*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "任何使用此屬性。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Socket
  id: Socket
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得基礎<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "類別衍生自<xref:System.Net.Sockets.NetworkStream>可以使用這個屬性，以取得基礎<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.NetworkStream> 使用基礎<xref:System.Net.Sockets.Socket>從通訊端屬性傳回，如果您需要存取超過其<xref:System.Net.Sockets.NetworkStream>提供。</xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.Socket>      > [!NOTE] >，這個值只可透過存取此類別或衍生的類別。"
  example:
  - "The following code example retrieves the underlying <xref:System.Net.Sockets.Socket> to verify an active connection.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_3_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_3_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_3_1.vb)]"
  syntax:
    content: protected System.Net.Sockets.Socket Socket { get; }
    return:
      type: System.Net.Sockets.Socket
      description: "A<xref:System.Net.Sockets.Socket>表示基礎網路連接。</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.NetworkStream.Socket*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "會將資料寫入<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  remarks: "Write 方法開始的指定位置`offset`並傳送`size`位元組的內容從`buffer`到網路。 寫入方法會封鎖，直到傳送要求的位元組數目或<xref:System.Net.Sockets.SocketException>就會擲回。</xref:System.Net.Sockets.SocketException> 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>屬性來取得特定的錯誤碼，並請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件 MSDN 中錯誤的詳細描述。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] >，查看<xref:System.Net.Sockets.NetworkStream>是可寫入存取<xref:System.Net.Sockets.NetworkStream.CanWrite%2A>屬性。</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream> 如果您嘗試要寫入<xref:System.Net.Sockets.NetworkStream>的是無法寫入，您會收到<xref:System.IO.IOException>.</xref:System.IO.IOException> </xref:System.Net.Sockets.NetworkStream> 如果您收到<xref:System.IO.IOException>，請檢查<xref:System.Exception.InnerException%2A>屬性來判斷如果起因<xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> </xref:System.Exception.InnerException%2A> </xref:System.IO.IOException>"
  example:
  - "The following code example checks to see whether the <xref:System.Net.Sockets.NetworkStream> is writable. If it is, then Write is used to write a small message.  \n  \n [!code-vb[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/visualbasic/87c395a5-03ea-4324-8b05-_1.vb)]\n [!code-cpp[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/cpp/87c395a5-03ea-4324-8b05-_1.cpp)]\n [!code-cs[NetworkStream_Synch_SendAndReceive#3](~/add/codesnippet/csharp/87c395a5-03ea-4324-8b05-_1.cs)]"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int size);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "類型的陣列<xref:System.Byte>，其中包含要寫入至資料<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。</xref:System.Byte>"
    - id: offset
      type: System.Int32
      description: "中的位置`buffer`要開始寫入資料。"
    - id: size
      type: System.Int32
      description: "要寫入的位元組數目<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>buffer</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> offset </code>參數小於 0。       -或- <code> offset </code>參數的長度大於<code> buffer </code>。       -或- <code> size </code>參數小於 0。       -或- <code> size </code>參數的長度大於<code> buffer </code>的值減掉<code> offset </code>參數。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入網路時發生失敗。       -或者-存取通訊端時發生錯誤。 請參閱 < 備註 > 一節，如需詳細資訊。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref href=&quot;System.Net.Sockets.NetworkStream&quot;> </xref>已關閉。       -或者-從網路讀取失敗。"
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.Writeable
  id: Writeable
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得值，指出是否<xref href=&quot;System.Net.Sockets.NetworkStream&quot;></xref>是可寫入。"
  remarks: "您必須衍生自<xref:System.Net.Sockets.NetworkStream>類別來使用可寫入的屬性。</xref:System.Net.Sockets.NetworkStream> 如果是 Writeable `true`，<xref:System.Net.Sockets.NetworkStream>允許呼叫<xref:System.Net.Sockets.NetworkStream.Write%2A>方法。</xref:System.Net.Sockets.NetworkStream.Write%2A> </xref:System.Net.Sockets.NetworkStream> 您也可以判斷是否<xref:System.Net.Sockets.NetworkStream>是藉由檢查可公開存取的可寫入<xref:System.Net.Sockets.NetworkStream.CanWrite%2A>屬性。</xref:System.Net.Sockets.NetworkStream.CanWrite%2A> </xref:System.Net.Sockets.NetworkStream>       可寫入的屬性時，會設定<xref:System.Net.Sockets.NetworkStream>已初始化。</xref:System.Net.Sockets.NetworkStream>"
  example:
  - "In the following code example, the `CanCommunicate` property checks the Writeable property to determine if the <xref:System.Net.Sockets.NetworkStream> is writable.  \n  \n [!code-cpp[NetworkStream_Protected_Members#1](~/add/codesnippet/cpp/p-system.net.sockets.net_5_1.cpp)]\n [!code-cs[NetworkStream_Protected_Members#1](~/add/codesnippet/csharp/p-system.net.sockets.net_5_1.cs)]\n [!code-vb[NetworkStream_Protected_Members#1](~/add/codesnippet/visualbasic/p-system.net.sockets.net_5_1.vb)]"
  syntax:
    content: protected bool Writeable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果資料可以寫入資料流。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.NetworkStream.Writeable*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  id: WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  langs:
  - csharp
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得或設定寫入作業封鎖，等待資料的時間量。"
  remarks: "如果這個屬性所指定的時間內不會寫入作業完成，在寫入作業會擲回<xref:System.IO.IOException>.</xref:System.IO.IOException>      > [!NOTE] > 這個屬性會影響執行的呼叫只同步寫入操作<xref:System.Net.Sockets.NetworkStream.Write%2A>方法。</xref:System.Net.Sockets.NetworkStream.Write%2A> 這個屬性不會影響執行呼叫的非同步寫入<xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>方法。</xref:System.Net.Sockets.NetworkStream.BeginWrite%2A>"
  example:
  - "The following code example sets the write time-out for a network stream to 10 milliseconds.  \n  \n [!code-cpp[NCLTcpServerSync#0](~/add/codesnippet/cpp/p-system.net.sockets.net_1_1.cpp)]\n [!code-cs[NCLTcpServerSync#0](~/add/codesnippet/csharp/p-system.net.sockets.net_1_1.cs)]"
  syntax:
    content: public override int WriteTimeout { get; set; }
    return:
      type: System.Int32
      description: "A <xref:System.Int32>，指定的時間，以毫秒為單位，在寫入作業失敗之前等候。</xref:System.Int32> 預設值， <xref:System.Threading.Timeout.Infinite>，指定寫入作業不會逾時。</xref:System.Threading.Timeout.Infinite>"
  overload: System.Net.Sockets.NetworkStream.WriteTimeout*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "指定的值小於或等於零，且不是<xref:System.Threading.Timeout.Infinite>.</xref:System.Threading.Timeout.Infinite>"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket)
  nameWithType: NetworkStream.NetworkStream(Socket)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket)
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: true
  name: Socket
  nameWithType: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.Net.Sockets.NetworkStream.#ctor(System.Net.Sockets.Socket,System.IO.FileAccess,System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream(Socket,FileAccess,Boolean)
  nameWithType: NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
  fullName: System.Net.Sockets.NetworkStream.NetworkStream(Socket,FileAccess,Boolean)
- uid: System.Net.Sockets.NetworkStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Net.Sockets.NetworkStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.Net.Sockets.NetworkStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.Net.Sockets.NetworkStream.CanRead
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
  fullName: System.Net.Sockets.NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
  fullName: System.Net.Sockets.NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
  fullName: System.Net.Sockets.NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
  fullName: System.Net.Sockets.NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close(System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close(Int32)
  nameWithType: NetworkStream.Close(Int32)
  fullName: System.Net.Sockets.NetworkStream.Close(Int32)
- uid: System.Net.Sockets.NetworkStream.DataAvailable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
  fullName: System.Net.Sockets.NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose(System.Boolean)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: NetworkStream.Dispose(Boolean)
  fullName: System.Net.Sockets.NetworkStream.Dispose(Boolean)
- uid: System.Net.Sockets.NetworkStream.EndRead(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: NetworkStream.EndRead(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndRead(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.EndWrite(System.IAsyncResult)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: NetworkStream.EndWrite(IAsyncResult)
  fullName: System.Net.Sockets.NetworkStream.EndWrite(IAsyncResult)
- uid: System.Net.Sockets.NetworkStream.Finalize
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize()
  nameWithType: NetworkStream.Finalize()
  fullName: System.Net.Sockets.NetworkStream.Finalize()
- uid: System.Net.Sockets.NetworkStream.Flush
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush()
  nameWithType: NetworkStream.Flush()
  fullName: System.Net.Sockets.NetworkStream.Flush()
- uid: System.Net.Sockets.NetworkStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: NetworkStream.FlushAsync(CancellationToken)
  fullName: System.Net.Sockets.NetworkStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Net.Sockets.NetworkStream.Length
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
  fullName: System.Net.Sockets.NetworkStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Net.Sockets.NetworkStream.Position
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
  fullName: System.Net.Sockets.NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Read(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Read(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Readable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
  fullName: System.Net.Sockets.NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
  fullName: System.Net.Sockets.NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: NetworkStream.Seek(Int64,SeekOrigin)
  fullName: System.Net.Sockets.NetworkStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.Net.Sockets.NetworkStream.SetLength(System.Int64)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: NetworkStream.SetLength(Int64)
  fullName: System.Net.Sockets.NetworkStream.SetLength(Int64)
- uid: System.Net.Sockets.NetworkStream.Socket
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
  fullName: System.Net.Sockets.NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: NetworkStream.Write(Byte[],Int32,Int32)
  fullName: System.Net.Sockets.NetworkStream.Write(Byte[],Int32,Int32)
- uid: System.Net.Sockets.NetworkStream.Writeable
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
  fullName: System.Net.Sockets.NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
  fullName: System.Net.Sockets.NetworkStream.WriteTimeout
- uid: System.Net.Sockets.NetworkStream.#ctor*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: NetworkStream
  nameWithType: NetworkStream.NetworkStream
- uid: System.Net.Sockets.NetworkStream.BeginRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginRead
  nameWithType: NetworkStream.BeginRead
- uid: System.Net.Sockets.NetworkStream.BeginWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: BeginWrite
  nameWithType: NetworkStream.BeginWrite
- uid: System.Net.Sockets.NetworkStream.CanRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanRead
  nameWithType: NetworkStream.CanRead
- uid: System.Net.Sockets.NetworkStream.CanSeek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanSeek
  nameWithType: NetworkStream.CanSeek
- uid: System.Net.Sockets.NetworkStream.CanTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanTimeout
  nameWithType: NetworkStream.CanTimeout
- uid: System.Net.Sockets.NetworkStream.CanWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: CanWrite
  nameWithType: NetworkStream.CanWrite
- uid: System.Net.Sockets.NetworkStream.Close*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Close
  nameWithType: NetworkStream.Close
- uid: System.Net.Sockets.NetworkStream.DataAvailable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: DataAvailable
  nameWithType: NetworkStream.DataAvailable
- uid: System.Net.Sockets.NetworkStream.Dispose*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Dispose
  nameWithType: NetworkStream.Dispose
- uid: System.Net.Sockets.NetworkStream.EndRead*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndRead
  nameWithType: NetworkStream.EndRead
- uid: System.Net.Sockets.NetworkStream.EndWrite*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: EndWrite
  nameWithType: NetworkStream.EndWrite
- uid: System.Net.Sockets.NetworkStream.Finalize*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Finalize
  nameWithType: NetworkStream.Finalize
- uid: System.Net.Sockets.NetworkStream.Flush*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Flush
  nameWithType: NetworkStream.Flush
- uid: System.Net.Sockets.NetworkStream.FlushAsync*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: FlushAsync
  nameWithType: NetworkStream.FlushAsync
- uid: System.Net.Sockets.NetworkStream.Length*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Length
  nameWithType: NetworkStream.Length
- uid: System.Net.Sockets.NetworkStream.Position*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Position
  nameWithType: NetworkStream.Position
- uid: System.Net.Sockets.NetworkStream.Read*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Read
  nameWithType: NetworkStream.Read
- uid: System.Net.Sockets.NetworkStream.Readable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Readable
  nameWithType: NetworkStream.Readable
- uid: System.Net.Sockets.NetworkStream.ReadTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: ReadTimeout
  nameWithType: NetworkStream.ReadTimeout
- uid: System.Net.Sockets.NetworkStream.Seek*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Seek
  nameWithType: NetworkStream.Seek
- uid: System.Net.Sockets.NetworkStream.SetLength*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: SetLength
  nameWithType: NetworkStream.SetLength
- uid: System.Net.Sockets.NetworkStream.Socket*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Socket
  nameWithType: NetworkStream.Socket
- uid: System.Net.Sockets.NetworkStream.Write*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Write
  nameWithType: NetworkStream.Write
- uid: System.Net.Sockets.NetworkStream.Writeable*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: Writeable
  nameWithType: NetworkStream.Writeable
- uid: System.Net.Sockets.NetworkStream.WriteTimeout*
  parent: System.Net.Sockets.NetworkStream
  isExternal: false
  name: WriteTimeout
  nameWithType: NetworkStream.WriteTimeout
