### YamlMime:ManagedReference
items:
- uid: System.Windows.FrameworkElement
  id: FrameworkElement
  children:
  - System.Windows.FrameworkElement.#ctor
  - System.Windows.FrameworkElement.ActualHeight
  - System.Windows.FrameworkElement.ActualHeightProperty
  - System.Windows.FrameworkElement.ActualWidth
  - System.Windows.FrameworkElement.ActualWidthProperty
  - System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  - System.Windows.FrameworkElement.ApplyTemplate
  - System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  - System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  - System.Windows.FrameworkElement.BeginInit
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  - System.Windows.FrameworkElement.BindingGroup
  - System.Windows.FrameworkElement.BindingGroupProperty
  - System.Windows.FrameworkElement.BringIntoView
  - System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  - System.Windows.FrameworkElement.ContextMenu
  - System.Windows.FrameworkElement.ContextMenuClosing
  - System.Windows.FrameworkElement.ContextMenuClosingEvent
  - System.Windows.FrameworkElement.ContextMenuOpening
  - System.Windows.FrameworkElement.ContextMenuOpeningEvent
  - System.Windows.FrameworkElement.ContextMenuProperty
  - System.Windows.FrameworkElement.Cursor
  - System.Windows.FrameworkElement.CursorProperty
  - System.Windows.FrameworkElement.DataContext
  - System.Windows.FrameworkElement.DataContextChanged
  - System.Windows.FrameworkElement.DataContextProperty
  - System.Windows.FrameworkElement.DefaultStyleKey
  - System.Windows.FrameworkElement.DefaultStyleKeyProperty
  - System.Windows.FrameworkElement.EndInit
  - System.Windows.FrameworkElement.FindName(System.String)
  - System.Windows.FrameworkElement.FindResource(System.Object)
  - System.Windows.FrameworkElement.FlowDirection
  - System.Windows.FrameworkElement.FlowDirectionProperty
  - System.Windows.FrameworkElement.FocusVisualStyle
  - System.Windows.FrameworkElement.FocusVisualStyleProperty
  - System.Windows.FrameworkElement.ForceCursor
  - System.Windows.FrameworkElement.ForceCursorProperty
  - System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  - System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  - System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  - System.Windows.FrameworkElement.GetTemplateChild(System.String)
  - System.Windows.FrameworkElement.GetUIParentCore
  - System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  - System.Windows.FrameworkElement.Height
  - System.Windows.FrameworkElement.HeightProperty
  - System.Windows.FrameworkElement.HorizontalAlignment
  - System.Windows.FrameworkElement.HorizontalAlignmentProperty
  - System.Windows.FrameworkElement.InheritanceBehavior
  - System.Windows.FrameworkElement.Initialized
  - System.Windows.FrameworkElement.InputScope
  - System.Windows.FrameworkElement.InputScopeProperty
  - System.Windows.FrameworkElement.IsInitialized
  - System.Windows.FrameworkElement.IsLoaded
  - System.Windows.FrameworkElement.Language
  - System.Windows.FrameworkElement.LanguageProperty
  - System.Windows.FrameworkElement.LayoutTransform
  - System.Windows.FrameworkElement.LayoutTransformProperty
  - System.Windows.FrameworkElement.Loaded
  - System.Windows.FrameworkElement.LoadedEvent
  - System.Windows.FrameworkElement.LogicalChildren
  - System.Windows.FrameworkElement.Margin
  - System.Windows.FrameworkElement.MarginProperty
  - System.Windows.FrameworkElement.MaxHeight
  - System.Windows.FrameworkElement.MaxHeightProperty
  - System.Windows.FrameworkElement.MaxWidth
  - System.Windows.FrameworkElement.MaxWidthProperty
  - System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  - System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  - System.Windows.FrameworkElement.MinHeight
  - System.Windows.FrameworkElement.MinHeightProperty
  - System.Windows.FrameworkElement.MinWidth
  - System.Windows.FrameworkElement.MinWidthProperty
  - System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  - System.Windows.FrameworkElement.Name
  - System.Windows.FrameworkElement.NameProperty
  - System.Windows.FrameworkElement.OnApplyTemplate
  - System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  - System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  - System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  - System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  - System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  - System.Windows.FrameworkElement.OverridesDefaultStyle
  - System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  - System.Windows.FrameworkElement.Parent
  - System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  - System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  - System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  - System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  - System.Windows.FrameworkElement.RequestBringIntoView
  - System.Windows.FrameworkElement.RequestBringIntoViewEvent
  - System.Windows.FrameworkElement.Resources
  - System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  - System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  - System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  - System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  - System.Windows.FrameworkElement.ShouldSerializeResources
  - System.Windows.FrameworkElement.ShouldSerializeStyle
  - System.Windows.FrameworkElement.ShouldSerializeTriggers
  - System.Windows.FrameworkElement.SizeChanged
  - System.Windows.FrameworkElement.SizeChangedEvent
  - System.Windows.FrameworkElement.SourceUpdated
  - System.Windows.FrameworkElement.Style
  - System.Windows.FrameworkElement.StyleProperty
  - System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.FrameworkElement.Tag
  - System.Windows.FrameworkElement.TagProperty
  - System.Windows.FrameworkElement.TargetUpdated
  - System.Windows.FrameworkElement.TemplatedParent
  - System.Windows.FrameworkElement.ToolTip
  - System.Windows.FrameworkElement.ToolTipClosing
  - System.Windows.FrameworkElement.ToolTipClosingEvent
  - System.Windows.FrameworkElement.ToolTipOpening
  - System.Windows.FrameworkElement.ToolTipOpeningEvent
  - System.Windows.FrameworkElement.ToolTipProperty
  - System.Windows.FrameworkElement.Triggers
  - System.Windows.FrameworkElement.TryFindResource(System.Object)
  - System.Windows.FrameworkElement.Unloaded
  - System.Windows.FrameworkElement.UnloadedEvent
  - System.Windows.FrameworkElement.UnregisterName(System.String)
  - System.Windows.FrameworkElement.UpdateDefaultStyle
  - System.Windows.FrameworkElement.UseLayoutRounding
  - System.Windows.FrameworkElement.UseLayoutRoundingProperty
  - System.Windows.FrameworkElement.VerticalAlignment
  - System.Windows.FrameworkElement.VerticalAlignmentProperty
  - System.Windows.FrameworkElement.VisualChildrenCount
  - System.Windows.FrameworkElement.Width
  - System.Windows.FrameworkElement.WidthProperty
  langs:
  - csharp
  name: FrameworkElement
  nameWithType: FrameworkElement
  fullName: System.Windows.FrameworkElement
  type: Class
  summary: "提供屬性、 事件和方法的 WPF 架構層級組[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]項目。 此類別代表所提供的 WPF 架構層級實作建置 WPF 核心層級的[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]所定義<xref href=&quot;System.Windows.UIElement&quot;> </xref>。"
  remarks: "FrameworkElement 是 WPF 架構層級項目類別以及的 WPF 核心層級設定之間的連接點<xref:System.Windows.UIElement>展示服務。</xref:System.Windows.UIElement> 如需有關這些概念的詳細資訊，請參閱[WPF 架構](~/add/includes/ajax-current-ext-md.md)。       FrameworkElement 擴充<xref:System.Windows.UIElement>並加入下列功能:-**版面配置系統定義**: FrameworkElement 提供特定的 WPF 架構層級實作某些方法<xref:System.Windows.UIElement>.</xref:System.Windows.UIElement>中的虛擬成員所定義的</xref:System.Windows.UIElement> 最值得注意的是，FrameworkElement 密封特定 WPF 核心層級配置覆寫，並改為提供 WPF 架構層級對等項目，衍生類別應該改為覆寫。 例如，FrameworkElement 密封<xref:System.Windows.UIElement.ArrangeCore%2A>但提供<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.</xref:System.Windows.FrameworkElement.ArrangeOverride%2A> </xref:System.Windows.UIElement.ArrangeCore%2A> 這些變更會反映在 WPF 架構層級沒有完整的版面配置系統可呈現任何 FrameworkElement 備妥的事實衍生的類別。 在 WPF 核心層級，特定的成員，將結構一般[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]根據的配置方案的位置，但未定義的版面配置系統實際引擎。 如需詳細資訊，請參閱[配置](~/add/includes/ajax-current-ext-md.md)。      -**邏輯樹狀結構︰**一般[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]程式設計模型通常表示在樹狀目錄中的項目。 隨附在標記中定義該樹狀結構的支援 FrameworkElement 層級實作與支援表示邏輯樹狀結構的項目樹狀結構。 但是請注意 FrameworkElement 刻意未定義內容的模型，而且會保留該衍生類別的責任。 如需詳細資訊，請參閱[中 WPF 樹狀架構](~/add/includes/ajax-current-ext-md.md)。      -**物件存留期的事件︰**通常是很有幫助 初始化項目時 （稱為建構函式），或項目時先載入到邏輯樹狀結構。 FrameworkElement 定義數個事件物件存留期與相關，提供有用的攔截程序牽涉到項目，例如新增更多的子元素的程式碼後置作業。 如需詳細資訊，請參閱[物件存留期事件](~/add/includes/ajax-current-ext-md.md)。      -**支援資料繫結和動態資源參考︰**屬性層級的支援資料繫結和資源實作由<xref:System.Windows.DependencyProperty>類別和屬性系統，但能夠解析成員值儲存為具體化<xref:System.Windows.Expression>（做為資料繫結和動態資源的程式設計建構） 藉由 FrameworkElement。</xref:System.Windows.Expression> </xref:System.Windows.DependencyProperty> 如需詳細資訊，請參閱[資料繫結概觀](~/add/includes/ajax-current-ext-md.md)和[XAML 資源](~/add/includes/ajax-current-ext-md.md)。      -**樣式︰** FrameworkElement 定義<xref:System.Windows.FrameworkElement.Style%2A>屬性。</xref:System.Windows.FrameworkElement.Style%2A> 不過，FrameworkElement 還不會定義支援範本，或支援裝飾項目。 控制項類別，例如<xref:System.Windows.Controls.Control>和<xref:System.Windows.Controls.ContentControl>.</xref:System.Windows.Controls.ContentControl></xref:System.Windows.Controls.Control>所導入這些功能      -**更多的動畫支援︰**某些動畫支援已定義在 WPF 核心層級，但 FrameworkElement 延伸此實作<xref:System.Windows.FrameworkElement.BeginStoryboard%2A>和相關的成員。</xref:System.Windows.FrameworkElement.BeginStoryboard%2A>       從類別階層架構，可以看出許多[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]從 FrameworkElement，直接或透過中繼的基底類別，例如<xref:System.Windows.Controls.Panel>或<xref:System.Windows.Controls.Control>.</xref:System.Windows.Controls.Control></xref:System.Windows.Controls.Panel>衍生的類別       如果您想要 FrameworkElement 做為基底類別，您可能想要先檢查現有的衍生的類別。 FrameworkElement 的基本案例中，提供支援，但也缺少一些功能 」 中的項目 」 的意義的建置組塊，用來建立適合[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]中[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]。 比方說，FrameworkElement 並未定義任何真實的內容模型。FrameworkElement 的基底類別不會定義可以建立內容[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]子項目。 特別是，您可能想要查看<xref:System.Windows.Controls.Control>和<xref:System.Windows.Controls.ContentControl>。</xref:System.Windows.Controls.ContentControl> </xref:System.Windows.Controls.Control>"
  syntax:
    content: >-
      [System.Windows.Markup.RuntimeNameProperty("Name")]

      [System.Windows.Markup.UsableDuringInitialization(true)]

      [System.Windows.Markup.XmlLangProperty("Language")]

      [System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))]

      public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.Media.Visual
  - System.Windows.UIElement
  implements:
  - System.ComponentModel.ISupportInitialize
  - System.Windows.IFrameworkInputElement
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Media.Visual.AddVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.FindCommonVisualAncestor(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsAncestorOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.IsDescendantOf(System.Windows.DependencyObject)
  - System.Windows.Media.Visual.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)
  - System.Windows.Media.Visual.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)
  - System.Windows.Media.Visual.PointFromScreen(System.Windows.Point)
  - System.Windows.Media.Visual.PointToScreen(System.Windows.Point)
  - System.Windows.Media.Visual.RemoveVisualChild(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Media3D.Visual3D)
  - System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToDescendant(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.TransformToVisual(System.Windows.Media.Visual)
  - System.Windows.Media.Visual.VisualBitmapEffect
  - System.Windows.Media.Visual.VisualBitmapEffectInput
  - System.Windows.Media.Visual.VisualBitmapScalingMode
  - System.Windows.Media.Visual.VisualCacheMode
  - System.Windows.Media.Visual.VisualClearTypeHint
  - System.Windows.Media.Visual.VisualClip
  - System.Windows.Media.Visual.VisualEdgeMode
  - System.Windows.Media.Visual.VisualEffect
  - System.Windows.Media.Visual.VisualOffset
  - System.Windows.Media.Visual.VisualOpacity
  - System.Windows.Media.Visual.VisualOpacityMask
  - System.Windows.Media.Visual.VisualParent
  - System.Windows.Media.Visual.VisualScrollableAreaClip
  - System.Windows.Media.Visual.VisualTextHintingMode
  - System.Windows.Media.Visual.VisualTextRenderingMode
  - System.Windows.Media.Visual.VisualTransform
  - System.Windows.Media.Visual.VisualXSnappingGuidelines
  - System.Windows.Media.Visual.VisualYSnappingGuidelines
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  - System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.AllowDrop
  - System.Windows.UIElement.AllowDropProperty
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.AreAnyTouchesCaptured
  - System.Windows.UIElement.AreAnyTouchesCapturedProperty
  - System.Windows.UIElement.AreAnyTouchesCapturedWithin
  - System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty
  - System.Windows.UIElement.AreAnyTouchesDirectlyOver
  - System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty
  - System.Windows.UIElement.AreAnyTouchesOver
  - System.Windows.UIElement.AreAnyTouchesOverProperty
  - System.Windows.UIElement.Arrange(System.Windows.Rect)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.UIElement.BitmapEffect
  - System.Windows.UIElement.BitmapEffectInput
  - System.Windows.UIElement.BitmapEffectInputProperty
  - System.Windows.UIElement.BitmapEffectProperty
  - System.Windows.UIElement.CacheMode
  - System.Windows.UIElement.CacheModeProperty
  - System.Windows.UIElement.CaptureMouse
  - System.Windows.UIElement.CaptureStylus
  - System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.Clip
  - System.Windows.UIElement.ClipProperty
  - System.Windows.UIElement.ClipToBounds
  - System.Windows.UIElement.ClipToBoundsProperty
  - System.Windows.UIElement.CommandBindings
  - System.Windows.UIElement.DesiredSize
  - System.Windows.UIElement.DragEnter
  - System.Windows.UIElement.DragEnterEvent
  - System.Windows.UIElement.DragLeave
  - System.Windows.UIElement.DragLeaveEvent
  - System.Windows.UIElement.DragOver
  - System.Windows.UIElement.DragOverEvent
  - System.Windows.UIElement.Drop
  - System.Windows.UIElement.DropEvent
  - System.Windows.UIElement.Effect
  - System.Windows.UIElement.EffectProperty
  - System.Windows.UIElement.Focus
  - System.Windows.UIElement.Focusable
  - System.Windows.UIElement.FocusableChanged
  - System.Windows.UIElement.FocusableProperty
  - System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.UIElement.GiveFeedback
  - System.Windows.UIElement.GiveFeedbackEvent
  - System.Windows.UIElement.GotFocus
  - System.Windows.UIElement.GotFocusEvent
  - System.Windows.UIElement.GotKeyboardFocus
  - System.Windows.UIElement.GotKeyboardFocusEvent
  - System.Windows.UIElement.GotMouseCapture
  - System.Windows.UIElement.GotMouseCaptureEvent
  - System.Windows.UIElement.GotStylusCapture
  - System.Windows.UIElement.GotStylusCaptureEvent
  - System.Windows.UIElement.GotTouchCapture
  - System.Windows.UIElement.GotTouchCaptureEvent
  - System.Windows.UIElement.HasAnimatedProperties
  - System.Windows.UIElement.HasEffectiveKeyboardFocus
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)
  - System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)
  - System.Windows.UIElement.InputBindings
  - System.Windows.UIElement.InputHitTest(System.Windows.Point)
  - System.Windows.UIElement.InvalidateArrange
  - System.Windows.UIElement.InvalidateMeasure
  - System.Windows.UIElement.InvalidateVisual
  - System.Windows.UIElement.IsArrangeValid
  - System.Windows.UIElement.IsEnabled
  - System.Windows.UIElement.IsEnabledChanged
  - System.Windows.UIElement.IsEnabledCore
  - System.Windows.UIElement.IsEnabledProperty
  - System.Windows.UIElement.IsFocused
  - System.Windows.UIElement.IsFocusedProperty
  - System.Windows.UIElement.IsHitTestVisible
  - System.Windows.UIElement.IsHitTestVisibleChanged
  - System.Windows.UIElement.IsHitTestVisibleProperty
  - System.Windows.UIElement.IsInputMethodEnabled
  - System.Windows.UIElement.IsKeyboardFocused
  - System.Windows.UIElement.IsKeyboardFocusedChanged
  - System.Windows.UIElement.IsKeyboardFocusedProperty
  - System.Windows.UIElement.IsKeyboardFocusWithin
  - System.Windows.UIElement.IsKeyboardFocusWithinChanged
  - System.Windows.UIElement.IsKeyboardFocusWithinProperty
  - System.Windows.UIElement.IsManipulationEnabled
  - System.Windows.UIElement.IsManipulationEnabledProperty
  - System.Windows.UIElement.IsMeasureValid
  - System.Windows.UIElement.IsMouseCaptured
  - System.Windows.UIElement.IsMouseCapturedChanged
  - System.Windows.UIElement.IsMouseCapturedProperty
  - System.Windows.UIElement.IsMouseCaptureWithin
  - System.Windows.UIElement.IsMouseCaptureWithinChanged
  - System.Windows.UIElement.IsMouseCaptureWithinProperty
  - System.Windows.UIElement.IsMouseDirectlyOver
  - System.Windows.UIElement.IsMouseDirectlyOverChanged
  - System.Windows.UIElement.IsMouseDirectlyOverProperty
  - System.Windows.UIElement.IsMouseOver
  - System.Windows.UIElement.IsMouseOverProperty
  - System.Windows.UIElement.IsStylusCaptured
  - System.Windows.UIElement.IsStylusCapturedChanged
  - System.Windows.UIElement.IsStylusCapturedProperty
  - System.Windows.UIElement.IsStylusCaptureWithin
  - System.Windows.UIElement.IsStylusCaptureWithinChanged
  - System.Windows.UIElement.IsStylusCaptureWithinProperty
  - System.Windows.UIElement.IsStylusDirectlyOver
  - System.Windows.UIElement.IsStylusDirectlyOverChanged
  - System.Windows.UIElement.IsStylusDirectlyOverProperty
  - System.Windows.UIElement.IsStylusOver
  - System.Windows.UIElement.IsStylusOverProperty
  - System.Windows.UIElement.IsVisible
  - System.Windows.UIElement.IsVisibleChanged
  - System.Windows.UIElement.IsVisibleProperty
  - System.Windows.UIElement.KeyDown
  - System.Windows.UIElement.KeyDownEvent
  - System.Windows.UIElement.KeyUp
  - System.Windows.UIElement.KeyUpEvent
  - System.Windows.UIElement.LayoutUpdated
  - System.Windows.UIElement.LostFocus
  - System.Windows.UIElement.LostFocusEvent
  - System.Windows.UIElement.LostKeyboardFocus
  - System.Windows.UIElement.LostKeyboardFocusEvent
  - System.Windows.UIElement.LostMouseCapture
  - System.Windows.UIElement.LostMouseCaptureEvent
  - System.Windows.UIElement.LostStylusCapture
  - System.Windows.UIElement.LostStylusCaptureEvent
  - System.Windows.UIElement.LostTouchCapture
  - System.Windows.UIElement.LostTouchCaptureEvent
  - System.Windows.UIElement.ManipulationBoundaryFeedback
  - System.Windows.UIElement.ManipulationBoundaryFeedbackEvent
  - System.Windows.UIElement.ManipulationCompleted
  - System.Windows.UIElement.ManipulationCompletedEvent
  - System.Windows.UIElement.ManipulationDelta
  - System.Windows.UIElement.ManipulationDeltaEvent
  - System.Windows.UIElement.ManipulationInertiaStarting
  - System.Windows.UIElement.ManipulationInertiaStartingEvent
  - System.Windows.UIElement.ManipulationStarted
  - System.Windows.UIElement.ManipulationStartedEvent
  - System.Windows.UIElement.ManipulationStarting
  - System.Windows.UIElement.ManipulationStartingEvent
  - System.Windows.UIElement.Measure(System.Windows.Size)
  - System.Windows.UIElement.MouseDown
  - System.Windows.UIElement.MouseDownEvent
  - System.Windows.UIElement.MouseEnter
  - System.Windows.UIElement.MouseEnterEvent
  - System.Windows.UIElement.MouseLeave
  - System.Windows.UIElement.MouseLeaveEvent
  - System.Windows.UIElement.MouseLeftButtonDown
  - System.Windows.UIElement.MouseLeftButtonDownEvent
  - System.Windows.UIElement.MouseLeftButtonUp
  - System.Windows.UIElement.MouseLeftButtonUpEvent
  - System.Windows.UIElement.MouseMove
  - System.Windows.UIElement.MouseMoveEvent
  - System.Windows.UIElement.MouseRightButtonDown
  - System.Windows.UIElement.MouseRightButtonDownEvent
  - System.Windows.UIElement.MouseRightButtonUp
  - System.Windows.UIElement.MouseRightButtonUpEvent
  - System.Windows.UIElement.MouseUp
  - System.Windows.UIElement.MouseUpEvent
  - System.Windows.UIElement.MouseWheel
  - System.Windows.UIElement.MouseWheelEvent
  - System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)
  - System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)
  - System.Windows.UIElement.OnCreateAutomationPeer
  - System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)
  - System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)
  - System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)
  - System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)
  - System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)
  - System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)
  - System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)
  - System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  - System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)
  - System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.UIElement.Opacity
  - System.Windows.UIElement.OpacityMask
  - System.Windows.UIElement.OpacityMaskProperty
  - System.Windows.UIElement.OpacityProperty
  - System.Windows.UIElement.PersistId
  - System.Windows.UIElement.PreviewDragEnter
  - System.Windows.UIElement.PreviewDragEnterEvent
  - System.Windows.UIElement.PreviewDragLeave
  - System.Windows.UIElement.PreviewDragLeaveEvent
  - System.Windows.UIElement.PreviewDragOver
  - System.Windows.UIElement.PreviewDragOverEvent
  - System.Windows.UIElement.PreviewDrop
  - System.Windows.UIElement.PreviewDropEvent
  - System.Windows.UIElement.PreviewGiveFeedback
  - System.Windows.UIElement.PreviewGiveFeedbackEvent
  - System.Windows.UIElement.PreviewGotKeyboardFocus
  - System.Windows.UIElement.PreviewGotKeyboardFocusEvent
  - System.Windows.UIElement.PreviewKeyDown
  - System.Windows.UIElement.PreviewKeyDownEvent
  - System.Windows.UIElement.PreviewKeyUp
  - System.Windows.UIElement.PreviewKeyUpEvent
  - System.Windows.UIElement.PreviewLostKeyboardFocus
  - System.Windows.UIElement.PreviewLostKeyboardFocusEvent
  - System.Windows.UIElement.PreviewMouseDown
  - System.Windows.UIElement.PreviewMouseDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonDown
  - System.Windows.UIElement.PreviewMouseLeftButtonDownEvent
  - System.Windows.UIElement.PreviewMouseLeftButtonUp
  - System.Windows.UIElement.PreviewMouseLeftButtonUpEvent
  - System.Windows.UIElement.PreviewMouseMove
  - System.Windows.UIElement.PreviewMouseMoveEvent
  - System.Windows.UIElement.PreviewMouseRightButtonDown
  - System.Windows.UIElement.PreviewMouseRightButtonDownEvent
  - System.Windows.UIElement.PreviewMouseRightButtonUp
  - System.Windows.UIElement.PreviewMouseRightButtonUpEvent
  - System.Windows.UIElement.PreviewMouseUp
  - System.Windows.UIElement.PreviewMouseUpEvent
  - System.Windows.UIElement.PreviewMouseWheel
  - System.Windows.UIElement.PreviewMouseWheelEvent
  - System.Windows.UIElement.PreviewQueryContinueDrag
  - System.Windows.UIElement.PreviewQueryContinueDragEvent
  - System.Windows.UIElement.PreviewStylusButtonDown
  - System.Windows.UIElement.PreviewStylusButtonDownEvent
  - System.Windows.UIElement.PreviewStylusButtonUp
  - System.Windows.UIElement.PreviewStylusButtonUpEvent
  - System.Windows.UIElement.PreviewStylusDown
  - System.Windows.UIElement.PreviewStylusDownEvent
  - System.Windows.UIElement.PreviewStylusInAirMove
  - System.Windows.UIElement.PreviewStylusInAirMoveEvent
  - System.Windows.UIElement.PreviewStylusInRange
  - System.Windows.UIElement.PreviewStylusInRangeEvent
  - System.Windows.UIElement.PreviewStylusMove
  - System.Windows.UIElement.PreviewStylusMoveEvent
  - System.Windows.UIElement.PreviewStylusOutOfRange
  - System.Windows.UIElement.PreviewStylusOutOfRangeEvent
  - System.Windows.UIElement.PreviewStylusSystemGesture
  - System.Windows.UIElement.PreviewStylusSystemGestureEvent
  - System.Windows.UIElement.PreviewStylusUp
  - System.Windows.UIElement.PreviewStylusUpEvent
  - System.Windows.UIElement.PreviewTextInput
  - System.Windows.UIElement.PreviewTextInputEvent
  - System.Windows.UIElement.PreviewTouchDown
  - System.Windows.UIElement.PreviewTouchDownEvent
  - System.Windows.UIElement.PreviewTouchMove
  - System.Windows.UIElement.PreviewTouchMoveEvent
  - System.Windows.UIElement.PreviewTouchUp
  - System.Windows.UIElement.PreviewTouchUpEvent
  - System.Windows.UIElement.QueryContinueDrag
  - System.Windows.UIElement.QueryContinueDragEvent
  - System.Windows.UIElement.QueryCursor
  - System.Windows.UIElement.QueryCursorEvent
  - System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)
  - System.Windows.UIElement.ReleaseAllTouchCaptures
  - System.Windows.UIElement.ReleaseMouseCapture
  - System.Windows.UIElement.ReleaseStylusCapture
  - System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  - System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.UIElement.RenderSize
  - System.Windows.UIElement.RenderTransform
  - System.Windows.UIElement.RenderTransformOrigin
  - System.Windows.UIElement.RenderTransformOriginProperty
  - System.Windows.UIElement.RenderTransformProperty
  - System.Windows.UIElement.ShouldSerializeCommandBindings
  - System.Windows.UIElement.ShouldSerializeInputBindings
  - System.Windows.UIElement.SnapsToDevicePixels
  - System.Windows.UIElement.SnapsToDevicePixelsProperty
  - System.Windows.UIElement.StylusButtonDown
  - System.Windows.UIElement.StylusButtonDownEvent
  - System.Windows.UIElement.StylusButtonUp
  - System.Windows.UIElement.StylusButtonUpEvent
  - System.Windows.UIElement.StylusDown
  - System.Windows.UIElement.StylusDownEvent
  - System.Windows.UIElement.StylusEnter
  - System.Windows.UIElement.StylusEnterEvent
  - System.Windows.UIElement.StylusInAirMove
  - System.Windows.UIElement.StylusInAirMoveEvent
  - System.Windows.UIElement.StylusInRange
  - System.Windows.UIElement.StylusInRangeEvent
  - System.Windows.UIElement.StylusLeave
  - System.Windows.UIElement.StylusLeaveEvent
  - System.Windows.UIElement.StylusMove
  - System.Windows.UIElement.StylusMoveEvent
  - System.Windows.UIElement.StylusOutOfRange
  - System.Windows.UIElement.StylusOutOfRangeEvent
  - System.Windows.UIElement.StylusPlugIns
  - System.Windows.UIElement.StylusSystemGesture
  - System.Windows.UIElement.StylusSystemGestureEvent
  - System.Windows.UIElement.StylusUp
  - System.Windows.UIElement.StylusUpEvent
  - System.Windows.UIElement.TextInput
  - System.Windows.UIElement.TextInputEvent
  - System.Windows.UIElement.TouchDown
  - System.Windows.UIElement.TouchDownEvent
  - System.Windows.UIElement.TouchEnter
  - System.Windows.UIElement.TouchEnterEvent
  - System.Windows.UIElement.TouchesCaptured
  - System.Windows.UIElement.TouchesCapturedWithin
  - System.Windows.UIElement.TouchesDirectlyOver
  - System.Windows.UIElement.TouchesOver
  - System.Windows.UIElement.TouchLeave
  - System.Windows.UIElement.TouchLeaveEvent
  - System.Windows.UIElement.TouchMove
  - System.Windows.UIElement.TouchMoveEvent
  - System.Windows.UIElement.TouchUp
  - System.Windows.UIElement.TouchUpEvent
  - System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)
  - System.Windows.UIElement.Uid
  - System.Windows.UIElement.UidProperty
  - System.Windows.UIElement.UpdateLayout
  - System.Windows.UIElement.Visibility
  - System.Windows.UIElement.VisibilityProperty
  platform:
  - net462
- uid: System.Windows.FrameworkElement.#ctor
  id: '#ctor'
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FrameworkElement()
  nameWithType: FrameworkElement.FrameworkElement()
  fullName: System.Windows.FrameworkElement.FrameworkElement()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>類別。"
  syntax:
    content: public FrameworkElement ();
    parameters: []
  overload: System.Windows.FrameworkElement.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualHeight
  id: ActualHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
  fullName: System.Windows.FrameworkElement.ActualHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得這個項目的呈現的高度。"
  remarks: "這個屬性是其他高度輸入和版面配置系統為基礎的導出的值。 值，由配置系統本身，根據實際呈現階段，並可能因此落後稍微設定值的屬性例如<xref:System.Windows.FrameworkElement.Height%2A>所輸入變更的基礎。</xref:System.Windows.FrameworkElement.Height%2A>       因為 ActualHeight 是計算的值，您應該注意可能有多個，或累加變更，各種作業之後所報告的版面配置系統。 版面配置系統可能會計算所需的量值的空間項目子系、 條件約束的父項目，依此類推。       雖然您無法設定此屬性從[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]，您可以根據<xref:System.Windows.Trigger>樣式中的值。</xref:System.Windows.Trigger>      <a name=&quot;dependencyPropertyInfo_ActualHeight&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  |中繼資料屬性設定為`true`|None |</xref:System.Windows.FrameworkElement.ActualHeightProperty>"
  example:
  - "The following example displays various height properties.  \n  \n [!code-cs[HeightMinHeightMaxHeight#3](~/add/codesnippet/csharp/Height_MinHeight_MaxHeight_CSharp/Window1.xaml.cs#3)]\n [!code-vb[HeightMinHeightMaxHeight#3](~/add/codesnippet/visualbasic/Height_MinHeight_MaxHeight/Window1.xaml.vb#3)]"
  syntax:
    content: public double ActualHeight { get; }
    return:
      type: System.Double
      description: "項目的高度，以值[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]。 預設值為 0 （零）。"
  overload: System.Windows.FrameworkElement.ActualHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualHeightProperty
  id: ActualHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualHeightProperty
  nameWithType: FrameworkElement.ActualHeightProperty
  fullName: System.Windows.FrameworkElement.ActualHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.ActualHeight*>相依性屬性。</xref:System.Windows.FrameworkElement.ActualHeight*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ActualHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualWidth
  id: ActualWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
  fullName: System.Windows.FrameworkElement.ActualWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得這個項目的呈現的寬度。"
  remarks: "這個屬性是其他寬度輸入和版面配置系統為基礎的導出的值。 值，由配置系統本身，根據實際呈現階段，並可能因此落後稍微設定值的屬性例如<xref:System.Windows.FrameworkElement.Width%2A>所輸入變更的基礎。</xref:System.Windows.FrameworkElement.Width%2A>       因為 ActualWidth 是計算的值，您應該注意可能有多個，或累加變更，各種作業之後所報告的版面配置系統。 版面配置系統可能會計算所需的量值的空間項目子系、 條件約束的父項目，依此類推。       雖然您無法設定此屬性從[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]，您可以根據<xref:System.Windows.Trigger>樣式中的值。</xref:System.Windows.Trigger>      <a name=&quot;dependencyPropertyInfo_ActualWidth&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  |中繼資料屬性設定為`true`|None |</xref:System.Windows.FrameworkElement.ActualWidthProperty>"
  example:
  - "The following example displays various width properties.  \n  \n [!code-vb[WidthMinWidthMaxWidth#3](~/add/codesnippet/visualbasic/Width_MinWidth_MaxWidth/Window1.xaml.vb#3)]\n [!code-cs[WidthMinWidthMaxWidth#3](~/add/codesnippet/csharp/Width_MinWidth_MaxWidth_CSharp/Window1.xaml.cs#3)]"
  syntax:
    content: public double ActualWidth { get; }
    return:
      type: System.Double
      description: "項目的寬度，以值[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]。 預設值為 0 （零）。"
  overload: System.Windows.FrameworkElement.ActualWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ActualWidthProperty
  id: ActualWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ActualWidthProperty
  nameWithType: FrameworkElement.ActualWidthProperty
  fullName: System.Windows.FrameworkElement.ActualWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.ActualWidth*>相依性屬性。</xref:System.Windows.FrameworkElement.ActualWidth*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ActualWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  id: AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: AddLogicalChild(Object)
  nameWithType: FrameworkElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.AddLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "將所提供的物件加入至這個項目的邏輯樹狀結構。"
  remarks: "使用這個方法的物件，代表項目的邏輯子項目集合的實作。 屬性 getter 或 setter，處理已變更事件，建構函式，或將集合型別本身內的類別可能透過集合維護的子元素的集合。       控制作者的處理邏輯樹狀結構，此層級不是建議的作法，除非可用控制項的基底類別的內容模型都適用於程式控制項案例。 請考慮在層級的子類別化<xref:System.Windows.Controls.ContentControl>， <xref:System.Windows.Controls.ItemsControl>，和<xref:System.Windows.Controls.HeaderedItemsControl>。</xref:System.Windows.Controls.HeaderedItemsControl> </xref:System.Windows.Controls.ItemsControl> </xref:System.Windows.Controls.ContentControl> 這些類別提供特定的強制執行的邏輯樹狀結構子項目，透過專用的內容模型[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]，以及通常希望出現在其他功能的支援[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]控制項，例如透過範本的樣式。 如需有關如何使用<xref:System.Windows.FrameworkElement.LogicalChildren%2A>和 AddLogicalChild，請參閱[中 WPF 樹狀架構](~/add/includes/ajax-current-ext-md.md)。</xref:System.Windows.FrameworkElement.LogicalChildren%2A>       AddLogicalChild 可能擲回例外狀況，如果呼叫時之邏輯樹狀結構正在反覆執行另一個處理序一次。"
  example:
  - "The following example implements a `Child` property on a custom <xref:System.Windows.FrameworkElement> that does its own visual layer implementation. The property setter is designed so that if the value changes, the old value is removed from the logical tree, as well as a class-specific visual collection. The property value is cached, and then the new value is added to both the logical tree and the custom visual collection.  \n  \n [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/visualbasic/compositiontargetrenderinganimations/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]\n [!code-cs[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/csharp/CompositionTargetRenderingAnimations/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]"
  syntax:
    content: protected void AddLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "要加入的子項目。"
  overload: System.Windows.FrameworkElement.AddLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ApplyTemplate
  id: ApplyTemplate
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ApplyTemplate()
  nameWithType: FrameworkElement.ApplyTemplate()
  fullName: System.Windows.FrameworkElement.ApplyTemplate()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "建置目前範本的視覺化樹狀結構，如有必要，並傳回值，指出此呼叫是否已重建視覺化樹狀結構。"
  remarks: "應用程式可以呼叫這個方法，以保證視覺化樹狀結構項目的已完成。 此保證步驟可能需要如果程式碼會檢查樹狀結構中的子項目。 典型的項目邏輯的應用程式中，呼叫 ApplyTemplate 並非必要，因為範本將會在適當的時間點的項目在其存留期自動套用。       每個量值上呼叫 ApplyTemplate 傳 WPF 架構層級配置系統。       <xref:System.Windows.FrameworkElement>在衍生的類別可以使用<xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>的情況下，明確地呼叫這個方法後，或由配置系統通知的類別處理常式。</xref:System.Windows.FrameworkElement.OnApplyTemplate%2A></xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>是範本完全產生，並附加至邏輯樹狀結構後呼叫。</xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>"
  syntax:
    content: public bool ApplyTemplate ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果視覺項目已加入到樹狀結構。傳回<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>否則。"
  overload: System.Windows.FrameworkElement.ApplyTemplate*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  id: ArrangeCore(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ArrangeCore(Rect)
  nameWithType: FrameworkElement.ArrangeCore(Rect)
  fullName: System.Windows.FrameworkElement.ArrangeCore(Rect)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "實作<xref:System.Windows.UIElement.ArrangeCore*>(定義為在虛擬<xref href=&quot;System.Windows.UIElement&quot;> </xref>) 和根據實作。</xref:System.Windows.UIElement.ArrangeCore*>"
  remarks: "這個方法是密封格式。 若要覆寫項目配置，您的<xref:System.Windows.FrameworkElement>衍生的類別必須覆寫<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.</xref:System.Windows.FrameworkElement.ArrangeOverride%2A></xref:System.Windows.FrameworkElement>的排列傳遞特別針對您自訂項目中的邏輯"
  syntax:
    content: protected override sealed void ArrangeCore (System.Windows.Rect finalRect);
    parameters:
    - id: finalRect
      type: System.Windows.Rect
      description: "這個項目應該用來排列本身和其子系之父系內的最終區域。"
  overload: System.Windows.FrameworkElement.ArrangeCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  id: ArrangeOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ArrangeOverride(Size)
  nameWithType: FrameworkElement.ArrangeOverride(Size)
  fullName: System.Windows.FrameworkElement.ArrangeOverride(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "在衍生類別中覆寫，放置子項目，並決定的大小<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>衍生的類別。"
  syntax:
    content: protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);
    parameters:
    - id: finalSize
      type: System.Windows.Size
      description: "這個項目應該用來排列本身和其子系之父系內的最終區域。"
    return:
      type: System.Windows.Size
      description: "使用的實際大小。"
  overload: System.Windows.FrameworkElement.ArrangeOverride*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginInit
  id: BeginInit
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginInit()
  nameWithType: FrameworkElement.BeginInit()
  fullName: System.Windows.FrameworkElement.BeginInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "啟動初始化處理程序的這個項目。"
  remarks: "如果您正在調整它們的方式仍未公開或連線到任何項目樹狀結構項目，您可以在個別的項目上呼叫這個方法。 比方說，您可能已建立新<xref:System.Windows.FrameworkElement>，但不是尚未將它附加到任何邏輯樹狀結構。</xref:System.Windows.FrameworkElement> 或者，您的項目所在的子元素，在其中之邏輯樹狀結構可能未連線至視窗或應用程式頁面。"
  syntax:
    content: public virtual void BeginInit ();
    parameters: []
  overload: System.Windows.FrameworkElement.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "開始所提供的分鏡腳本中所包含的動作順序。"
  remarks: "最常見的動畫案例不會使用這個方法。 通常您會建立<xref:System.Windows.Media.Animation.Storyboard>或<xref:System.Windows.Media.Animation.BeginStoryboard>元素標記，然後再將這些做為<xref:System.Windows.EventTrigger>內容項目上。</xref:System.Windows.EventTrigger> </xref:System.Windows.Media.Animation.BeginStoryboard> </xref:System.Windows.Media.Animation.Storyboard> 事件所觸發，動畫就會執行。 在控制方面的大部分<xref:System.Windows.Media.Animation.Storyboard>標記中公開的屬性可以定址。</xref:System.Windows.Media.Animation.Storyboard>       請勿使用簽章`isControllable`，參數，或指定該參數時， `false`，一旦動畫到達&quot;填滿 」 期間，會移除相關聯的動畫時間軸時鐘。 因此動畫無法重新啟動之後執行一次。 控制動畫也必須要有分鏡腳本[X:name 指示詞](~/add/includes/ajax-current-ext-md.md)或可供程式碼中參考。"
  example:
  - "The following example retrieves a <xref:System.Windows.Media.Animation.Storyboard> from resources, and then runs that <xref:System.Windows.Media.Animation.Storyboard> when an internal event is class handled.  \n  \n [!code-vb[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/visualbasic/cubeanimation_xbap/page1.xaml.vb#febeginstoryboard)]\n [!code-cs[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/csharp/CubeAnimation_XBAP/Page1.xaml.cs#febeginstoryboard)]"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "若要開始分鏡腳本。"
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "開始使用選項指定如果屬性已有動畫效果要採取的動作中提供的分鏡腳本，包含的動作順序。"
  remarks: "最常見的動畫案例不會使用這個方法。 通常您會建立<xref:System.Windows.Media.Animation.Storyboard>或<xref:System.Windows.Media.Animation.BeginStoryboard>元素標記，然後再將這些做為<xref:System.Windows.EventTrigger>內容項目上。</xref:System.Windows.EventTrigger> </xref:System.Windows.Media.Animation.BeginStoryboard> </xref:System.Windows.Media.Animation.Storyboard> 事件所觸發，動畫就會執行。 在控制方面的大部分<xref:System.Windows.Media.Animation.Storyboard>標記中公開的屬性可以定址。</xref:System.Windows.Media.Animation.Storyboard>       請勿使用簽章`isControllable`，參數，或指定該參數時， `false`，一旦動畫到達&quot;填滿 」 期間，會移除相關聯的動畫時間軸時鐘。 因此動畫無法重新啟動之後執行一次。 控制動畫也必須要有分鏡腳本[X:name 指示詞](~/add/includes/ajax-current-ext-md.md)或可供程式碼中參考。       遞移式行為可指定為<xref:System.Windows.Media.Animation.BeginStoryboard>.</xref:System.Windows.Media.Animation.BeginStoryboard>的屬性      ## 撰寫 HandoffBehavior 時使用您套用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>屬性使用<xref:System.Windows.Media.Animation.HandoffBehavior><xref:System.Windows.Media.Animation.HandoffBehavior>，任何<xref:System.Windows.Media.Animation.Clock>之前與該屬性相關聯的物件會繼續耗用系統資源; 計時系統不會自動移除時鐘。</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       若要避免發生效能問題，當您藉由套用大量時鐘<xref:System.Windows.Media.Animation.HandoffBehavior>，在它們完成之後，您應該從動畫屬性移除組成的時鐘。</xref:System.Windows.Media.Animation.HandoffBehavior> 有數種方式可移除時鐘:-若要從屬性移除所有時鐘，請使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>動畫物件的方法。</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 指定的第一個參數，要繪製之屬性和`null`做為第二個。 這會從屬性移除所有動畫時鐘。      -若要移除<xref:System.Windows.Media.Animation.AnimationClock>的時鐘，清單中使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>屬性<xref:System.Windows.Media.Animation.AnimationClock>來擷取<xref:System.Windows.Media.Animation.ClockController>，然後呼叫此<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法的<xref:System.Windows.Media.Animation.ClockController>。</xref:System.Windows.Media.Animation.ClockController></xref:System.Windows.Media.Animation.ClockController.Remove%2A></xref:System.Windows.Media.Animation.ClockController></xref:System.Windows.Media.Animation.AnimationClock></xref:System.Windows.Media.Animation.Clock.Controller%2A></xref:System.Windows.Media.Animation.AnimationClock>特定 這通常是<xref:System.Windows.Media.Animation.Clock.Completed>時鐘的事件處理常式。</xref:System.Windows.Media.Animation.Clock.Completed> 請注意，只有根時鐘可以控制<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>子時鐘的屬性會傳回`null`。</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> 也請注意，<xref:System.Windows.Media.Animation.Clock.Completed>是否有效的持續時間的時鐘永遠不會引發事件。</xref:System.Windows.Media.Animation.Clock.Completed>  在此情況下，使用者必須決定何時呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       這是主要的動畫長的存留期的物件上的問題。  記憶體回收物件時，也會中斷其時鐘和記憶體回收。       如需時鐘物件的詳細資訊，請參閱[動畫和計時系統概觀](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example retrieves a <xref:System.Windows.Media.Animation.Storyboard> from resources, and then runs that <xref:System.Windows.Media.Animation.Storyboard> when an internal event is class handled.  \n  \n [!code-vb[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/visualbasic/cubeanimation_xbap/page1.xaml.vb#febeginstoryboard)]\n [!code-cs[CubeAnimation#FEBeginStoryboard](~/add/codesnippet/csharp/CubeAnimation_XBAP/Page1.xaml.cs#febeginstoryboard)]"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "若要開始分鏡腳本。"
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "描述使用分鏡腳本中所述的屬性已有動畫效果的行為在列舉值。"
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "開始提供分鏡腳本的指定控制項的動畫啟動之後的狀態中包含的動作順序。"
  remarks: "最常見的動畫案例不會使用這個方法。 通常您會建立<xref:System.Windows.Media.Animation.Storyboard>或<xref:System.Windows.Media.Animation.BeginStoryboard>元素標記，然後再將這些做為<xref:System.Windows.EventTrigger>內容項目上。</xref:System.Windows.EventTrigger> </xref:System.Windows.Media.Animation.BeginStoryboard> </xref:System.Windows.Media.Animation.Storyboard> 事件所觸發，動畫就會執行。 在控制方面的大部分<xref:System.Windows.Media.Animation.Storyboard>標記中公開的屬性可以定址。</xref:System.Windows.Media.Animation.Storyboard>       請勿使用簽章`isControllable`，參數，或指定該參數時， `false`，一旦動畫到達&quot;填滿 」 期間，會移除相關聯的動畫時間軸時鐘。 因此動畫無法重新啟動之後執行一次。 控制動畫也必須要有分鏡腳本[X:name 指示詞](~/add/includes/ajax-current-ext-md.md)或可供程式碼中參考。       遞移式行為可指定為<xref:System.Windows.Media.Animation.BeginStoryboard>.</xref:System.Windows.Media.Animation.BeginStoryboard>的屬性      ## 撰寫 HandoffBehavior 時使用您套用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>屬性使用<xref:System.Windows.Media.Animation.HandoffBehavior><xref:System.Windows.Media.Animation.HandoffBehavior>，任何<xref:System.Windows.Media.Animation.Clock>之前與該屬性相關聯的物件會繼續耗用系統資源; 計時系統不會自動移除時鐘。</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       若要避免發生效能問題，當您藉由套用大量時鐘<xref:System.Windows.Media.Animation.HandoffBehavior>，在它們完成之後，您應該從動畫屬性移除組成的時鐘。</xref:System.Windows.Media.Animation.HandoffBehavior> 有數種方式可移除時鐘:-若要從屬性移除所有時鐘，請使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>動畫物件的方法。</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 指定的第一個參數，要繪製之屬性和`null`做為第二個。 這會從屬性移除所有動畫時鐘。      -若要移除<xref:System.Windows.Media.Animation.AnimationClock>的時鐘，清單中使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>屬性<xref:System.Windows.Media.Animation.AnimationClock>來擷取<xref:System.Windows.Media.Animation.ClockController>，然後呼叫此<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法的<xref:System.Windows.Media.Animation.ClockController>。</xref:System.Windows.Media.Animation.ClockController></xref:System.Windows.Media.Animation.ClockController.Remove%2A></xref:System.Windows.Media.Animation.ClockController></xref:System.Windows.Media.Animation.AnimationClock></xref:System.Windows.Media.Animation.Clock.Controller%2A></xref:System.Windows.Media.Animation.AnimationClock>特定 這通常是<xref:System.Windows.Media.Animation.Clock.Completed>時鐘的事件處理常式。</xref:System.Windows.Media.Animation.Clock.Completed> 請注意，只有根時鐘可以控制<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>子時鐘的屬性會傳回`null`。</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> 也請注意，<xref:System.Windows.Media.Animation.Clock.Completed>是否有效的持續時間的時鐘永遠不會引發事件。</xref:System.Windows.Media.Animation.Clock.Completed>  在此情況下，使用者必須決定何時呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       這是主要的動畫長的存留期的物件上的問題。  記憶體回收物件時，也會中斷其時鐘和記憶體回收。       如需時鐘物件的詳細資訊，請參閱[動畫和計時系統概觀](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "若要開始分鏡腳本。"
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "描述使用分鏡腳本中所述的屬性已有動畫效果的行為在列舉值。"
    - id: isControllable
      type: System.Boolean
      description: "宣告動畫是否可控制 （暫停） 啟動後。"
  overload: System.Windows.FrameworkElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BindingGroup
  id: BindingGroup
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
  fullName: System.Windows.FrameworkElement.BindingGroup
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定<xref href=&quot;System.Windows.Data.BindingGroup&quot;></xref>所用的項目。"
  remarks: "A<xref:System.Windows.Data.BindingGroup>可以用來驗證物件的多個屬性的值。</xref:System.Windows.Data.BindingGroup> 例如，假設應用程式會提示使用者輸入的位址，然後填入型別的物件`Address`，其中包含屬性`Street`， `City`， `ZipCode`，和`Country`，與使用者提供的值。 應用程式必須包含四個面板<xref:System.Windows.Controls.TextBox>控制項，其中每個繫結至其中一個物件的屬性。</xref:System.Windows.Controls.TextBox> 您可以使用<xref:System.Windows.Controls.ValidationRule>中<xref:System.Windows.Data.BindingGroup>驗證`Address`物件。</xref:System.Windows.Data.BindingGroup> </xref:System.Windows.Controls.ValidationRule> 例如，<xref:System.Windows.Controls.ValidationRule>可以確保，郵遞區號就是有效的地址的國家/地區。</xref:System.Windows.Controls.ValidationRule>       子項目會繼承<xref:System.Windows.Data.BindingGroup>從其父項目，就如同任何其他可繼承的屬性。</xref:System.Windows.Data.BindingGroup>      <a name=&quot;dependencyPropertyInfo_BindingGroup&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  |中繼資料屬性設定為**true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.BindingGroupProperty>"
  example:
  - "The following examples are part of an application that checks whether the user has set the properties of two objects to equal values. The first example creates two <xref:System.Windows.Controls.TextBox> controls, each of which is bound to a different data source. The <xref:System.Windows.Controls.StackPanel> has a <xref:System.Windows.Data.BindingGroup> that contains a <xref:System.Windows.Controls.ValidationRule> that checks that the two strings are equal.  \n  \n [!code-xml[BindingGroupSnippets#BindingGroupComplete](~/add/codesnippet/xaml/BindingGroupSnippets/Window3.xaml#bindinggroupcomplete)]  \n  \n The following example shows the <xref:System.Windows.Controls.ValidationRule> that the previous example uses.  In the <xref:System.Windows.Controls.ValidationRule.Validate%2A> method override, the example gets each source object from the <xref:System.Windows.Data.BindingGroup> and checks whether the properties of the objects are equal.  \n  \n [!code-cs[BindingGroupSnippets#BindingGroupNameValidationRule](~/add/codesnippet/csharp/BindingGroupSnippets/Window3.xaml.cs#bindinggroupnamevalidationrule)]\n [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/add/codesnippet/visualbasic/bindinggroupsnippets/window3.xaml.vb#bindinggroupnamevalidationrule)]  \n  \n To invoke the <xref:System.Windows.Controls.ValidationRule>, call the <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> method.  The following example calls <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> when the click event of the button occurs.  \n  \n [!code-cs[BindingGroupSnippets#UpdateSourcesClick](~/add/codesnippet/csharp/BindingGroupSnippets/Window3.xaml.cs#updatesourcesclick)]\n [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/add/codesnippet/visualbasic/bindinggroupsnippets/window3.xaml.vb#updatesourcesclick)]"
  syntax:
    content: public System.Windows.Data.BindingGroup BindingGroup { get; set; }
    return:
      type: System.Windows.Data.BindingGroup
      description: "<xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref>所用的項目。"
  overload: System.Windows.FrameworkElement.BindingGroup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BindingGroupProperty
  id: BindingGroupProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BindingGroupProperty
  nameWithType: FrameworkElement.BindingGroupProperty
  fullName: System.Windows.FrameworkElement.BindingGroupProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.BindingGroup*>相依性屬性。</xref:System.Windows.FrameworkElement.BindingGroup*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty BindingGroupProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BringIntoView
  id: BringIntoView
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BringIntoView()
  nameWithType: FrameworkElement.BringIntoView()
  fullName: System.Windows.FrameworkElement.BringIntoView()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "嘗試將這個項目帶入檢視中，它包含在任何可捲動區域內。"
  remarks: "藉由呼叫這個方法，您將提高<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件來自 目前的項目。</xref:System.Windows.FrameworkElement.RequestBringIntoView> 會引發這個事件，以便可由處理<xref:System.Windows.Controls.ScrollViewer>，或衍生或類似類別</xref:System.Windows.Controls.ScrollViewer> 預期的行為是，父項目，標示為已處理的事件資料，在處理事件和事件的來源資料被引進的邏輯內嵌在透過檢視<xref:System.Windows.Controls.ScrollViewer>控制項。</xref:System.Windows.Controls.ScrollViewer> 既不<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件或 BringIntoView 方法傳輸相關的成功或失敗，而不是，事件通常是標示為成功處理上的任何資訊。</xref:System.Windows.FrameworkElement.RequestBringIntoView> 失敗的原因可包含的項目設定，例如<xref:System.Windows.UIElement.Visibility%2A>位於某些<xref:System.Windows.Visibility>.</xref:System.Windows.Visibility>以外的值</xref:System.Windows.UIElement.Visibility%2A>       如果您使用未指定的簽章`targetRectangle`，然後整個項目大小 (其<xref:System.Windows.UIElement.RenderSize%2A>) 將會看見。</xref:System.Windows.UIElement.RenderSize%2A>       藉由呼叫這個方法，您可能會呼叫<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>上包含之項目的任何父可捲動區域。</xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> 如果這個項目不包含在可捲動區域，<xref:System.Windows.FrameworkElement.RequestBringIntoView>仍然會引發事件，但沒有作用，因為會不有任何事件接聽程式。</xref:System.Windows.FrameworkElement.RequestBringIntoView>"
  example:
  - "The following example implements a handler for an application navigation event that responds whenever the [!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)] being navigated to includes a fragment. The fragment is named in the [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)] following the hash sign (#), and the implemented behavior causes the element to scroll into view within the frame. BringIntoView and <xref:System.Windows.FrameworkElement.RequestBringIntoView> request that scrolling behavior in the example.  \n  \n [!code-vb[FragmentNavigationSample#FEBringIntoView](~/add/codesnippet/visualbasic/FragmentNavigationSampleVisualBasic/MainWindow.xaml.vb#febringintoview)]\n [!code-cs[FragmentNavigationSample#FEBringIntoView](~/add/codesnippet/csharp/FragmentNavigationSample/MainWindow.xaml.cs#febringintoview)]"
  syntax:
    content: public void BringIntoView ();
    parameters: []
  overload: System.Windows.FrameworkElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  id: BringIntoView(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: BringIntoView(Rect)
  nameWithType: FrameworkElement.BringIntoView(Rect)
  fullName: System.Windows.FrameworkElement.BringIntoView(Rect)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "嘗試將帶入檢視中，它包含在任何可捲動區域內的這個項目提供的區域大小。"
  remarks: "藉由呼叫這個方法，您將提高<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件來自 目前的項目。</xref:System.Windows.FrameworkElement.RequestBringIntoView> 會引發這個事件，以便可由處理<xref:System.Windows.Controls.ScrollViewer>，或衍生或類似類別</xref:System.Windows.Controls.ScrollViewer> 預期的行為是，父項目，標示為已處理的事件資料，在處理事件和事件的來源資料被引進的邏輯內嵌在透過檢視<xref:System.Windows.Controls.ScrollViewer>控制項。</xref:System.Windows.Controls.ScrollViewer> 既不<xref:System.Windows.FrameworkElement.RequestBringIntoView>事件和<xref:System.Windows.FrameworkElement.BringIntoView%2A>方法傳輸相關的成功或失敗，而不是，事件通常是標示為成功處理上的任何資訊。</xref:System.Windows.FrameworkElement.BringIntoView%2A> </xref:System.Windows.FrameworkElement.RequestBringIntoView> 失敗的原因可包含的項目設定，例如<xref:System.Windows.UIElement.Visibility%2A>位於某些<xref:System.Windows.Visibility>.</xref:System.Windows.Visibility>以外的值</xref:System.Windows.UIElement.Visibility%2A>       如果您使用未指定的簽章`targetRectangle`，然後整個項目大小 (其<xref:System.Windows.UIElement.RenderSize%2A>) 將會看見。</xref:System.Windows.UIElement.RenderSize%2A>       藉由呼叫這個方法，您可能會呼叫<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>上包含之項目的任何父可捲動區域。</xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> 如果這個項目不包含在可捲動區域，<xref:System.Windows.FrameworkElement.RequestBringIntoView>仍然會引發事件，但沒有作用，因為會不有任何事件接聽程式。</xref:System.Windows.FrameworkElement.RequestBringIntoView>"
  example:
  - "The following example has a large graphic in a constrained scrolling region. A button on the page has a handler that scrolls the view to a particular region of the large graphic.  \n  \n [!code-xml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/add/codesnippet/xaml/BaseElementsSmorgasbord/Page1.xaml#bringintoviewrectmarkup)]  \n  \n [!code-cs[BaseElementsSmorgasbord#BringIntoViewRectCode](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#bringintoviewrectcode)]\n [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#bringintoviewrectcode)]"
  syntax:
    content: public void BringIntoView (System.Windows.Rect targetRectangle);
    parameters:
    - id: targetRectangle
      type: System.Windows.Rect
      description: "指定的項目也帶入檢視的大小。"
  overload: System.Windows.FrameworkElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenu
  id: ContextMenu
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
  fullName: System.Windows.FrameworkElement.ContextMenu
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定透過要求的操作功能表時應該出現操作功能表項目的[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]從這個項目中。"
  remarks: "<xref:System.Windows.Controls.ContextMenu>本身是<xref:System.Windows.FrameworkElement>衍生類別，而且是可行的<xref:System.Windows.Controls.ContextMenu>本身具有 ContextMenu 屬性。</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.FrameworkElement></xref:System.Windows.Controls.ContextMenu> 不過，這會建立令人混淆的內容功能表經驗的使用者並不建議此做法。      <a name=&quot;dependencyPropertyInfo_ContextMenu&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  |中繼資料屬性設定為`true`|None |</xref:System.Windows.FrameworkElement.ContextMenuProperty>"
  syntax:
    content: public System.Windows.Controls.ContextMenu ContextMenu { get; set; }
    return:
      type: System.Windows.Controls.ContextMenu
      description: "指派給此項目的操作功能表。"
  overload: System.Windows.FrameworkElement.ContextMenu*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuClosing
  id: ContextMenuClosing
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuClosing
  nameWithType: FrameworkElement.ContextMenuClosing
  fullName: System.Windows.FrameworkElement.ContextMenuClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "項目上的任何操作功能表關閉之前發生。"
  remarks: "若要隱藏關閉內容功能表的 事件處理常式應將其標記為已處理。       若要使用此事件為<xref:System.Windows.EventTrigger>在樣式中，您必須參考事件的基礎服務定義︰ [!code-xml [CorePseudocode #FEContextMenuClosing](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuclosing) ] (需要這種使用方式，因為上的事件實作<xref:System.Windows.FrameworkElement>會公開基礎服務事件，您可以使用它的觸發程序未對應的 ContextMenuClosing 識別項)。</xref:System.Windows.FrameworkElement> </xref:System.Windows.EventTrigger>       <xref:System.Windows.Controls.ContextMenu>本身是<xref:System.Windows.FrameworkElement>衍生的類別，但 ContextMenuClosing 將不會引發此事件的內容功能表直接。</xref:System.Windows.FrameworkElement></xref:System.Windows.Controls.ContextMenu> 相反地，會引發事件，從 「 擁有 」 做為屬性的內容功能表，且只會在使用者嘗試以關閉在 UI 中的內容功能表時所引發的項目。 但是它可能是<xref:System.Windows.Controls.ContextMenu>本身有<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性 （巢狀的內容功能表）。</xref:System.Windows.FrameworkElement.ContextMenu%2A> </xref:System.Windows.Controls.ContextMenu> 在此情況下<xref:System.Windows.Controls.ContextMenu>實際上並擁有巢狀<xref:System.Windows.Controls.ContextMenu>然後可能會引發事件，與正在巢狀的內容功能表上的事件來源。</xref:System.Windows.Controls.ContextMenu> </xref:System.Windows.Controls.ContextMenu>       <xref:System.Windows.Controls.ContextMenu>類別本身也有類似的事件 (<xref:System.Windows.Controls.ContextMenu.Closed>) 但<xref:System.Windows.Controls.ContextMenu.Closed>事件不會為您提供取消的使用者動作的機會。</xref:System.Windows.Controls.ContextMenu.Closed> </xref:System.Windows.Controls.ContextMenu.Closed> </xref:System.Windows.Controls.ContextMenu>      <a name=&quot;routedEventInfo_ContextMenuClosing&quot;></a># # 路由事件資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  |路由策略 |反昇 |  |委派 |<xref:System.Windows.Controls.ContextMenuEventHandler>|     -覆寫<xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A>實作在衍生類別中這個事件的類別處理。</xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A> </xref:System.Windows.Controls.ContextMenuEventHandler> </xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuClosingEvent
  id: ContextMenuClosingEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuClosingEvent
  nameWithType: FrameworkElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkElement.ContextMenuClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref href=&quot;System.Windows.FrameworkElement.ContextMenuClosing&quot;></xref>路由的事件。"
  remarks: "註冊路由的事件時，會建立路由的事件識別項。 這些識別碼包含識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。 您可以使用這些識別項來加入類別處理常式。       如需註冊路由的事件的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 如需使用路由的事件識別項來加入類別處理常式的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuOpening
  id: ContextMenuOpening
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuOpening
  nameWithType: FrameworkElement.ContextMenuOpening
  fullName: System.Windows.FrameworkElement.ContextMenuOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "項目上的任何操作功能表開啟時發生。"
  remarks: "若要手動開啟內容功能表，為已處理的事件處理常式時，應該標記相關的事件。 否則，現有的值<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性會用來自動開啟內容功能表。</xref:System.Windows.FrameworkElement.ContextMenu%2A> 標記處理的事件會有效地取消的預設動作，並可能得以重設的<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性，然後開啟新的<xref:System.Windows.Controls.ContextMenu>。</xref:System.Windows.Controls.ContextMenu></xref:System.Windows.FrameworkElement.ContextMenu%2A>的值 不過，是您應該注意的時間問題。 為了完全取代透過 ContextMenuOpening 處理常式的內容功能表，初始的內容功能表不得為 null 或空白。 或者，您可能需要處理事件，並手動開啟新的內容功能表。 如需詳細資訊，請參閱[如何︰ 處理 ContextMenuOpening 事件](~/add/includes/ajax-current-ext-md.md)。       若要使用此事件為<xref:System.Windows.EventTrigger>在樣式中，您必須參考基礎的附加的事件︰ [!code-xml [CorePseudocode #FEContextMenuOpening](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuopening) ] (需要這種使用方式，因為上的事件實作<xref:System.Windows.FrameworkElement>會公開基礎服務事件，您可以將它使用觸發程序中沒有對應 ContextMenuOpening 識別項)。</xref:System.Windows.FrameworkElement> </xref:System.Windows.EventTrigger>       <xref:System.Windows.Controls.ContextMenu>本身是<xref:System.Windows.FrameworkElement>衍生的類別，但不是會從內容功能表開啟做為來源引發這個事件。</xref:System.Windows.FrameworkElement></xref:System.Windows.Controls.ContextMenu> 從 「 擁有 」 做為屬性的內容功能表，且只會在使用者嘗試在 UI 中開啟內容功能表時所引發的項目，會引發事件。 可能會<xref:System.Windows.Controls.ContextMenu>本身有<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性，但是您應該避免這種情況 (如需詳細資訊，請參閱<xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=fullName>)。</xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=fullName> </xref:System.Windows.FrameworkElement.ContextMenu%2A> </xref:System.Windows.Controls.ContextMenu>       <xref:System.Windows.Controls.ContextMenu>類別本身也有類似的事件 (<xref:System.Windows.Controls.ContextMenu.Opened>) 但<xref:System.Windows.Controls.ContextMenu.Opened>不會為您提供取消的使用者動作的機會。</xref:System.Windows.Controls.ContextMenu.Opened> </xref:System.Windows.Controls.ContextMenu.Opened> </xref:System.Windows.Controls.ContextMenu>      <a name=&quot;routedEventInfo_ContextMenuOpening&quot;></a># # 路由事件資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  |路由策略 |反昇 |  |委派 |<xref:System.Windows.Controls.ContextMenuEventHandler>|     -覆寫<xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A>實作在衍生類別中這個事件的類別處理。</xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A> </xref:System.Windows.Controls.ContextMenuEventHandler> </xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  id: ContextMenuOpeningEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref href=&quot;System.Windows.FrameworkElement.ContextMenuOpening&quot;></xref>路由的事件。"
  remarks: "註冊路由的事件時，會建立路由的事件識別項。 這些識別碼包含識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。 您可以使用這些識別項來加入類別處理常式。       如需註冊路由的事件的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 如需使用路由的事件識別項來加入類別處理常式的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ContextMenuProperty
  id: ContextMenuProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ContextMenuProperty
  nameWithType: FrameworkElement.ContextMenuProperty
  fullName: System.Windows.FrameworkElement.ContextMenuProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.ContextMenu*>相依性屬性。</xref:System.Windows.FrameworkElement.ContextMenu*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ContextMenuProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Cursor
  id: Cursor
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Cursor
  nameWithType: FrameworkElement.Cursor
  fullName: System.Windows.FrameworkElement.Cursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定當滑鼠指標位於此項目上方時所顯示的游標。"
  remarks: "當您設定此屬性[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]處理器依賴的型別轉換<xref:System.Windows.Input.Cursor>類別來評估的字串。</xref:System.Windows.Input.Cursor> 提供的字串應評估為<xref:System.Windows.Input.CursorType>值。</xref:System.Windows.Input.CursorType> 請參閱<xref:System.Windows.Input.Cursor>如需詳細資訊。</xref:System.Windows.Input.Cursor>       這個屬性所建立的資料指標將還是不會顯示當滑鼠指標位在這個項目也是取決於值的<xref:System.Windows.FrameworkElement.ForceCursor%2A>屬性。</xref:System.Windows.FrameworkElement.ForceCursor%2A> 此外，事件相關的考量，例如使用中拖曳滑鼠擷取、 文字編輯模式中的控制項，並依此類推，也會影響資料指標具有較高的優先順序比您指定這個屬性的值。       若要還原的此屬性設定為最終的預設行為，將它設定為`null`一次。       `null`預設真的表示實際的資料指標的值判斷此處延後，應該從別處取得。 如果看到不含以程式設計方式從任何來源的值，預設資料指標，是以視覺化方式超過[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]應用程式將會箭號。 不過，暫時性游標會變更未設定為資料指標的值的項目時透過傳送。 屬性只會報告中的非 null 值的資料指標狀況下，它是實際設定，例如透過程式碼或樣式。 每次移動滑鼠停留[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]應用程式引發<xref:System.Windows.UIElement.QueryCursor>事件。</xref:System.Windows.UIElement.QueryCursor> 事件反昇，且此路由上的任何項目都有機會處理事件，並設定資料指標到這個事件的引數的值。 這是會產生在大部分情況下以視覺化方式明顯的資料指標的機制。 如果<xref:System.Windows.UIElement.QueryCursor>處理常式傳回一個資料指標結果，則事件處理，而且引數中已變更的值優先順序高於在任何層級中，資料指標屬性的值除非<xref:System.Windows.FrameworkElement.ForceCursor%2A>設定。</xref:System.Windows.FrameworkElement.ForceCursor%2A> </xref:System.Windows.UIElement.QueryCursor>       您如果不建立自訂的資料指標，通常有設定此屬性設為靜態屬性的值<xref:System.Windows.Input.Cursors>類別。</xref:System.Windows.Input.Cursors> 程式碼中設定資料指標需要下列其中之一:-呼叫<xref:System.Windows.Input.Cursor>建構函式來取得<xref:System.Windows.Input.Cursor>執行個體。</xref:System.Windows.Input.Cursor> </xref:System.Windows.Input.Cursor> 這兩個簽章<xref:System.Windows.Input.Cursor>建構函式使用資料流或檔案，您所建立的頁數<xref:System.Windows.Input.Cursor>自訂的資料指標的物件。</xref:System.Windows.Input.Cursor> </xref:System.Windows.Input.Cursor>      -使用<xref:System.Windows.Input.CursorConverter>類別和其<xref:System.Windows.Input.CursorConverter.ConvertFrom%2A>方法，以指定的資料指標<xref:System.Windows.Input.CursorType>，或可以評估為字串<xref:System.Windows.Input.CursorType>，並轉換至<xref:System.Windows.Input.Cursor>。</xref:System.Windows.Input.Cursor>傳回</xref:System.Windows.Input.CursorType></xref:System.Windows.Input.CursorType></xref:System.Windows.Input.CursorConverter.ConvertFrom%2A></xref:System.Windows.Input.CursorConverter>       設定<xref:System.Windows.Input.Cursor>自訂值中未啟用部分信任。</xref:System.Windows.Input.Cursor> 如需有關自訂的資料指標的詳細資訊，請參閱[輸入概觀](~/add/includes/ajax-current-ext-md.md)。      <a name=&quot;dependencyPropertyInfo_Cursor&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.CursorProperty>|  |中繼資料屬性設定為`true`|None |</xref:System.Windows.FrameworkElement.CursorProperty>"
  example:
  - "The following example shows how to deliberately set the cursor graphic.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public System.Windows.Input.Cursor Cursor { get; set; }
    return:
      type: System.Windows.Input.Cursor
      description: "要顯示的游標。 預設值定義為<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>每個此相依性屬性。 不過，實際的預設值，在執行階段將來自各種不同的因素。"
  overload: System.Windows.FrameworkElement.Cursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.CursorProperty
  id: CursorProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: CursorProperty
  nameWithType: FrameworkElement.CursorProperty
  fullName: System.Windows.FrameworkElement.CursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.Cursor*>相依性屬性。</xref:System.Windows.FrameworkElement.Cursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty CursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContext
  id: DataContext
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContext
  nameWithType: FrameworkElement.DataContext
  fullName: System.Windows.FrameworkElement.DataContext
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定參與資料繫結中時的資料內容的項目。"
  remarks: "*資料內容*是一種概念，可讓項目繼承其父項目，用於繫結，以及其他特性，例如路徑繫結的資料來源的相關資訊。       資料內容設為直接[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]物件，並將該物件的內容來評估的繫結。 或者，您可以將資料內容設<xref:System.Windows.Data.DataSourceProvider>物件。</xref:System.Windows.Data.DataSourceProvider>       這個相依性屬性會繼承屬性值。 如果有子項目不含 DataContext 透過本機值或樣式建立的其他值，對屬性系統將會設定要指派此值與最接近的父元素的 DataContext 值的值。       或者，您可以使用下列的屬性之一<xref:System.Windows.Data.Binding>類別來明確指定繫結來源︰ <xref:System.Windows.Data.Binding.ElementName%2A>， <xref:System.Windows.Data.Binding.Source%2A>，或<xref:System.Windows.Data.Binding.RelativeSource%2A>.</xref:System.Windows.Data.Binding.RelativeSource%2A> </xref:System.Windows.Data.Binding.Source%2A> </xref:System.Windows.Data.Binding.ElementName%2A> </xref:System.Windows.Data.Binding> 如需詳細資訊，請參閱[How to︰ 指定的繫結來源](~/add/includes/ajax-current-ext-md.md)。       在[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]，DataContext 大部分都是設為<xref:System.Windows.Data.Binding>宣告。</xref:System.Windows.Data.Binding> 您可以使用屬性項目語法或屬性語法。 在範例中，此頁面上顯示屬性語法。 您也可以使用程式碼，若要設定 DataContext。       DataContext 是可繫結的屬性，以便在其中一個內容可能繫結至另一個案例。 不過，如果您繫結到 DataContext，小心建立循環繫結參考 （請不要繫結 DataContext 本身，也就是基於 DataContext 屬性的屬性值繼承本質這麼做）。      <a name=&quot;xamlPropertyElementUsage_DataContext&quot;></a># # XAML 屬性項目用法```   <object>     <object.DataContext>       <dataContextObject />     </object.DataContext>   </object>   ``` <a name=&quot;xamlAttributeUsage_DataContext&quot;> </a> # # XAML 屬性使用方式```   <object DataContext=&quot;bindingUsage&quot;/>   - or -   <object DataContext=&quot;{resourceExtension contextResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_DataContext&quot;> </a> # # XAML 值*dataContextObject*直接內嵌的物件做為父項目中的任何繫結的資料內容。             一般而言，這個物件是<xref:System.Windows.Data.Binding>或另一個<xref:System.Windows.Data.BindingBase>衍生類別。</xref:System.Windows.Data.BindingBase> </xref:System.Windows.Data.Binding> 或者，任何未經處理資料[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]物件適用於繫結，可能會放在這裡，以實際的繫結稍後所定義的類型。       *bindingUsage*評估為適當的資料內容的繫結使用方式。 如需詳細資訊，請參閱[繫結標記延伸](~/add/includes/ajax-current-ext-md.md)。       *resourceExtension*下列其中之一︰ 或。 定義為資源中之物件的未經處理資料時，就會使用這種使用方式。 請參閱[XAML 資源](~/add/includes/ajax-current-ext-md.md)。       *contextResourceKey* <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>內從所要求之物件的金鑰識別碼      <a name=&quot;dependencyPropertyInfo_DataContext&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.DataContextProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.DataContextProperty>"
  example:
  - "The following example illustrates how a data context acts on a binding and provides the information that defines the specific values of bound properties.  \n  \n [!code-xml[MasterDetail#DataContextProperty](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty)]  \n[!code-xml[MasterDetail#DataContextProperty2](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty2)]  \n[!code-xml[MasterDetail#DataContextProperty3](~/add/codesnippet/xaml/MasterDetail/Page1.xaml#datacontextproperty3)]"
  syntax:
    content: public object DataContext { get; set; }
    return:
      type: System.Object
      description: "要做為資料內容的物件。"
  overload: System.Windows.FrameworkElement.DataContext*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContextChanged
  id: DataContextChanged
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContextChanged
  nameWithType: FrameworkElement.DataContextChanged
  fullName: System.Windows.FrameworkElement.DataContextChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "此元素的資料內容變更時發生。"
  remarks: "如需資料內容和資料繫結的說明，請參閱[資料繫結概觀](~/add/includes/ajax-current-ext-md.md)。      > [!IMPORTANT] > 時<xref:System.Windows.FrameworkElement.DataContext%2A>潛在影響的項目變更時，這個項目上的所有資料繫結屬性。</xref:System.Windows.FrameworkElement.DataContext%2A> 這適用於任何項目邏輯樹狀結構中，目前項目的子項目繼承的資料內容，以及目前的項目本身。 所有這類的現有繫結必須重新解譯新<xref:System.Windows.FrameworkElement.DataContext%2A>並會重新評估繫結結果。</xref:System.Windows.FrameworkElement.DataContext%2A> 資料繫結引擎不具決定性的這些處，相對於 DataContextChanged 事件的引發順序。 重新評估可能可以事件之前、 發生事件之後，或以任何混合。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DataContextProperty
  id: DataContextProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DataContextProperty
  nameWithType: FrameworkElement.DataContextProperty
  fullName: System.Windows.FrameworkElement.DataContextProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.DataContext*>相依性屬性。</xref:System.Windows.FrameworkElement.DataContext*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty DataContextProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DefaultStyleKey
  id: DefaultStyleKey
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
  fullName: System.Windows.FrameworkElement.DefaultStyleKey
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定要用來使用或定義佈景主題樣式時參考這個控制項的樣式的索引鍵。"
  remarks: "這個屬性通常是透過其直接屬性存取子的任何不設定。 相反地，您覆寫這個相依性屬性的特定類型的中繼資料每次您建立<xref:System.Windows.FrameworkElement>衍生之類別的</xref:System.Windows.FrameworkElement>新 當您衍生的控制項時，呼叫<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>方法針對<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>控制項中的靜態建構函式中的識別項，衍生類別 （或對等的類別初始化）。</xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> </xref:System.Windows.DependencyProperty.OverrideMetadata%2A>       控制項通常會覆寫它自己的型別，這個屬性的預設值，但在某些情況下也可以使用基底類型有主題字典中的樣式。 如果基底控制項的 [控制項] 範本已完整定義該衍生的控制項的視覺表示法，而且衍生的型別公開的任何其他成員不需要額外的項目控制項範本的一部分，這樣做只實際。       如果您想要您的項目或故意不使用佈景主題樣式的控制項，設定<xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>屬性`true`。</xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A>      <a name=&quot;dependencyPropertyInfo_DefaultStyleKey&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>"
  example:
  - "The following example illustrates the dependency property metadata override usage discussed in Remarks. This code defines a custom control class `NumericUpDown` intended to be used from a dedicated control library assembly. The illustrated static constructor references some private initialization function, registers a class handler (another common control subclassing scenario; see [Marking Routed Events as Handled, and Class Handling](~/add/includes/ajax-current-ext-md.md)) and finally overrides the DefaultStyleKey dependency property metadata on the `NumericUpDown` class. DefaultStyleKey always returns its own type as the intended key, which is the convention that the theme style system uses to look up the style for some arbitrary otherwise non-styled control. The complete sample also defines the actual control's theme style that is referenced by that key; see [NumericUpDown Custom Control with Theme and UI Automation Support Sample](http://go.microsoft.com/fwlink/?LinkID=160025).  \n  \n [!code-cs[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/add/codesnippet/csharp/CustomControlLibrary/NumericUpDown.cs#staticctorofcustomclasscommontasks)]\n [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/add/codesnippet/visualbasic/customcontrollibrary/numericupdown.vb#staticctorofcustomclasscommontasks)]  \n[!code-cs[CustomControlNumericUpDown#Close](~/add/codesnippet/csharp/CustomControlLibrary/NumericUpDown.cs#close)]\n[!code-vb[CustomControlNumericUpDown#Close](~/add/codesnippet/visualbasic/customcontrollibrary/numericupdown.vb#close)]"
  syntax:
    content: protected object DefaultStyleKey { get; set; }
    return:
      type: System.Object
      description: "樣式索引鍵。 佈景主題樣式查閱一部分正常運作，這個值必須是<xref:System.Type>要加上樣式的控制項。</xref:System.Type>"
  overload: System.Windows.FrameworkElement.DefaultStyleKey*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  id: DefaultStyleKeyProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.DefaultStyleKey*>相依性屬性。</xref:System.Windows.FrameworkElement.DefaultStyleKey*>"
  syntax:
    content: protected static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.EndInit
  id: EndInit
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: EndInit()
  nameWithType: FrameworkElement.EndInit()
  fullName: System.Windows.FrameworkElement.EndInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "表示初始化程序項目的已完成。"
  remarks: "如果<xref:System.Windows.FrameworkElement.BeginInit%2A>之前已呼叫過，基底實作將會引發<xref:System.Windows.FrameworkElement.Initialized>事件。</xref:System.Windows.FrameworkElement.Initialized> </xref:System.Windows.FrameworkElement.BeginInit%2A> 否則，如果<xref:System.Windows.FrameworkElement.BeginInit%2A>，不會呼叫或找不取決於是否<xref:System.Windows.FrameworkElement.BeginInit%2A>已呼叫<xref:System.Windows.FrameworkElement.Initialized>就不會引發，並改為擲回例外狀況。</xref:System.Windows.FrameworkElement.Initialized> </xref:System.Windows.FrameworkElement.BeginInit%2A> </xref:System.Windows.FrameworkElement.BeginInit%2A>"
  syntax:
    content: public virtual void EndInit ();
    parameters: []
  overload: System.Windows.FrameworkElement.EndInit*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "呼叫 EndInit，但沒有<xref:System.Windows.FrameworkElement.BeginInit*>先前項目上呼叫。</xref:System.Windows.FrameworkElement.BeginInit*>"
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FindName(System.String)
  id: FindName(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FindName(String)
  nameWithType: FrameworkElement.FindName(String)
  fullName: System.Windows.FrameworkElement.FindName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "尋找具有所提供的識別項名稱的項目。"
  remarks: "如果項目具有子項目，這些子項目會遞迴搜尋所有要求的具名項目。       FindName 命名目前的項目範圍中的運作方式。 如需詳細資訊，請參閱[WPF XAML Namescopes](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public object FindName (string name);
    parameters:
    - id: name
      type: System.String
      description: "要求之項目的名稱。"
    return:
      type: System.Object
      description: "要求的項目。 這可以是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果找不到任何相符的元素。"
  overload: System.Windows.FrameworkElement.FindName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: FrameworkElement.FindResource(Object)
  fullName: System.Windows.FrameworkElement.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "搜尋具有指定的索引鍵的資源，並擲回例外狀況，如果找不到要求的資源。"
  remarks: "> [!IMPORTANT]> 如果找不到機碼中呼叫這個方法，會擲回例外狀況。 如果您不想處理的例外狀況所導致的呼叫 FindResource，呼叫<xref:System.Windows.FrameworkElement.TryFindResource%2A>改用。</xref:System.Windows.FrameworkElement.TryFindResource%2A> <xref:System.Windows.FrameworkElement.TryFindResource%2A>傳回`null`當找不到要求的資源，並不會擲回例外狀況。</xref:System.Windows.FrameworkElement.TryFindResource%2A>       如果呼叫的項目上找不到資源，父項目邏輯樹狀結構中是搜尋下一步，然後應用程式，然後佈景主題，和最後系統資源。 這項查閱方法等同於樹狀結構會如何搜尋如果所要求資源標記中動態資源參考。 如需資源查閱的詳細資訊，請參閱[XAML 資源](~/add/includes/ajax-current-ext-md.md)。       一般而言，您立即轉換的 FindResource，傳回值之屬性的型別您設定與傳回的資源。       資源索引鍵不一定是字串。 例如，樣式的佈景主題層級的控制項索引鍵，<xref:System.Type>的控制項，和應用程式或網頁的樣式的控制項通常會使用這個相同的金鑰慣例。</xref:System.Type> 如需詳細資訊，請參閱[設定樣式和範本](~/add/includes/ajax-current-ext-md.md)或[XAML 資源](../Topic/XAML%20Resources.md)。"
  example:
  - "The following example obtains a named resource and casts it to an appropriate type to fill a property.  \n  \n [!code-cs[PropertiesOvwSupport#ResourceProceduralGet](~/add/codesnippet/csharp/PropertiesOvwSupport/page3.xaml.cs#resourceproceduralget)]\n [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/add/codesnippet/visualbasic/propertiesovwsupport/page3.xaml.vb#resourceproceduralget)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "要求之資源的索引鍵的識別碼。"
    return:
      type: System.Object
      description: "要求的資源。 如果找不到具有提供之索引鍵的資源，則會擲回例外狀況。 <xref href=&quot;System.Windows.DependencyProperty.UnsetValue&quot;> </xref>也可能會在例外狀況的情況下傳回值。"
  overload: System.Windows.FrameworkElement.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "<code>resourceKey</code>找不到與事件處理常式不存在的<xref href=&quot;System.Windows.Threading.Dispatcher.UnhandledException&quot;></xref>事件。       -<code>resourceKey</code>找不到和<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled*>屬性是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>中<xref href=&quot;System.Windows.Threading.Dispatcher.UnhandledException&quot;></xref>事件。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceKey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FlowDirection
  id: FlowDirection
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
  fullName: System.Windows.FrameworkElement.FlowDirection
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定文字和其他的方向[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]流程控制其配置的任何父項目中的項目。"
  remarks: "The dependency property usage sets the FlowDirection on this element. Because of property value inheritance, setting FlowDirection on an element can potentially set FlowDirection on all child elements that did not set FlowDirection locally or though other means such as styles.  \n  \n This property is not automatically set as part of any application culture information, because an element might contain content that is not necessarily intended to obey the general flow direction implied by the culture information. For more information on globalization considerations, see [Globalization for WPF](~/add/includes/ajax-current-ext-md.md).  \n  \n This property has a defined [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] property accessor, so it functions as a dependency property. However, it is also registered as attached, so it can also function as an attached property. The attached registration is mainly so that property value inheritance is supported, but the property can also be used as a true attached property. The attached property usage is only relevant if the object you intend to set the flow direction on has a <xref:System.Windows.FrameworkElement> parent element that performs layout upon it, is itself not a <xref:System.Windows.FrameworkElement>, and does not already have a more directly defined `FlowDirection` property. (Some of the flow document classes such as <xref:System.Windows.Documents.Block> and <xref:System.Windows.Documents.Inline> define their own `FlowDirection`, and this property can also set the flow direction. The property value is then read by the eventual content host without requiring attached property usage.)  \n  \n<a name=\"xamlAttributeUsage_FlowDirection\"></a>   \n## XAML Attribute Usage  \n \\<*object* **FlowDirection**=\"<xref:System.Windows.FlowDirection>\"/>  \n  \n<a name=\"xamlTextUsage_FlowDirection\"></a>   \n## XAML Text Usage  \n This property can also be set on classes that are not <xref:System.Windows.FrameworkElement> derived classes, by the following [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] attached property usage:  \n  \n `<` *object* `FrameworkElement.`**FlowDirection**=\"<xref:System.Windows.FlowDirection>`\"/>`  \n  \n<a name=\"dependencyPropertyInfo_FlowDirection\"></a>   \n## Dependency Property Information  \n  \n|||  \n|-|-|  \n|Identifier field|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  \n|Metadata properties set to `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  \n  \n This property is both a dependency property and an attached property; see Remarks."
  syntax:
    content: public System.Windows.FlowDirection FlowDirection { get; set; }
    return:
      type: System.Windows.FlowDirection
      description: "方向文字和其他[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]項目中的流向其父項目，做為列舉值。 預設值是<xref href=&quot;System.Windows.FlowDirection&quot;> </xref>。"
  overload: System.Windows.FrameworkElement.FlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FlowDirectionProperty
  id: FlowDirectionProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FlowDirectionProperty
  nameWithType: FrameworkElement.FlowDirectionProperty
  fullName: System.Windows.FrameworkElement.FlowDirectionProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.FlowDirection*>相依性屬性。</xref:System.Windows.FrameworkElement.FlowDirection*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FlowDirectionProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FocusVisualStyle
  id: FocusVisualStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
  fullName: System.Windows.FrameworkElement.FocusVisualStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定此屬性，可自訂外觀、 效果或其他樣式特性，捕捉到鍵盤焦點時，會套用至這個項目。"
  remarks: "這個屬性會影響視覺外觀，但不會報告<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>中繼資料中。</xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> 這是因為視覺外觀變更是事件驅動和在任何時候，可能不適用，因此通常不應報告中繼資料中的任何視覺效果或版面配置資訊。       在概念上，套用至控制項的焦點視覺行為應該保持一致控制項。 如果您正在撰寫整個佈景主題，只變更焦點視覺化樣式為最實用的方式，來強制執行一致性。 設定這個屬性上個別控制項樣式，而非佈景主題的部分不是預定的使用方式，這個屬性，因為它可能會造成混淆的使用者經驗，關於鍵盤焦點。 如果您打算是刻意不一致的佈景主題的控制項特定行為，更好的方法是使用觸發程序在樣式為個別的輸入的狀態的屬性，例如<xref:System.Windows.UIElement.IsFocused%2A>或<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>，以及若要這樣做不以視覺化方式會干擾任何現有的焦點視覺化樣式的方式。</xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> </xref:System.Windows.UIElement.IsFocused%2A> FocusVisualStyle 和替代焦點屬性的設計用意的資訊，請參閱[樣式的焦點在控制項和 FocusVisualStyle](~/add/includes/ajax-current-ext-md.md)。      <a name=&quot;xamlAttributeUsage_FocusVisualStyle&quot;></a># # XAML 屬性使用方式```   <object FocusVisualStyle=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_FocusVisualStyle&quot;> </a> # # XAML 屬性項目用法<a name=&quot;xamlValues_FocusVisualStyle&quot;> </a> # # XAML 值*resourceExtension*下列其中之一:、 或。       請參閱[XAML 資源](~/add/includes/ajax-current-ext-md.md)。       *styleResourceKey*識別所要求的樣式的索引鍵。 索引鍵參考<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>中現有的資源      > [!NOTE] > 屬性項目語法是可行，但不是建議。 請參閱[內嵌樣式和樣板](~/add/includes/ajax-current-ext-md.md)。 使用繫結參考或<xref:System.Windows.Data.Binding>也是可行的但不常見。</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_FocusVisualStyle&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  |中繼資料屬性設定為`true`|None |</xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>"
  syntax:
    content: public System.Windows.Style FocusVisualStyle { get; set; }
    return:
      type: System.Windows.Style
      description: "若要將焦點套用樣式。 相依性屬性中所宣告的預設值是空的靜態<xref href=&quot;System.Windows.Style&quot;> </xref>。 不過，在執行階段有效的值是通常 （但並非一定） 提供佈景主題支援為控制項的樣式。"
  overload: System.Windows.FrameworkElement.FocusVisualStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.FocusVisualStyleProperty
  id: FocusVisualStyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: FocusVisualStyleProperty
  nameWithType: FrameworkElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkElement.FocusVisualStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.FocusVisualStyle*>相依性屬性。</xref:System.Windows.FrameworkElement.FocusVisualStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ForceCursor
  id: ForceCursor
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
  fullName: System.Windows.FrameworkElement.ForceCursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，指出是否此<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>應強制[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]來呈現所宣告的資料指標<xref:System.Windows.FrameworkElement.Cursor*>屬性。</xref:System.Windows.FrameworkElement.Cursor*>"
  remarks: "如果您將此屬性設定為`true`將會覆寫子項目所建立的資料指標喜好設定。 這樣做，一般應用程式[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]可能會造成混淆的使用者，特別是如果子元素嘗試以指定資料指標。 在控制項的子類別化或複合 （compositing） 的情況下更適合設定 ForceCursor。      <a name=&quot;dependencyPropertyInfo_ForceCursor&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  |中繼資料屬性設定為`true`|None |</xref:System.Windows.FrameworkElement.ForceCursorProperty>"
  example:
  - "The following example forces the cursor value.  \n  \n [!code-xml[ForceCursor#ForceCursor](~/add/codesnippet/xaml/forcecursor/default.xaml#forcecursor)]"
  syntax:
    content: public bool ForceCursor { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個項目上方的資料指標簡報強制使用目前<xref:System.Windows.FrameworkElement.Cursor*>設定資料指標 （包括所有子系項目上）; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Windows.FrameworkElement.Cursor*> 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkElement.ForceCursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ForceCursorProperty
  id: ForceCursorProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ForceCursorProperty
  nameWithType: FrameworkElement.ForceCursorProperty
  fullName: System.Windows.FrameworkElement.ForceCursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.ForceCursor*>相依性屬性。</xref:System.Windows.FrameworkElement.ForceCursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ForceCursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  id: GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkElement.GetBindingExpression(DependencyProperty)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "傳回<xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref> ，代表指定之屬性的繫結。"
  remarks: "檢查傳回值`null`是一種技術可用來判斷屬性是否有作用中的繫結。       這個方法是其實只是方便包裝<xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName>方法。</xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName> GetBindingExpression 傳遞目前執行個體和`dp`至<xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName>。</xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=fullName>參數"
  syntax:
    content: public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "目標<xref href=&quot;System.Windows.DependencyProperty&quot;></xref>取得從繫結。"
    return:
      type: System.Windows.Data.BindingExpression
      description: "A <xref href=&quot;System.Windows.Data.BindingExpression&quot;> </xref>如果目標屬性具有作用中的繫結; 否則會傳回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkElement.GetBindingExpression*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  id: GetFlowDirection(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetFlowDirection(DependencyObject)
  nameWithType: FrameworkElement.GetFlowDirection(DependencyObject)
  fullName: System.Windows.FrameworkElement.GetFlowDirection(DependencyObject)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得值<xref:System.Windows.FrameworkElement.FlowDirection*>附加屬性指定<xref href=&quot;System.Windows.DependencyObject&quot;> </xref>。</xref:System.Windows.FrameworkElement.FlowDirection*>"
  remarks: "這個方法的主要用途為支援附加的屬性的語法<xref:System.Windows.FrameworkElement.FlowDirection%2A>屬性，因此允許的提供項目子系<xref:System.Windows.FrameworkElement>以指定的排列方式，其父項目中的資料流程方向。</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement.FlowDirection%2A> 若要取得值，在目前<xref:System.Windows.FrameworkElement>，使用 direct[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]存取子<xref:System.Windows.FrameworkElement.FlowDirection%2A>.</xref:System.Windows.FrameworkElement.FlowDirection%2A> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);
    parameters:
    - id: element
      type: System.Windows.DependencyObject
      description: "要傳回<xref:System.Windows.FrameworkElement.FlowDirection*>for...in</xref:System.Windows.FrameworkElement.FlowDirection*>項目"
    return:
      type: System.Windows.FlowDirection
      description: "要求的資料流程方向，做為列舉值。"
  overload: System.Windows.FrameworkElement.GetFlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  id: GetLayoutClip(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetLayoutClip(Size)
  nameWithType: FrameworkElement.GetLayoutClip(Size)
  fullName: System.Windows.FrameworkElement.GetLayoutClip(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "傳回幾何裁剪遮罩。 版面配置系統嘗試排列大於可用的顯示空間的項目套用遮罩。"
  remarks: "將減去邊界`layoutSlotSize`版面配置系統行為的一部分。       傳回的 null 參考會指出沒有裁剪部分會發生。 預設實作一定會傳回`null`時<xref:System.Windows.UIElement.ClipToBounds%2A>是`false`。</xref:System.Windows.UIElement.ClipToBounds%2A> 這個方法會覆寫<xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=fullName>.</xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=fullName> <xref:System.Windows.FrameworkElement>實作會使用<xref:System.Windows.FrameworkElement.MaxHeight%2A>和<xref:System.Windows.FrameworkElement.MaxWidth%2A>在其計算中。</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement> 數個類別的子<xref:System.Windows.FrameworkElement>覆寫這個方法一次。</xref:System.Windows.FrameworkElement> <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=fullName>會覆寫永遠傳回`null`因為裝飾項通常會刻意一般範圍外。</xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=fullName> <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=fullName>and <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=fullName> return `null` if <xref:System.Windows.UIElement.ClipToBounds%2A> is `false`.</xref:System.Windows.UIElement.ClipToBounds%2A></xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=fullName></xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=fullName>"
  syntax:
    content: protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);
    parameters:
    - id: layoutSlotSize
      type: System.Windows.Size
      description: "視覺呈現的項目之部分的大小。"
    return:
      type: System.Windows.Media.Geometry
      description: "裁剪幾何。"
  overload: System.Windows.FrameworkElement.GetLayoutClip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetTemplateChild(System.String)
  id: GetTemplateChild(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetTemplateChild(String)
  nameWithType: FrameworkElement.GetTemplateChild(String)
  fullName: System.Windows.FrameworkElement.GetTemplateChild(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "傳回的具現化的視覺化樹狀結構中具名的項目<xref href=&quot;System.Windows.Controls.ControlTemplate&quot;> </xref>。"
  remarks: "中的範本[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]有獨立的名稱範圍。 這是因為樣板是重複使用，而且在範本中定義的任何名稱不能是唯一的當多個執行個體，每個控制項的具現化的範本。 呼叫 GetTemplateChild 方法來傳回來自樣板具現化後的物件參考。 您無法使用<xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>方法來尋找範本中的項目，因為<xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>扮演更常見的範圍，而且之間沒有連線<xref:System.Windows.Controls.ControlTemplate>類別本身和具現化的範本，一旦套用。</xref:System.Windows.Controls.ControlTemplate> </xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName> </xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=fullName>       <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>提供這個方法與相同的功能。</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName> <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>已受到保護而不是公用，並使用正確名稱範圍，使其得以存取的範本內的項目和尋找名為項目的考量。</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName> 使用<xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>當您需要取得其父控制項以外的項目。</xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=fullName>"
  syntax:
    content: protected System.Windows.DependencyObject GetTemplateChild (string childName);
    parameters:
    - id: childName
      type: System.String
      description: "若要尋找的子系的名稱。"
    return:
      type: System.Windows.DependencyObject
      description: "要求的項目。 可能是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果要求的名稱項目不存在。"
  overload: System.Windows.FrameworkElement.GetTemplateChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetUIParentCore
  id: GetUIParentCore
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetUIParentCore()
  nameWithType: FrameworkElement.GetUIParentCore()
  fullName: System.Windows.FrameworkElement.GetUIParentCore()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "如果沒有視覺父代，則傳回此項目的替代邏輯父。"
  remarks: "這個方法會覆寫<xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=fullName>.</xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=fullName> 預設值<xref:System.Windows.FrameworkElement>實作會傳回預期單一視覺化父項目，也就是相同的結果，以取得<xref:System.Windows.FrameworkElement.Parent%2A>值。</xref:System.Windows.FrameworkElement.Parent%2A> </xref:System.Windows.FrameworkElement> 在衍生的類別實作可能會傳回替代的父代關聯性。"
  syntax:
    content: protected override System.Windows.DependencyObject GetUIParentCore ();
    parameters: []
    return:
      type: System.Windows.DependencyObject
      description: "傳回的項目以外<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>每當這個方法的 WPF 架構層級實作具有非視覺父連線時。"
  overload: System.Windows.FrameworkElement.GetUIParentCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  id: GetVisualChild(System.Int32)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: GetVisualChild(Int32)
  nameWithType: FrameworkElement.GetVisualChild(Int32)
  fullName: System.Windows.FrameworkElement.GetVisualChild(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "覆寫&lt;xref:System.Windows.Media.Visual.GetVisualChild%2A?displayProperty=fullName&gt;，並從子項目集合傳回指定索引處的子系。"
  remarks: "在<xref:System.Windows.FrameworkElement>實作中，唯一有效的索引為零。</xref:System.Windows.FrameworkElement> 內容模型的 GetVisualChild 支援零個或一個子項目不是集合。"
  example:
  - "The following example shows how a custom adorner uses the values declared by a <xref:System.Windows.Media.VisualCollection> that it maintains for its multiple visual children. These values are reported through overrides of <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> and GetVisualChild.  \n  \n [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverridespre)]\n [!code-cs[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverridespre)]  \n[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverrides)]\n[!code-cs[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverrides)]"
  syntax:
    content: protected override System.Windows.Media.Visual GetVisualChild (int index);
    parameters:
    - id: index
      type: System.Int32
      description: "要求的子項目集合中以零為起始的索引。"
    return:
      type: System.Windows.Media.Visual
      description: "要求的子項目。 這應該不會傳回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; 如果提供的索引超出範圍，會擲回例外狀況。"
  overload: System.Windows.FrameworkElement.GetVisualChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Height
  id: Height
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Height
  nameWithType: FrameworkElement.Height
  fullName: System.Windows.FrameworkElement.Height
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定項目的建議的高度。"
  remarks: "高度位於三個可寫入屬性的其中一個<xref:System.Windows.FrameworkElement>旗標會指定高度資訊。</xref:System.Windows.FrameworkElement> 其他兩個是<xref:System.Windows.FrameworkElement.MinHeight%2A>和<xref:System.Windows.FrameworkElement.MaxHeight%2A>。</xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A> 如果之間的衝突這些值，應用程式的實際高度決定的順序是第一個<xref:System.Windows.FrameworkElement.MinHeight%2A>必須能接受，然後<xref:System.Windows.FrameworkElement.MaxHeight%2A>，最後，如果它是高度的範圍內。</xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A>       如果這個項目是一些其他項目內的子元素，然後將此屬性設定為值其實只是建議的值。 版面配置系統，以及特定配置的邏輯父項目會使用值為非繫結輸入配置程序期間。 實際上，<xref:System.Windows.FrameworkElement>是幾乎的其他項目; 即使設定於<xref:System.Windows.Window>。</xref:System.Windows.Window>高度的子項目</xref:System.Windows.FrameworkElement> (如<xref:System.Windows.Window>，基礎的應用程式模型建立建立 Hwnd 基本呈現假設時，會使用值主控應用程式。)</xref:System.Windows.Window>     除了可接受<xref:System.Double>的值，這個屬性也可以是<xref:System.Double.NaN?displayProperty=fullName>.</xref:System.Double.NaN?displayProperty=fullName> </xref:System.Double> 這是您在程式碼中指定自動調整大小行為的方式。 在[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]您設定值的字串 「 自動 」 （不區分大小寫） 若要啟用自動調整大小行為。 自動調整大小行為表示項目將會填入可用的高度。 不過請注意，特定控制項通常會提供預設值，透過其預設佈景主題樣式，將會停用自動調整大小行為，除非它是特別重新啟用。       這個屬性傳回的值一律為任何已設定為它的值相同。 相較之下，值<xref:System.Windows.FrameworkElement.ActualHeight%2A>而異。</xref:System.Windows.FrameworkElement.ActualHeight%2A> 這種情形是以靜態方式因為配置基於某些原因，拒絕建議的大小或立刻顯示。 版面配置系統本身會相對於高度的屬性系統的組以非同步方式運作，且可能有處理該特定尚未調整大小屬性變更。       值限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。</xref:System.Windows.ValidateValueCallback> </xref:System.Double> 如果您嘗試設定無效的值時，會擲回執行階段例外狀況。       驗證檢查，除了沒有繫結會強制執行由配置系統的高度不具決定性的上限值 (這是非常大數目，大於<xref:System.Single.MaxValue?displayProperty=fullName>但小於<xref:System.Double.MaxValue?displayProperty=fullName>)。</xref:System.Double.MaxValue?displayProperty=fullName> </xref:System.Single.MaxValue?displayProperty=fullName> 如果超過此限制，將不會呈現項目，並擲回任何例外狀況。 請勿將高度設為明顯地大於任何可能的視覺顯示的大小上限的值，或您可能會超過此不具決定性的上限。      <a name=&quot;xamlAttributeUsage_Height&quot;></a># # XAML 屬性使用方式```   <object Height=&quot;double&quot;/>   - or -   <object Height=&quot;qualifiedDouble&quot;/>   - or -   <object Height=&quot;Auto&quot;/>   ``` <a name=&quot;xamlValues_Height&quot;> </a> # # XAML 值*double* <xref:System.Double>的字串表示法<xref:System.Double>等於或大於 0.0 的值。</xref:System.Double> </xref:System.Double>           如需上限資訊，請參閱 < 備註 >。 這個值會解譯為[!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確地包含小數位數。 執行個體的值`1`是可接受。       *qualifiedDouble* A *double*值 （如上所述），後面接著下列單元宣告字串的其中之一︰ `px`， `in`， `cm`， `pt`。       `px`（預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in`英吋; 1in = = 96px`cm`是公釐。 1cm==(96/2.54) px`pt`點; 1pt==(96/72) px**自動**啟用自動調整大小行為。        請參閱 < 備註 >。      <a name=&quot;dependencyPropertyInfo_Height&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.HeightProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.HeightProperty>"
  syntax:
    content: public double Height { get; set; }
    return:
      type: System.Double
      description: "項目的高度，請在[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]。 預設值是&lt;xref:System.Double?displayProperty=fullName&gt;。 此值必須等於或大於 0.0。 如需上限資訊，請參閱 < 備註 >。"
  overload: System.Windows.FrameworkElement.Height*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HeightProperty
  id: HeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HeightProperty
  nameWithType: FrameworkElement.HeightProperty
  fullName: System.Windows.FrameworkElement.HeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.Height*>相依性屬性。</xref:System.Windows.FrameworkElement.Height*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty HeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HorizontalAlignment
  id: HorizontalAlignment
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
  fullName: System.Windows.FrameworkElement.HorizontalAlignment
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定套用至此元素在父項目，例如面板或項目控制項組成時的水平對齊特性。"
  remarks: "當<xref:System.Windows.FrameworkElement.Height%2A><xref:System.Windows.FrameworkElement.Width%2A>項目上明確設定屬性</xref:System.Windows.FrameworkElement.Width%2A>，這些度量需要較高優先順序在配置期間，將會取消設定至<xref:System.Windows.HorizontalAlignment>。</xref:System.Windows.HorizontalAlignment>水平對齊的典型的效果</xref:System.Windows.FrameworkElement.Height%2A>       水平對齊是[!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)]實際上會相依性屬性的屬性存取子。 這個特定的相依性屬性經常會有子類別化項目，特別是控制項中以不同方式設定其明顯&quot;default&quot;值。 這通常發生在兩種方式之一︰ 重新登錄相依性屬性的特定子類別，但具有不同的中繼資料來設定其預設值。或以不同的方式設定該相依性屬性的值為預設樣式套用。 例如，明顯 「 預設 」 的水平對齊的<xref:System.Windows.Controls.Label>控制項將會是<xref:System.Windows.HorizontalAlignment>，即使<xref:System.Windows.Controls.Label>繼承 HorizontalAlignment 直接從<xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> </xref:System.Windows.Controls.Label> </xref:System.Windows.HorizontalAlignment> </xref:System.Windows.Controls.Label> 這是因為該值重設的預設樣式中<xref:System.Windows.Controls.Label>，樣式的控制項範本內。</xref:System.Windows.Controls.Label>       <xref:System.Windows.Controls.Canvas>時不會使用水平對齊撰寫版面配置，因為<xref:System.Windows.Controls.Canvas>根據絕對位置。</xref:System.Windows.Controls.Canvas></xref:System.Windows.Controls.Canvas>       當<xref:System.Windows.Controls.Label>或衍生的類別，<xref:System.Windows.Controls.Label>會重新定義為<xref:System.Windows.HorizontalAlignment>.</xref:System.Windows.HorizontalAlignment>這個相依性屬性的預設值</xref:System.Windows.Controls.Label></xref:System.Windows.Controls.Label>繼承      <a name=&quot;dependencyPropertyInfo_HorizontalAlignment&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> </xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>"
  syntax:
    content: public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }
    return:
      type: System.Windows.HorizontalAlignment
      description: "水平對齊方式設定，做為列舉值。 預設值是<xref href=&quot;System.Windows.HorizontalAlignment&quot;> </xref>。"
  overload: System.Windows.FrameworkElement.HorizontalAlignment*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  id: HorizontalAlignmentProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: HorizontalAlignmentProperty
  nameWithType: FrameworkElement.HorizontalAlignmentProperty
  fullName: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.HorizontalAlignment*>相依性屬性。</xref:System.Windows.FrameworkElement.HorizontalAlignment*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InheritanceBehavior
  id: InheritanceBehavior
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
  fullName: System.Windows.FrameworkElement.InheritanceBehavior
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定屬性值繼承、 資源索引鍵查閱和 RelativeSource FindAncestor 查閱的範圍限制。"
  remarks: "項目樹狀結構中的特定界限設定 InheritanceBehavior 刻意限制的繼承行為，強制資源查閱來檢查應用程式資源，或防止 RelativeSource FindAncestor 查閱查詢目前的項目，或任何進一步的範圍。 使用繫結，就會發生 RelativeSource FindAncestor 查閱<xref:System.Windows.Data.RelativeSource>具有其<xref:System.Windows.Data.RelativeSource.Mode%2A>屬性設定為<xref:System.Windows.Data.RelativeSourceMode?displayProperty=fullName>值。</xref:System.Windows.Data.RelativeSourceMode?displayProperty=fullName> </xref:System.Windows.Data.RelativeSource.Mode%2A> </xref:System.Windows.Data.RelativeSource>       如果您想要將此屬性設定衍生的類別，您應該在靜態建構函式或其他初始化常式中如此做。"
  syntax:
    content: protected System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }
    return:
      type: System.Windows.InheritanceBehavior
      description: "列舉值。 預設值是<xref href=&quot;System.Windows.InheritanceBehavior&quot;> </xref>。"
  overload: System.Windows.FrameworkElement.InheritanceBehavior*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Initialized
  id: Initialized
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Initialized
  nameWithType: FrameworkElement.Initialized
  fullName: System.Windows.FrameworkElement.Initialized
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "發生時這<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>已初始化。 此事件會伴隨的情況下其中的值<xref:System.Windows.FrameworkElement.IsInitialized*>屬性從變更<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> （或未定義） 至<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。</xref:System.Windows.FrameworkElement.IsInitialized*>"
  remarks: "此事件將在每次引發<xref:System.Windows.FrameworkElement.EndInit%2A>或<xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A>呼叫的方法。</xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> </xref:System.Windows.FrameworkElement.EndInit%2A> 任一種方法的呼叫可以有來自應用程式程式碼，或透過[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]處理器的行為時[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]處理網頁。       您是否選擇處理<xref:System.Windows.FrameworkElement.Loaded>或初始化取決於您的需求。</xref:System.Windows.FrameworkElement.Loaded> 如果您不需要讀取項目屬性、 想要重設的屬性，而且不需要任何配置資訊，初始化可能會更好的事件，以根據採取行動。 如果您需要的項目，才能使用，所有屬性，而且您將設定重設配置，可能是屬性<xref:System.Windows.FrameworkElement.Loaded>可能會更好的事件，以根據採取行動。</xref:System.Windows.FrameworkElement.Loaded> 請小心重新進入的如果您的處理常式會由配置系統表示新的配置傳遞需要解譯任何屬性重設。 (您可能需要檢查<xref:System.Windows.FrameworkPropertyMetadata>屬性，如果您不確定哪些屬性可以要求新的版面配置上的值通過，在變更時。)</xref:System.Windows.FrameworkPropertyMetadata>     如需詳細資訊有關順序的物件事件<xref:System.Windows.FrameworkElement>，以及是否有數個相關應用程式和項目類別，請參閱[物件存留期事件](~/add/includes/ajax-current-ext-md.md)。</xref:System.Windows.FrameworkElement>"
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InputScope
  id: InputScope
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InputScope
  nameWithType: FrameworkElement.InputScope
  fullName: System.Windows.FrameworkElement.InputScope
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定所使用的輸入內容<xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>。"
  remarks: "這個相依性屬性會繼承屬性值。 如果有子項目不含 InputScope 透過本機值或樣式建立的其他值，對屬性系統將會設定要指派此值與最接近的祖系項目的 InputScope 值的值。       雖然[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]語法使用量列為和語法上允許中, 設定這個屬性[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]並不常見。      <a name=&quot;dependencyPropertyInfo_InputScope&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.InputScopeProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.InputScopeProperty>"
  syntax:
    content: public System.Windows.Input.InputScope InputScope { get; set; }
    return:
      type: System.Windows.Input.InputScope
      description: "輸入的範圍，修改替代的輸入方法中輸入的解譯方式。 預設值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> （結果會在預設的命令處理）。"
  overload: System.Windows.FrameworkElement.InputScope*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.InputScopeProperty
  id: InputScopeProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: InputScopeProperty
  nameWithType: FrameworkElement.InputScopeProperty
  fullName: System.Windows.FrameworkElement.InputScopeProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.InputScope*>相依性屬性。</xref:System.Windows.FrameworkElement.InputScope*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty InputScopeProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.IsInitialized
  id: IsInitialized
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
  fullName: System.Windows.FrameworkElement.IsInitialized
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得值，指出是否已初始化這個項目，根據處理期間[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]處理器，或是明確地其<xref:System.Windows.FrameworkElement.EndInit*>呼叫方法。</xref:System.Windows.FrameworkElement.EndInit*>"
  remarks: "這個屬性也可能`true`如果此項目已移動邏輯樹狀結構內，使它有新的父項目，並且因此變成一次重新載入。       此屬性相當實用，如果您也會使用<xref:System.Windows.FrameworkElement.BeginInit%2A>和<xref:System.Windows.FrameworkElement.EndInit%2A>.</xref:System.Windows.FrameworkElement.EndInit%2A> </xref:System.Windows.FrameworkElement.BeginInit%2A> 邏輯樹狀結構中所載入的項目[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]處理器會確保進行初始化。 不在邏輯樹狀結構中的元素會初始化時<xref:System.Windows.FrameworkElement.EndInit%2A>稱為。</xref:System.Windows.FrameworkElement.EndInit%2A> 沒有任何特定處理的情況下<xref:System.Windows.FrameworkElement.BeginInit%2A>和<xref:System.Windows.FrameworkElement.EndInit%2A>，建構函式會傳回初始化的結果時，會發生此情況。</xref:System.Windows.FrameworkElement.EndInit%2A> </xref:System.Windows.FrameworkElement.BeginInit%2A>"
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果項目初始化每個先前提及[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]處理或方法呼叫，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkElement.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.IsLoaded
  id: IsLoaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
  fullName: System.Windows.FrameworkElement.IsLoaded
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得值，指出這個項目是否已載入的簡報。"
  remarks: "從新建構<xref:System.Windows.FrameworkElement>，這個屬性一開始`false`，且會維持`true`設為它之後`true`，即使之後移除元素已連線的邏輯樹狀結構中程式碼。</xref:System.Windows.FrameworkElement> `true`狀態是項目會載入簡報引擎時設定的一般呈現邏輯。       一般而言，載入項目會轉譯，但不是全部<xref:System.Windows.FrameworkElement>衍生的類別中有一份簡報和其他屬性，例如<xref:System.Windows.UIElement.Visibility%2A>可能會影響簡報。</xref:System.Windows.UIElement.Visibility%2A> </xref:System.Windows.FrameworkElement>"
  example:
  - "The following example implements two handlers: one is handling the <xref:System.Windows.FrameworkElement.Loaded> event of the root element, so it is certain that the page root element is loaded because that is the significance of the event. The other handler is hooked to a user control, and calls IsLoaded to assure that the root element is loaded completely. Both handlers call the same function (not shown) that will populate child elements with fresh data.  \n  \n [!code-cs[GroupBoxExample#FEIsLoaded](~/add/codesnippet/csharp/GroupBoxExample/Page1.xaml.cs#feisloaded)]"
  syntax:
    content: public bool IsLoaded { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果目前的項目附加至項目樹狀結構中;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果項目已永遠不會附加到載入的項目樹狀結構。"
  overload: System.Windows.FrameworkElement.IsLoaded*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Language
  id: Language
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Language
  nameWithType: FrameworkElement.Language
  fullName: System.Windows.FrameworkElement.Language
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定套用至項目的當地語系化/全球化語言資訊。"
  remarks: "字串格式會依照 RFC 3066 標準。 例如，美國英文是&quot;EN-US&quot;。 如需值和格式的詳細資訊，請參閱<xref:System.Windows.Markup.XmlLanguage>.</xref:System.Windows.Markup.XmlLanguage>       這個相依性屬性會繼承屬性值。 如果有子項目不含其他語言建立透過本機值或樣式的值，對屬性系統將會設定要指派此值與最接近上階元素的語言值的值。       [!INCLUDE[TLA2#tla_xml](~/add/includes/tla2sharptla-xml-md.md)]定義的一般意義`xml:lang`屬性。 語言基本上會公開這個屬性為相依性屬性的意義。 語言可以透過程式設計的方式，調整，而且可以參與平行設計的方式的屬性系統值繼承如何`xml:lang`屬性可以繼承中的子系項目範圍[!INCLUDE[TLA2#tla_xml](~/add/includes/tla2sharptla-xml-md.md)]。 如果您設定的語言，此值會變成`xml:lang`並覆寫任何先前的值。 如需詳細資訊，請參閱[xml: lang 處理在 XAML 中](~/add/includes/ajax-current-ext-md.md)。      <a name=&quot;dependencyPropertyInfo_CultureInfo&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.LanguageProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkElement.LanguageProperty>"
  syntax:
    content: public System.Windows.Markup.XmlLanguage Language { get; set; }
    return:
      type: System.Windows.Markup.XmlLanguage
      description: "這個項目的語言資訊。 預設值是<xref href=&quot;System.Windows.Markup.XmlLanguage&quot;></xref>具有其<xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>值設定為字串&quot;EN-US&quot;。</xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>"
  overload: System.Windows.FrameworkElement.Language*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LanguageProperty
  id: LanguageProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LanguageProperty
  nameWithType: FrameworkElement.LanguageProperty
  fullName: System.Windows.FrameworkElement.LanguageProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.Language*>相依性屬性。</xref:System.Windows.FrameworkElement.Language*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LanguageProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LayoutTransform
  id: LayoutTransform
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
  fullName: System.Windows.FrameworkElement.LayoutTransform
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定圖形轉換執行配置時應套用至這個項目。"
  remarks: "相對於<xref:System.Windows.UIElement.RenderTransform%2A>，LayoutTransform 會影響結果的版面配置。</xref:System.Windows.UIElement.RenderTransform%2A>       設定轉換提供強大的縮放和旋轉的功能。 不過，會忽略 LayoutTransform<xref:System.Windows.Media.TranslateTransform>作業。</xref:System.Windows.Media.TranslateTransform> 這是因為子項目的的版面配置系統行為<xref:System.Windows.FrameworkElement>自動更正任何位移的縮放或旋轉項目到配置的位置和父項目的座標系統。</xref:System.Windows.FrameworkElement>       如果您不需要完全傳遞配置系統案例中叫用 LayoutTransform 可能會導致效能不佳的應用程式。 當您將套用至 LayoutTransform<xref:System.Windows.Controls.Panel.Children%2A>集合<xref:System.Windows.Controls.Panel>觸發新的行程由配置系統，強制所有螢幕物件 remeasured 和重新排列。</xref:System.Windows.Controls.Panel> </xref:System.Windows.Controls.Panel.Children%2A> 如果您要更新的完整應用程式[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]，這項功能可能完全您的需要。 不過，如果您不需要完整的配置傳遞，使用<xref:System.Windows.UIElement.RenderTransform%2A>屬性，它不會叫用這個版面配置系統，並因此，通常是比較好的選擇，此案例。</xref:System.Windows.UIElement.RenderTransform%2A>       會有幫助 LayoutTransform 的範例案例包括︰ 旋轉元素，例如功能表元件從水平為垂直或反之亦然，縮放比例元素 （拉近） 焦點，提供編輯行為，依此類推。     <a name=&quot;dependencyPropertyInfo_LayoutTransform&quot;> </a> # # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.LayoutTransformProperty>"
  example:
  - "The following example shows how to apply a LayoutTransform to an element. The example creates an instance of <xref:System.Windows.Controls.Button> and hosts it within a parent <xref:System.Windows.Controls.Grid>. It also uses the LayoutTransform property to apply a <xref:System.Windows.Media.RotateTransform> to the <xref:System.Windows.Controls.Button>.  \n  \n [!code-vb[LayoutTransform#1](~/add/codesnippet/visualbasic/LayoutTransformVB/LayoutTransform.vb#1)]\n [!code-cpp[LayoutTransform#1](~/add/codesnippet/cpp/layouttransform/LayoutTransform.cpp#1)]\n [!code-xml[LayoutTransform#1](~/add/codesnippet/xaml/LayoutTransform/default.xaml#1)]\n [!code-cs[LayoutTransform#1](~/add/codesnippet/csharp/LayoutTransformCsharp/LayoutTransform.cs#1)]"
  syntax:
    content: public System.Windows.Media.Transform LayoutTransform { get; set; }
    return:
      type: System.Windows.Media.Transform
      description: "轉換應該使用這個項目。 預設值為<xref:System.Windows.Media.Transform.Identity*>.</xref:System.Windows.Media.Transform.Identity*>"
  overload: System.Windows.FrameworkElement.LayoutTransform*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LayoutTransformProperty
  id: LayoutTransformProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LayoutTransformProperty
  nameWithType: FrameworkElement.LayoutTransformProperty
  fullName: System.Windows.FrameworkElement.LayoutTransformProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.LayoutTransform*>相依性屬性。</xref:System.Windows.FrameworkElement.LayoutTransform*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LayoutTransformProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Loaded
  id: Loaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Loaded
  nameWithType: FrameworkElement.Loaded
  fullName: System.Windows.FrameworkElement.Loaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "項目已配置版面、 呈現以及可以互動時發生。"
  remarks: "載入通常是最後一個事件中引發的項目初始化順序。 它將會引發這個事件之後<xref:System.Windows.FrameworkElement.Initialized>.</xref:System.Windows.FrameworkElement.Initialized> 您是否選擇處理 Loaded 或<xref:System.Windows.FrameworkElement.Initialized>取決於您的需求。</xref:System.Windows.FrameworkElement.Initialized> 如果您不需要讀取項目屬性，想要重設的屬性，並不需要任何配置資訊，<xref:System.Windows.FrameworkElement.Initialized>可能會更好的事件，以根據採取行動。</xref:System.Windows.FrameworkElement.Initialized> 如果您需要的所有屬性的項目，才能使用，而且您將會設定屬性都可能會重設配置、 載入可能會更好的事件，以根據採取行動。 請小心重新進入的如果您的處理常式會由配置系統表示新的配置傳遞需要解譯任何屬性重設。 (您可能需要檢查<xref:System.Windows.FrameworkPropertyMetadata>屬性，如果您不確定哪些屬性可以要求新的版面配置上的值通過，在變更時。)</xref:System.Windows.FrameworkPropertyMetadata>     如需詳細資訊有關順序的物件事件<xref:System.Windows.FrameworkElement>，以及是否有數個相關應用程式和項目類別，請參閱[物件存留期事件](~/add/includes/ajax-current-ext-md.md)。</xref:System.Windows.FrameworkElement>       直接路由的事件不會遵循路由，才會處理在引發相同的項目內。 直接路由的事件並支援其他路由的事件的行為︰ 它們支援可存取的處理常式集合中，且可用來當作<xref:System.Windows.EventTrigger>樣式。</xref:System.Windows.EventTrigger>       載入和<xref:System.Windows.FrameworkElement.Unloaded>可能同時會引發控制項，因為使用者起始的系統主題變更。</xref:System.Windows.FrameworkElement.Unloaded> 佈景主題變更會導致控制項樣板和自主視覺化樹狀結構，因此使得卸載再重新載入整個控制項的失效。 因此無法假設 Loaded 發生只頁面第一次載入時透過巡覽至頁面。      <a name=&quot;routedEventInfo_Loaded&quot;></a># # 路由事件資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.LoadedEvent>|  |路由策略 |直接 |  |委派 |<xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkElement.LoadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Loaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LoadedEvent
  id: LoadedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LoadedEvent
  nameWithType: FrameworkElement.LoadedEvent
  fullName: System.Windows.FrameworkElement.LoadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref href=&quot;System.Windows.FrameworkElement.Loaded&quot;></xref>路由的事件。"
  remarks: "註冊路由的事件時，會建立路由的事件識別項。 這些識別碼包含識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。 您可以使用這些識別項來加入類別處理常式。       如需註冊路由的事件的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 如需使用路由的事件識別項來加入類別處理常式的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LoadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.LogicalChildren
  id: LogicalChildren
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
  fullName: System.Windows.FrameworkElement.LogicalChildren
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得這個元素的邏輯子元素的列舉值。"
  remarks: "LogicalChildren 可讓您逐一查看項目子系。 這適用於項目可能沒有定義且固定的集合，但仍然會包含一個以上的子元素，特別是<xref:System.Windows.FrameworkContentElement>子項目。</xref:System.Windows.FrameworkContentElement>       如需有關如何使用 LogicalChildren 和<xref:System.Windows.FrameworkElement.AddLogicalChild%2A>，請參閱[中 WPF 樹狀架構](~/add/includes/ajax-current-ext-md.md)。</xref:System.Windows.FrameworkElement.AddLogicalChild%2A>"
  syntax:
    content: protected virtual System.Collections.IEnumerator LogicalChildren { get; }
    return:
      type: System.Collections.IEnumerator
      description: "此項目的邏輯子項目列舉值。"
  overload: System.Windows.FrameworkElement.LogicalChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Margin
  id: Margin
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Margin
  nameWithType: FrameworkElement.Margin
  fullName: System.Windows.FrameworkElement.Margin
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定項目的外的邊界。"
  remarks: "邊界是這個項目和其他配置建立時將相鄰的項目之間的間距[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]。 共用的項目可能是對等項目 （例如中其他項目的一般父控制項的集合），或也可能是此項目的父代。       邊界設定為<xref:System.Windows.Thickness>結構，而不是數字，以便可以設定邊界對稱性。</xref:System.Windows.Thickness> <xref:System.Windows.Thickness>結構本身支援字串型別轉換，好讓您可以指定非對稱的邊界，以[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]也屬性語法。</xref:System.Windows.Thickness>       非零邊界適用於外部項目配置<xref:System.Windows.FrameworkElement.ActualWidth%2A>和<xref:System.Windows.FrameworkElement.ActualHeight%2A>。</xref:System.Windows.FrameworkElement.ActualHeight%2A></xref:System.Windows.FrameworkElement.ActualWidth%2A>空間       邊界會加總的同層級項目在版面配置。例如，都與 30 的邊界設定邊緣相鄰的兩個相鄰項目會有 60 之間的空間單位。       如果配置的矩形空間沒有夠大，邊界以及元素內容區域，則已設定邊界的項目將會不通常限制指定的邊界的大小。 計算配置時，將會改為限制項目的內容區域。 邊界會被限制的唯一情況也是內容已被限制到零。      <a name=&quot;xamlAttributeUsage_Margin&quot;></a># # XAML 屬性使用方式```   <object Margin=&quot;left,top,right,bottom&quot;/>   - or -   <object Margin=&quot;left,top&quot;/>   - or -   <object Margin=&quot;thicknessReference&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_Margin&quot;> </a> # # XAML 屬性項目用法```   <object>     <object.Margin>       <Thickness Left=&quot;left&quot; Top=&quot;top&quot; Right=&quot;right&quot; Bottom=&quot;bottom&quot;/>     </object.Margin>   </object>   ``` <a name=&quot;xamlValues_Margin&quot;> </a> # # XAML 值*左、 上方，以滑鼠右鍵、 下方*數字值介於 0 和<xref:System.Double.PositiveInfinity>旗標會指定四個可能維度屬性的<xref:System.Windows.Thickness>結構。</xref:System.Windows.Thickness> </xref:System.Double.PositiveInfinity>                   屬性使用方式也會接受縮寫對稱與邏輯上提供的順序套用的值。 比方說，`Margin=&quot;20&quot;`會解譯成表示<xref:System.Windows.Thickness>且其所有屬性設定為 20。</xref:System.Windows.Thickness> `Margin=&quot;20,50&quot;`將解譯成表示<xref:System.Windows.Thickness>與<xref:System.Windows.Thickness.Left%2A>和<xref:System.Windows.Thickness.Right%2A>設為 20，和<xref:System.Windows.Thickness.Top%2A>和<xref:System.Windows.Thickness.Bottom%2A>設定為 50。</xref:System.Windows.Thickness.Bottom%2A> </xref:System.Windows.Thickness.Top%2A> </xref:System.Windows.Thickness.Right%2A> </xref:System.Windows.Thickness.Left%2A> </xref:System.Windows.Thickness>       預設單位<xref:System.Windows.Thickness>量值是[!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)]。</xref:System.Windows.Thickness> 您也可以藉由附加單位類型字串來指定其他單位`cm`， `in`，或`pt`任何量值。       數字作為值[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]屬性不需要指定小數位數 （0 是可以接受的並沒有提供的 0.0)。 如需有關[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]使用量，請參閱<xref:System.Windows.Thickness>.</xref:System.Windows.Thickness>       *thicknessReference*至現有的<xref:System.Windows.Thickness>。</xref:System.Windows.Thickness>物件參考 這可能是`}`、 a、 或`}`參考。 如需有關[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]使用量，請參閱<xref:System.Windows.Thickness>.</xref:System.Windows.Thickness>      <a name=&quot;dependencyPropertyInfo_Margin&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.MarginProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MarginProperty>"
  syntax:
    content: public System.Windows.Thickness Margin { get; set; }
    return:
      type: System.Windows.Thickness
      description: "提供項目的邊界值。 預設值是<xref href=&quot;System.Windows.Thickness&quot;></xref>使用所有屬性皆等於 0 （零）。"
  overload: System.Windows.FrameworkElement.Margin*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MarginProperty
  id: MarginProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MarginProperty
  nameWithType: FrameworkElement.MarginProperty
  fullName: System.Windows.FrameworkElement.MarginProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.Margin*>相依性屬性。</xref:System.Windows.FrameworkElement.Margin*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MarginProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxHeight
  id: MaxHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
  fullName: System.Windows.FrameworkElement.MaxHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定項目的最大高度限制。"
  remarks: "這是三個屬性的其中一個上<xref:System.Windows.FrameworkElement>旗標會指定高度資訊。</xref:System.Windows.FrameworkElement> 其他兩個是<xref:System.Windows.FrameworkElement.MinHeight%2A>和<xref:System.Windows.FrameworkElement.Height%2A>。</xref:System.Windows.FrameworkElement.Height%2A> </xref:System.Windows.FrameworkElement.MinHeight%2A>  如果這些值之間沒有衝突，實際高度判斷應用程式的順序是第一個<xref:System.Windows.FrameworkElement.MinHeight%2A>必須能接受的則 MaxHeight，最後如果<xref:System.Windows.FrameworkElement.Height%2A>.</xref:System.Windows.FrameworkElement.Height%2A>的範圍內每一種</xref:System.Windows.FrameworkElement.MinHeight%2A>       值限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。</xref:System.Windows.ValidateValueCallback> </xref:System.Double> 如果您嘗試設定無效的值會擲回執行階段例外狀況。      <a name=&quot;xamlAttributeUsage_MaxHeight&quot;></a># # XAML 屬性使用方式```   <object MaxHeight=&quot;double&quot;/>   - or –   <object MaxHeight =&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MaxHeight&quot;> </a> # # XAML 值*double* <xref:System.Double>的字串表示法<xref:System.Double>等於或大於 0.0 的值。</xref:System.Double> </xref:System.Double>           這會解譯為[!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確地包含小數位數。 執行個體的值`1`是可接受。       相同<xref:System.Double>套用屬性值 > 一節中所述的範圍限制，只不過您必須使用[X:static 標記延伸](~/add/includes/ajax-current-ext-md.md)如果您需要明確地設定這個值為<xref:System.Double.PositiveInfinity>.</xref:System.Double.PositiveInfinity> </xref:System.Double>       *qualifiedDouble* A *double*值 （如上所述），後面接著下列單元宣告字串的其中之一︰ `px`， `in`， `cm`， `pt`。       `px`（預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in`英吋; 1in = = 96px`cm`是公釐。 1cm==(96/2.54) px`pt`點; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MaxHeight&quot;> </a> # # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MaxHeightProperty>       "
  syntax:
    content: public double MaxHeight { get; set; }
    return:
      type: System.Double
      description: "最大高度的項目，請在[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]。 預設值是<xref:System.Double>.</xref:System.Double> 這個值可以是等於或大於 0.0 的任何值。 <xref:System.Double>仍有效。</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MaxHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxHeightProperty
  id: MaxHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxHeightProperty
  nameWithType: FrameworkElement.MaxHeightProperty
  fullName: System.Windows.FrameworkElement.MaxHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.MaxHeight*>相依性屬性。</xref:System.Windows.FrameworkElement.MaxHeight*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MaxHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxWidth
  id: MaxWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
  fullName: System.Windows.FrameworkElement.MaxWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定項目的最大寬度限制。"
  remarks: "這是三個屬性的其中一個上<xref:System.Windows.FrameworkElement>旗標會指定寬度資訊。</xref:System.Windows.FrameworkElement> 其他兩個是<xref:System.Windows.FrameworkElement.MinWidth%2A>和<xref:System.Windows.FrameworkElement.Width%2A>。</xref:System.Windows.FrameworkElement.Width%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A> 如果這些值之間沒有衝突，應用程式的實際寬度決定的順序是第一個<xref:System.Windows.FrameworkElement.MinWidth%2A>必須能接受的則 MaxWidth，最後如果<xref:System.Windows.FrameworkElement.Width%2A>.</xref:System.Windows.FrameworkElement.Width%2A>的範圍內每一種</xref:System.Windows.FrameworkElement.MinWidth%2A>       值限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。</xref:System.Windows.ValidateValueCallback> </xref:System.Double> 如果您嘗試設定無效的值時，會擲回執行階段例外狀況。      <a name=&quot;xamlAttributeUsage_MaxWidth&quot;></a># # XAML 屬性使用方式```   <object MaxWidth=&quot;double&quot;/>   - or -   <object MaxWidth=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MaxWidth&quot;> </a> # # XAML 值*double* <xref:System.Double>的字串表示法<xref:System.Double>等於或大於 0.0 的值。</xref:System.Double> </xref:System.Double>           這會解譯為[!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確地包含小數位數。 執行個體的值`1`是可接受。       相同<xref:System.Double>套用屬性值 > 一節中所述的範圍限制，只不過您必須使用[X:static 標記延伸](~/add/includes/ajax-current-ext-md.md)來設定這個值為<xref:System.Double.PositiveInfinity>.</xref:System.Double.PositiveInfinity> </xref:System.Double>       *qualifiedDouble* A *double*值 （如上所述），後面接著下列單元宣告字串的其中之一︰ `px`， `in`， `cm`， `pt`。       `px`（預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in`英吋; 1in = = 96px`cm`是公釐。 1cm==(96/2.54) px`pt`點; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MaxWidth&quot;> </a> # # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MaxWidthProperty>       "
  syntax:
    content: public double MaxWidth { get; set; }
    return:
      type: System.Double
      description: "項目的最大寬度，請在[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]。 預設值是<xref:System.Double>.</xref:System.Double> 這個值可以是等於或大於 0.0 的任何值。 <xref:System.Double>仍有效。</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MaxWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MaxWidthProperty
  id: MaxWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MaxWidthProperty
  nameWithType: FrameworkElement.MaxWidthProperty
  fullName: System.Windows.FrameworkElement.MaxWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.MaxWidth*>相依性屬性。</xref:System.Windows.FrameworkElement.MaxWidth*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MaxWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  id: MeasureCore(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MeasureCore(Size)
  nameWithType: FrameworkElement.MeasureCore(Size)
  fullName: System.Windows.FrameworkElement.MeasureCore(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "實作基本的測量傳遞配置系統行為<xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>。"
  remarks: "這個方法會覆寫<xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName>連接 WPF 核心層級和 WPF 架構層級配置量值實作。</xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName> <xref:System.Windows.FrameworkElement>實作密封方法。</xref:System.Windows.FrameworkElement> 若要調整 WPF 架構層級為基礎的任何項目的測量行程配置行為，請覆寫<xref:System.Windows.FrameworkElement.MeasureOverride%2A>改用。</xref:System.Windows.FrameworkElement.MeasureOverride%2A> 若要調整量值傳遞的項目之刻意不 WPF 架構層級上建立或使用<xref:System.Windows.FrameworkElement>，請覆寫<xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName>.</xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=fullName></xref:System.Windows.FrameworkElement>配置行為"
  syntax:
    content: protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);
    parameters:
    - id: availableSize
      type: System.Windows.Size
      description: "父項目可以提供給子項目使用的大小。"
    return:
      type: System.Windows.Size
      description: "版面配置中此項目所需的大小。"
  overload: System.Windows.FrameworkElement.MeasureCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  id: MeasureOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MeasureOverride(Size)
  nameWithType: FrameworkElement.MeasureOverride(Size)
  fullName: System.Windows.FrameworkElement.MeasureOverride(Size)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "當在衍生類別中覆寫時，測量子項目所需配置的大小，並決定的大小<xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>-衍生的類別。"
  remarks: "覆寫要實作自訂版面配置您的項目調整大小行為，因為它所參與的 MeasureOverride[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]版面配置系統。 您的實作應該執行下列動作︰ 1。  逐一查看項目的特定集合的子系屬於配置中，呼叫<xref:System.Windows.UIElement.Measure%2A>每個子項目上。</xref:System.Windows.UIElement.Measure%2A>      2.  立即取得<xref:System.Windows.UIElement.DesiredSize%2A>的子系上 (這設定為屬性之後<xref:System.Windows.UIElement.Measure%2A>稱為)。</xref:System.Windows.UIElement.Measure%2A> </xref:System.Windows.UIElement.DesiredSize%2A>      3.  計算父系的子項目測量為基礎的網路所需的大小。       MeasureOverride 的傳回值應該是項目的自己所需大小，就會變成目前的項目之父元素的量值輸入。 同樣的程序會在頁面的根項目為止，持續進行的版面配置系統。       在此過程中，子元素可能會傳回較大<xref:System.Windows.UIElement.DesiredSize%2A>大小比初始`availableSize`來表示的子項目想更多空間。</xref:System.Windows.UIElement.DesiredSize%2A> 這可能會藉由引進可捲動區域，藉由建立某些方式堆疊的順序或任何數目的解決方案來進行測量或排列內容調整父控制項、 處理中您自己的實作。      > [!IMPORTANT] > 項目應該呼叫<xref:System.Windows.UIElement.Measure%2A>在此程序期間每個子系，否則子項目會無法正確調整大小或排列。</xref:System.Windows.UIElement.Measure%2A>"
  syntax:
    content: protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);
    parameters:
    - id: availableSize
      type: System.Windows.Size
      description: "這個項目可以提供給子項目使用的大小。 Infinity 可以指定為一個值，指出項目會調整大小以任何內容可供使用。"
    return:
      type: System.Windows.Size
      description: "這個項目決定其大小所需的配置，其計算子項目大小的基礎。"
  overload: System.Windows.FrameworkElement.MeasureOverride*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinHeight
  id: MinHeight
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
  fullName: System.Windows.FrameworkElement.MinHeight
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定元素的最小高度限制。"
  remarks: "這是三個屬性的其中一個上<xref:System.Windows.FrameworkElement>旗標會指定高度資訊。</xref:System.Windows.FrameworkElement>  其他兩個是<xref:System.Windows.FrameworkElement.Height%2A>和<xref:System.Windows.FrameworkElement.MaxHeight%2A>。</xref:System.Windows.FrameworkElement.MaxHeight%2A> </xref:System.Windows.FrameworkElement.Height%2A> 實際的高度項判斷是，如果這些值，應用程式的順序之間衝突第一個 MinHeight 必須遵照，然後<xref:System.Windows.FrameworkElement.MaxHeight%2A>，最後如果<xref:System.Windows.FrameworkElement.Height%2A>.</xref:System.Windows.FrameworkElement.Height%2A>的範圍內每一種</xref:System.Windows.FrameworkElement.MaxHeight%2A>       值限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。</xref:System.Windows.ValidateValueCallback> </xref:System.Double> 如果您嘗試設定無效的值時，會擲回執行階段例外狀況。      <a name=&quot;xamlAttributeUsage_MinHeight&quot;></a># # XAML 屬性使用方式```   <object MinHeight=&quot;double&quot;/>   - or -   <object MinHeight=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MinHeight&quot;> </a> # # XAML 值*double* <xref:System.Double>的字串表示法<xref:System.Double>等於或大於 0.0 的值。</xref:System.Double> </xref:System.Double>           這會解譯為[!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確地包含小數位數。 執行個體的值`1`是可接受。       相同<xref:System.Double>套用屬性值 > 一節中所述的範圍限制。</xref:System.Double>       *qualifiedDouble* A *double*值 （如上所述），後面接著下列單元宣告字串的其中之一︰ `px`， `in`， `cm`， `pt`。       `px`（預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in`英吋; 1in = = 96px`cm`是公釐。 1cm==(96/2.54) px`pt`點; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MinHeight&quot;> </a> # # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.MinHeightProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MinHeightProperty>       "
  syntax:
    content: public double MinHeight { get; set; }
    return:
      type: System.Double
      description: "項目的最小高度，請在[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]。 預設值為 0.0。 這個值可以是等於或大於 0.0 的任何值。 不過，<xref:System.Double>不是有效的也不是&lt;xref:System.Double?displayProperty=fullName&gt;。</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MinHeight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinHeightProperty
  id: MinHeightProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinHeightProperty
  nameWithType: FrameworkElement.MinHeightProperty
  fullName: System.Windows.FrameworkElement.MinHeightProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.MinHeight*>相依性屬性。</xref:System.Windows.FrameworkElement.MinHeight*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MinHeightProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinWidth
  id: MinWidth
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
  fullName: System.Windows.FrameworkElement.MinWidth
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定元素的最小寬度限制。"
  remarks: "這是三個屬性的其中一個上<xref:System.Windows.FrameworkElement>旗標會指定寬度資訊。</xref:System.Windows.FrameworkElement>  其他兩個是<xref:System.Windows.FrameworkElement.Width%2A>和<xref:System.Windows.FrameworkElement.MaxWidth%2A>。</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.Width%2A>  實際寬度的判斷，如果這些值，應用程式的順序之間衝突第一個 MinWidth 必須遵照，然後<xref:System.Windows.FrameworkElement.MaxWidth%2A>，最後如果<xref:System.Windows.FrameworkElement.Width%2A>.</xref:System.Windows.FrameworkElement.Width%2A>的範圍內每一種</xref:System.Windows.FrameworkElement.MaxWidth%2A>       值限制<xref:System.Double>值會強制執行<xref:System.Windows.ValidateValueCallback>機制。</xref:System.Windows.ValidateValueCallback> </xref:System.Double> 如果您嘗試設定無效的值時，會擲回執行階段例外狀況。      <a name=&quot;xamlAttributeUsage_MinWidth&quot;></a># # XAML 屬性使用方式```   <object MinWidth=&quot;double&quot;/>   - or -   <object MinWidth=&quot;qualifiedDouble&quot;/>   ``` <a name=&quot;xamlValues_MinWidth&quot;> </a> # # XAML 值*double* <xref:System.Double>的字串表示法<xref:System.Double>等於或大於 0.0 的值。</xref:System.Double> </xref:System.Double>           這會解譯為[!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確地包含小數位數。 執行個體的值`1`是可接受。       相同<xref:System.Double>套用屬性值 > 一節中所述的範圍限制。</xref:System.Double>       *qualifiedDouble* A *double*值 （如上所述），後面接著下列單元宣告字串的其中之一︰ `px`， `in`， `cm`， `pt`。       `px`（預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in`英吋; 1in = = 96px`cm`是公釐。 1cm==(96/2.54) px`pt`點; 1pt==(96/72) px <a name=&quot;dependencyPropertyInfo_MinWidth&quot;> </a> # # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.MinWidthProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.MinWidthProperty>       "
  syntax:
    content: public double MinWidth { get; set; }
    return:
      type: System.Double
      description: "最小寬度的項目，請在[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]。 預設值為 0.0。 這個值可以是等於或大於 0.0 的任何值。 不過，<xref:System.Double>不正確，也不是&lt;xref:System.Double?displayProperty=fullName&gt;。</xref:System.Double>"
  overload: System.Windows.FrameworkElement.MinWidth*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MinWidthProperty
  id: MinWidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MinWidthProperty
  nameWithType: FrameworkElement.MinWidthProperty
  fullName: System.Windows.FrameworkElement.MinWidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.MinWidth*>相依性屬性。</xref:System.Windows.FrameworkElement.MinWidth*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty MinWidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  id: MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkElement.MoveFocus(TraversalRequest)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "將鍵盤焦點離開這個項目與另一個項目移以提供的周遊的方向。"
  remarks: "此實作會覆寫<xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=fullName>和密封方法。</xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=fullName>"
  example:
  - "The following example implements a handler that handles several possible button inputs. Each button represents a possible <xref:System.Windows.Input.FocusNavigationDirection>. The handler tracks the element with current keyboard focus, and calls MoveFocus on that element, by specifying the appropriate <xref:System.Windows.Input.FocusNavigationDirection> as initialization for the <xref:System.Windows.Input.TraversalRequest> type parameter provided.  \n  \n [!code-cs[FocusSample#FocusSampleMoveFocus](~/add/codesnippet/csharp/FocusSample/Window1.xaml.cs#focussamplemovefocus)]\n [!code-vb[FocusSample#FocusSampleMoveFocus](~/add/codesnippet/visualbasic/focussample/window1.xaml.vb#focussamplemovefocus)]"
  syntax:
    content: public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);
    parameters:
    - id: request
      type: System.Windows.Input.TraversalRequest
      description: "重點是要移動，做為列舉值的方向。"
    return:
      type: System.Boolean
      description: "傳回<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果已成功; 移動焦點<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果的方向會與目標項目會指定不存在或可能不鍵盤焦點。"
  overload: System.Windows.FrameworkElement.MoveFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Name
  id: Name
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Name
  nameWithType: FrameworkElement.Name
  fullName: System.Windows.FrameworkElement.Name
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定項目的識別名稱。 此名稱提供參考，以便之後處理期間建構標記項目可以參考程式碼後置，例如事件處理常式程式碼，[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]處理器。"
  remarks: "這個屬性的最常見的使用方式是指定[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]做為屬性標記的項目名稱。       這個屬性基本上會提供 WPF 架構層級方便的屬性來設定[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] [X:name 指示詞](~/add/includes/ajax-current-ext-md.md)。       名稱必須是唯一的名稱範圍內。 如需詳細資訊，請參閱[WPF XAML Namescopes](~/add/includes/ajax-current-ext-md.md)。       取得名稱，如果您要在程式碼中建立項目並不常見。 如果已經在程式碼中有適當的參考，您可以直接呼叫方法和屬性上的項目參考，而且通常不需要的名稱。 這個例外狀況名稱字串是否以某些多載意義，例如是否要顯示在該名稱很有用[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]。 設定程式碼後置如果從標記設定原始名稱中的名稱也不建議，並於載入後變更屬性[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]不會變更原始的物件參考。 只有在剖析期間明確建立的基礎命名範圍時，會建立物件參考。 您必須特別呼叫<xref:System.Windows.FrameworkElement.RegisterName%2A>有效的變更對已載入元素的 Name 屬性。</xref:System.Windows.FrameworkElement.RegisterName%2A>       其中一個值得注意的案例是重要設定名稱從程式碼時，註冊項目的分鏡腳本會執行，對的名稱，以便在執行階段可以參考它們。 您可以註冊之前，可能也需要具現化，並指派<xref:System.Windows.NameScope>執行個體。</xref:System.Windows.NameScope> 請參閱 < 範例 > 一節中，或[概觀腳本](~/add/includes/ajax-current-ext-md.md)。       設定名稱從程式碼受到限制的應用程式，但更常見取得依名稱的項目。 一個特定案例中，這是您的應用程式是否支援頁面會重新載入至應用程式，而執行的階段程式碼不一定是程式碼後置定義該網頁瀏覽模型。 公用程式方法<xref:System.Windows.FrameworkElement.FindName%2A>，這是可從任何<xref:System.Windows.FrameworkElement>，可以找到依名稱的任何項目邏輯樹狀中的項目，搜尋樹狀目錄中以遞迴方式視。</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement.FindName%2A> 您可以使用或<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>靜態方法<xref:System.Windows.LogicalTreeHelper>，這也會使用名稱字串，做為引數。</xref:System.Windows.LogicalTreeHelper> </xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>       常用根項目 (<xref:System.Windows.Window>，<xref:System.Windows.Controls.Page>例如) 實作的介面<xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.Controls.Page> </xref:System.Windows.Window> 此介面的實作應該強制執行的名稱是其範圍內模稜兩可。 定義這個介面的根項目也將 namescope 行為界限定義所有相關[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]。       Name 屬性也可做為其他處理序的識別項。 比方說， [!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)] automation 模型將使用名稱當做 AutomationId 的用戶端和提供者。       使用名稱的字串值會有一些限制，為基礎所加諸[X:name 指示詞](../Topic/x:Name%20Directive.md)所定義[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]規格。 最值得注意的是，名稱必須以字母或底線字元 (_) 開頭，並必須包含字母、 數字或底線。 如需詳細資訊，請參閱[WPF XAML Namescopes](../Topic/WPF%20XAML%20Namescopes.md)。       名稱是其中一個非常少的相依性屬性，無法以動畫顯示 (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>是`true`中繼資料中)，因為名稱本身是重要的目標動畫。</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> 資料繫結名稱技術上來說，但是極不常見的案例，因為資料繫結名稱不能做的屬性的主要用途︰ 若要提供的程式碼後置識別連接點。      <a name=&quot;dependencyPropertyInfo_Name&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.NameProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> </xref:System.Windows.FrameworkElement.NameProperty>"
  example:
  - "The following example sets the Name property in code, and then registers the name into the newly created <xref:System.Windows.NameScope> by calling <xref:System.Windows.FrameworkElement.RegisterName%2A>. The technique illustrated here is a requirement for animating with storyboards, because storyboards require targeting by the Name, and cannot be targeted by object reference.  \n  \n [!code-vb[animateHeight_procedural#FEName](~/add/codesnippet/visualbasic/animateheight/animatedheightexample.vb#fename)]\n [!code-cs[animateHeight_procedural#FEName](~/add/codesnippet/csharp/animateheight_csharp/AnimatedHeightExample.cs#fename)]"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "項目的名稱。 預設為空字串。"
  overload: System.Windows.FrameworkElement.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.NameProperty
  id: NameProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: NameProperty
  nameWithType: FrameworkElement.NameProperty
  fullName: System.Windows.FrameworkElement.NameProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.Name*>相依性屬性。</xref:System.Windows.FrameworkElement.Name*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty NameProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnApplyTemplate
  id: OnApplyTemplate
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnApplyTemplate()
  nameWithType: FrameworkElement.OnApplyTemplate()
  fullName: System.Windows.FrameworkElement.OnApplyTemplate()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "當在衍生類別中覆寫時，會叫用每當應用程式程式碼或內部處理程序呼叫<xref:System.Windows.FrameworkElement.ApplyTemplate*>.</xref:System.Windows.FrameworkElement.ApplyTemplate*>"
  remarks: "這個方法會具有預設的實作。       範本是項目的已完成的視覺化樹狀結構的 [範本] 屬性是來自區段<xref:System.Windows.Style>，它會套用項目。</xref:System.Windows.Style> 如需詳細資訊，請參閱[設定樣式和範本](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public virtual void OnApplyTemplate ();
    parameters: []
  overload: System.Windows.FrameworkElement.OnApplyTemplate*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "未處理時叫用<xref href=&quot;System.Windows.FrameworkElement.ContextMenuClosing&quot;></xref>路由的事件到達其路由中的這個類別。 實作這個方法可為此事件加入類別處理。"
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "提供事件的相關資料。"
  overload: System.Windows.FrameworkElement.OnContextMenuClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "未處理時叫用<xref href=&quot;System.Windows.FrameworkElement.ContextMenuOpening&quot;></xref>路由的事件到達其路由中的這個類別。 實作這個方法可為此事件加入類別處理。"
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "<xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Windows.FrameworkElement.OnContextMenuOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  id: OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkElement.OnGotFocus(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "未處理時叫用<xref href=&quot;System.Windows.UIElement.GotFocus&quot;></xref>事件到達其路由中的此項目。"
  remarks: "不同於在某些其他 * 基底的項目，OnGotFocus 所公開的方法沒有預設實作。 具體來說，它有覆寫基底項目， <xref:System.Windows.UIElement.OnGotFocus%2A>.</xref:System.Windows.UIElement.OnGotFocus%2A>的下一個層級中的 null 實作的實作 叫用時，OnGotFocus 會從鍵盤焦點由於目前的項目產生事件的案例中此項目上設定適當的焦點行為。 OnGotFocus 處理常式不會將標示的事件引數為已處理，即使焦點設定為目前的項目。 如果事件的來源是另一個項目樹狀目錄 （不是目前項目），此處理常式沒有任何作用。       您可以覆寫此方法，以變更您的項目，則預設焦點行為，但請注意，變更焦點行為，如此一來可能會更好可藉由不允許完全可設定焦點的項目 (請參閱<xref:System.Windows.UIElement.Focusable%2A>)。</xref:System.Windows.UIElement.Focusable%2A>"
  syntax:
    content: protected override void OnGotFocus (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "<xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Windows.FrameworkElement.OnGotFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  id: OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkElement.OnInitialized(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.FrameworkElement.Initialized&quot;></xref>事件。 這個方法會叫用每當<xref:System.Windows.FrameworkElement.IsInitialized*>設<xref uid=&quot;langword_csharp_true &quot; name=&quot;true &quot; href=&quot;&quot;></xref>內部。</xref:System.Windows.FrameworkElement.IsInitialized*>"
  remarks: "This particular On* method is not a class handler hook. Nor does it exactly follow the established [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] On\\* method convention that the matching event could be suppressed by overriding this method and not calling the base implementation.  \n  \n Note that the <xref:System.Windows.FrameworkElement.IsInitialized%2A> property is read-only, so you cannot set <xref:System.Windows.FrameworkElement.IsInitialized%2A> to force initialization behavior. Setting the initialization state is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)] framework."
  syntax:
    content: protected virtual void OnInitialized (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref href=&quot;System.Windows.RoutedEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Windows.FrameworkElement.OnInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "叫用每當上任何相依性屬性的有效值<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>已更新。 引數參數中報告變更的特定相依性屬性。 覆寫<xref:System.Windows.DependencyObject.OnPropertyChanged*>.</xref:System.Windows.DependencyObject.OnPropertyChanged*>"
  remarks: "這個方法不是偵測一般的屬性變更或失效。 它改為僅供修改的一般失效模式如果已知廣泛分類屬性的特定資訊。       這可能會叫用方法多次物件的存留期間。 因此，達到更佳的效能，如果您覆寫特定屬性的中繼資料，然後將附加<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>個別屬性的函式。</xref:System.Windows.PropertyChangedCallback> </xref:System.Windows.CoerceValueCallback> 不過，您會使用這個方法如果<xref:System.Windows.FrameworkElement>包含大量的值相互關聯的相依性屬性，或如果它包含邏輯，例如轉譯行為，必須重新執行的幾個相關的屬性失效的情況。</xref:System.Windows.FrameworkElement>       請注意，相同具名`OnPropertyChanged`方法具有不同簽章 (參數類型是<xref:System.ComponentModel.PropertyChangedEventArgs>) 可以出現在數個類別。</xref:System.ComponentModel.PropertyChangedEventArgs> 確認`OnPropertyChanged`用於資料物件通知，而且是<xref:System.ComponentModel.INotifyPropertyChanged>。</xref:System.ComponentModel.INotifyPropertyChanged>合約的一部分"
  syntax:
    content: protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "事件資料，描述已變更屬性，以及新舊值。"
  overload: System.Windows.FrameworkElement.OnPropertyChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  id: OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnRenderSizeChanged(SizeChangedInfo)
  nameWithType: FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  fullName: System.Windows.FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.FrameworkElement.SizeChanged&quot;></xref>事件時，使用指定的資訊作為最終事件資料的一部分。"
  remarks: "這個方法會覆寫<xref:System.Windows.UIElement.OnRenderSizeChanged%2A>.</xref:System.Windows.UIElement.OnRenderSizeChanged%2A> 如果您呼叫這個方法則會重設<xref:System.Windows.FrameworkElement.ActualWidth%2A>屬性，<xref:System.Windows.FrameworkElement.ActualHeight%2A>屬性，或兩者，根據指定為提供的引數中的變更，並且您總是會引發此事件。</xref:System.Windows.FrameworkElement.ActualHeight%2A> </xref:System.Windows.FrameworkElement.ActualWidth%2A>"
  syntax:
    content: protected override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);
    parameters:
    - id: sizeInfo
      type: System.Windows.SizeChangedInfo
      description: "舊的和新大小變更所涉及的詳細資料。"
  overload: System.Windows.FrameworkElement.OnRenderSizeChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  id: OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkElement.OnStyleChanged(Style,Style)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "叫用這個項目上的使用中的樣式變更時，這會導致無效的配置。"
  remarks: "這個方法已設定的樣式變更條件內部旗標的預設實作。"
  syntax:
    content: protected virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);
    parameters:
    - id: oldStyle
      type: System.Windows.Style
      description: "舊樣式。"
    - id: newStyle
      type: System.Windows.Style
      description: "新的樣式。"
  overload: System.Windows.FrameworkElement.OnStyleChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "未處理時叫用<xref href=&quot;System.Windows.FrameworkElement.ToolTipClosing&quot;></xref>路由的事件到達其路由中的這個類別。 實作這個方法可為此事件加入類別處理。"
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled."
  syntax:
    content: protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "提供事件的相關資料。"
  overload: System.Windows.FrameworkElement.OnToolTipClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "叫用每當<xref href=&quot;System.Windows.FrameworkElement.ToolTipOpening&quot;></xref>路由的事件到達其路由中的這個類別。 實作這個方法可為此事件加入類別處理。"
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "提供事件的相關資料。"
  overload: System.Windows.FrameworkElement.OnToolTipOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  id: OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: FrameworkElement.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.FrameworkElement.OnVisualParentChanged(DependencyObject)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "視覺化樹狀結構中這個項目之父項目變更時叫用。 覆寫<xref:System.Windows.UIElement.OnVisualParentChanged*>.</xref:System.Windows.UIElement.OnVisualParentChanged*>"
  remarks: "視覺化樹狀結構是不同的邏輯樹狀結構，因為後者省略集合，例如不以視覺化的方式，呈現的項目，並展開根據其佈景主題和樣式複合 （compositing） 的某些項目。 如需詳細資訊，請參閱[中 WPF 樹狀架構](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: protected override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);
    parameters:
    - id: oldParent
      type: System.Windows.DependencyObject
      description: "舊的父項目。 可能是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>來表示，項目沒有視覺化父項目之前。"
  overload: System.Windows.FrameworkElement.OnVisualParentChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle
  id: OverridesDefaultStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，指出這個項目是否包含來自佈景主題樣式的樣式屬性。"
  remarks: "這個屬性的最常見的用法是提供佈景主題樣式的樣式 setter 內間接使用。      > [!IMPORTANT] > 如果您將設定 OverridesDefaultStyle`true`控制，您將會隱藏佈景主題樣式所提供的預設控制項範本。 該控制項範本通常包含內容展示器和其他複合項目可提供基本[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]功能和控制項的視覺效果。 如果您想要繼續支援相同的功能，做為預設佈景主題樣式的控制項，您必須提供具有複寫相同的結構的控制項範本的其他樣式。 如需詳細資訊，請參閱[控制項撰寫概觀](~/add/includes/ajax-current-ext-md.md)。      <a name=&quot;dependencyPropertyInfo_OverridesDefaultStyle&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>"
  syntax:
    content: public bool OverridesDefaultStyle { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個項目不會使用佈景主題樣式屬性。樣式產生的所有屬性都來自於本機應用程式樣式和佈景主題樣式屬性不會套用。 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>如果應用程式樣式套用第一次，然後佈景主題樣式適用於應用程式樣式中未明確設定的屬性。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkElement.OverridesDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  id: OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.OverridesDefaultStyle*>相依性屬性。</xref:System.Windows.FrameworkElement.OverridesDefaultStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Parent
  id: Parent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Parent
  nameWithType: FrameworkElement.Parent
  fullName: System.Windows.FrameworkElement.Parent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得這個項目的邏輯父項目。"
  remarks: "父系可能是`null`項目未具現化，但未連接至任何最後會連接到頁面層級的根項目或應用程式物件的邏輯樹狀結構中。       請注意，根據您的應用程式功能，有可能變更邏輯父項目，可以保留此屬性的值不會反映該變更。 您通常應該取得的值之前您需要它。       請參閱[中 WPF 樹狀架構](~/add/includes/ajax-current-ext-md.md)的邏輯樹狀結構周遊和則適合使用這項技術的父項目探索父案例的詳細資訊。       屬性引擎有可能重新計算所有的屬性值的項目時，它會重設父代，因為有些屬性是繼承的處理邏輯樹狀結構的值。 <xref:System.Windows.FrameworkElement.DataContext%2A>可套用的項目會重設父代時，也可以變更繫結。</xref:System.Windows.FrameworkElement.DataContext%2A>       變更項目的父代通常只是透過操作的集合，使用專用新增或移除方法，或透過設定內容屬性的項目。       使用父屬性的最常見的案例是要取得的參考，然後以取得各種<xref:System.Windows.FrameworkElement>屬性值從父代。</xref:System.Windows.FrameworkElement> 範本，將範本最終的父代`null`。 若要取得略過此點，並將延伸至邏輯樹狀結構實際套用的範本，使用<xref:System.Windows.FrameworkElement.TemplatedParent%2A>.</xref:System.Windows.FrameworkElement.TemplatedParent%2A>       請注意這個屬性不會報告在這些項從邏輯樹狀結構父項中的視覺化樹狀結構父代。 視覺化樹狀結構的父代不是一般的應用程式案例通常會特別重要，但可能某些視覺層級的情況下所需的父項目。 請參閱<xref:System.Windows.Media.VisualTreeHelper>.</xref:System.Windows.Media.VisualTreeHelper>"
  example:
  - "The following example shows code that checks for an element's parent, and then uses property values from the parent to set properties on the child element to match. In this case these are properties that affect the rendering size.  \n  \n [!code-vb[GeometryDesigner#FEParentProperty](~/add/codesnippet/visualbasic/geometrydesigner/window1.xaml.vb#feparentproperty)]\n [!code-cs[GeometryDesigner#FEParentProperty](~/add/codesnippet/csharp/GeometryDesigner/Window1.xaml.cs#feparentproperty)]"
  syntax:
    content: public System.Windows.DependencyObject Parent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "這個項目的邏輯父代。"
  overload: System.Windows.FrameworkElement.Parent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  id: ParentLayoutInvalidated(System.Windows.UIElement)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ParentLayoutInvalidated(UIElement)
  nameWithType: FrameworkElement.ParentLayoutInvalidated(UIElement)
  fullName: System.Windows.FrameworkElement.ParentLayoutInvalidated(UIElement)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "支援累加配置實作中的特定子類別<xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>。 ParentLayoutInvalidated 子項目已設定為無效的中繼資料會影響父代的量值中標示為的屬性時叫用，或在配置期間排列傳遞。"
  remarks: "如果這個項目具有子項目所在某些屬性無效的而且屬性被標示為<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>或<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>屬性中繼資料，在註冊期間，這個方法會叫用。</xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> </xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> 方法引動過程會告知哪個特定子項目必須重新測量，如果此項目支援的配置部分 （累加） 更新的父項目。       根據預設，<xref:System.Windows.FrameworkElement>不支援累加配置，然後在<xref:System.Windows.FrameworkElement>類別，這個方法有預設的實作。</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement> 覆寫這個方法，可能需要的案例不常見，因為它會要求您修改預設版面配置系統行為。       範例實作的狀況可能是如果類別具有明顯比 WPF 架構層級配置系統更嚴格的可能的子元素的類型限制。 基於這些自訂項目本質，屬性變更可能會刻意延後當您實作某些自訂版面配置的行為。 比方說，測量/排列方法覆寫，嘗試最佳化子項目的呈現階段，可能會延後某些類型的變更通常會導致另一個配置傳遞。"
  syntax:
    content: protected virtual void ParentLayoutInvalidated (System.Windows.UIElement child);
    parameters:
    - id: child
      type: System.Windows.UIElement
      description: "報告變更的子項目。"
  overload: System.Windows.FrameworkElement.ParentLayoutInvalidated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  id: PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkElement.PredictFocus(FocusNavigationDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "判斷下一個項目將會收到焦點相對於所提供的焦點移動的方向，這個項目，但實際上不會移動焦點。"
  remarks: "<xref:System.Windows.FrameworkElement.MoveFocus%2A>是實際移動焦點的相關的方法。</xref:System.Windows.FrameworkElement.MoveFocus%2A>"
  example:
  - "The following example implements a handler that handles several possible button inputs, each button representing a possible <xref:System.Windows.Input.FocusNavigationDirection>. The handler tracks the element with current keyboard focus, and calls PredictFocus on that element, and specifies the appropriate <xref:System.Windows.Input.FocusNavigationDirection> as initialization for the <xref:System.Windows.Input.TraversalRequest> type parameter provided. Instead of moving to that element as <xref:System.Windows.FrameworkElement.MoveFocus%2A> would do, the handler changes the physical dimensions of the predicted focus destination for visualization purposes.  \n  \n [!code-cs[FocusSample#FEPredictFocus](~/add/codesnippet/csharp/FocusSample/Window1.xaml.cs#fepredictfocus)]\n [!code-vb[FocusSample#FEPredictFocus](~/add/codesnippet/visualbasic/focussample/window1.xaml.vb#fepredictfocus)]"
  syntax:
    content: public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Input.FocusNavigationDirection
      description: "判斷預期焦點變更方向。"
    return:
      type: System.Windows.DependencyObject
      description: "如果焦點實際上周遊，專注的下一個項目會移至。 可能會傳回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果焦點無法提供的方向移動相對於這個項目。"
  overload: System.Windows.FrameworkElement.PredictFocus*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: 'Specified one of the following directions in the <xref href=&quot;System.Windows.Input.TraversalRequest&quot;></xref>: <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>. 這些指示不合法的 PredictFocus (它們是合法的但<xref:System.Windows.FrameworkElement.MoveFocus*>)。</xref:System.Windows.FrameworkElement.MoveFocus*>'
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  id: RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RegisterName(String,Object)
  nameWithType: FrameworkElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkElement.RegisterName(String,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "提供存取子，可簡化存取<xref:System.Windows.NameScope>註冊方法。</xref:System.Windows.NameScope>"
  remarks: "這個方法是呼叫<xref:System.Windows.NameScope.RegisterName%2A>.</xref:System.Windows.NameScope.RegisterName%2A>便利的方法 實作會檢查後續的父項目，直到找到適用於<xref:System.Windows.NameScope>實作中，找到所尋找的項目，用來實作<xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.NameScope> 如需命名範圍的詳細資訊，請參閱[WPF XAML Namescopes](~/add/includes/ajax-current-ext-md.md)。       呼叫 RegisterName 會需要正確的應用程式程式碼中建立時的動畫分鏡腳本連結。 這是因為其中一個索引鍵的分鏡腳本屬性<xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>，會使用執行階段名稱查詢，而不是能夠充分目標項目的參考。</xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> 即使該元素是可供參考從程式碼存取，也是如此。 如需有關為什麼您需要註冊的分鏡腳本目標名稱的詳細資訊，請參閱[概觀腳本](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - >-
    [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/add/codesnippet/visualbasic/animateproperty_storyboards_vb/scopeexample.vb#namescopeexample)]
     [!code-cs[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/add/codesnippet/csharp/AnimateProperty_Storyboards_csharp/ScopeExample.cs#namescopeexample)]
  syntax:
    content: public void RegisterName (string name, object scopedElement);
    parameters:
    - id: name
      type: System.String
      description: "使用指定的名稱 / 物件對應的名稱。"
    - id: scopedElement
      type: System.Object
      description: "對應的物件。"
  overload: System.Windows.FrameworkElement.RegisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  id: RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.RemoveLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "移除這個項目邏輯樹狀結構中所提供的物件。 <xref href=&quot;System.Windows.FrameworkElement&quot;></xref>更新受影響的邏輯樹狀結構父指標，以便與刪除保持同步。"
  remarks: "使用此方法實作的邏輯子系的項目表示物件的集合。 這可能是屬性 getter 或 setter，類別處理常式的`Changed`事件、 建構函式，或集合內的類型本身。       控制項的作者，處理邏輯樹狀結構，此層級不建議的作法，除非是提供基底控制項類別的內容模型沒有適合。 請考慮在層級的子類別化<xref:System.Windows.Controls.ContentControl>， <xref:System.Windows.Controls.ItemsControl>，和<xref:System.Windows.Controls.HeaderedItemsControl>。</xref:System.Windows.Controls.HeaderedItemsControl> </xref:System.Windows.Controls.ItemsControl> </xref:System.Windows.Controls.ContentControl> 這些類別會提供透過專用的邏輯子系的特定增強的內容模型[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]，以及通常希望出現在其他功能的支援[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]控制項，例如透過範本的樣式。"
  example:
  - "The following example implements a `Child` property on a custom <xref:System.Windows.FrameworkElement> that does its own visual layer implementation. The property's setter is designed so that if the value changes, the old value is removed from the logical tree, as well as a class-specific visual collection. The values are cached, and then the new value is added to both the standard WPF framework level logical tree and the custom visual collection.  \n  \n [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/visualbasic/compositiontargetrenderinganimations/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]\n [!code-cs[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/add/codesnippet/csharp/CompositionTargetRenderingAnimations/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]"
  syntax:
    content: protected void RemoveLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "要移除的項目。"
  overload: System.Windows.FrameworkElement.RemoveLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RequestBringIntoView
  id: RequestBringIntoView
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RequestBringIntoView
  nameWithType: FrameworkElement.RequestBringIntoView
  fullName: System.Windows.FrameworkElement.RequestBringIntoView
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "發生時<xref:System.Windows.FrameworkElement.BringIntoView*>這個項目上呼叫。</xref:System.Windows.FrameworkElement.BringIntoView*>"
  remarks: "這個事件表示至父代<xref:System.Windows.Controls.ScrollViewer>（或衍生類別），引發 RequestBringIntoView 事件的項目應該會看見可捲動區域內。</xref:System.Windows.Controls.ScrollViewer> <xref:System.Windows.Controls.ScrollViewer>處理，使用類別處理事件的 RequestBringIntoView 事件將然後標示。</xref:System.Windows.Controls.ScrollViewer> 一般情況下 RequestBringIntoView 事件資料應該不會標示為已處理的任何類別，並控制捲動區域，或任何執行個體，處理常式，因為這樣會干擾，目的是呼叫<xref:System.Windows.FrameworkElement.BringIntoView%2A>.</xref:System.Windows.FrameworkElement.BringIntoView%2A>的項目      <a name=&quot;routedEventInfo_RequestBringIntoView&quot;></a># # 路由事件資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  |路由策略 |反昇 |  |委派 |<xref:System.Windows.RequestBringIntoViewEventHandler>|</xref:System.Windows.RequestBringIntoViewEventHandler></xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>"
  syntax:
    content: public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;
    return:
      type: System.Windows.RequestBringIntoViewEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  id: RequestBringIntoViewEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: RequestBringIntoViewEvent
  nameWithType: FrameworkElement.RequestBringIntoViewEvent
  fullName: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref href=&quot;System.Windows.FrameworkElement.RequestBringIntoView&quot;></xref>路由的事件。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Resources
  id: Resources
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Resources
  nameWithType: FrameworkElement.Resources
  fullName: System.Windows.FrameworkElement.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定在本機定義的資源字典。"
  remarks: "可以完全或部分中定義的資源字典[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]通常會建立為屬性項目，且通常是針對任何個別頁面或應用程式的根項目。 放置在此層級的資源字典，可以更輕鬆地尋找個別的子系中的項目頁面 （或從任何頁面上，在應用程式的情況下）。 在大部分的應用程式案例中，我們建議樣式定義做為物件項目內的資源字典，或定義為外部資源，以便可以是獨立的整個樣式資源 （這種方式有助於劃分設計從開發人員責任分隔需要加以編輯的實體檔案）。       請注意，這個屬性會傳回直接在該元素中宣告的資源字典。 這是不同於實際資源對應程序，其中的子元素可以存取任何遞迴地向上搜尋每個父項目中所定義的資源。       資源也可以從集合中的程式碼所參考，但請注意在中建立資源[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]絕對不會之前之後存取<xref:System.Windows.FrameworkElement.Loaded>宣告字典的項目就會引發。</xref:System.Windows.FrameworkElement.Loaded> 以非同步方式並不會剖析資源的事實上，即使<xref:System.Windows.FrameworkElement.Loaded>事件可確保您可以參考[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]定義資源。</xref:System.Windows.FrameworkElement.Loaded> 因此您應該通常只存取[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]資源定義為一部分的執行階段程式碼，或透過其他[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]技術，例如樣式或屬性值的資源擴充功能參考。 當您透過程式碼存取資源時，它是基本上等同於從進行參考[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。       基礎<xref:System.Windows.ResourceDictionary>支援加入、 移除或使用程式碼來查詢集合中的資源所需的方法。</xref:System.Windows.ResourceDictionary> 資源屬性是可設定為支援完全取代為新項目的資源集合的案例或不同<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>       請注意，[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]所示的語法不包括<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>的項目 這是隱含的集合語法; 的範例可以省略標記，表示集合項目。 會改為指定做為項目加入至集合的項目。 如需有關隱含的集合和[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]，請參閱[XAML 語法的詳細資料](~/add/includes/ajax-current-ext-md.md)。 一種情況下，<xref:System.Windows.ResourceDictionary>仍然有項目就是引進合併的字典，在此情況下是否有通常該<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>任何子項目時，明確指定</xref:System.Windows.ResourceDictionary>的位置 如需詳細資訊，請參閱[合併資源字典](~/add/includes/ajax-current-ext-md.md)。      <a name=&quot;xamlPropertyElementUsage_Resources&quot;></a># # XAML 屬性項目用法```   <object>     <object.Resources>       oneOrMoreResourceElements     </object.Resources>   </object>   ``` <a name=&quot;xamlValues_Resources&quot;> </a> # # XAML 值*oneOrMoreResourceElements*一或多個物件項目，其中每個定義的資源。       每個資源屬性的項目在每個<xref:System.Windows.ResourceDictionary>值必須是唯一的[X:key 指示詞](~/add/includes/ajax-current-ext-md.md)，做為唯一索引鍵從<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>擷取值時</xref:System.Windows.ResourceDictionary>"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "目前在本機定義的資源字典，其中每個資源都可以使用索引鍵來存取。"
  overload: System.Windows.FrameworkElement.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  id: SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "將繫結附加至這個項目，根據提供的來源屬性名稱當做資料來源的路徑限定性條件。"
  remarks: "這個方法是便利的方法用於呼叫<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>，然後傳遞做為目前的執行個體<xref:System.Windows.DependencyObject>，並建立新<xref:System.Windows.Data.Binding>依據提供`path`參數。</xref:System.Windows.Data.Binding> </xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName> 此簽章是更方便，如果您要建立簡單的預設繫結。 如果您要指定非預設的條件，任何繫結屬性，或想要使用<xref:System.Windows.Data.MultiBinding>或<xref:System.Windows.Data.PriorityBinding>，您應該使用<xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>簽章。</xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> </xref:System.Windows.Data.PriorityBinding> </xref:System.Windows.Data.MultiBinding>"
  example:
  - "The following example sets a binding using a specific path.  \n  \n [!code-cs[BaseElementsSmorgasbord#SetBindingPath](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#setbindingpath)]\n [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#setbindingpath)]"
  syntax:
    content: public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "識別應該要建立繫結的目的地屬性。"
    - id: path
      type: System.String
      description: "來源屬性名稱或用來繫結屬性的路徑。"
    return:
      type: System.Windows.Data.BindingExpression
      description: "記錄繫結的條件。 這個傳回值可用於錯誤檢查。"
  overload: System.Windows.FrameworkElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  id: SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "將繫結附加至這個項目，根據提供的繫結物件。"
  remarks: "這個方法是便利的方法<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>，然後傳遞目前的執行個體，作為<xref:System.Windows.DependencyObject>.</xref:System.Windows.DependencyObject></xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>函式呼叫"
  syntax:
    content: public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "識別應該要建立繫結的屬性。"
    - id: binding
      type: System.Windows.Data.BindingBase
      description: "代表資料繫結的詳細規格。"
    return:
      type: System.Windows.Data.BindingExpressionBase
      description: "記錄繫結的條件。 這個傳回值可用於錯誤檢查。"
  overload: System.Windows.FrameworkElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  id: SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetFlowDirection(DependencyObject,FlowDirection)
  nameWithType: FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  fullName: System.Windows.FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "設定的值<xref:System.Windows.FrameworkElement.FlowDirection*>附加屬性提供的項目。</xref:System.Windows.FrameworkElement.FlowDirection*>"
  remarks: "這個方法支援附加的屬性的語法<xref:System.Windows.FrameworkElement.FlowDirection%2A>屬性，因此允許的提供項目子系<xref:System.Windows.FrameworkElement>以指定的排列方式，其父項目中的資料流程方向。</xref:System.Windows.FrameworkElement> </xref:System.Windows.FrameworkElement.FlowDirection%2A> 在目前設定的值<xref:System.Windows.FrameworkElement>，使用 direct[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]存取子<xref:System.Windows.FrameworkElement.FlowDirection%2A>.</xref:System.Windows.FrameworkElement.FlowDirection%2A> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);
    parameters:
    - id: element
      type: System.Windows.DependencyObject
      description: "指定文字方向的項目。"
    - id: value
      type: System.Windows.FlowDirection
      description: "指定方向的列舉值。"
  overload: System.Windows.FrameworkElement.SetFlowDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  id: SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkElement.SetResourceReference(DependencyProperty,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "搜尋具有指定名稱的資源，並設定其資源參考指定之屬性。"
  remarks: "資源參考是可讓您使用類似[DynamicResource 標記延伸](~/add/includes/ajax-current-ext-md.md)標記中。 資源參考建立內部的運算式，提供執行階段的延遲為基礎的指定屬性的值。 每次您的資源字典表示變更的值，透過內部事件，或目前的項目重設父代重新評估運算式 （父代變更會變更的字典查閱路徑）。"
  syntax:
    content: public void SetResourceReference (System.Windows.DependencyProperty dp, object name);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "繫結至資源屬性。"
    - id: name
      type: System.Object
      description: "資源的名稱。"
  overload: System.Windows.FrameworkElement.SetResourceReference*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeResources
  id: ShouldSerializeResources
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeResources()
  nameWithType: FrameworkElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkElement.ShouldSerializeResources()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "傳回序列化程序是否應該序列化的內容<xref:System.Windows.FrameworkElement.Resources*>屬性。</xref:System.Windows.FrameworkElement.Resources*>"
  remarks: "這會傳回`true`，只要在本機<xref:System.Windows.FrameworkElement.Resources%2A>.</xref:System.Windows.FrameworkElement.Resources%2A>沒有至少一個索引鍵的資源"
  syntax:
    content: public bool ShouldSerializeResources ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Windows.FrameworkElement.Resources*>屬性值應該序列化，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Windows.FrameworkElement.Resources*>"
  overload: System.Windows.FrameworkElement.ShouldSerializeResources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle
  id: ShouldSerializeStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeStyle()
  nameWithType: FrameworkElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkElement.ShouldSerializeStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "傳回序列化程序是否應該序列化的內容<xref:System.Windows.FrameworkElement.Style*>屬性。</xref:System.Windows.FrameworkElement.Style*>"
  remarks: "這會傳回`true`如果<xref:System.Windows.Style>本機設定。</xref:System.Windows.Style>"
  syntax:
    content: public bool ShouldSerializeStyle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Windows.FrameworkElement.Style*>屬性值應該序列化，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Windows.FrameworkElement.Style*>"
  overload: System.Windows.FrameworkElement.ShouldSerializeStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers
  id: ShouldSerializeTriggers
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ShouldSerializeTriggers()
  nameWithType: FrameworkElement.ShouldSerializeTriggers()
  fullName: System.Windows.FrameworkElement.ShouldSerializeTriggers()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "傳回序列化程序是否應該序列化的內容<xref:System.Windows.FrameworkElement.Triggers*>屬性。</xref:System.Windows.FrameworkElement.Triggers*>"
  remarks: "這個方法會傳回`true`如果<xref:System.Windows.FrameworkElement.Triggers%2A>屬性在本機設定。</xref:System.Windows.FrameworkElement.Triggers%2A>"
  syntax:
    content: public bool ShouldSerializeTriggers ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Windows.FrameworkElement.Triggers*>屬性值應該序列化，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Windows.FrameworkElement.Triggers*>"
  overload: System.Windows.FrameworkElement.ShouldSerializeTriggers*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SizeChanged
  id: SizeChanged
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SizeChanged
  nameWithType: FrameworkElement.SizeChanged
  fullName: System.Windows.FrameworkElement.SizeChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "發生當任一<> *> 或<> *> 屬性變更值，這個項目上的。"
  remarks: "直接路由的事件不會遵循路由，才會處理在引發相同的項目內。 直接路由的事件並支援其他路由的事件的行為︰ 它們支援可存取的處理常式集合中，且可用來當作<xref:System.Windows.EventTrigger>樣式。</xref:System.Windows.EventTrigger>       版面配置系統會讀取內容內<xref:System.Windows.SizeChangedEventArgs>引數類別，這個事件，以判斷是否應該在報告的大小變更視為重要。</xref:System.Windows.SizeChangedEventArgs> 這可讓版面配置系統或您的特定控制項的版面配置實作來避免強制版面配置變更，因為以視覺化方式無法察覺舊的和新的高度或寬度值之間的差異。 無法察覺的差異可能是因為浮點資料類型的捨入或相同結果的計算。      <a name=&quot;routedEventInfo_SizeChanged&quot;></a># # 路由事件資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  |路由策略 |直接 |  |委派 |<xref:System.Windows.SizeChangedEventHandler>|</xref:System.Windows.SizeChangedEventHandler></xref:System.Windows.FrameworkElement.SizeChangedEvent>"
  syntax:
    content: public event System.Windows.SizeChangedEventHandler SizeChanged;
    return:
      type: System.Windows.SizeChangedEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SizeChangedEvent
  id: SizeChangedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SizeChangedEvent
  nameWithType: FrameworkElement.SizeChangedEvent
  fullName: System.Windows.FrameworkElement.SizeChangedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref href=&quot;System.Windows.FrameworkElement.SizeChanged&quot;></xref>路由的事件。"
  remarks: "註冊路由的事件時，會建立路由的事件識別項。 這些識別碼包含識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。 您可以使用這些識別項來加入類別處理常式。       如需註冊路由的事件的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 如需使用路由的事件識別項來加入類別處理常式的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent SizeChangedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.SourceUpdated
  id: SourceUpdated
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: SourceUpdated
  nameWithType: FrameworkElement.SourceUpdated
  fullName: System.Windows.FrameworkElement.SourceUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "任何現有的屬性，這個項目上的繫結的來源值變更時發生。"
  remarks: "此事件會建立一個別名<xref:System.Windows.Data.Binding.SourceUpdated>引發任何事件<xref:System.Windows.Data.Binding>與這個項目相關聯。</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.SourceUpdated>      <a name=&quot;xamlAttributeUsage_SourceUpdated&quot;></a># # XAML 屬性使用方式```   <object SourceUpdated=&quot;eventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> SourceUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Style
  id: Style
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Style
  nameWithType: FrameworkElement.Style
  fullName: System.Windows.FrameworkElement.Style
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定這個項目呈現時使用的樣式。"
  remarks: "控制項，通常是提供的預設樣式來自控制項主題設定，或樣式通常由套用至該類型的控制項在頁面或應用程式層級 （隱含樣式） 的資源目前的樣式。 這個屬性不會設定或傳回預設 （佈景主題） 樣式，但會傳回隱含樣式或項目做為明確樣式。 在隱含或明確樣式的情況下，樣式是指定為資源，或在本機定義並不重要。       設定樣式會有一些限制。 您可以將整個樣式屬性重設為 新<xref:System.Windows.Style>在任何時間，這會強制配置重新編輯畫。</xref:System.Windows.Style> 不過，一旦該樣式會放在使用中載入的項目，<xref:System.Windows.Style>應該被視為已密封。</xref:System.Windows.Style> 嘗試變更的任何個別的使用中樣式屬性 (例如在集合內的任何項目<xref:System.Windows.Style.Setters%2A>)，會擲回例外狀況。</xref:System.Windows.Style.Setters%2A> 標記中定義的樣式會被視為正在使用中，一旦載入時將它從資源字典 （資源），或載入它包含在的頁面 （適用於內嵌樣式）。       樣式是具有特殊的優先順序的相依性屬性。 本機設定樣式通常都是在運作的最高的優先順序屬性系統中。 如果樣式此時為 null，期間載入屬性系統會檢查本機或應用程式將該類型指定的資源中的隱含樣式。 如果樣式仍 null 在此步驟之後，然後顯示用途的動作樣式通常來自預設 （佈景主題） 的樣式，但樣式屬性值中不會傳回預設樣式。 請參閱[相依性屬性的值優先順序](~/add/includes/ajax-current-ext-md.md)或[設定樣式和範本](~/add/includes/ajax-current-ext-md.md)。      <a name=&quot;xamlAttributeUsage_Style&quot;></a># # XAML 屬性使用方式```   <object Style=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_Style&quot;> </a> # # XAML 屬性項目用法<a name=&quot;xamlValues_Style&quot;> </a> # # XAML 值*resourceExtension*下列其中之一:、 或。       請參閱[XAML 資源](~/add/includes/ajax-current-ext-md.md)。       *styleResourceKey*識別所要求的樣式的索引鍵。 索引鍵參考<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>中現有的資源      > [!NOTE] > 屬性項目語法是可行，但不是建議針對大部分的樣式案例。 請參閱[內嵌樣式和樣板](~/add/includes/ajax-current-ext-md.md)。 使用繫結參考或<xref:System.Windows.Data.Binding>也是可行的但不常見。</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_Style&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.StyleProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.StyleProperty>"
  example:
  - "The following example defines a style in a resource dictionary.  \n  \n [!code-xml[FEResource#StyleProperty](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty)]  \n[!code-xml[FEResource#StyleProperty2](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty2)]  \n[!code-xml[FEResource#StyleProperty3](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty3)]  \n[!code-xml[FEResource#StyleProperty4](~/add/codesnippet/xaml/FEResource/default.xaml#styleproperty4)]"
  syntax:
    content: public System.Windows.Style Style { get; set; }
    return:
      type: System.Windows.Style
      description: "已套用的非預設樣式項目，如果有的話。 否則， <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。 預設建構預設<xref href=&quot;System.Windows.FrameworkElement&quot;></xref>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkElement.Style*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.StyleProperty
  id: StyleProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: StyleProperty
  nameWithType: FrameworkElement.StyleProperty
  fullName: System.Windows.FrameworkElement.StyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.Style*>相依性屬性。</xref:System.Windows.FrameworkElement.Style*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty StyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "如需這個成員的說明，請參閱<xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>方法。</xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>"
  remarks: "這個成員是明確介面成員實作。 它可用時，才<xref:System.Windows.FrameworkElement>執行個體轉換成<xref:System.Windows.Markup.IQueryAmbient>介面。</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.FrameworkElement>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "要求的環境屬性的名稱。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<code> propertyName </code>可用，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Tag
  id: Tag
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Tag
  nameWithType: FrameworkElement.Tag
  fullName: System.Windows.FrameworkElement.Tag
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定可以用來儲存這個項目相關的自訂資訊的任意物件值。"
  remarks: "這個屬性相當於在其他標籤屬性[!INCLUDE[TLA#tla_ms](~/add/includes/tlasharptla-ms-md.md)]程式設計模型，例如[!INCLUDE[TLA#tla_vba](~/add/includes/ajax-current-ext-md.md)]或[!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)]。 標記用來提供既有的屬性位置，您可以在其中儲存有關任何一些基本的自訂資訊<xref:System.Windows.FrameworkElement>而不需要您子類別化項目。</xref:System.Windows.FrameworkElement>       因為此屬性會接受物件，您可能必須以設定標記屬性使用屬性項目用法[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]至具有已知與內建型別轉換子，例如字串的物件以外的任何項目。 這種方式中使用的物件通常不是標準內[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]命名空間，因此可能需要為了引進，做為外部命名空間的命名空間對應[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]項目。 如需詳細資訊，請參閱[XAML 命名空間和 WPF XAML 命名空間對應](~/add/includes/ajax-current-ext-md.md)和[XAML 和自訂類別 wpf](~/add/includes/ajax-current-ext-md.md)。      <a name=&quot;dependencyPropertyInfo_Tag&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.TagProperty>|  |中繼資料屬性設定為`true`|None |</xref:System.Windows.FrameworkElement.TagProperty>"
  syntax:
    content: public object Tag { get; set; }
    return:
      type: System.Object
      description: "預定的值。 這個屬性就沒有預設值。"
  overload: System.Windows.FrameworkElement.Tag*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TagProperty
  id: TagProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TagProperty
  nameWithType: FrameworkElement.TagProperty
  fullName: System.Windows.FrameworkElement.TagProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.Tag*>相依性屬性。</xref:System.Windows.FrameworkElement.Tag*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TagProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TargetUpdated
  id: TargetUpdated
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TargetUpdated
  nameWithType: FrameworkElement.TargetUpdated
  fullName: System.Windows.FrameworkElement.TargetUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "這個項目上的任何屬性繫結的目標值變更時發生。"
  remarks: "此事件會建立一個別名<xref:System.Windows.Data.Binding.TargetUpdated>引發任何事件<xref:System.Windows.Data.Binding>與這個項目相關聯。</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.TargetUpdated> 這通常表示有問題的繫結是雙向繫結，繫結的相依性屬性 affirms，先前的屬性值無效現在根據任何驗證或快取的屬性或資料來源支援的配置。       您可以使用 TargetUpdated 事件的事件資料來判斷所報告的目標值更新的特定屬性。      <a name=&quot;xamlAttributeUsage_TargetUpdated&quot;></a># # XAML 屬性使用方式```   <object TargetUpdated=&quot;eventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> TargetUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TemplatedParent
  id: TemplatedParent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
  fullName: System.Windows.FrameworkElement.TemplatedParent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得這個項目的範本父代參考。 如果未透過範本建立的項目，這個屬性無關。"
  remarks: "通常是 TemplatedParent`null`會在您的應用程式標記或程式碼中建立的物件。 這是因為您建立這些物件直接，不會透過範本。 物件或一般名稱參考來查核邏輯樹狀結構根目錄中，從取得的參考，不是來自範本。       情況下，可能不會 TemplatedParent`null`包含點擊測試查核視覺化樹狀結構，與特定低階事件輸入的事件處理等作業<xref:System.Windows.Media.VisualTreeHelper>，或使用列舉值，這可能會傳回來自範本的項目。</xref:System.Windows.Media.VisualTreeHelper> 另一種情況是如果您特別呼叫<xref:System.Windows.FrameworkTemplate.FindName%2A>針對現有<xref:System.Windows.FrameworkTemplate>和會使用傳回的物件。</xref:System.Windows.FrameworkTemplate> </xref:System.Windows.FrameworkTemplate.FindName%2A>       範本是範本的內容會一次建立的實際共用的物件。 因此，如果您取得的項目，以來自範本的物件參考時，您可能會發現明顯的邏輯樹狀結構不會到達頁面根。 若要連接至邏輯樹狀結構頁面的這類的範本參考，您應該取得 TemplatedParent 值，並繼續瀏覽所需的項目樹狀結構。"
  syntax:
    content: public System.Windows.DependencyObject TemplatedParent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "項目其<xref href=&quot;System.Windows.FrameworkTemplate&quot;> </xref> <xref:System.Windows.FrameworkTemplate.VisualTree*>造成要建立這個項目。</xref:System.Windows.FrameworkTemplate.VisualTree*> 這個值通常是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; 請參閱 < 備註 >。"
  overload: System.Windows.FrameworkElement.TemplatedParent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTip
  id: ToolTip
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
  fullName: System.Windows.FrameworkElement.ToolTip
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定顯示在這個項目的工具提示物件[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]。"
  remarks: "如果這個屬性的值屬於型別<xref:System.Windows.Controls.ToolTip>，該值就會用於工具提示[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]。</xref:System.Windows.Controls.ToolTip>  如果值為任何其他型別，則該值會用作*內容*如<xref:System.Windows.Controls.ToolTip>提供 （建構） 系統。</xref:System.Windows.Controls.ToolTip> 如需詳細資訊，請參閱<xref:System.Windows.Controls.ToolTipService>.</xref:System.Windows.Controls.ToolTipService> 服務類別會提供可用來進一步自訂<xref:System.Windows.Controls.ToolTip>.</xref:System.Windows.Controls.ToolTip>的附加的屬性      <a name=&quot;xamlAttributeUsage_ToolTip&quot;></a># # XAML 屬性使用方式```   <object ToolTip=&quot;toolTipContent&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_ToolTip&quot;> </a> # # XAML 屬性項目用法```   <object>     <object.ToolTip>       <ToolTip .../>     </object.ToolTip>   </object>   - or -   <object>     <object.ToolTip>       toolTipObjectContent     </object.ToolTip>   </object>   ``` <a name=&quot;xamlValues_ToolTip&quot;> </a> # # XAML 值*toolTipContent*工具提示會顯示文字的字串。                   *toolTipObjectContent*是用來做為內容<xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement>物件項目表單中所提供的某些物件 通常這會是<xref:System.Windows.FrameworkElement>或其他一些建立工具提示中，最後會包含文字內容的複合 （compositing） 配置的複合 （compositing） 的項目。</xref:System.Windows.FrameworkElement> 在這種用法，<xref:System.Windows.Controls.ToolTip>元素建立隱含從已剖析[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]，而*toolTipObjectContent*內容設定為其<xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName>屬性。</xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName> </xref:System.Windows.Controls.ToolTip>       `ToolTip`.../>    See <xref:System.Windows.Controls.ToolTip>.</xref:System.Windows.Controls.ToolTip>      <a name=&quot;dependencyPropertyInfo_ToolTip&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.ToolTipProperty>|  |中繼資料屬性設定為`true`|None |</xref:System.Windows.FrameworkElement.ToolTipProperty>"
  example:
  - "The following example creates a <xref:System.Windows.Controls.ToolTip> in code and then sets the ToolTip property on a <xref:System.Windows.Controls.Primitives.StatusBar> control.  \n  \n [!code-vb[StatusBar#MakeProgressBar](~/add/codesnippet/visualbasic/statusbar/window1.xaml.vb#makeprogressbar)]\n [!code-cs[StatusBar#MakeProgressBar](~/add/codesnippet/csharp/StatusBar/Window1.xaml.cs#makeprogressbar)]"
  syntax:
    content: public object ToolTip { get; set; }
    return:
      type: System.Object
      description: "工具提示物件。 為什麼這個參數已不強類型的詳細資訊，請參閱以下的 < 備註 >。"
  overload: System.Windows.FrameworkElement.ToolTip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipClosing
  id: ToolTipClosing
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipClosing
  nameWithType: FrameworkElement.ToolTipClosing
  fullName: System.Windows.FrameworkElement.ToolTipClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "項目上的任何工具提示關閉之前發生。"
  remarks: "標示為已處理的 ToolTipClosing 事件並不會取消關閉工具提示。 工具提示顯示之後，關閉工具提示會進行只回應使用者互動與 UI。       此事件不可以是<xref:System.Windows.EventTrigger>樣式。</xref:System.Windows.EventTrigger> 這是因為此事件的識別項欄位會重複使用來自服務未公開新增/移除服務層級事件的事件方法的實作。      <a name=&quot;routedEventInfo_ToolTipClosing&quot;></a># # 路由事件資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  |路由策略 |直接 |  |委派 |<xref:System.Windows.Controls.ToolTipEventHandler>|     -覆寫<xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>實作在衍生類別中這個事件的類別處理。</xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> </xref:System.Windows.Controls.ToolTipEventHandler> </xref:System.Windows.FrameworkElement.ToolTipClosingEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipClosingEvent
  id: ToolTipClosingEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipClosingEvent
  nameWithType: FrameworkElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkElement.ToolTipClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref href=&quot;System.Windows.FrameworkElement.ToolTipClosing&quot;></xref>路由的事件。"
  remarks: "註冊路由的事件時，會建立路由的事件識別項。 這些識別碼包含識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。 您可以使用這些識別項來加入類別處理常式。       如需註冊路由的事件的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 如需使用路由的事件識別項來加入類別處理常式的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipOpening
  id: ToolTipOpening
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipOpening
  nameWithType: FrameworkElement.ToolTipOpening
  fullName: System.Windows.FrameworkElement.ToolTipOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "項目上的任何工具提示開啟時發生。"
  remarks: "若要避免工具提示出現在 UI 中，可以將標記 ToolTipOpening 的處理常式<xref:System.Windows.Controls.ToolTipEventArgs>處理的事件資料。</xref:System.Windows.Controls.ToolTipEventArgs> 否則，顯示工具提示，使用值<xref:System.Windows.FrameworkElement.ToolTip%2A>做為工具提示內容的屬性。</xref:System.Windows.FrameworkElement.ToolTip%2A> 另一個可能的狀況是您可以撰寫會重設的值的處理常式<xref:System.Windows.FrameworkElement.ToolTip%2A>針對項目，事件來源，才會顯示工具提示的屬性。</xref:System.Windows.FrameworkElement.ToolTip%2A>       如果不會引發 ToolTipOpening 值<xref:System.Windows.FrameworkElement.ToolTip%2A>是`null`或其他未設定。</xref:System.Windows.FrameworkElement.ToolTip%2A> 不刻意設定<xref:System.Windows.FrameworkElement.ToolTip%2A>至`null`tooltip 為開啟，或開啟; 這並不會影響關閉工具提示中，且會改為建立在 UI 中讓人困擾的視覺成品時。</xref:System.Windows.FrameworkElement.ToolTip%2A>       ToolTipOpening 事件不可以是<xref:System.Windows.EventTrigger>樣式。</xref:System.Windows.EventTrigger> 這是因為此事件的識別項欄位會重複使用來自服務未公開新增/移除服務層級事件的事件方法的實作。      <a name=&quot;routedEventInfo_ToolTipOpening&quot;></a># # 路由事件資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  |路由策略 |直接 |  |委派 |<xref:System.Windows.Controls.ToolTipEventHandler>|     -覆寫<xref:System.Windows.FrameworkElement.OnToolTipClosing%2A>實作在衍生類別中這個事件的類別處理。</xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> </xref:System.Windows.Controls.ToolTipEventHandler> </xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipOpeningEvent
  id: ToolTipOpeningEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipOpeningEvent
  nameWithType: FrameworkElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkElement.ToolTipOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref href=&quot;System.Windows.FrameworkElement.ToolTipOpening&quot;></xref>路由的事件。"
  remarks: "註冊路由的事件時，會建立路由的事件識別項。 這些識別碼包含識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。 您可以使用這些識別項來加入類別處理常式。       如需註冊路由的事件的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 如需使用路由的事件識別項來加入類別處理常式的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.ToolTipProperty
  id: ToolTipProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: ToolTipProperty
  nameWithType: FrameworkElement.ToolTipProperty
  fullName: System.Windows.FrameworkElement.ToolTipProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.ToolTip*>相依性屬性。</xref:System.Windows.FrameworkElement.ToolTip*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ToolTipProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Triggers
  id: Triggers
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Triggers
  nameWithType: FrameworkElement.Triggers
  fullName: System.Windows.FrameworkElement.Triggers
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得直接在這個項目或子項目中建立的觸發程序的集合。"
  remarks: "> [!NOTE]> 這個屬性只能在設定[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]集合語法所示，透過或存取的集合物件和使用的各種方法，例如 Add。 用來存取集合物件本身屬性是唯讀，集合本身為讀寫。 屬性只存在於根項目。嘗試尋找它，或將它設定其他位置，將會導致擲回例外狀況。       這個屬性不會啟用檢查存在於這個項目上的使用中的樣式部分的觸發程序。 它只會報告常值加入至集合，在標記或程式碼中的觸發程序的集合。 項目通常不會有此類項目根據預設 (透過範本執行個體)。它目前更常見是來自改為建立在樣式中的複合控制項的觸發程序。       行為 （並嘗試建立的效果是來自哪一個項目宣告的觸發程序集合），以觸發條件和觸發程序的效果可能是因為在這個項目，或可能是因為在其子項目邏輯樹狀結構中。 請注意，如果您使用存留期事件，例如<xref:System.Windows.FrameworkElement.Loaded>若要取得此集合，子元素的觸發程序會尚未完全載入，而集合將會小於在執行階段會真正。</xref:System.Windows.FrameworkElement.Loaded>       請注意，項目上建立觸發程序的集合只支援<xref:System.Windows.EventTrigger>，不屬性觸發程序 (<xref:System.Windows.Trigger>)。</xref:System.Windows.Trigger> </xref:System.Windows.EventTrigger> 如果您需要屬性觸發程序，必須將這些樣式或範本中，並再指派該樣式或範本的項目可以是直接透過<xref:System.Windows.FrameworkElement.Style%2A>屬性，或間接透過隱含樣式參考。</xref:System.Windows.FrameworkElement.Style%2A>      <a name=&quot;xamlPropertyElementUsage_Triggers&quot;></a># # XAML 屬性項目用法```   <object>     <object.Triggers>       oneOrMoreTriggers     </object.Triggers>   </object>   ``` <a name=&quot;xamlValues_Triggers&quot;> </a> # # XAML 值*oneOrMoreTriggers*一或多個定義<xref:System.Windows.EventTrigger>項目。</xref:System.Windows.EventTrigger>       每個這類觸發程序必須包含有效的分鏡腳本動作和參考。 請注意，這個集合只能建立在頁面的根項目上。 如需詳細資訊，請參閱[概觀腳本](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public System.Windows.TriggerCollection Triggers { get; }
    return:
      type: System.Windows.TriggerCollection
      description: "強類型的集合<xref href=&quot;System.Windows.Trigger&quot;></xref>物件。"
  overload: System.Windows.FrameworkElement.Triggers*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: FrameworkElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkElement.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "搜尋的資源，以指定的索引鍵，並傳回該資源，如果找到。"
  remarks: "如果呼叫的項目上找不到資源，處理邏輯樹狀結構向上搜尋父資源樹狀結構，在樹狀結構的方式相同搜尋的若資源已由索引鍵要求在執行階段。 方法會傳回`null`只有該金鑰的任何資源存不在於資源樹狀目錄中任何位置，如果每個現有的條件，在樹狀目錄的該 TryFindResource 呼叫。       通常您會立即傳回值轉換為您嘗試使用傳回的資源值設定屬性的型別。       <xref:System.Windows.FrameworkElement.FindResource%2A>方法具有類似的行為不同之處在於它擲回例外狀況，如果不傳回提供的索引鍵的任何資源。</xref:System.Windows.FrameworkElement.FindResource%2A>"
  example:
  - "The following example is implemented as a button handler, where the button being clicked sets its background to a resource-defined brush obtained by calling TryFindResource on itself. This walks the element tree and finds the resource (the resource itself is defined in [!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] and is not shown).  \n  \n [!code-cs[BaseElementsSmorgasbord#FETryFindResource](~/add/codesnippet/csharp/BaseElementsSmorgasbord/Page1.xaml.cs#fetryfindresource)]\n [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/add/codesnippet/visualbasic/baseelementssmorgasbord/page1.xaml.vb#fetryfindresource)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "要尋找資源的索引鍵的識別碼。"
    return:
      type: System.Object
      description: "找到的資源，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果使用提供的任何資源<code> key </code>找到。"
  overload: System.Windows.FrameworkElement.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Unloaded
  id: Unloaded
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Unloaded
  nameWithType: FrameworkElement.Unloaded
  fullName: System.Windows.FrameworkElement.Unloaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "發生於從載入元素的項目樹狀結構中移除項目。"
  remarks: "直接路由的事件不會遵循路由，才會處理在引發相同的項目內。 直接路由的事件並支援其他路由的事件的行為︰ 它們支援可存取的處理常式集合中，且可用來當作<xref:System.Windows.EventTrigger>樣式。</xref:System.Windows.EventTrigger>       <xref:System.Windows.FrameworkElement.Loaded>並卸載可能同時會引發由於使用者啟動系統的佈景主題變更的控制項上。</xref:System.Windows.FrameworkElement.Loaded> 佈景主題變更會導致控制項樣板和自主視覺化樹狀結構，因此使得卸載再重新載入整個控制項的失效。 因此無法假設卸載只會發生在巡覽離開該頁面。       請注意在應用程式開始關閉之後不會引發卸載事件。 所定義的條件時，就會發生應用程式關閉<xref:System.Windows.Application.ShutdownMode%2A>屬性，就會發生。</xref:System.Windows.Application.ShutdownMode%2A> 如果您清除程式碼中事件處理常式卸載，例如針對<xref:System.Windows.Window>或<xref:System.Windows.Controls.UserControl>，它可能不會呼叫如預期般。</xref:System.Windows.Controls.UserControl> </xref:System.Windows.Window>      <a name=&quot;routedEventInfo_Unloaded&quot;></a># # 路由事件資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.UnloadedEvent>|  |路由策略 |直接 |  |委派 |<xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkElement.UnloadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Unloaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UnloadedEvent
  id: UnloadedEvent
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UnloadedEvent
  nameWithType: FrameworkElement.UnloadedEvent
  fullName: System.Windows.FrameworkElement.UnloadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref href=&quot;System.Windows.FrameworkElement.Unloaded&quot;></xref>路由的事件。"
  remarks: "註冊路由的事件時，會建立路由的事件識別項。 這些識別碼包含識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。 您可以使用這些識別項來加入類別處理常式。       如需註冊路由的事件的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 如需使用路由的事件識別項來加入類別處理常式的詳細資訊，請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>.</xref:System.Windows.EventManager.RegisterClassHandler%2A>"
  syntax:
    content: public static readonly System.Windows.RoutedEvent UnloadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UnregisterName(System.String)
  id: UnregisterName(System.String)
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UnregisterName(String)
  nameWithType: FrameworkElement.UnregisterName(String)
  fullName: System.Windows.FrameworkElement.UnregisterName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "簡化存取<xref:System.Windows.NameScope>取消註冊方法。</xref:System.Windows.NameScope>"
  remarks: "您只需要取消註冊名稱如果您想要重新註冊該相同名稱的另一個項目。"
  syntax:
    content: public void UnregisterName (string name);
    parameters:
    - id: name
      type: System.String
      description: "從目前的範圍中移除之名稱-物件組的名稱。"
  overload: System.Windows.FrameworkElement.UnregisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle
  id: UpdateDefaultStyle
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UpdateDefaultStyle()
  nameWithType: FrameworkElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkElement.UpdateDefaultStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "重新套用至目前的預設樣式<xref href=&quot;System.Windows.FrameworkElement&quot;> </xref>。"
  syntax:
    content: public void UpdateDefaultStyle ();
    parameters: []
  overload: System.Windows.FrameworkElement.UpdateDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UseLayoutRounding
  id: UseLayoutRounding
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
  fullName: System.Windows.FrameworkElement.UseLayoutRounding
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，指出配置進位是否應該套用到此項目的大小和位置在配置期間。"
  remarks: "當 UseLayoutRounding 屬性的項目是`true`，所有的非整數像素值期間所計算<xref:System.Windows.UIElement.Measure%2A>和<xref:System.Windows.UIElement.Arrange%2A>傳遞會捨入到整個像素值。</xref:System.Windows.UIElement.Arrange%2A> </xref:System.Windows.UIElement.Measure%2A>       子項目會繼承這個屬性。      > [!NOTE] > 應設 UseLayoutRounding`true`根元素。 版面配置系統會將子座標加入至父代的座標。因此，如果父座標不像素界限上，子座標也不像素界限上。 如果 UseLayoutRounding 無法設定在根目錄中，設定<xref:System.Windows.UIElement.SnapsToDevicePixels%2A>上的子系，以取得您想要的效果。</xref:System.Windows.UIElement.SnapsToDevicePixels%2A>       繪製像素界限的物件排除半透明效果的邊緣時，所產生的消除鋸齒邊緣落在裝置像素。 下圖顯示落在裝置像素的單一像素寬度列的輸出。 左邊的行號不會使用配置進位，且已消除鋸齒。 在右邊的列會使用配置進位。       ![消除鋸齒線條與單一像素線條比較。](~/add/media/pixelsnaplinecompare.PNG &quot;消除鋸齒線條與單一像素線條比較。&quot;)       當您使用配置進位，<xref:System.Windows.GridUnitType>調整大小、 版面配置系統會建立小型的變化中的資料行或資料列的度量，以避免呈現子像素。</xref:System.Windows.GridUnitType> 例如，如果方格具有 3 個資料行大小的 100 總寬度<xref:System.Windows.GridUnitType>，而不是建立三個資料行 33.3 等寬，版面配置系統會建立 2 個資料行的寬度為 33，另一個則的寬度為 34。</xref:System.Windows.GridUnitType>      > [!NOTE] > 中.NET 4.6 已變更配置進位以減少含邊界之控制項中的裁剪功能的執行個體。 根據預設，如果您的目標 Framework 是.NET Framework 4.6 或更高版本，會啟用這項功能。 以舊版 framework 為目標的應用程式可以選擇加入新行為加入 app.config 檔案中的下列設定︰`<runtime>``<AppContextSwitchOverrides      value=&quot;Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false&quot;/>``</runtime>`設定才會生效，.NET Framework 4.6 上執行應用程式時。"
  example:
  - "The following example demonstrates the effect that the UseLayoutRounding property has on a single pixel-width line. The line on the left does not use layout rounding and the line on the right uses layout rounding. If you slowly resize the window, you can see the difference that layout rounding makes.  \n  \n```xaml  \n  \n<Page x:Class=\"LayoutRounding.Lines\"  \n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"  \n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"  \n    Title=\"Lines\" Name=\"linesPage\"  \n    >  \n  <StackPanel Width=\"150\"  Margin=\"7\" Orientation=\"Horizontal\">  \n    <!-- Single pixel line with layout rounding turned OFF.-->  \n    <Rectangle UseLayoutRounding=\"False\"  \n       Width=\"45.5\" Margin=\"10\" Height=\"1\" Fill=\"Red\"/>  \n    <!-- Single pixel line with layout rounding turned ON.-->  \n    <Rectangle UseLayoutRounding=\"True\"  \n      Width=\"45.5\" Margin=\"10\" Height=\"1\" Fill=\"Red\"/>  \n  </StackPanel>  \n  <!-- Background Grid -->  \n  <Page.Background>  \n    <DrawingBrush  Viewport=\"0,0,10,10\" ViewportUnits=\"Absolute\" TileMode=\"Tile\">  \n      <DrawingBrush.Drawing>  \n        <DrawingGroup>  \n          <GeometryDrawing Brush=\"White\">  \n            <GeometryDrawing.Geometry>  \n              <RectangleGeometry Rect=\"0,0,1,1\" />  \n            </GeometryDrawing.Geometry>  \n          </GeometryDrawing>  \n          <GeometryDrawing Geometry=\"M0,0 L1,0 1,0.1, 0,0.1Z \" Brush=\"#CCCCFF\" />  \n          <GeometryDrawing Geometry=\"M0,0 L0,1 0.1,1, 0.1,0Z\" Brush=\"#CCCCFF\" />  \n        </DrawingGroup>  \n      </DrawingBrush.Drawing>  \n    </DrawingBrush>  \n  </Page.Background>  \n</Page>  \n```"
  syntax:
    content: public bool UseLayoutRounding { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果套用配置進位;否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkElement.UseLayoutRounding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  id: UseLayoutRoundingProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: UseLayoutRoundingProperty
  nameWithType: FrameworkElement.UseLayoutRoundingProperty
  fullName: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.UseLayoutRounding*>相依性屬性。</xref:System.Windows.FrameworkElement.UseLayoutRounding*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VerticalAlignment
  id: VerticalAlignment
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
  fullName: System.Windows.FrameworkElement.VerticalAlignment
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定套用至這個項目，例如面板或項目控制項的父元素中組成時的垂直對齊特性。"
  remarks: "當<xref:System.Windows.FrameworkElement.Height%2A><xref:System.Windows.FrameworkElement.Width%2A>項目上明確設定屬性</xref:System.Windows.FrameworkElement.Width%2A>，這些度量需要配置優先者列] 和 [取消設定此屬性為<xref:System.Windows.VerticalAlignment>。</xref:System.Windows.VerticalAlignment>規則的效果</xref:System.Windows.FrameworkElement.Height%2A>       垂直對齊是[!INCLUDE[TLA#tla_net](~/add/includes/tlasharptla-net-md.md)]實際上會相依性屬性的屬性存取子。 這個特定的相依性屬性相當常有衍生的項目類別，特別是控制項中以不同方式設定其明顯&quot;default&quot;值。 這通常發生在兩種方式之一︰ 重新登錄相依性屬性的特定衍生類別中，但具有不同的中繼資料來設定其預設值;或以不同的方式設定該相依性屬性的值為預設樣式套用。 例如，明顯 「 預設 」 的垂直對齊的<xref:System.Windows.Controls.ComboBoxItem>控制項將會是<xref:System.Windows.VerticalAlignment>，即使<xref:System.Windows.Controls.ComboBoxItem>繼承 VerticalAlignment 直接從<xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement> </xref:System.Windows.Controls.ComboBoxItem> </xref:System.Windows.VerticalAlignment> </xref:System.Windows.Controls.ComboBoxItem> 這是因為該值重設的預設樣式中<xref:System.Windows.Controls.ComboBoxItem>，樣式的控制項範本內。</xref:System.Windows.Controls.ComboBoxItem>       <xref:System.Windows.Controls.Canvas>不會使用垂直對齊時撰寫版面配置，因為<xref:System.Windows.Controls.Canvas>根據絕對位置。</xref:System.Windows.Controls.Canvas></xref:System.Windows.Controls.Canvas>       當<xref:System.Windows.Controls.ComboBoxItem>或任何衍生的類別，<xref:System.Windows.Controls.ComboBoxItem>會重新定義為<xref:System.Windows.VerticalAlignment>.</xref:System.Windows.VerticalAlignment>這個屬性的預設值</xref:System.Windows.Controls.ComboBoxItem></xref:System.Windows.Controls.ComboBoxItem>繼承      <a name=&quot;dependencyPropertyInfo_VerticalAlignment&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> </xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>"
  syntax:
    content: public System.Windows.VerticalAlignment VerticalAlignment { get; set; }
    return:
      type: System.Windows.VerticalAlignment
      description: "垂直對齊設定。 預設值是<xref href=&quot;System.Windows.VerticalAlignment&quot;> </xref>。"
  overload: System.Windows.FrameworkElement.VerticalAlignment*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VerticalAlignmentProperty
  id: VerticalAlignmentProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VerticalAlignmentProperty
  nameWithType: FrameworkElement.VerticalAlignmentProperty
  fullName: System.Windows.FrameworkElement.VerticalAlignmentProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.VerticalAlignment*>相依性屬性。</xref:System.Windows.FrameworkElement.VerticalAlignment*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.VisualChildrenCount
  id: VisualChildrenCount
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
  fullName: System.Windows.FrameworkElement.VisualChildrenCount
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得此項目內的視覺子項目的數目。"
  remarks: "<xref:System.Windows.FrameworkElement>VisualChildrenCount 的實作一律會傳回零個或一個。</xref:System.Windows.FrameworkElement> 維護可能會超過一個視覺化子集合的類別必須覆寫，此屬性和<xref:System.Windows.FrameworkElement.GetVisualChild%2A>.</xref:System.Windows.FrameworkElement.GetVisualChild%2A>       這個屬性通常用來決定用於實作的版面配置覆寫目前的子集合的上限 (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>， <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>)。</xref:System.Windows.FrameworkElement.ArrangeOverride%2A> </xref:System.Windows.FrameworkElement.MeasureOverride%2A>"
  example:
  - "The following example shows how a custom adorner uses the values declared by a <xref:System.Windows.Media.VisualCollection> that it maintains for its multiple visual children and reports these values through overrides of VisualChildrenCount and <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  \n  \n [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverridespre)]\n [!code-cs[Adorners_ResizingAdorner#FEVisualOverridesPre](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverridespre)]  \n[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/visualbasic/resizingadorner/resizingadorner.vb#fevisualoverrides)]\n[!code-cs[Adorners_ResizingAdorner#FEVisualOverrides](~/add/codesnippet/csharp/ResizingAdorner/ResizingAdorner.cs#fevisualoverrides)]"
  syntax:
    content: protected override int VisualChildrenCount { get; }
    return:
      type: System.Int32
      description: "視覺子項目，這個項目的數目。"
  overload: System.Windows.FrameworkElement.VisualChildrenCount*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.Width
  id: Width
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: Width
  nameWithType: FrameworkElement.Width
  fullName: System.Windows.FrameworkElement.Width
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定項目的寬度。"
  remarks: "這是三個屬性的其中一個上<xref:System.Windows.FrameworkElement>旗標會指定寬度資訊。</xref:System.Windows.FrameworkElement>  其他兩個是<xref:System.Windows.FrameworkElement.MinWidth%2A>和<xref:System.Windows.FrameworkElement.MaxWidth%2A>。</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A>  如果這些值之間沒有衝突，這是第一次應用程式的實際寬度判斷順序<xref:System.Windows.FrameworkElement.MinWidth%2A>必須能接受，然後<xref:System.Windows.FrameworkElement.MaxWidth%2A>，最後如果每一種寬度的範圍內。</xref:System.Windows.FrameworkElement.MaxWidth%2A> </xref:System.Windows.FrameworkElement.MinWidth%2A>       這個屬性傳回的值一律為任何已設定為它的值相同。 相較之下，值<xref:System.Windows.FrameworkElement.ActualWidth%2A>而異。</xref:System.Windows.FrameworkElement.ActualWidth%2A> 版面配置可能會拒絕某些原因建議的大小。 此外，版面配置系統本身相對於寬度的屬性系統組以非同步方式運作，而且可能處理該特定尚未調整大小屬性變更。       除了可接受<xref:System.Double>的值，這個屬性也可以是<xref:System.Double.NaN?displayProperty=fullName>.</xref:System.Double.NaN?displayProperty=fullName> </xref:System.Double> 這是您指定自動調整大小行為的方式。 在[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]您設定值的字串 「 自動 」 （不區分大小寫） 若要啟用自動調整大小行為。 自動調整大小行為表示項目將會填入可用的寬度。 不過請注意，特定控制項通常會提供將會停用自動調整大小行為，除非它是特別重新啟用其預設樣式中的預設值。       驗證檢查，除了沒有繫結會強制執行由配置系統的寬度不具決定性的上限值 (這是非常大數目，大於<xref:System.Single.MaxValue?displayProperty=fullName>但小於<xref:System.Double.MaxValue?displayProperty=fullName>)。</xref:System.Double.MaxValue?displayProperty=fullName> </xref:System.Single.MaxValue?displayProperty=fullName> 如果超過此限制，將不會呈現項目，並擲回任何例外狀況。 請勿將寬度設為明顯地大於任何可能的視覺顯示的大小上限的值，或您可能會超過此不具決定性的上限。      <a name=&quot;xamlAttributeUsage_Width&quot;></a># # XAML 屬性使用方式```   <object Width=&quot;double&quot;/>   - or –   <object Width =&quot;qualifiedDouble&quot;/>   - or -   <object Width =&quot;Auto&quot;/>   ``` <a name=&quot;xamlValues_Width&quot;> </a> # # XAML 值*double* <xref:System.Double>的字串表示法<xref:System.Double>等於或大於 0.0 的值。</xref:System.Double> </xref:System.Double>           如需上限資訊，請參閱 < 備註 >。 這個值會解譯為[!INCLUDE[TLA#tla_dipixel](~/add/includes/tlasharptla-dipixel-md.md)]度量。 字串不需要明確地包含小數位數。 執行個體的值`1`是可接受。       *qualifiedDouble* A *double*值 （如上所述），後面接著下列單元宣告字串的其中之一︰ `px`， `in`， `cm`， `pt`。       `px`（預設值） [!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)] `in`英吋; 1in = = 96px`cm`是公釐。 1cm==(96/2.54) px`pt`點; 1pt==(96/72) px`Auto`啟用自動調整大小行為。        請參閱 < 備註 >。      <a name=&quot;dependencyPropertyInfo_Width&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkElement.WidthProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkElement.WidthProperty>"
  syntax:
    content: public double Width { get; set; }
    return:
      type: System.Double
      description: "項目的寬度，請在[!INCLUDE[TLA#tla_dipixel#plural](~/add/includes/ajax-current-ext-md.md)]。 預設值是&lt;xref:System.Double?displayProperty=fullName&gt;。 此值必須等於或大於 0.0。 如需上限資訊，請參閱 < 備註 >。"
  overload: System.Windows.FrameworkElement.Width*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkElement.WidthProperty
  id: WidthProperty
  parent: System.Windows.FrameworkElement
  langs:
  - csharp
  name: WidthProperty
  nameWithType: FrameworkElement.WidthProperty
  fullName: System.Windows.FrameworkElement.WidthProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkElement.Width*>相依性屬性。</xref:System.Windows.FrameworkElement.Width*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty WidthProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.UIElement
  isExternal: false
  name: System.Windows.UIElement
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Windows.FrameworkElement.#ctor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FrameworkElement()
  nameWithType: FrameworkElement.FrameworkElement()
  fullName: System.Windows.FrameworkElement.FrameworkElement()
- uid: System.Windows.FrameworkElement.ActualHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
  fullName: System.Windows.FrameworkElement.ActualHeight
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.FrameworkElement.ActualHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeightProperty
  nameWithType: FrameworkElement.ActualHeightProperty
  fullName: System.Windows.FrameworkElement.ActualHeightProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.FrameworkElement.ActualWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
  fullName: System.Windows.FrameworkElement.ActualWidth
- uid: System.Windows.FrameworkElement.ActualWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidthProperty
  nameWithType: FrameworkElement.ActualWidthProperty
  fullName: System.Windows.FrameworkElement.ActualWidthProperty
- uid: System.Windows.FrameworkElement.AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: AddLogicalChild(Object)
  nameWithType: FrameworkElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.AddLogicalChild(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.FrameworkElement.ApplyTemplate
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ApplyTemplate()
  nameWithType: FrameworkElement.ApplyTemplate()
  fullName: System.Windows.FrameworkElement.ApplyTemplate()
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeCore(Rect)
  nameWithType: FrameworkElement.ArrangeCore(Rect)
  fullName: System.Windows.FrameworkElement.ArrangeCore(Rect)
- uid: System.Windows.Rect
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
- uid: System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeOverride(Size)
  nameWithType: FrameworkElement.ArrangeOverride(Size)
  fullName: System.Windows.FrameworkElement.ArrangeOverride(Size)
- uid: System.Windows.Size
  parent: System.Windows
  isExternal: false
  name: Size
  nameWithType: Size
  fullName: System.Windows.Size
- uid: System.Windows.FrameworkElement.BeginInit
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginInit()
  nameWithType: FrameworkElement.BeginInit()
  fullName: System.Windows.FrameworkElement.BeginInit()
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard)
- uid: System.Windows.Media.Animation.Storyboard
  parent: System.Windows.Media.Animation
  isExternal: false
  name: Storyboard
  nameWithType: Storyboard
  fullName: System.Windows.Media.Animation.Storyboard
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior)
- uid: System.Windows.Media.Animation.HandoffBehavior
  parent: System.Windows.Media.Animation
  isExternal: false
  name: HandoffBehavior
  nameWithType: HandoffBehavior
  fullName: System.Windows.Media.Animation.HandoffBehavior
- uid: System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
- uid: System.Windows.FrameworkElement.BindingGroup
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
  fullName: System.Windows.FrameworkElement.BindingGroup
- uid: System.Windows.Data.BindingGroup
  parent: System.Windows.Data
  isExternal: false
  name: BindingGroup
  nameWithType: BindingGroup
  fullName: System.Windows.Data.BindingGroup
- uid: System.Windows.FrameworkElement.BindingGroupProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroupProperty
  nameWithType: FrameworkElement.BindingGroupProperty
  fullName: System.Windows.FrameworkElement.BindingGroupProperty
- uid: System.Windows.FrameworkElement.BringIntoView
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView()
  nameWithType: FrameworkElement.BringIntoView()
  fullName: System.Windows.FrameworkElement.BringIntoView()
- uid: System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView(Rect)
  nameWithType: FrameworkElement.BringIntoView(Rect)
  fullName: System.Windows.FrameworkElement.BringIntoView(Rect)
- uid: System.Windows.FrameworkElement.ContextMenu
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
  fullName: System.Windows.FrameworkElement.ContextMenu
- uid: System.Windows.Controls.ContextMenu
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenu
  nameWithType: ContextMenu
  fullName: System.Windows.Controls.ContextMenu
- uid: System.Windows.FrameworkElement.ContextMenuClosing
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuClosing
  nameWithType: FrameworkElement.ContextMenuClosing
  fullName: System.Windows.FrameworkElement.ContextMenuClosing
- uid: System.Windows.Controls.ContextMenuEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventHandler
  nameWithType: ContextMenuEventHandler
  fullName: System.Windows.Controls.ContextMenuEventHandler
- uid: System.Windows.FrameworkElement.ContextMenuClosingEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuClosingEvent
  nameWithType: FrameworkElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkElement.ContextMenuClosingEvent
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Windows.FrameworkElement.ContextMenuOpening
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuOpening
  nameWithType: FrameworkElement.ContextMenuOpening
  fullName: System.Windows.FrameworkElement.ContextMenuOpening
- uid: System.Windows.FrameworkElement.ContextMenuOpeningEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkElement.ContextMenuOpeningEvent
- uid: System.Windows.FrameworkElement.ContextMenuProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenuProperty
  nameWithType: FrameworkElement.ContextMenuProperty
  fullName: System.Windows.FrameworkElement.ContextMenuProperty
- uid: System.Windows.FrameworkElement.Cursor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkElement.Cursor
  fullName: System.Windows.FrameworkElement.Cursor
- uid: System.Windows.Input.Cursor
  parent: System.Windows.Input
  isExternal: false
  name: Cursor
  nameWithType: Cursor
  fullName: System.Windows.Input.Cursor
- uid: System.Windows.FrameworkElement.CursorProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: CursorProperty
  nameWithType: FrameworkElement.CursorProperty
  fullName: System.Windows.FrameworkElement.CursorProperty
- uid: System.Windows.FrameworkElement.DataContext
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkElement.DataContext
  fullName: System.Windows.FrameworkElement.DataContext
- uid: System.Windows.FrameworkElement.DataContextChanged
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContextChanged
  nameWithType: FrameworkElement.DataContextChanged
  fullName: System.Windows.FrameworkElement.DataContextChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.FrameworkElement.DataContextProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContextProperty
  nameWithType: FrameworkElement.DataContextProperty
  fullName: System.Windows.FrameworkElement.DataContextProperty
- uid: System.Windows.FrameworkElement.DefaultStyleKey
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
  fullName: System.Windows.FrameworkElement.DefaultStyleKey
- uid: System.Windows.FrameworkElement.DefaultStyleKeyProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkElement.DefaultStyleKeyProperty
- uid: System.Windows.FrameworkElement.EndInit
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: EndInit()
  nameWithType: FrameworkElement.EndInit()
  fullName: System.Windows.FrameworkElement.EndInit()
- uid: System.Windows.FrameworkElement.FindName(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindName(String)
  nameWithType: FrameworkElement.FindName(String)
  fullName: System.Windows.FrameworkElement.FindName(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.FrameworkElement.FindResource(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindResource(Object)
  nameWithType: FrameworkElement.FindResource(Object)
  fullName: System.Windows.FrameworkElement.FindResource(Object)
- uid: System.Windows.FrameworkElement.FlowDirection
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
  fullName: System.Windows.FrameworkElement.FlowDirection
- uid: System.Windows.FlowDirection
  parent: System.Windows
  isExternal: false
  name: FlowDirection
  nameWithType: FlowDirection
  fullName: System.Windows.FlowDirection
- uid: System.Windows.FrameworkElement.FlowDirectionProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirectionProperty
  nameWithType: FrameworkElement.FlowDirectionProperty
  fullName: System.Windows.FrameworkElement.FlowDirectionProperty
- uid: System.Windows.FrameworkElement.FocusVisualStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
  fullName: System.Windows.FrameworkElement.FocusVisualStyle
- uid: System.Windows.Style
  parent: System.Windows
  isExternal: false
  name: Style
  nameWithType: Style
  fullName: System.Windows.Style
- uid: System.Windows.FrameworkElement.FocusVisualStyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyleProperty
  nameWithType: FrameworkElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkElement.FocusVisualStyleProperty
- uid: System.Windows.FrameworkElement.ForceCursor
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
  fullName: System.Windows.FrameworkElement.ForceCursor
- uid: System.Windows.FrameworkElement.ForceCursorProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursorProperty
  nameWithType: FrameworkElement.ForceCursorProperty
  fullName: System.Windows.FrameworkElement.ForceCursorProperty
- uid: System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkElement.GetBindingExpression(DependencyProperty)
- uid: System.Windows.Data.BindingExpression
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpression
  nameWithType: BindingExpression
  fullName: System.Windows.Data.BindingExpression
- uid: System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetFlowDirection(DependencyObject)
  nameWithType: FrameworkElement.GetFlowDirection(DependencyObject)
  fullName: System.Windows.FrameworkElement.GetFlowDirection(DependencyObject)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetLayoutClip(Size)
  nameWithType: FrameworkElement.GetLayoutClip(Size)
  fullName: System.Windows.FrameworkElement.GetLayoutClip(Size)
- uid: System.Windows.Media.Geometry
  parent: System.Windows.Media
  isExternal: false
  name: Geometry
  nameWithType: Geometry
  fullName: System.Windows.Media.Geometry
- uid: System.Windows.FrameworkElement.GetTemplateChild(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetTemplateChild(String)
  nameWithType: FrameworkElement.GetTemplateChild(String)
  fullName: System.Windows.FrameworkElement.GetTemplateChild(String)
- uid: System.Windows.FrameworkElement.GetUIParentCore
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetUIParentCore()
  nameWithType: FrameworkElement.GetUIParentCore()
  fullName: System.Windows.FrameworkElement.GetUIParentCore()
- uid: System.Windows.FrameworkElement.GetVisualChild(System.Int32)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetVisualChild(Int32)
  nameWithType: FrameworkElement.GetVisualChild(Int32)
  fullName: System.Windows.FrameworkElement.GetVisualChild(Int32)
- uid: System.Windows.Media.Visual
  parent: System.Windows.Media
  isExternal: false
  name: Visual
  nameWithType: Visual
  fullName: System.Windows.Media.Visual
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.FrameworkElement.Height
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Height
  nameWithType: FrameworkElement.Height
  fullName: System.Windows.FrameworkElement.Height
- uid: System.Windows.FrameworkElement.HeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HeightProperty
  nameWithType: FrameworkElement.HeightProperty
  fullName: System.Windows.FrameworkElement.HeightProperty
- uid: System.Windows.FrameworkElement.HorizontalAlignment
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
  fullName: System.Windows.FrameworkElement.HorizontalAlignment
- uid: System.Windows.HorizontalAlignment
  parent: System.Windows
  isExternal: false
  name: HorizontalAlignment
  nameWithType: HorizontalAlignment
  fullName: System.Windows.HorizontalAlignment
- uid: System.Windows.FrameworkElement.HorizontalAlignmentProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignmentProperty
  nameWithType: FrameworkElement.HorizontalAlignmentProperty
  fullName: System.Windows.FrameworkElement.HorizontalAlignmentProperty
- uid: System.Windows.FrameworkElement.InheritanceBehavior
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
  fullName: System.Windows.FrameworkElement.InheritanceBehavior
- uid: System.Windows.InheritanceBehavior
  parent: System.Windows
  isExternal: false
  name: InheritanceBehavior
  nameWithType: InheritanceBehavior
  fullName: System.Windows.InheritanceBehavior
- uid: System.Windows.FrameworkElement.Initialized
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Initialized
  nameWithType: FrameworkElement.Initialized
  fullName: System.Windows.FrameworkElement.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.FrameworkElement.InputScope
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkElement.InputScope
  fullName: System.Windows.FrameworkElement.InputScope
- uid: System.Windows.Input.InputScope
  parent: System.Windows.Input
  isExternal: false
  name: InputScope
  nameWithType: InputScope
  fullName: System.Windows.Input.InputScope
- uid: System.Windows.FrameworkElement.InputScopeProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScopeProperty
  nameWithType: FrameworkElement.InputScopeProperty
  fullName: System.Windows.FrameworkElement.InputScopeProperty
- uid: System.Windows.FrameworkElement.IsInitialized
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
  fullName: System.Windows.FrameworkElement.IsInitialized
- uid: System.Windows.FrameworkElement.IsLoaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
  fullName: System.Windows.FrameworkElement.IsLoaded
- uid: System.Windows.FrameworkElement.Language
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Language
  nameWithType: FrameworkElement.Language
  fullName: System.Windows.FrameworkElement.Language
- uid: System.Windows.Markup.XmlLanguage
  parent: System.Windows.Markup
  isExternal: false
  name: XmlLanguage
  nameWithType: XmlLanguage
  fullName: System.Windows.Markup.XmlLanguage
- uid: System.Windows.FrameworkElement.LanguageProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LanguageProperty
  nameWithType: FrameworkElement.LanguageProperty
  fullName: System.Windows.FrameworkElement.LanguageProperty
- uid: System.Windows.FrameworkElement.LayoutTransform
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
  fullName: System.Windows.FrameworkElement.LayoutTransform
- uid: System.Windows.Media.Transform
  parent: System.Windows.Media
  isExternal: false
  name: Transform
  nameWithType: Transform
  fullName: System.Windows.Media.Transform
- uid: System.Windows.FrameworkElement.LayoutTransformProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransformProperty
  nameWithType: FrameworkElement.LayoutTransformProperty
  fullName: System.Windows.FrameworkElement.LayoutTransformProperty
- uid: System.Windows.FrameworkElement.Loaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Loaded
  nameWithType: FrameworkElement.Loaded
  fullName: System.Windows.FrameworkElement.Loaded
- uid: System.Windows.RoutedEventHandler
  parent: System.Windows
  isExternal: false
  name: RoutedEventHandler
  nameWithType: RoutedEventHandler
  fullName: System.Windows.RoutedEventHandler
- uid: System.Windows.FrameworkElement.LoadedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LoadedEvent
  nameWithType: FrameworkElement.LoadedEvent
  fullName: System.Windows.FrameworkElement.LoadedEvent
- uid: System.Windows.FrameworkElement.LogicalChildren
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
  fullName: System.Windows.FrameworkElement.LogicalChildren
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Windows.FrameworkElement.Margin
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Margin
  nameWithType: FrameworkElement.Margin
  fullName: System.Windows.FrameworkElement.Margin
- uid: System.Windows.Thickness
  parent: System.Windows
  isExternal: false
  name: Thickness
  nameWithType: Thickness
  fullName: System.Windows.Thickness
- uid: System.Windows.FrameworkElement.MarginProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MarginProperty
  nameWithType: FrameworkElement.MarginProperty
  fullName: System.Windows.FrameworkElement.MarginProperty
- uid: System.Windows.FrameworkElement.MaxHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
  fullName: System.Windows.FrameworkElement.MaxHeight
- uid: System.Windows.FrameworkElement.MaxHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeightProperty
  nameWithType: FrameworkElement.MaxHeightProperty
  fullName: System.Windows.FrameworkElement.MaxHeightProperty
- uid: System.Windows.FrameworkElement.MaxWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
  fullName: System.Windows.FrameworkElement.MaxWidth
- uid: System.Windows.FrameworkElement.MaxWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidthProperty
  nameWithType: FrameworkElement.MaxWidthProperty
  fullName: System.Windows.FrameworkElement.MaxWidthProperty
- uid: System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureCore(Size)
  nameWithType: FrameworkElement.MeasureCore(Size)
  fullName: System.Windows.FrameworkElement.MeasureCore(Size)
- uid: System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureOverride(Size)
  nameWithType: FrameworkElement.MeasureOverride(Size)
  fullName: System.Windows.FrameworkElement.MeasureOverride(Size)
- uid: System.Windows.FrameworkElement.MinHeight
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
  fullName: System.Windows.FrameworkElement.MinHeight
- uid: System.Windows.FrameworkElement.MinHeightProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeightProperty
  nameWithType: FrameworkElement.MinHeightProperty
  fullName: System.Windows.FrameworkElement.MinHeightProperty
- uid: System.Windows.FrameworkElement.MinWidth
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
  fullName: System.Windows.FrameworkElement.MinWidth
- uid: System.Windows.FrameworkElement.MinWidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidthProperty
  nameWithType: FrameworkElement.MinWidthProperty
  fullName: System.Windows.FrameworkElement.MinWidthProperty
- uid: System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkElement.MoveFocus(TraversalRequest)
- uid: System.Windows.Input.TraversalRequest
  parent: System.Windows.Input
  isExternal: false
  name: TraversalRequest
  nameWithType: TraversalRequest
  fullName: System.Windows.Input.TraversalRequest
- uid: System.Windows.FrameworkElement.Name
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Name
  nameWithType: FrameworkElement.Name
  fullName: System.Windows.FrameworkElement.Name
- uid: System.Windows.FrameworkElement.NameProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: NameProperty
  nameWithType: FrameworkElement.NameProperty
  fullName: System.Windows.FrameworkElement.NameProperty
- uid: System.Windows.FrameworkElement.OnApplyTemplate
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnApplyTemplate()
  nameWithType: FrameworkElement.OnApplyTemplate()
  fullName: System.Windows.FrameworkElement.OnApplyTemplate()
- uid: System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuClosing(ContextMenuEventArgs)
- uid: System.Windows.Controls.ContextMenuEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventArgs
  nameWithType: ContextMenuEventArgs
  fullName: System.Windows.Controls.ContextMenuEventArgs
- uid: System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkElement.OnContextMenuOpening(ContextMenuEventArgs)
- uid: System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkElement.OnGotFocus(RoutedEventArgs)
- uid: System.Windows.RoutedEventArgs
  parent: System.Windows
  isExternal: false
  name: RoutedEventArgs
  nameWithType: RoutedEventArgs
  fullName: System.Windows.RoutedEventArgs
- uid: System.Windows.FrameworkElement.OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkElement.OnInitialized(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.DependencyPropertyChangedEventArgs
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventArgs
  nameWithType: DependencyPropertyChangedEventArgs
  fullName: System.Windows.DependencyPropertyChangedEventArgs
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnRenderSizeChanged(SizeChangedInfo)
  nameWithType: FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
  fullName: System.Windows.FrameworkElement.OnRenderSizeChanged(SizeChangedInfo)
- uid: System.Windows.SizeChangedInfo
  parent: System.Windows
  isExternal: false
  name: SizeChangedInfo
  nameWithType: SizeChangedInfo
  fullName: System.Windows.SizeChangedInfo
- uid: System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkElement.OnStyleChanged(Style,Style)
- uid: System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipClosing(ToolTipEventArgs)
- uid: System.Windows.Controls.ToolTipEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventArgs
  nameWithType: ToolTipEventArgs
  fullName: System.Windows.Controls.ToolTipEventArgs
- uid: System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkElement.OnToolTipOpening(ToolTipEventArgs)
- uid: System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnVisualParentChanged(DependencyObject)
  nameWithType: FrameworkElement.OnVisualParentChanged(DependencyObject)
  fullName: System.Windows.FrameworkElement.OnVisualParentChanged(DependencyObject)
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkElement.OverridesDefaultStyleProperty
- uid: System.Windows.FrameworkElement.Parent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkElement.Parent
  fullName: System.Windows.FrameworkElement.Parent
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ParentLayoutInvalidated(UIElement)
  nameWithType: FrameworkElement.ParentLayoutInvalidated(UIElement)
  fullName: System.Windows.FrameworkElement.ParentLayoutInvalidated(UIElement)
- uid: System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkElement.PredictFocus(FocusNavigationDirection)
- uid: System.Windows.Input.FocusNavigationDirection
  parent: System.Windows.Input
  isExternal: false
  name: FocusNavigationDirection
  nameWithType: FocusNavigationDirection
  fullName: System.Windows.Input.FocusNavigationDirection
- uid: System.Windows.FrameworkElement.RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RegisterName(String,Object)
  nameWithType: FrameworkElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkElement.RegisterName(String,Object)
- uid: System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkElement.RemoveLogicalChild(Object)
- uid: System.Windows.FrameworkElement.RequestBringIntoView
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RequestBringIntoView
  nameWithType: FrameworkElement.RequestBringIntoView
  fullName: System.Windows.FrameworkElement.RequestBringIntoView
- uid: System.Windows.RequestBringIntoViewEventHandler
  parent: System.Windows
  isExternal: false
  name: RequestBringIntoViewEventHandler
  nameWithType: RequestBringIntoViewEventHandler
  fullName: System.Windows.RequestBringIntoViewEventHandler
- uid: System.Windows.FrameworkElement.RequestBringIntoViewEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RequestBringIntoViewEvent
  nameWithType: FrameworkElement.RequestBringIntoViewEvent
  fullName: System.Windows.FrameworkElement.RequestBringIntoViewEvent
- uid: System.Windows.FrameworkElement.Resources
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkElement.Resources
  fullName: System.Windows.FrameworkElement.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,String)
- uid: System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkElement.SetBinding(DependencyProperty,BindingBase)
- uid: System.Windows.Data.BindingExpressionBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpressionBase
  nameWithType: BindingExpressionBase
  fullName: System.Windows.Data.BindingExpressionBase
- uid: System.Windows.Data.BindingBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingBase
  nameWithType: BindingBase
  fullName: System.Windows.Data.BindingBase
- uid: System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetFlowDirection(DependencyObject,FlowDirection)
  nameWithType: FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
  fullName: System.Windows.FrameworkElement.SetFlowDirection(DependencyObject,FlowDirection)
- uid: System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkElement.SetResourceReference(DependencyProperty,Object)
- uid: System.Windows.FrameworkElement.ShouldSerializeResources
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeResources()
  nameWithType: FrameworkElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkElement.ShouldSerializeResources()
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeStyle()
  nameWithType: FrameworkElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkElement.ShouldSerializeStyle()
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeTriggers()
  nameWithType: FrameworkElement.ShouldSerializeTriggers()
  fullName: System.Windows.FrameworkElement.ShouldSerializeTriggers()
- uid: System.Windows.FrameworkElement.SizeChanged
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SizeChanged
  nameWithType: FrameworkElement.SizeChanged
  fullName: System.Windows.FrameworkElement.SizeChanged
- uid: System.Windows.SizeChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: SizeChangedEventHandler
  nameWithType: SizeChangedEventHandler
  fullName: System.Windows.SizeChangedEventHandler
- uid: System.Windows.FrameworkElement.SizeChangedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SizeChangedEvent
  nameWithType: FrameworkElement.SizeChangedEvent
  fullName: System.Windows.FrameworkElement.SizeChangedEvent
- uid: System.Windows.FrameworkElement.SourceUpdated
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SourceUpdated
  nameWithType: FrameworkElement.SourceUpdated
  fullName: System.Windows.FrameworkElement.SourceUpdated
- uid: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<DataTransferEventArgs>
  nameWithType: EventHandler<DataTransferEventArgs>
  fullName: System.EventHandler<System.Windows.Data.DataTransferEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Data.DataTransferEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Data.DataTransferEventArgs
    name: DataTransferEventArgs
    nameWithType: DataTransferEventArgs
    fullName: DataTransferEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.FrameworkElement.Style
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Style
  nameWithType: FrameworkElement.Style
  fullName: System.Windows.FrameworkElement.Style
- uid: System.Windows.FrameworkElement.StyleProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: StyleProperty
  nameWithType: FrameworkElement.StyleProperty
  fullName: System.Windows.FrameworkElement.StyleProperty
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Windows.FrameworkElement.Tag
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkElement.Tag
  fullName: System.Windows.FrameworkElement.Tag
- uid: System.Windows.FrameworkElement.TagProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TagProperty
  nameWithType: FrameworkElement.TagProperty
  fullName: System.Windows.FrameworkElement.TagProperty
- uid: System.Windows.FrameworkElement.TargetUpdated
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TargetUpdated
  nameWithType: FrameworkElement.TargetUpdated
  fullName: System.Windows.FrameworkElement.TargetUpdated
- uid: System.Windows.FrameworkElement.TemplatedParent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
  fullName: System.Windows.FrameworkElement.TemplatedParent
- uid: System.Windows.FrameworkElement.ToolTip
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
  fullName: System.Windows.FrameworkElement.ToolTip
- uid: System.Windows.FrameworkElement.ToolTipClosing
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipClosing
  nameWithType: FrameworkElement.ToolTipClosing
  fullName: System.Windows.FrameworkElement.ToolTipClosing
- uid: System.Windows.Controls.ToolTipEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventHandler
  nameWithType: ToolTipEventHandler
  fullName: System.Windows.Controls.ToolTipEventHandler
- uid: System.Windows.FrameworkElement.ToolTipClosingEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipClosingEvent
  nameWithType: FrameworkElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkElement.ToolTipClosingEvent
- uid: System.Windows.FrameworkElement.ToolTipOpening
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipOpening
  nameWithType: FrameworkElement.ToolTipOpening
  fullName: System.Windows.FrameworkElement.ToolTipOpening
- uid: System.Windows.FrameworkElement.ToolTipOpeningEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipOpeningEvent
  nameWithType: FrameworkElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkElement.ToolTipOpeningEvent
- uid: System.Windows.FrameworkElement.ToolTipProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTipProperty
  nameWithType: FrameworkElement.ToolTipProperty
  fullName: System.Windows.FrameworkElement.ToolTipProperty
- uid: System.Windows.FrameworkElement.Triggers
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Triggers
  nameWithType: FrameworkElement.Triggers
  fullName: System.Windows.FrameworkElement.Triggers
- uid: System.Windows.TriggerCollection
  parent: System.Windows
  isExternal: false
  name: TriggerCollection
  nameWithType: TriggerCollection
  fullName: System.Windows.TriggerCollection
- uid: System.Windows.FrameworkElement.TryFindResource(System.Object)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: FrameworkElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkElement.TryFindResource(Object)
- uid: System.Windows.FrameworkElement.Unloaded
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Unloaded
  nameWithType: FrameworkElement.Unloaded
  fullName: System.Windows.FrameworkElement.Unloaded
- uid: System.Windows.FrameworkElement.UnloadedEvent
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnloadedEvent
  nameWithType: FrameworkElement.UnloadedEvent
  fullName: System.Windows.FrameworkElement.UnloadedEvent
- uid: System.Windows.FrameworkElement.UnregisterName(System.String)
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnregisterName(String)
  nameWithType: FrameworkElement.UnregisterName(String)
  fullName: System.Windows.FrameworkElement.UnregisterName(String)
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UpdateDefaultStyle()
  nameWithType: FrameworkElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkElement.UpdateDefaultStyle()
- uid: System.Windows.FrameworkElement.UseLayoutRounding
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
  fullName: System.Windows.FrameworkElement.UseLayoutRounding
- uid: System.Windows.FrameworkElement.UseLayoutRoundingProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRoundingProperty
  nameWithType: FrameworkElement.UseLayoutRoundingProperty
  fullName: System.Windows.FrameworkElement.UseLayoutRoundingProperty
- uid: System.Windows.FrameworkElement.VerticalAlignment
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
  fullName: System.Windows.FrameworkElement.VerticalAlignment
- uid: System.Windows.VerticalAlignment
  parent: System.Windows
  isExternal: false
  name: VerticalAlignment
  nameWithType: VerticalAlignment
  fullName: System.Windows.VerticalAlignment
- uid: System.Windows.FrameworkElement.VerticalAlignmentProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignmentProperty
  nameWithType: FrameworkElement.VerticalAlignmentProperty
  fullName: System.Windows.FrameworkElement.VerticalAlignmentProperty
- uid: System.Windows.FrameworkElement.VisualChildrenCount
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
  fullName: System.Windows.FrameworkElement.VisualChildrenCount
- uid: System.Windows.FrameworkElement.Width
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Width
  nameWithType: FrameworkElement.Width
  fullName: System.Windows.FrameworkElement.Width
- uid: System.Windows.FrameworkElement.WidthProperty
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: WidthProperty
  nameWithType: FrameworkElement.WidthProperty
  fullName: System.Windows.FrameworkElement.WidthProperty
- uid: System.Windows.FrameworkElement.#ctor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FrameworkElement
  nameWithType: FrameworkElement.FrameworkElement
- uid: System.Windows.FrameworkElement.ActualHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualHeight
  nameWithType: FrameworkElement.ActualHeight
- uid: System.Windows.FrameworkElement.ActualWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ActualWidth
  nameWithType: FrameworkElement.ActualWidth
- uid: System.Windows.FrameworkElement.AddLogicalChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: AddLogicalChild
  nameWithType: FrameworkElement.AddLogicalChild
- uid: System.Windows.FrameworkElement.ApplyTemplate*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ApplyTemplate
  nameWithType: FrameworkElement.ApplyTemplate
- uid: System.Windows.FrameworkElement.ArrangeCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeCore
  nameWithType: FrameworkElement.ArrangeCore
- uid: System.Windows.FrameworkElement.ArrangeOverride*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ArrangeOverride
  nameWithType: FrameworkElement.ArrangeOverride
- uid: System.Windows.FrameworkElement.BeginInit*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginInit
  nameWithType: FrameworkElement.BeginInit
- uid: System.Windows.FrameworkElement.BeginStoryboard*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BeginStoryboard
  nameWithType: FrameworkElement.BeginStoryboard
- uid: System.Windows.FrameworkElement.BindingGroup*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkElement.BindingGroup
- uid: System.Windows.FrameworkElement.BringIntoView*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: BringIntoView
  nameWithType: FrameworkElement.BringIntoView
- uid: System.Windows.FrameworkElement.ContextMenu*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkElement.ContextMenu
- uid: System.Windows.FrameworkElement.Cursor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkElement.Cursor
- uid: System.Windows.FrameworkElement.DataContext*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkElement.DataContext
- uid: System.Windows.FrameworkElement.DefaultStyleKey*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkElement.DefaultStyleKey
- uid: System.Windows.FrameworkElement.EndInit*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: EndInit
  nameWithType: FrameworkElement.EndInit
- uid: System.Windows.FrameworkElement.FindName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindName
  nameWithType: FrameworkElement.FindName
- uid: System.Windows.FrameworkElement.FindResource*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FindResource
  nameWithType: FrameworkElement.FindResource
- uid: System.Windows.FrameworkElement.FlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FlowDirection
  nameWithType: FrameworkElement.FlowDirection
- uid: System.Windows.FrameworkElement.FocusVisualStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkElement.FocusVisualStyle
- uid: System.Windows.FrameworkElement.ForceCursor*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkElement.ForceCursor
- uid: System.Windows.FrameworkElement.GetBindingExpression*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetBindingExpression
  nameWithType: FrameworkElement.GetBindingExpression
- uid: System.Windows.FrameworkElement.GetFlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetFlowDirection
  nameWithType: FrameworkElement.GetFlowDirection
- uid: System.Windows.FrameworkElement.GetLayoutClip*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetLayoutClip
  nameWithType: FrameworkElement.GetLayoutClip
- uid: System.Windows.FrameworkElement.GetTemplateChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetTemplateChild
  nameWithType: FrameworkElement.GetTemplateChild
- uid: System.Windows.FrameworkElement.GetUIParentCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetUIParentCore
  nameWithType: FrameworkElement.GetUIParentCore
- uid: System.Windows.FrameworkElement.GetVisualChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: GetVisualChild
  nameWithType: FrameworkElement.GetVisualChild
- uid: System.Windows.FrameworkElement.Height*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Height
  nameWithType: FrameworkElement.Height
- uid: System.Windows.FrameworkElement.HorizontalAlignment*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: HorizontalAlignment
  nameWithType: FrameworkElement.HorizontalAlignment
- uid: System.Windows.FrameworkElement.InheritanceBehavior*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InheritanceBehavior
  nameWithType: FrameworkElement.InheritanceBehavior
- uid: System.Windows.FrameworkElement.InputScope*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkElement.InputScope
- uid: System.Windows.FrameworkElement.IsInitialized*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkElement.IsInitialized
- uid: System.Windows.FrameworkElement.IsLoaded*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkElement.IsLoaded
- uid: System.Windows.FrameworkElement.Language*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Language
  nameWithType: FrameworkElement.Language
- uid: System.Windows.FrameworkElement.LayoutTransform*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LayoutTransform
  nameWithType: FrameworkElement.LayoutTransform
- uid: System.Windows.FrameworkElement.LogicalChildren*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkElement.LogicalChildren
- uid: System.Windows.FrameworkElement.Margin*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Margin
  nameWithType: FrameworkElement.Margin
- uid: System.Windows.FrameworkElement.MaxHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxHeight
  nameWithType: FrameworkElement.MaxHeight
- uid: System.Windows.FrameworkElement.MaxWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MaxWidth
  nameWithType: FrameworkElement.MaxWidth
- uid: System.Windows.FrameworkElement.MeasureCore*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureCore
  nameWithType: FrameworkElement.MeasureCore
- uid: System.Windows.FrameworkElement.MeasureOverride*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MeasureOverride
  nameWithType: FrameworkElement.MeasureOverride
- uid: System.Windows.FrameworkElement.MinHeight*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinHeight
  nameWithType: FrameworkElement.MinHeight
- uid: System.Windows.FrameworkElement.MinWidth*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MinWidth
  nameWithType: FrameworkElement.MinWidth
- uid: System.Windows.FrameworkElement.MoveFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: MoveFocus
  nameWithType: FrameworkElement.MoveFocus
- uid: System.Windows.FrameworkElement.Name*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Name
  nameWithType: FrameworkElement.Name
- uid: System.Windows.FrameworkElement.OnApplyTemplate*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnApplyTemplate
  nameWithType: FrameworkElement.OnApplyTemplate
- uid: System.Windows.FrameworkElement.OnContextMenuClosing*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuClosing
  nameWithType: FrameworkElement.OnContextMenuClosing
- uid: System.Windows.FrameworkElement.OnContextMenuOpening*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnContextMenuOpening
  nameWithType: FrameworkElement.OnContextMenuOpening
- uid: System.Windows.FrameworkElement.OnGotFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnGotFocus
  nameWithType: FrameworkElement.OnGotFocus
- uid: System.Windows.FrameworkElement.OnInitialized*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnInitialized
  nameWithType: FrameworkElement.OnInitialized
- uid: System.Windows.FrameworkElement.OnPropertyChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnPropertyChanged
  nameWithType: FrameworkElement.OnPropertyChanged
- uid: System.Windows.FrameworkElement.OnRenderSizeChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnRenderSizeChanged
  nameWithType: FrameworkElement.OnRenderSizeChanged
- uid: System.Windows.FrameworkElement.OnStyleChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnStyleChanged
  nameWithType: FrameworkElement.OnStyleChanged
- uid: System.Windows.FrameworkElement.OnToolTipClosing*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipClosing
  nameWithType: FrameworkElement.OnToolTipClosing
- uid: System.Windows.FrameworkElement.OnToolTipOpening*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnToolTipOpening
  nameWithType: FrameworkElement.OnToolTipOpening
- uid: System.Windows.FrameworkElement.OnVisualParentChanged*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OnVisualParentChanged
  nameWithType: FrameworkElement.OnVisualParentChanged
- uid: System.Windows.FrameworkElement.OverridesDefaultStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkElement.Parent*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkElement.Parent
- uid: System.Windows.FrameworkElement.ParentLayoutInvalidated*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ParentLayoutInvalidated
  nameWithType: FrameworkElement.ParentLayoutInvalidated
- uid: System.Windows.FrameworkElement.PredictFocus*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: PredictFocus
  nameWithType: FrameworkElement.PredictFocus
- uid: System.Windows.FrameworkElement.RegisterName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RegisterName
  nameWithType: FrameworkElement.RegisterName
- uid: System.Windows.FrameworkElement.RemoveLogicalChild*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: RemoveLogicalChild
  nameWithType: FrameworkElement.RemoveLogicalChild
- uid: System.Windows.FrameworkElement.Resources*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkElement.Resources
- uid: System.Windows.FrameworkElement.SetBinding*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetBinding
  nameWithType: FrameworkElement.SetBinding
- uid: System.Windows.FrameworkElement.SetFlowDirection*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetFlowDirection
  nameWithType: FrameworkElement.SetFlowDirection
- uid: System.Windows.FrameworkElement.SetResourceReference*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: SetResourceReference
  nameWithType: FrameworkElement.SetResourceReference
- uid: System.Windows.FrameworkElement.ShouldSerializeResources*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeResources
  nameWithType: FrameworkElement.ShouldSerializeResources
- uid: System.Windows.FrameworkElement.ShouldSerializeStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeStyle
  nameWithType: FrameworkElement.ShouldSerializeStyle
- uid: System.Windows.FrameworkElement.ShouldSerializeTriggers*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ShouldSerializeTriggers
  nameWithType: FrameworkElement.ShouldSerializeTriggers
- uid: System.Windows.FrameworkElement.Style*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Style
  nameWithType: FrameworkElement.Style
- uid: System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: FrameworkElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.FrameworkElement.Tag*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkElement.Tag
- uid: System.Windows.FrameworkElement.TemplatedParent*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkElement.TemplatedParent
- uid: System.Windows.FrameworkElement.ToolTip*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkElement.ToolTip
- uid: System.Windows.FrameworkElement.Triggers*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Triggers
  nameWithType: FrameworkElement.Triggers
- uid: System.Windows.FrameworkElement.TryFindResource*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: TryFindResource
  nameWithType: FrameworkElement.TryFindResource
- uid: System.Windows.FrameworkElement.UnregisterName*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UnregisterName
  nameWithType: FrameworkElement.UnregisterName
- uid: System.Windows.FrameworkElement.UpdateDefaultStyle*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UpdateDefaultStyle
  nameWithType: FrameworkElement.UpdateDefaultStyle
- uid: System.Windows.FrameworkElement.UseLayoutRounding*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: UseLayoutRounding
  nameWithType: FrameworkElement.UseLayoutRounding
- uid: System.Windows.FrameworkElement.VerticalAlignment*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VerticalAlignment
  nameWithType: FrameworkElement.VerticalAlignment
- uid: System.Windows.FrameworkElement.VisualChildrenCount*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: VisualChildrenCount
  nameWithType: FrameworkElement.VisualChildrenCount
- uid: System.Windows.FrameworkElement.Width*
  parent: System.Windows.FrameworkElement
  isExternal: false
  name: Width
  nameWithType: FrameworkElement.Width
