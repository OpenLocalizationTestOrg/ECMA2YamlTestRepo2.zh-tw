### YamlMime:ManagedReference
items:
- uid: System.Security.Policy.EvidenceBase
  id: EvidenceBase
  children:
  - System.Security.Policy.EvidenceBase.#ctor
  - System.Security.Policy.EvidenceBase.Clone
  langs:
  - csharp
  name: EvidenceBase
  nameWithType: EvidenceBase
  fullName: System.Security.Policy.EvidenceBase
  type: Class
  summary: "提供從以辨識項必須衍生使用的所有物件的基底類別。"
  remarks: "之前[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]，幾乎任何物件可用來做為辨識項物件，如果想要套用以辨識項的裝載程式碼。 例如，某些.NET Framework 程式碼辨識<xref:System.Uri?displayProperty=fullName>辨識項的物件。</xref:System.Uri?displayProperty=fullName> Common language runtime (CLR) 會被視為辨識項物件做為<xref:System.Object?displayProperty=fullName>參考，並沒有套用到它們的任何型別安全。</xref:System.Object?displayProperty=fullName>       這會顯示問題，因為沒有隱含的類型無法當做辨識項物件的限制。 具體而言，辨識項所做的任何物件必須是可序列化的無法`null`。 如果未符合這些需求，而 CLR 所需的這些假設其中一個作業執行時，就會發生例外狀況。       中引進的 EvidenceBase 類別、 辨識項的所有物件必須都衍生自，[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]啟用條件約束上的可用來當做辨識項的物件類型，並提供所有的辨識項物件中加入新功能和需求的能力。 EvidenceBase 類別可確保，在具現化，辨識項物件是可序列化。 此外，也可以藉由新增新的預設實作對基底類別建立新的辨識項需求。       使用 CLR 的辨識項物件中已更新的所有型別[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]衍生自 EvidenceBase。"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public abstract class EvidenceBase
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Security.Policy.EvidenceBase.#ctor
  id: '#ctor'
  parent: System.Security.Policy.EvidenceBase
  langs:
  - csharp
  name: EvidenceBase()
  nameWithType: EvidenceBase.EvidenceBase()
  fullName: System.Security.Policy.EvidenceBase.EvidenceBase()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.Policy
  summary: "初始化的新執行個體<xref href=&quot;System.Security.Policy.EvidenceBase&quot;></xref>類別。"
  remarks: "當做辨識項的所有物件必須都是可序列化。 因為可序列化的屬性不會傳播給衍生類別，您必須將標記為可序列化，任何衍生型別。"
  syntax:
    content: protected EvidenceBase ();
    parameters: []
  overload: System.Security.Policy.EvidenceBase.#ctor*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "要當做辨識項不是可序列化物件。"
  platform:
  - net462
- uid: System.Security.Policy.EvidenceBase.Clone
  id: Clone
  parent: System.Security.Policy.EvidenceBase
  langs:
  - csharp
  name: Clone()
  nameWithType: EvidenceBase.Clone()
  fullName: System.Security.Policy.EvidenceBase.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.Policy
  summary: "建立新的物件是目前的執行個體的完整複本。"
  remarks: "複本是包含在集合中的辨識項的所有物件的完整複本。"
  syntax:
    content: public virtual System.Security.Policy.EvidenceBase Clone ();
    parameters: []
    return:
      type: System.Security.Policy.EvidenceBase
      description: "此辨識項物件的複本。"
  overload: System.Security.Policy.EvidenceBase.Clone*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Security.Policy.EvidenceBase.#ctor
  parent: System.Security.Policy.EvidenceBase
  isExternal: false
  name: EvidenceBase()
  nameWithType: EvidenceBase.EvidenceBase()
  fullName: System.Security.Policy.EvidenceBase.EvidenceBase()
- uid: System.Security.Policy.EvidenceBase.Clone
  parent: System.Security.Policy.EvidenceBase
  isExternal: false
  name: Clone()
  nameWithType: EvidenceBase.Clone()
  fullName: System.Security.Policy.EvidenceBase.Clone()
- uid: System.Security.Policy.EvidenceBase
  parent: System.Security.Policy
  isExternal: false
  name: EvidenceBase
  nameWithType: EvidenceBase
  fullName: System.Security.Policy.EvidenceBase
- uid: System.Security.Policy.EvidenceBase.#ctor*
  parent: System.Security.Policy.EvidenceBase
  isExternal: false
  name: EvidenceBase
  nameWithType: EvidenceBase.EvidenceBase
- uid: System.Security.Policy.EvidenceBase.Clone*
  parent: System.Security.Policy.EvidenceBase
  isExternal: false
  name: Clone
  nameWithType: EvidenceBase.Clone
