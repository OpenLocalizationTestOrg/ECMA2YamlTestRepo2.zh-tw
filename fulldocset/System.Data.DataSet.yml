### YamlMime:ManagedReference
items:
- uid: System.Data.DataSet
  id: DataSet
  children:
  - System.Data.DataSet.#ctor
  - System.Data.DataSet.#ctor(System.String)
  - System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)
  - System.Data.DataSet.AcceptChanges
  - System.Data.DataSet.BeginInit
  - System.Data.DataSet.CaseSensitive
  - System.Data.DataSet.Clear
  - System.Data.DataSet.Clone
  - System.Data.DataSet.Copy
  - System.Data.DataSet.CreateDataReader
  - System.Data.DataSet.CreateDataReader(System.Data.DataTable[])
  - System.Data.DataSet.DataSetName
  - System.Data.DataSet.DefaultViewManager
  - System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)
  - System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.EndInit
  - System.Data.DataSet.EnforceConstraints
  - System.Data.DataSet.ExtendedProperties
  - System.Data.DataSet.GetChanges
  - System.Data.DataSet.GetChanges(System.Data.DataRowState)
  - System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)
  - System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.GetSchemaSerializable
  - System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.GetXml
  - System.Data.DataSet.GetXmlSchema
  - System.Data.DataSet.HasChanges
  - System.Data.DataSet.HasChanges(System.Data.DataRowState)
  - System.Data.DataSet.HasErrors
  - System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])
  - System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])
  - System.Data.DataSet.InferXmlSchema(System.String,System.String[])
  - System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])
  - System.Data.DataSet.Initialized
  - System.Data.DataSet.InitializeDerivedDataSet
  - System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Data.DataSet.IsInitialized
  - System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])
  - System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])
  - System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])
  - System.Data.DataSet.Locale
  - System.Data.DataSet.Merge(System.Data.DataRow[])
  - System.Data.DataSet.Merge(System.Data.DataSet)
  - System.Data.DataSet.Merge(System.Data.DataTable)
  - System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)
  - System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)
  - System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)
  - System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  - System.Data.DataSet.MergeFailed
  - System.Data.DataSet.Namespace
  - System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  - System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)
  - System.Data.DataSet.OnRemoveTable(System.Data.DataTable)
  - System.Data.DataSet.Prefix
  - System.Data.DataSet.RaisePropertyChanging(System.String)
  - System.Data.DataSet.ReadXml(System.IO.Stream)
  - System.Data.DataSet.ReadXml(System.IO.TextReader)
  - System.Data.DataSet.ReadXml(System.String)
  - System.Data.DataSet.ReadXml(System.Xml.XmlReader)
  - System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)
  - System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)
  - System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)
  - System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)
  - System.Data.DataSet.ReadXmlSchema(System.IO.Stream)
  - System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)
  - System.Data.DataSet.ReadXmlSchema(System.String)
  - System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)
  - System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)
  - System.Data.DataSet.RejectChanges
  - System.Data.DataSet.Relations
  - System.Data.DataSet.RemotingFormat
  - System.Data.DataSet.Reset
  - System.Data.DataSet.SchemaSerializationMode
  - System.Data.DataSet.ShouldSerializeRelations
  - System.Data.DataSet.ShouldSerializeTables
  - System.Data.DataSet.Site
  - System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection
  - System.Data.DataSet.System#ComponentModel#IListSource#GetList
  - System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema
  - System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  - System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  - System.Data.DataSet.Tables
  - System.Data.DataSet.WriteXml(System.IO.Stream)
  - System.Data.DataSet.WriteXml(System.IO.TextWriter)
  - System.Data.DataSet.WriteXml(System.String)
  - System.Data.DataSet.WriteXml(System.Xml.XmlWriter)
  - System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  - System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  - System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)
  - System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  - System.Data.DataSet.WriteXmlSchema(System.IO.Stream)
  - System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)
  - System.Data.DataSet.WriteXmlSchema(System.String)
  - System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)
  - System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})
  - System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})
  - System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})
  - System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})
  langs:
  - csharp
  name: DataSet
  nameWithType: DataSet
  fullName: System.Data.DataSet
  type: Class
  summary: "代表記憶體中快取的資料。"
  remarks: "資料集，也就是從資料來源擷取資料的記憶體中快取是 ADO.NET 架構的主要元件。 資料集所組成的集合<xref:System.Data.DataTable>物件，您可以與彼此相關以<xref:System.Data.DataRelation>物件。</xref:System.Data.DataRelation> </xref:System.Data.DataTable> 您可以使用強制在資料集中的資料完整性<xref:System.Data.UniqueConstraint>和<xref:System.Data.ForeignKeyConstraint>物件。</xref:System.Data.ForeignKeyConstraint> </xref:System.Data.UniqueConstraint> 如需有關使用資料集物件的詳細資訊，請參閱[資料集、 Datatable 和 Dataview](~/add/includes/ajax-current-ext-md.md)。       而<xref:System.Data.DataTable>物件包含的資料，<xref:System.Data.DataRelationCollection>可讓您巡覽資料表階層架構。</xref:System.Data.DataRelationCollection> </xref:System.Data.DataTable> 資料表包含在<xref:System.Data.DataTableCollection>透過存取<xref:System.Data.DataSet.Tables%2A>屬性。</xref:System.Data.DataSet.Tables%2A> </xref:System.Data.DataTableCollection> 當存取<xref:System.Data.DataTable>物件，請注意，它們是有條件地區分大小寫。</xref:System.Data.DataTable> 例如，如果一個<xref:System.Data.DataTable>名為&quot;mydatatable&quot;和另一個名為&quot;Mydatatable 」，用來搜尋的其中一個資料表的字串會視為區分大小寫。</xref:System.Data.DataTable> 不過，如果&quot;mydatatable 」 存在，&quot;Mydatatable&quot;並不會搜尋字串會視為為不區分大小寫。 如需有關使用<xref:System.Data.DataTable>物件，請參閱[建立 DataTable](~/add/includes/ajax-current-ext-md.md)。</xref:System.Data.DataTable>       資料集可以讀寫資料和結構描述為 XML 文件。 資料和結構描述可以會透過 HTTP 傳輸並啟用 XML 的任何平台上的任何應用程式，使用。 您可以將結構描述儲存為 XML 結構描述與<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，這個方法，而結構描述和資料可以儲存使用<xref:System.Data.DataSet.WriteXml%2A>方法。</xref:System.Data.DataSet.WriteXml%2A> </xref:System.Data.DataSet.WriteXmlSchema%2A> 若要讀取 XML 文件包含結構描述和資料，使用<xref:System.Data.DataSet.ReadXml%2A>方法。</xref:System.Data.DataSet.ReadXml%2A>       在一般的多層式實作中，更新的原始資料的步驟，建立及重新整理資料集，並在輪中，為︰ 1。  建置和每個<xref:System.Data.DataTable>資料集中的資料來源中使用<xref:System.Data.Common.DataAdapter>.</xref:System.Data.Common.DataAdapter></xref:System.Data.DataTable>填滿      2.  變更中個別的資料<xref:System.Data.DataTable>藉由加入、 更新或刪除物件<xref:System.Data.DataRow>物件。</xref:System.Data.DataRow> </xref:System.Data.DataTable>      3.  叫用<xref:System.Data.DataSet.GetChanges%2A>方法來建立功能的資料變更的第二個資料集。</xref:System.Data.DataSet.GetChanges%2A>      4.  呼叫<xref:System.Data.Common.DataAdapter.Update%2A>方法<xref:System.Data.Common.DataAdapter>，做為引數傳遞的第二個資料集。</xref:System.Data.Common.DataAdapter> </xref:System.Data.Common.DataAdapter.Update%2A>      5.  叫用<xref:System.Data.DataSet.Merge%2A>方法，將合併到第一個從第二個資料集的變更。</xref:System.Data.DataSet.Merge%2A>      6.  叫用<xref:System.Data.DataSet.AcceptChanges%2A>資料集。</xref:System.Data.DataSet.AcceptChanges%2A> 或者，叫用<xref:System.Data.DataSet.RejectChanges%2A>取消所做的變更。</xref:System.Data.DataSet.RejectChanges%2A>      > [!NOTE] > 資料集和<xref:System.Data.DataTable>物件繼承自<xref:System.ComponentModel.MarshalByValueComponent>，並支援<xref:System.Runtime.Serialization.ISerializable>遠端執行功能的介面。</xref:System.Runtime.Serialization.ISerializable> </xref:System.ComponentModel.MarshalByValueComponent> </xref:System.Data.DataTable> 這些是唯一可以進行遠端通訊的 ADO.NET 物件。      > [!NOTE] > 因為完成項宣告已經隱藏在資料集中未從資料集繼承的類別完成，記憶體回收行程。 在衍生的類別可以呼叫<xref:System.GC.ReRegisterForFinalize%2A>其建構函式，以允許記憶體回收行程最終處理而類別中的方法。</xref:System.GC.ReRegisterForFinalize%2A>"
  example:
  - "The following example consists of several methods that, combined, create and fill a DataSet from the **Northwind** database.  \n  \n [!code-cs[Classic WebData DataSet Example#1](~/add/codesnippet/csharp/t-system.data.dataset_1.cs)]\n [!code-vb[Classic WebData DataSet Example#1](~/add/codesnippet/visualbasic/t-system.data.dataset_1.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultProperty("DataSetName")]

      [System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]

      [System.Xml.Serialization.XmlRoot("DataSet")]

      [System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")]

      public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable
  inheritance:
  - System.Object
  - System.ComponentModel.MarshalByValueComponent
  implements:
  - System.ComponentModel.IListSource
  - System.ComponentModel.ISupportInitializeNotification
  - System.Runtime.Serialization.ISerializable
  - System.Xml.Serialization.IXmlSerializable
  inheritedMembers:
  - System.ComponentModel.MarshalByValueComponent.Container
  - System.ComponentModel.MarshalByValueComponent.DesignMode
  - System.ComponentModel.MarshalByValueComponent.Dispose
  - System.ComponentModel.MarshalByValueComponent.Dispose(System.Boolean)
  - System.ComponentModel.MarshalByValueComponent.Disposed
  - System.ComponentModel.MarshalByValueComponent.Events
  - System.ComponentModel.MarshalByValueComponent.GetService(System.Type)
  - System.ComponentModel.MarshalByValueComponent.ToString
  platform:
  - net462
- uid: System.Data.DataSet.#ctor
  id: '#ctor'
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSet()
  nameWithType: DataSet.DataSet()
  fullName: System.Data.DataSet.DataSet()
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "初始化的新執行個體<xref href=&quot;System.Data.DataSet&quot;></xref>類別。"
  remarks: "這項實作<xref:System.Data.DataSet>建構函式不採用任何參數，並建立一個預設名稱，&quot;NewDataSet，&quot;新的執行個體。</xref:System.Data.DataSet>       名稱<xref:System.Data.DataSet>，才能確保的 XML 表示法<xref:System.Data.DataSet>一律會有文件項目，也就是最高層級的項目結構描述定義中的名稱。</xref:System.Data.DataSet> </xref:System.Data.DataSet>"
  example:
  - "The following example creates a new <xref:System.Data.DataSet>, and adds two <xref:System.Data.DataTable> objects to it.  \n  \n [!code-vb[Classic WebData DataSet.DataSet Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.sh_1_1.vb)]"
  syntax:
    content: public DataSet ();
    parameters: []
  overload: System.Data.DataSet.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSet(String)
  nameWithType: DataSet.DataSet(String)
  fullName: System.Data.DataSet.DataSet(String)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "初始化的新執行個體<xref href=&quot;System.Data.DataSet&quot;></xref>具有指定名稱的類別。"
  remarks: "名稱<xref:System.Data.DataSet>，才能確保的 XML 表示法<xref:System.Data.DataSet>一律會有文件項目，也就是最高的層級項目結構描述定義中的名稱。</xref:System.Data.DataSet> </xref:System.Data.DataSet>"
  example:
  - "The following example creates a new <xref:System.Data.DataSet>, to which two <xref:System.Data.DataTable> objects are added.  \n  \n [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.sh_0_1.vb)]"
  syntax:
    content: public DataSet (string dataSetName);
    parameters:
    - id: dataSetName
      type: System.String
      description: "名稱<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.DataSet.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: '#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)'
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSet(SerializationInfo,StreamingContext)
  nameWithType: DataSet.DataSet(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.DataSet(SerializationInfo,StreamingContext)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "初始化的新執行個體<xref href=&quot;System.Data.DataSet&quot;></xref>類別具有指定的序列化資訊和內容。"
  syntax:
    content: protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "要序列化或還原序列化物件所需的資料。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "來源和目的端的給定序列化資料流。"
  overload: System.Data.DataSet.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)
  id: '#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)'
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSet(SerializationInfo,StreamingContext,Boolean)
  nameWithType: DataSet.DataSet(SerializationInfo,StreamingContext,Boolean)
  fullName: System.Data.DataSet.DataSet(SerializationInfo,StreamingContext,Boolean)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "初始化的新執行個體<xref href=&quot;System.Data.DataSet&quot;></xref>類別。"
  syntax:
    content: protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>物件。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "<xref:System.Runtime.Serialization.StreamingContext>物件。</xref:System.Runtime.Serialization.StreamingContext>"
    - id: ConstructSchema
      type: System.Boolean
      description: "布林值。"
  overload: System.Data.DataSet.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.AcceptChanges
  id: AcceptChanges
  parent: System.Data.DataSet
  langs:
  - csharp
  name: AcceptChanges()
  nameWithType: DataSet.AcceptChanges()
  fullName: System.Data.DataSet.AcceptChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "認可對此所做的所有變更<xref href=&quot;System.Data.DataSet&quot;></xref>自載入後，或自上次呼叫 AcceptChanges。"
  remarks: "同時<xref:System.Data.DataRow>和<xref:System.Data.DataTable>類別有 AcceptChanges 方法。</xref:System.Data.DataTable> </xref:System.Data.DataRow> 呼叫<xref:System.Data.DataTable.AcceptChanges%2A>在<xref:System.Data.DataTable>層級原因<xref:System.Data.DataRow.AcceptChanges%2A>每個方法<xref:System.Data.DataRow>呼叫。</xref:System.Data.DataRow> </xref:System.Data.DataRow.AcceptChanges%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.AcceptChanges%2A> 同樣地，叫用 AcceptChanges <xref:System.Data.DataSet> <xref:System.Data.DataTable.AcceptChanges%2A> <xref:System.Data.DataSet>.</xref:System.Data.DataSet>中每一個資料表上呼叫</xref:System.Data.DataTable.AcceptChanges%2A>會導致</xref:System.Data.DataSet> 如此一來，在中，您必須在可以叫用此方法的多個層級。 呼叫的 AcceptChanges<xref:System.Data.DataSet>可讓您叫用所有從屬物件 （例如，資料表和資料列） 中的某個呼叫的方法。</xref:System.Data.DataSet>       當您呼叫`AcceptChanges`上`DataSet`，任何<xref:System.Data.DataRow>物件仍在編輯模式中的順利結束編輯。</xref:System.Data.DataRow> 每個<xref:System.Data.DataRow><xref:System.Data.DataRow.RowState%2A>屬性也會變更。`Added`和`Modified`資料列會變成`Unchanged`，和`Deleted`會移除資料列。 </xref:System.Data.DataRow.RowState%2A></xref:System.Data.DataRow>       如果`DataSet`包含<xref:System.Data.ForeignKeyConstraint>叫用的物件`AcceptChanges`方法也會導致<xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A>強制執行。</xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> </xref:System.Data.ForeignKeyConstraint>      > [!NOTE]  >   `AcceptChanges`和`RejectChanges`只會套用到`DataRow`相關的變更 （亦即，新增、 移除、 刪除和修改）。 它們並不適用於結構描述或結構化變更。   >> 如果資料集時已填滿使用 DataAdapter 呼叫 AcceptChanges 不會回到資料來源複寫這些變更。 在此情況下，呼叫<xref:System.Data.Common.DataAdapter.Update%2A>改用。</xref:System.Data.Common.DataAdapter.Update%2A> 請參閱[以 Dataadapter 更新資料來源](http://msdn.microsoft.com/library/33y2221y.aspx)如需詳細資訊。"
  example:
  - "The following example adds a <xref:System.Data.DataRow> to a <xref:System.Data.DataTable> in a <xref:System.Data.DataSet>. The AcceptChanges method is then called on the <xref:System.Data.DataSet>, which cascades to all <xref:System.Data.DataTable> objects that it contains.  \n  \n [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ac_1.vb)]\n [!code-cs[Classic WebData DataSet.AcceptChanges#1](~/add/codesnippet/csharp/m-system.data.dataset.ac_1.cs)]"
  syntax:
    content: public void AcceptChanges ();
    parameters: []
  overload: System.Data.DataSet.AcceptChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.BeginInit
  id: BeginInit
  parent: System.Data.DataSet
  langs:
  - csharp
  name: BeginInit()
  nameWithType: DataSet.BeginInit()
  fullName: System.Data.DataSet.BeginInit()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "開始初始化<xref href=&quot;System.Data.DataSet&quot;></xref>是用於表單或另一個元件所使用。 初始化發生於執行階段。"
  remarks: "Visual Studio.NET 設計環境會使用這個方法來開始初始化用於表單或為另一個元件所使用的元件。 <xref:System.Data.DataSet.EndInit%2A>方法結束初始化。</xref:System.Data.DataSet.EndInit%2A> 使用 BeginInit 和<xref:System.Data.DataSet.EndInit%2A>方法可防止控制項完全初始化之前使用。</xref:System.Data.DataSet.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Data.DataSet.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.CaseSensitive
  id: CaseSensitive
  parent: System.Data.DataSet
  langs:
  - csharp
  name: CaseSensitive
  nameWithType: DataSet.CaseSensitive
  fullName: System.Data.DataSet.CaseSensitive
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得或設定值，指出是否字串內的比較<xref href=&quot;System.Data.DataTable&quot;></xref>物件會區分大小寫。"
  remarks: "CaseSensitive 屬性會影響如何在每個執行排序、 搜尋和篩選作業<xref:System.Data.DataTable>中所含物件<xref:System.Data.DataSet>時使用<xref:System.Data.DataTable.Select%2A>方法。</xref:System.Data.DataTable.Select%2A> </xref:System.Data.DataSet> </xref:System.Data.DataTable>       根據預設，設定的 CaseSensitive 屬性<xref:System.Data.DataSet>也會設定<xref:System.Data.DataTable.CaseSensitive%2A>的每個相關聯的屬性<xref:System.Data.DataTable>為相同的值。</xref:System.Data.DataTable> </xref:System.Data.DataTable.CaseSensitive%2A> </xref:System.Data.DataSet>"
  example:
  - "The following example toggles the CaseSensitive property.  \n  \n [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.ca_1.vb)]"
  syntax:
    content: public bool CaseSensitive { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果字串比較會區分大小寫。否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.CaseSensitive*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Clear
  id: Clear
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Clear()
  nameWithType: DataSet.Clear()
  fullName: System.Data.DataSet.Clear()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "清除<xref href=&quot;System.Data.DataSet&quot;></xref>藉由移除所有的資料表中的所有資料列的任何資料。"
  remarks: "如果<xref:System.Data.DataSet>繫結到<xref:System.Xml.XmlDataDocument>呼叫清除或<xref:System.Data.DataTable.Clear%2A?displayProperty=fullName>引發<xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.DataTable.Clear%2A?displayProperty=fullName> 、</xref:System.Xml.XmlDataDocument> </xref:System.Data.DataSet> 若要避免這種情況下，會周遊一次移除一個每個資料列的每個資料表。"
  example:
  - "The following example clears the <xref:System.Data.DataSet> of all rows in all tables.  \n  \n [!code-vb[Classic WebData DataSet.Clear Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.cl_1_1.vb)]\n [!code-cs[Classic WebData DataSet.Clear Example#1](~/add/codesnippet/csharp/m-system.data.dataset.cl_1_1.cs)]"
  syntax:
    content: public void Clear ();
    parameters: []
  overload: System.Data.DataSet.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Clone
  id: Clone
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Clone()
  nameWithType: DataSet.Clone()
  fullName: System.Data.DataSet.Clone()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "結構複製<xref href=&quot;System.Data.DataSet&quot;> </xref>，包括所有<xref href=&quot;System.Data.DataTable&quot;></xref>結構描述、 關聯和條件約束。 不會複製任何資料。"
  remarks: >-
    > [!NOTE]

    >  If these classes have been subclassed, the clone will also be of the same subclasses.
  example:
  - "The following example creates a clone of a <xref:System.Data.DataSet> object's schema.  \n  \n [!code-cs[Classic WebData DataSet.Clone Example#1](~/add/codesnippet/csharp/m-system.data.dataset.cl_0_1.cs)]\n [!code-vb[Classic WebData DataSet.Clone Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.cl_0_1.vb)]"
  syntax:
    content: public virtual System.Data.DataSet Clone ();
    parameters: []
    return:
      type: System.Data.DataSet
      description: "新<xref href=&quot;System.Data.DataSet&quot;></xref>包含相同的結構描述與目前<xref href=&quot;System.Data.DataSet&quot;> </xref>，但沒有任何資料。"
  overload: System.Data.DataSet.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Copy
  id: Copy
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Copy()
  nameWithType: DataSet.Copy()
  fullName: System.Data.DataSet.Copy()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "將結構和資料複製這個<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: ''
  example:
  - "The following example uses the Copy method to create a copy of the original <xref:System.Data.DataSet>.  \n  \n [!code-cs[Classic WebData DataSet.Copy Example#1](~/add/codesnippet/csharp/m-system.data.dataset.copy_1.cs)]\n [!code-vb[Classic WebData DataSet.Copy Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.copy_1.vb)]"
  syntax:
    content: public System.Data.DataSet Copy ();
    parameters: []
    return:
      type: System.Data.DataSet
      description: "新<xref href=&quot;System.Data.DataSet&quot;></xref>具有相同的結構 （資料表結構描述、 關聯和條件約束） 和資料，因為這樣<xref href=&quot;System.Data.DataSet&quot;> </xref>。       <div class=&quot;alert NOTE&quot;>    如果這些類別具有已子類別化，複製也會屬於相同的子類別。      </div>"
  overload: System.Data.DataSet.Copy*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.CreateDataReader
  id: CreateDataReader
  parent: System.Data.DataSet
  langs:
  - csharp
  name: CreateDataReader()
  nameWithType: DataSet.CreateDataReader()
  fullName: System.Data.DataSet.CreateDataReader()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "傳回<xref href=&quot;System.Data.DataTableReader&quot;></xref>與每個設定的其中一個結果<xref href=&quot;System.Data.DataTable&quot;> </xref>，請在相同排序資料表中顯示的樣子<xref:System.Data.DataSet.Tables*>集合。</xref:System.Data.DataSet.Tables*>"
  remarks: "若要確保結果集內傳回的順序<xref:System.Data.DataTableReader>，如果<xref:System.Data.DataTable>內<xref:System.Data.DataSet>是空的它會以空的結果集內傳回`DataTableReader`。</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.DataTableReader>"
  example:
  - "The following example creates three <xref:System.Data.DataTable> instances, and adds each to a <xref:System.Data.DataSet>. The example then passes the filled `DataSet` to a procedure that calls the CreateDataReader method, and proceeds to iterate through all the result sets contained within the <xref:System.Data.DataTableReader>. The example displays the results in the Console window.  \n  \n [!code-vb[DataWorks DataSet.DataTableReader#1](~/add/codesnippet/visualbasic/m-system.data.dataset.cr_0_1.vb)]\n [!code-cs[DataWorks DataSet.DataTableReader#1](~/add/codesnippet/csharp/m-system.data.dataset.cr_0_1.cs)]"
  syntax:
    content: public System.Data.DataTableReader CreateDataReader ();
    parameters: []
    return:
      type: System.Data.DataTableReader
      description: "A <xref href=&quot;System.Data.DataTableReader&quot;> </xref>包含一或多個結果集，對應至<xref href=&quot;System.Data.DataTable&quot;></xref>包含來源中的執行個體<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.DataSet.CreateDataReader*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.CreateDataReader(System.Data.DataTable[])
  id: CreateDataReader(System.Data.DataTable[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: CreateDataReader(DataTable[])
  nameWithType: DataSet.CreateDataReader(DataTable[])
  fullName: System.Data.DataSet.CreateDataReader(DataTable[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "傳回<xref href=&quot;System.Data.DataTableReader&quot;></xref>與每個設定的其中一個結果<xref href=&quot;System.Data.DataTable&quot;> </xref>。"
  remarks: "為了確保結果的順序設定內傳回<xref:System.Data.DataTableReader>，如果<xref:System.Data.DataTable>內<xref:System.Data.DataSet>是空的它會以空的結果集內傳回`DataTableReader`。</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.DataTableReader> 因為這個多載的版本，可讓您提供一份`DataTable`做為參數的情況下，您可以指定結果集內傳回的出現的順序`DataTableReader`。"
  example:
  - "This example, a Console application, creates three <xref:System.Data.DataTable> instances and adds each to a <xref:System.Data.DataSet>. The example calls the CreateDataReader method and displays the contents of the returned <xref:System.Data.DataTableReader>. Note that the order of the result sets in the `DataTableReader` is controlled by the order of the `DataTable` instances passed as parameters. The example displays the results in the Console window.  \n  \n [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/add/codesnippet/visualbasic/m-system.data.dataset.cr_1_1.vb)]\n [!code-cs[DataWorks DataSet.DataTableReaderTables#1](~/add/codesnippet/csharp/m-system.data.dataset.cr_1_1.cs)]"
  syntax:
    content: public System.Data.DataTableReader CreateDataReader (System.Data.DataTable[] dataTables);
    parameters:
    - id: dataTables
      type: System.Data.DataTable[]
      description: "提供的順序結果的 Datatable 的陣列設定中傳回<xref href=&quot;System.Data.DataTableReader&quot;> </xref>。"
    return:
      type: System.Data.DataTableReader
      description: "A <xref href=&quot;System.Data.DataTableReader&quot;> </xref>包含一或多個結果集，對應至<xref href=&quot;System.Data.DataTable&quot;></xref>包含來源中的執行個體<xref href=&quot;System.Data.DataSet&quot;> </xref>。 傳回的結果集位於所指定的順序<code> dataTables </code>參數。"
  overload: System.Data.DataSet.CreateDataReader*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.DataSetName
  id: DataSetName
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DataSetName
  nameWithType: DataSet.DataSetName
  fullName: System.Data.DataSet.DataSetName
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得或設定目前的名稱<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: ''
  example:
  - "The following example creates a new <xref:System.Data.DataSet> with the given DataSetName.  \n  \n [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.da_1.vb)]\n [!code-cs[Classic WebData DataSet.DataSetName Example#1](~/add/codesnippet/csharp/p-system.data.dataset.da_1.cs)]"
  syntax:
    content: public string DataSetName { get; set; }
    return:
      type: System.String
      description: "名稱<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.DataSet.DataSetName*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.DefaultViewManager
  id: DefaultViewManager
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DefaultViewManager
  nameWithType: DataSet.DefaultViewManager
  fullName: System.Data.DataSet.DefaultViewManager
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得資料中所包含的自訂檢視<xref href=&quot;System.Data.DataSet&quot;></xref>允許篩選、 搜尋和瀏覽 使用自訂<xref href=&quot;System.Data.DataViewManager&quot;> </xref>。"
  remarks: "<xref:System.Data.DataViewManager>屬性可讓您建立自訂設定的每個<xref:System.Data.DataTable>在<xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataTable> DefaultViewManager 所傳回</xref:System.Data.DataViewManager>的       當您取得<xref:System.Data.DataView>從<xref:System.Data.DataTable>，排序次序、 篩選和<xref:System.Data.DataViewRowState>根據 DefaultViewManager 屬性中的設定會設定。</xref:System.Data.DataViewRowState> </xref:System.Data.DataTable> </xref:System.Data.DataView>"
  example:
  - "The following example gets the default <xref:System.Data.DataViewManager> for a <xref:System.Data.DataSet>, and adds a <xref:System.Data.DataTable> to the <xref:System.Data.DataTableCollection>.  \n  \n [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.de_1.vb)]"
  syntax:
    content: public System.Data.DataViewManager DefaultViewManager { get; }
    return:
      type: System.Data.DataViewManager
      description: "A <xref href=&quot;System.Data.DataViewManager&quot;></xref> object."
  overload: System.Data.DataSet.DefaultViewManager*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)
  id: DetermineSchemaSerializationMode(System.Xml.XmlReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DetermineSchemaSerializationMode(XmlReader)
  nameWithType: DataSet.DetermineSchemaSerializationMode(XmlReader)
  fullName: System.Data.DataSet.DetermineSchemaSerializationMode(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "決定<xref:System.Data.DataSet.SchemaSerializationMode*>如<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.Data.DataSet.SchemaSerializationMode*>"
  remarks: "具型別<xref:System.Data.DataSet>來判斷其<xref:System.Data.DataSet.SchemaSerializationMode%2A>.</xref:System.Data.DataSet.SchemaSerializationMode%2A></xref:System.Data.DataSet>還原序列化時，就可以呼叫這個方法"
  syntax:
    content: protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>還原序列化期間所傳入的執行個體<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.Xml.XmlReader>"
    return:
      type: System.Data.SchemaSerializationMode
      description: "<xref href=&quot;System.Data.SchemaSerializationMode&quot;> </xref>列舉，指出是否已省略裝載的結構描述資訊。"
  overload: System.Data.DataSet.DetermineSchemaSerializationMode*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  nameWithType: DataSet.DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "決定<xref:System.Data.DataSet.SchemaSerializationMode*>如<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.Data.DataSet.SchemaSerializationMode*>"
  remarks: "具型別<xref:System.Data.DataSet>來判斷其<xref:System.Data.DataSet.SchemaSerializationMode%2A>.</xref:System.Data.DataSet.SchemaSerializationMode%2A></xref:System.Data.DataSet>還原序列化時，就可以呼叫這個方法"
  syntax:
    content: protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref> ， <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>的受保護建構函式&lt;xref:System.Data.DataSet.%23ctor%2A&gt;以遠端處理案例中還原序列化期間叫用。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "<xref:System.Runtime.Serialization.StreamingContext>， <xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>的受保護建構函式&lt;xref:System.Data.DataSet.%23ctor%2A&gt;以遠端處理案例中還原序列化期間叫用。</xref:System.Runtime.Serialization.StreamingContext>"
    return:
      type: System.Data.SchemaSerializationMode
      description: "<xref href=&quot;System.Data.SchemaSerializationMode&quot;> </xref>列舉，指出是否已省略裝載的結構描述資訊。"
  overload: System.Data.DataSet.DetermineSchemaSerializationMode*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.EndInit
  id: EndInit
  parent: System.Data.DataSet
  langs:
  - csharp
  name: EndInit()
  nameWithType: DataSet.EndInit()
  fullName: System.Data.DataSet.EndInit()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "初始化結束<xref href=&quot;System.Data.DataSet&quot;></xref>是用於表單或另一個元件所使用。 初始化發生於執行階段。"
  remarks: "Visual Studio.NET 設計環境會使用這個方法來結束初始化用於表單或為另一個元件所使用的元件。 <xref:System.Data.DataSet.BeginInit%2A>方法會啟動初始化。</xref:System.Data.DataSet.BeginInit%2A> 使用<xref:System.Data.DataSet.BeginInit%2A>和 EndInit 方法可防止控制項完全初始化之前使用。</xref:System.Data.DataSet.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Data.DataSet.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.EnforceConstraints
  id: EnforceConstraints
  parent: System.Data.DataSet
  langs:
  - csharp
  name: EnforceConstraints
  nameWithType: DataSet.EnforceConstraints
  fullName: System.Data.DataSet.EnforceConstraints
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得或設定值，指出是否嘗試任何 update 作業時，會遵循條件約束規則。"
  remarks: "條件約束會在設定<xref:System.Data.DataTable>層級 (<xref:System.Data.DataTable.Constraints%2A>屬性)。</xref:System.Data.DataTable.Constraints%2A> </xref:System.Data.DataTable> 如需有關建立條件約束的詳細資訊，請參閱[DataTable 條件約束](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example creates a <xref:System.Data.DataSet> with one table, one column, five rows, and one <xref:System.Data.UniqueConstraint>. The EnforceConstraints property is set to `false` and the values of each row are set to the same value. When the EnforceConstraints property is reset to `true`, a <xref:System.Data.ConstraintException> is generated.  \n  \n [!code-cs[Classic WebData DataSet.EnforceConstraints Example#1](~/add/codesnippet/csharp/p-system.data.dataset.en_1.cs)]\n [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.en_1.vb)]"
  syntax:
    content: public bool EnforceConstraints { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果會強制執行規則。否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.EnforceConstraints*
  exceptions:
  - type: System.Data.ConstraintException
    commentId: T:System.Data.ConstraintException
    description: "無法強制執行一個或多個條件約束。"
  platform:
  - net462
- uid: System.Data.DataSet.ExtendedProperties
  id: ExtendedProperties
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ExtendedProperties
  nameWithType: DataSet.ExtendedProperties
  fullName: System.Data.DataSet.ExtendedProperties
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得相關聯的自訂的使用者資訊的集合<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>。"
  remarks: "ExtendedProperties 屬性可讓您儲存自訂的資訊與`DataSet`。 例如，您可能會儲存資料應該重新整理的時間。       擴充的屬性的類型必須是<xref:System.String>如果您想要它們時保存<xref:System.Data.DataSet>寫入為 XML。</xref:System.Data.DataSet> </xref:System.String>"
  example:
  - "The following example adds a custom property to the <xref:System.Data.PropertyCollection> returned by the <xref:System.Data.DataColumn.ExtendedProperties%2A> property. The second example retrieves the custom property.  \n  \n [!code-cs[Classic WebData DataColumn.ExtendedProperties Example#1](~/add/codesnippet/csharp/p-system.data.dataset.ex_1.cs)]\n [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.ex_1.vb)]"
  syntax:
    content: public System.Data.PropertyCollection ExtendedProperties { get; }
    return:
      type: System.Data.PropertyCollection
      description: "A <xref href=&quot;System.Data.PropertyCollection&quot;> </xref>以自訂使用者資訊。"
  overload: System.Data.DataSet.ExtendedProperties*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetChanges
  id: GetChanges
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetChanges()
  nameWithType: DataSet.GetChanges()
  fullName: System.Data.DataSet.GetChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得一份<xref href=&quot;System.Data.DataSet&quot;> </xref> ，其中包含所有對它自載入後，或自<xref:System.Data.DataSet.AcceptChanges*>上次呼叫。</xref:System.Data.DataSet.AcceptChanges*>"
  remarks: "建立新<xref:System.Data.DataSet>包含的所有資料列的原始複本<xref:System.Data.DataSet>具有暫止的變更。</xref:System.Data.DataSet> </xref:System.Data.DataSet> 關聯性條件約束會造成其他不變的資料列新增至新<xref:System.Data.DataSet>如果變更的資料列包含對應至外部索引鍵中的變更資料列的主索引鍵。</xref:System.Data.DataSet> 方法會傳回`null`是否有任何資料列在原始<xref:System.Data.DataSet>具有暫止的變更。</xref:System.Data.DataSet>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. Two values are changed, and one row is added. A subset of the changed data is created using the GetChanges method. After reconciling errors, a new column is added to the subset, changing the schema. When the <xref:System.Data.DataSet.Merge%2A> method is called with the `missingSchemaAction` set to `MissingSchemaAction.Add`, the new column is added to the original <xref:System.Data.DataSet> object's schema.  \n  \n [!code-cs[Classic WebData DataSet.GetChanges Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ge_0_1.cs)]\n [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ge_0_1.vb)]"
  syntax:
    content: public System.Data.DataSet GetChanges ();
    parameters: []
    return:
      type: System.Data.DataSet
      description: "從這個變更複本<xref href=&quot;System.Data.DataSet&quot;> </xref> ，可以執行的動作上及更新版本中使用<xref:System.Data.DataSet.Merge*>.</xref:System.Data.DataSet.Merge*>合併 如果發現任何變更的資料列，則方法會傳回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.GetChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetChanges(System.Data.DataRowState)
  id: GetChanges(System.Data.DataRowState)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetChanges(DataRowState)
  nameWithType: DataSet.GetChanges(DataRowState)
  fullName: System.Data.DataSet.GetChanges(DataRowState)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得一份<xref href=&quot;System.Data.DataSet&quot;></xref>包含自上次載入後，或之後所做的所有變更<xref:System.Data.DataSet.AcceptChanges*>呼叫，以進行篩選<xref href=&quot;System.Data.DataRowState&quot;> </xref>。</xref:System.Data.DataSet.AcceptChanges*>"
  remarks: "<xref:System.Data.DataSet.GetChanges%2A>方法用來產生第二個<xref:System.Data.DataSet>導入原始的物件，其中包含所做的變更。</xref:System.Data.DataSet> </xref:System.Data.DataSet.GetChanges%2A> 使用`rowStates`引數以指定的變更應該包含新的物件類型。       傳回此複本為了中能順利合併回至這個原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 關聯性條件約束可能會導致父資料列標示為`Unchanged`包含。 如果所需的任何資料列<xref:System.Data.DataRowState>找不到，<xref:System.Data.DataSet.GetChanges%2A>方法會傳回`null`。</xref:System.Data.DataSet.GetChanges%2A> </xref:System.Data.DataRowState>"
  example:
  - "The following example uses the <xref:System.Data.DataSet.GetChanges%2A> method to create a second <xref:System.Data.DataSet> object, which is then used to update a data source.  \n  \n [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ge_2_1.vb)]\n [!code-cs[Classic WebData DataSet.GetChanges1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ge_2_1.cs)]"
  syntax:
    content: public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);
    parameters:
    - id: rowStates
      type: System.Data.DataRowState
      description: "其中一個<xref href=&quot;System.Data.DataRowState&quot;></xref>值。"
    return:
      type: System.Data.DataSet
      description: "已篩選的複本<xref href=&quot;System.Data.DataSet&quot;> </xref> ，可以執行的動作，之後再使用<xref:System.Data.DataSet.Merge*>.</xref:System.Data.DataSet.Merge*>內合併 如果所需的任何資料列<xref href=&quot;System.Data.DataRowState&quot;></xref>找不到，則方法會傳回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.GetChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)
  id: GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetDataSetSchema(XmlSchemaSet)
  nameWithType: DataSet.GetDataSetSchema(XmlSchemaSet)
  fullName: System.Data.DataSet.GetDataSetSchema(XmlSchemaSet)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得一份<xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;></xref>資料集。"
  syntax:
    content: public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);
    parameters:
    - id: schemaSet
      type: System.Xml.Schema.XmlSchemaSet
      description: "指定的結構描述設定。"
    return:
      type: System.Xml.Schema.XmlSchemaComplexType
      description: "A copy of <xref href=&quot;System.Xml.Schema.XmlSchemaSet&quot;></xref>."
  overload: System.Data.DataSet.GetDataSetSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: DataSet.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.GetObjectData(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "要序列化所需的資料填入的序列化資訊物件<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  syntax:
    content: public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>存與相關聯之序列化的資料<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A <xref:System.Runtime.Serialization.StreamingContext>，其中包含來源和目的地的序列化資料流相關聯<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Data.DataSet.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>info</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.GetSchemaSerializable
  id: GetSchemaSerializable
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetSchemaSerializable()
  nameWithType: DataSet.GetSchemaSerializable()
  fullName: System.Data.DataSet.GetSchemaSerializable()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "傳回可序列化<xref:System.Xml.Schema.XMLSchema>執行個體。</xref:System.Xml.Schema.XMLSchema>"
  syntax:
    content: protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();
    parameters: []
    return:
      type: System.Xml.Schema.XmlSchema
      description: "<xref:System.Xml.Schema.XMLSchema>執行個體。</xref:System.Xml.Schema.XMLSchema>"
  overload: System.Data.DataSet.GetSchemaSerializable*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetSerializationData(SerializationInfo,StreamingContext)
  nameWithType: DataSet.GetSerializationData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.GetSerializationData(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "還原序列化的二進位檔或 XML 資料流的資料表資料。"
  syntax:
    content: protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>執行個體。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "資料流的內容。"
  overload: System.Data.DataSet.GetSerializationData*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetXml
  id: GetXml
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetXml()
  nameWithType: DataSet.GetXml()
  fullName: System.Data.DataSet.GetXml()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "傳回儲存在資料的 XML 表示法<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "呼叫此方法等於呼叫<xref:System.Data.DataSet.WriteXml%2A>設<xref:System.Data.XmlWriteMode>為<xref:System.Data.XmlWriteMode>.</xref:System.Data.XmlWriteMode> </xref:System.Data.XmlWriteMode> </xref:System.Data.DataSet.WriteXml%2A>       GetXml 傳回 XML 字串形式，因此需要以更多成本負擔比<xref:System.Data.DataSet.WriteXml%2A>寫入 XML 檔案。</xref:System.Data.DataSet.WriteXml%2A>       如果您要建置<xref:System.Data.DataSet>使用結構描述推斷和序列化它使用 XML 或 Web 服務的資料行順序可能會變更。</xref:System.Data.DataSet>"
  example:
  - "The following example creates a <xref:System.Data.DataSet> and <xref:System.Data.DataTable>, adds sample data, and then displays the data in XML format.  \n  \n [!code-cs[Classic WebData DataSet.GetXml Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ge_1_1.cs)]\n [!code-vb[Classic WebData DataSet.GetXml Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ge_1_1.vb)]  \n  \n This sample demonstrates how to write data into an XML file from a DataSet and read data into DataSet from XML. This sample will create one dataset with two tables, use two ways to export a dataset into the XML files (WriteXml and GetXml), and use two ways (ReadXml and InferXmlSchema) to import a dataset from the XML files.  \n  \n Before you compile and run the sample, you need to create four XML files in the sample directory. First, create ElementsWithAttributes.xml:  \n  \n```  \n<MySchool>  \n  <Course CourseID=\"C1045\" Year=\"2012\"  Title=\"Calculus\" Credits=\"4\" DepartmentID=\"7\">New</Course>  \n  <Course CourseID=\"C1061\" Year=\"2012\"  Title=\"Physics\" Credits=\"4\" DepartmentID=\"1\" />  \n  <Department DepartmentID=\"1\" Name=\"Engineering\" Budget=\"350000\" StartDate=\"2007-09-01T00:00:00+08:00\" Administrator=\"2\" />  \n  <Department DepartmentID=\"7\" Name=\"Mathematics\" Budget=\"250024\" StartDate=\"2007-09-01T00:00:00+08:00\" Administrator=\"3\">Cancelled</Department>  \n</MySchool>  \n```  \n  \n Next, create ElementsWithChildElementsxml.xml:  \n  \n```  \n<MySchool>  \n  <Course>  \n    <CourseID>C1045</CourseID>  \n    <Year>2012</Year>  \n    <Title>Calculus</Title>  \n    <Credits>4</Credits>  \n    <DepartmentID>7</DepartmentID>  \n  </Course>  \n  <Course>  \n    <CourseID>C1061</CourseID>  \n    <Year>2012</Year>  \n    <Title>Physics</Title>  \n    <Credits>4</Credits>  \n    <DepartmentID>1</DepartmentID>  \n  </Course>  \n  <Course>  \n    <CourseID>C2021</CourseID>  \n    <Year>2012</Year>  \n    <Title>Composition</Title>  \n    <Credits>3</Credits>  \n    <DepartmentID>2</DepartmentID>  \n  </Course>  \n  <Course>  \n    <CourseID>C2042</CourseID>  \n    <Year>2012</Year>  \n    <Title>Literature</Title>  \n    <Credits>4</Credits>  \n    <DepartmentID>2</DepartmentID>  \n  </Course>  \n  <Department>  \n    <DepartmentID>1</DepartmentID>  \n    <Name>Engineering</Name>  \n    <Budget>350000</Budget>  \n    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  \n    <Administrator>2</Administrator>  \n  </Department>  \n  <Department>  \n    <DepartmentID>2</DepartmentID>  \n    <Name>English</Name>  \n    <Budget>120000</Budget>  \n    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  \n    <Administrator>6</Administrator>  \n  </Department>  \n  <Department>  \n    <DepartmentID>4</DepartmentID>  \n    <Name>Economics</Name>  \n    <Budget>200000</Budget>  \n    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  \n    <Administrator>4</Administrator>  \n  </Department>  \n  <Department>  \n    <DepartmentID>7</DepartmentID>  \n    <Name>Mathematics</Name>  \n    <Budget>250024</Budget>  \n    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  \n    <Administrator>3</Administrator>  \n  </Department>  \n</MySchool>  \n```  \n  \n Now create ElementsWithOnlyAttributes.xml:  \n  \n```  \n<MySchool>  \n  <Course CourseID=\"C1045\" Year=\"2012\"  Title=\"Calculus\" Credits=\"4\" DepartmentID=\"7\" />  \n  <Course CourseID=\"C1061\" Year=\"2012\"  Title=\"Physics\" Credits=\"4\" DepartmentID=\"1\" />  \n  <Department DepartmentID=\"1\" Name=\"Engineering\" Budget=\"350000\" StartDate=\"2007-09-01T00:00:00+08:00\" Administrator=\"2\" />  \n  <Department DepartmentID=\"7\" Name=\"Mathematics\" Budget=\"250024\" StartDate=\"2007-09-01T00:00:00+08:00\" Administrator=\"3\" />  \n</MySchool>  \n```  \n  \n And finally, create RepeatingElements.xml:  \n  \n```  \n<MySchool>  \n  <Course>C1045</Course>  \n  <Course>C1061</Course>  \n  <Department>Engineering</Department>   \n  <Department>Mathematics</Department>  \n</MySchool>  \n```  \n  \n Now you can compile and run the following source code.  [How to Store Data of DataSet into XML File](http://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) has Visual Basic and C# projects for this sample.  \n  \n```  \nusing System;  \nusing System.Data;  \nusing System.IO;  \nusing System.Text;  \nusing System.Xml;  \n  \n// Use WriteXml method to export the dataset.  \nstatic class DataTableHelper {  \n   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  \n      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  \n         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  \n            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  \n            Console.WriteLine(\"Write {0} to the File {1}.\", dataset.DataSetName, xmlFileName);  \n            Console.WriteLine();  \n         }  \n      }  \n   }  \n  \n   // Use GetXml method to get the XML data of the dataset and then export to the file.  \n   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  \n      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  \n         writer.WriteLine(dataset.GetXml());  \n         Console.WriteLine(\"Get Xml data from {0} and write to the File {1}.\", dataset.DataSetName, xmlFileName);  \n         Console.WriteLine();  \n      }  \n   }  \n  \n   // Use ReadXml method to import the dataset from the dataset.  \n   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  \n      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  \n         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  \n            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  \n         }  \n      }  \n   }  \n  \n   // Display the columns and value of DataSet.  \n   public static void ShowDataSet(DataSet dataset) {  \n      foreach (DataTable table in dataset.Tables) {  \n         Console.WriteLine(\"Table {0}:\", table.TableName);  \n         ShowDataTable(table);  \n      }  \n   }  \n  \n   // Display the columns and value of DataTable.  \n   private static void ShowDataTable(DataTable table) {  \n      foreach (DataColumn col in table.Columns) {  \n         Console.Write(\"{0,-14}\", col.ColumnName);  \n      }  \n      Console.WriteLine(\"{0,-14}\", \"\");  \n  \n      foreach (DataRow row in table.Rows) {  \n         if (row.RowState == DataRowState.Deleted) {  \n            foreach (DataColumn col in table.Columns) {  \n               if (col.DataType.Equals(typeof(DateTime))) {  \n                  Console.Write(\"{0,-14:d}\", row[col, DataRowVersion.Original]);  \n               }  \n               else if (col.DataType.Equals(typeof(Decimal))) {  \n                  Console.Write(\"{0,-14:C}\", row[col, DataRowVersion.Original]);  \n               }  \n               else {  \n                  Console.Write(\"{0,-14}\", row[col, DataRowVersion.Original]);  \n               }  \n            }  \n         }  \n         else {  \n            foreach (DataColumn col in table.Columns) {  \n               if (col.DataType.Equals(typeof(DateTime))) {  \n                  Console.Write(\"{0,-14:d}\", row[col]);  \n               }  \n               else if (col.DataType.Equals(typeof(Decimal))) {  \n                  Console.Write(\"{0,-14:C}\", row[col]);  \n               }  \n               else {  \n                  Console.Write(\"{0,-14}\", row[col]);  \n               }  \n            }  \n         }  \n         Console.WriteLine(\"{0,-14}\", \"\");  \n      }  \n   }  \n  \n   // Display the columns of DataSet.  \n   public static void ShowDataSetSchema(DataSet dataSet) {  \n      Console.WriteLine(\"{0} contains the following tables:\", dataSet.DataSetName);  \n      foreach (DataTable table in dataSet.Tables) {  \n         Console.WriteLine(\"   Table {0} contains the following columns:\", table.TableName);  \n         ShowDataTableSchema(table);  \n      }  \n   }  \n  \n   // Display the columns of DataTable  \n   private static void ShowDataTableSchema(DataTable table) {  \n      String columnString = \"\";  \n      foreach (DataColumn col in table.Columns) {  \n         columnString += col.ColumnName + \"   \";  \n      }  \n      Console.WriteLine(columnString);  \n   }  \n}  \n  \nclass Program {  \n   static void Main(string[] args) {  \n      // Create the DataSet  \n      DataSet school = new DataSet(\"MySchool\");  \n      DataTable course = CreateCourse();  \n      DataTable department = CreateDepartment();  \n      school.Tables.Add(course);  \n      school.Tables.Add(department);  \n  \n      // Define the constraint between the tables.  \n      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint(\"CourseDepartFK\", department.Columns[\"DepartmentID\"], course.Columns[\"DepartmentID\"]);  \n      courseDepartFK.DeleteRule = Rule.Cascade;  \n      courseDepartFK.UpdateRule = Rule.Cascade;  \n      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  \n      course.Constraints.Add(courseDepartFK);  \n  \n      InsertDepartments(department);  \n      InsertCourses(course);  \n  \n      // Export the dataset to the XML file.  \n      Console.WriteLine(\"Data of the whole DataSet {0}\", school.DataSetName);  \n      DataTableHelper.ShowDataSet(school);  \n  \n      String xmlWithSchemaFileName = \"WriterXMLWithSchema.xml\";  \n      String xmlGetDataFileName = \"GetXML.xml\";  \n  \n      // Use two ways to export the dataset to the Xml file.  \n      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  \n      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  \n  \n      // Import the dataset from the XML file.  \n      // Use two ways to import the dataset from the Xml file.  \n      Console.WriteLine(\"Read Xml document into a new DataSet:\");  \n      DataSet newSchool = new DataSet(\"NewSchool\");  \n      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  \n      DataTableHelper.ShowDataSetSchema(newSchool);  \n      Console.WriteLine();  \n  \n      Console.WriteLine(\"Infer a schema for a DataSet from an XML document:\");  \n      InferDataSetSchemaFromXml();  \n  \n      Console.WriteLine(\"Press any key to exit.\");  \n      Console.ReadKey();  \n   }  \n  \n   static DataTable CreateCourse() {  \n      DataTable course = new DataTable(\"Course\");  \n      DataColumn[] cols ={  \n                              new DataColumn(\"CourseID\",typeof(String)),  \n                              new DataColumn(\"Year\",typeof(Int32)),  \n                              new DataColumn(\"Title\",typeof(String)),  \n                              new DataColumn(\"Credits\",typeof(Int32)),  \n                              new DataColumn(\"DepartmentID\",typeof(Int32))};  \n      course.Columns.AddRange(cols);  \n  \n      course.PrimaryKey = new DataColumn[] { course.Columns[\"CourseID\"], course.Columns[\"Year\"] };  \n  \n      return course;  \n   }  \n  \n   static DataTable CreateDepartment() {  \n      DataTable department = new DataTable(\"Department\");  \n      DataColumn[] cols = {   \n                                new DataColumn(\"DepartmentID\", typeof(Int32)),  \n                                new DataColumn(\"Name\",typeof(String)),  \n                                new DataColumn(\"Budget\",typeof(Decimal)),  \n                                new DataColumn(\"StartDate\",typeof(DateTime)),  \n                                new DataColumn(\"Administrator\",typeof(Int32))};  \n      department.Columns.AddRange(cols);  \n  \n      department.PrimaryKey = new DataColumn[] { department.Columns[\"DepartmentID\"] };  \n  \n      return department;  \n   }  \n  \n   static void InsertDepartments(DataTable department) {  \n      Object[] rows = {   \n                            new Object[]{1,\"Engineering\",350000.00,new DateTime(2007,9,1),2},  \n                            new Object[]{2,\"English\",120000.00,new DateTime(2007,9,1),6},  \n                            new Object[]{4,\"Economics\",200000.00,new DateTime(2007,9,1),4},  \n                            new Object[]{7,\"Mathematics\",250024.00,new DateTime(2007,9,1),3}};  \n  \n      foreach (Object[] row in rows) {  \n         department.Rows.Add(row);  \n      }  \n   }  \n  \n   static void InsertCourses(DataTable course) {  \n      Object[] rows ={  \n                               new Object[]{\"C1045\",2012,\"Calculus\",4,7},  \n                               new Object[]{\"C1061\",2012,\"Physics\",4,1},  \n                               new Object[]{\"C2021\",2012,\"Composition\",3,2},  \n                               new Object[]{\"C2042\",2012,\"Literature\",4,2}};  \n  \n      foreach (Object[] row in rows) {  \n         course.Rows.Add(row);  \n      }  \n   }  \n  \n   // Display the results of inferring schema from four types of XML structures  \n   private static void InferDataSetSchemaFromXml() {  \n      String[] xmlFileNames = {   \n  \n                                    @\"ElementsWithOnlyAttributes.xml\",   \n                                    @\"ElementsWithAttributes.xml\",  \n                                    @\"RepeatingElements.xml\",   \n                                    @\"ElementsWithChildElements.xml\" };  \n  \n      foreach (String xmlFileName in xmlFileNames) {  \n         Console.WriteLine(\"Result of {0}\", Path.GetFileNameWithoutExtension(xmlFileName));  \n         DataSet newSchool = new DataSet();  \n         newSchool.InferXmlSchema(xmlFileName, null);  \n         DataTableHelper.ShowDataSetSchema(newSchool);  \n         Console.WriteLine();  \n      }  \n   }  \n}  \n```"
  syntax:
    content: public string GetXml ();
    parameters: []
    return:
      type: System.String
      description: "字串中儲存之資料的表示法<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.DataSet.GetXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.GetXmlSchema
  id: GetXmlSchema
  parent: System.Data.DataSet
  langs:
  - csharp
  name: GetXmlSchema()
  nameWithType: DataSet.GetXmlSchema()
  fullName: System.Data.DataSet.GetXmlSchema()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "傳回 XML 結構描述中儲存之資料的 XML 表示法<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "呼叫此方法等於呼叫<xref:System.Data.DataSet.WriteXmlSchema%2A>，只不過寫入主要結構描述。</xref:System.Data.DataSet.WriteXmlSchema%2A>       GetXmlSchema 傳回 XML 字串形式，因此需要以更多成本負擔比<xref:System.Data.DataSet.WriteXmlSchema%2A>寫入 XML 檔案。</xref:System.Data.DataSet.WriteXmlSchema%2A>       如果您要建置<xref:System.Data.DataSet>使用結構描述推斷和序列化它使用 XML 或 Web 服務的資料行順序可能會變更。</xref:System.Data.DataSet>"
  example:
  - "The following example creates a <xref:System.Data.DataSet> and <xref:System.Data.DataTable>, and then displays the schema in XML format.  \n  \n [!code-cs[Classic WebData DataSet.GetXmlSchema Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ge_3_1.cs)]\n [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ge_3_1.vb)]"
  syntax:
    content: public string GetXmlSchema ();
    parameters: []
    return:
      type: System.String
      description: "也就字串的 XML 結構描述中儲存之資料的 XML 表示法<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.DataSet.GetXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.HasChanges
  id: HasChanges
  parent: System.Data.DataSet
  langs:
  - csharp
  name: HasChanges()
  nameWithType: DataSet.HasChanges()
  fullName: System.Data.DataSet.HasChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得值，指出是否<xref href=&quot;System.Data.DataSet&quot;></xref>有變更，包括新增、 刪除或修改過的資料列。"
  remarks: ''
  example:
  - "The following example uses the <xref:System.Data.DataSet.GetChanges%2A> method to create a second <xref:System.Data.DataSet> object that is then used to update a data source.  \n  \n [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ha_0_1.vb)]\n [!code-cs[Classic WebData DataSet.HasChanges Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ha_0_1.cs)]"
  syntax:
    content: public bool HasChanges ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Data.DataSet&quot;></xref>有變更，否則為<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.HasChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.HasChanges(System.Data.DataRowState)
  id: HasChanges(System.Data.DataRowState)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: HasChanges(DataRowState)
  nameWithType: DataSet.HasChanges(DataRowState)
  fullName: System.Data.DataSet.HasChanges(DataRowState)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得值，指出是否<xref href=&quot;System.Data.DataSet&quot;></xref>有變更，包括新增、 刪除或修改過的資料列，以進行篩選<xref href=&quot;System.Data.DataRowState&quot;> </xref>。"
  remarks: "檢查<xref:System.Data.DataSet.HasChanges%2A>屬性`DataSet`叫用之前<xref:System.Data.DataSet.GetChanges%2A>方法。</xref:System.Data.DataSet.GetChanges%2A> </xref:System.Data.DataSet.HasChanges%2A>"
  example:
  - "The following example uses the <xref:System.Data.DataSet.GetChanges%2A> method to create a second <xref:System.Data.DataSet> object, which is then used to update a data source.  \n  \n [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.ha_1_1.vb)]\n [!code-cs[Classic WebData DataSet.GetChanges1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.ha_1_1.cs)]"
  syntax:
    content: public bool HasChanges (System.Data.DataRowState rowStates);
    parameters:
    - id: rowStates
      type: System.Data.DataRowState
      description: "其中一個<xref href=&quot;System.Data.DataRowState&quot;></xref>值。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Data.DataSet&quot;></xref>有變更，否則為<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.HasChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.HasErrors
  id: HasErrors
  parent: System.Data.DataSet
  langs:
  - csharp
  name: HasErrors
  nameWithType: DataSet.HasErrors
  fullName: System.Data.DataSet.HasErrors
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得值，指出是否有錯誤的任何<xref href=&quot;System.Data.DataTable&quot;></xref>物件在這個<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "每個<xref:System.Data.DataTable>中<xref:System.Data.DataSet>還有<xref:System.Data.DataTable.HasErrors%2A>屬性。</xref:System.Data.DataTable.HasErrors%2A> </xref:System.Data.DataSet> </xref:System.Data.DataTable> 使用`HasErrors`屬性`DataSet`首先，判斷資料表是否錯誤，檢查個別之前<xref:System.Data.DataTable>物件。</xref:System.Data.DataTable> 如果`DataTable`有錯誤，錯誤<xref:System.Data.DataTable.GetErrors%2A>方法傳回的陣列<xref:System.Data.DataRow>包含錯誤的物件。</xref:System.Data.DataRow> </xref:System.Data.DataTable.GetErrors%2A>"
  example:
  - "The following example uses the HasErrors property to determine whether a <xref:System.Data.DataSet> object contains errors. If so, the errors for each <xref:System.Data.DataRow> in each <xref:System.Data.DataTable> are printed.  \n  \n [!code-cs[Classic WebData DataSet.HasErrors Example#1](~/add/codesnippet/csharp/p-system.data.dataset.ha_1.cs)]\n [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.ha_1.vb)]"
  syntax:
    content: public bool HasErrors { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果任何資料表包含錯誤; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.HasErrors*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])
  id: InferXmlSchema(System.IO.Stream,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InferXmlSchema(Stream,String[])
  nameWithType: DataSet.InferXmlSchema(Stream,String[])
  fullName: System.Data.DataSet.InferXmlSchema(Stream,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "適用於從指定的 XML 結構描述<xref:System.IO.Stream>至<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.IO.Stream>"
  syntax:
    content: public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "<xref uid=&quot;langword_csharp_Stream&quot; name=&quot;Stream&quot; href=&quot;&quot;> </xref>要從其中讀取的結構描述。"
    - id: nsArray
      type: System.String[]
      description: "要排除的結構描述推斷的命名空間統一資源識別元 (URI) 字串的陣列。"
  overload: System.Data.DataSet.InferXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])
  id: InferXmlSchema(System.IO.TextReader,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InferXmlSchema(TextReader,String[])
  nameWithType: DataSet.InferXmlSchema(TextReader,String[])
  fullName: System.Data.DataSet.InferXmlSchema(TextReader,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "適用於從指定的 XML 結構描述<xref:System.IO.TextReader>至<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.IO.TextReader>"
  syntax:
    content: public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref uid=&quot;langword_csharp_TextReader&quot; name=&quot;TextReader&quot; href=&quot;&quot;> </xref>要從其中讀取的結構描述。"
    - id: nsArray
      type: System.String[]
      description: "要排除的結構描述推斷的命名空間統一資源識別元 (URI) 字串的陣列。"
  overload: System.Data.DataSet.InferXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.InferXmlSchema(System.String,System.String[])
  id: InferXmlSchema(System.String,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InferXmlSchema(String,String[])
  nameWithType: DataSet.InferXmlSchema(String,String[])
  fullName: System.Data.DataSet.InferXmlSchema(String,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "從指定的檔案來套用 XML 結構描述<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  syntax:
    content: public void InferXmlSchema (string fileName, string[] nsArray);
    parameters:
    - id: fileName
      type: System.String
      description: "要從其中讀取的結構描述 （包括路徑） 的檔案名稱。"
    - id: nsArray
      type: System.String[]
      description: "要排除的結構描述推斷的命名空間統一資源識別元 (URI) 字串的陣列。"
  overload: System.Data.DataSet.InferXmlSchema*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>未設定為<xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>。"
  platform:
  - net462
- uid: System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])
  id: InferXmlSchema(System.Xml.XmlReader,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InferXmlSchema(XmlReader,String[])
  nameWithType: DataSet.InferXmlSchema(XmlReader,String[])
  fullName: System.Data.DataSet.InferXmlSchema(XmlReader,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "適用於從指定的 XML 結構描述<xref:System.Xml.XmlReader>至<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.Xml.XmlReader>"
  syntax:
    content: public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref uid=&quot;langword_csharp_XMLReader&quot; name=&quot;XMLReader&quot; href=&quot;&quot;> </xref>要從其中讀取的結構描述。"
    - id: nsArray
      type: System.String[]
      description: "要排除的結構描述推斷的命名空間統一資源識別元 (URI) 字串的陣列。"
  overload: System.Data.DataSet.InferXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Initialized
  id: Initialized
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Initialized
  nameWithType: DataSet.Initialized
  fullName: System.Data.DataSet.Initialized
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "之後，就會發生<xref href=&quot;System.Data.DataSet&quot;></xref>已初始化。"
  remarks: "如需詳細資訊，請參閱<xref:System.Data.DataSet.IsInitialized%2A>.</xref:System.Data.DataSet.IsInitialized%2A>"
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.InitializeDerivedDataSet
  id: InitializeDerivedDataSet
  parent: System.Data.DataSet
  langs:
  - csharp
  name: InitializeDerivedDataSet()
  nameWithType: DataSet.InitializeDerivedDataSet()
  fullName: System.Data.DataSet.InitializeDerivedDataSet()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "還原序列化的所有資料表資料的二進位或 XML 資料流中的資料集。"
  syntax:
    content: protected virtual void InitializeDerivedDataSet ();
    parameters: []
  overload: System.Data.DataSet.InitializeDerivedDataSet*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: IsBinarySerialized(SerializationInfo,StreamingContext)
  nameWithType: DataSet.IsBinarySerialized(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.IsBinarySerialized(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "會檢查格式的序列化表示<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>。"
  remarks: "此成員支援.NET Framework 基礎結構，並不是直接從您的程式碼使用。"
  syntax:
    content: protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>物件。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "<xref:System.Runtime.Serialization.StreamingContext>物件。</xref:System.Runtime.Serialization.StreamingContext>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果指定<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;></xref>代表<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>以二進位格式，序列化<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>否則。"
  overload: System.Data.DataSet.IsBinarySerialized*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.IsInitialized
  id: IsInitialized
  parent: System.Data.DataSet
  langs:
  - csharp
  name: IsInitialized
  nameWithType: DataSet.IsInitialized
  fullName: System.Data.DataSet.IsInitialized
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得值，指出是否<xref href=&quot;System.Data.DataSet&quot;></xref>已初始化。"
  remarks: "傳回的狀態<xref:System.Data.DataSet>時它由所建構，例如 Visual Studio。</xref:System.Data.DataSet> <xref:System.Data.DataSet.BeginInit%2A>方法將它設定為`false`和<xref:System.Data.DataSet.EndInit%2A>方法將它設定為`true`。</xref:System.Data.DataSet.EndInit%2A> </xref:System.Data.DataSet.BeginInit%2A>"
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示元件已完成初始化，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])
  id: Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Load(IDataReader,LoadOption,DataTable[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,DataTable[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,DataTable[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "填滿<xref href=&quot;System.Data.DataSet&quot;></xref>從資料來源，使用提供的值與<xref href=&quot;System.Data.IDataReader&quot;> </xref>，使用的陣列<xref href=&quot;System.Data.DataTable&quot;></xref>提供結構描述和命名空間資訊的執行個體。"
  remarks: "<xref:System.Data.DataTable.Load%2A>方法提供的技巧，以便填滿單一<xref:System.Data.DataTable>從擷取的資料<xref:System.Data.IDataReader>執行個體。</xref:System.Data.IDataReader> </xref:System.Data.DataTable> </xref:System.Data.DataTable.Load%2A> 這個方法會提供相同的功能，但可讓您從<xref:System.Data.IDataReader>分成多個資料表內<xref:System.Data.DataSet>.</xref:System.Data.DataSet></xref:System.Data.IDataReader>載入多個結果集      > [!NOTE] > 載入作業將會失敗並<xref:System.InvalidOperationException>若有任何內送的來源資料行`reader`是計算資料行。</xref:System.InvalidOperationException>       `loadOption`參數可讓您指定要匯入現有的資料進行互動的資料及可以是任何值的方式<xref:System.Data.LoadOption>列舉型別。</xref:System.Data.LoadOption> 請參閱文件<xref:System.Data.DataTable><xref:System.Data.DataTable.Load%2A>如需有關使用此參數的方法。</xref:System.Data.DataTable.Load%2A></xref:System.Data.DataTable>       `tables`參數可讓您指定的陣列<xref:System.Data.DataTable>執行個體，指出資料表對應至每一個結果集從讀取器的載入順序。</xref:System.Data.DataTable> Loadmethod 填滿每個提供<xref:System.Data.DataTable>具有資料從單一結果集，從來源資料讀取器執行個體。</xref:System.Data.DataTable> 每個結果集之後，Loadmethod 會移至下一個設定中讀取器，直到沒有其他結果集的結果。       這個方法的名稱解析配置等同於後續<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法的<xref:System.Data.Common.DbDataAdapter>類別。</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  example:
  - "The following example creates a new <xref:System.Data.DataSet>, adds two <xref:System.Data.DataTable> instances to the <xref:System.Data.DataSet>, and then fills the <xref:System.Data.DataSet> using the Load method, retrieving data from a <xref:System.Data.DataTableReader> that contains two result sets. Finally, the example displays the contents of the tables in the console window.  \n  \n [!code-vb[DataWorks DataSet.LoadTables#1](~/add/codesnippet/visualbasic/54dbea54-b320-4c41-9f97-_1.vb)]\n [!code-cs[DataWorks DataSet.LoadTables#1](~/add/codesnippet/csharp/54dbea54-b320-4c41-9f97-_1.cs)]"
  syntax:
    content: public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.DataTable[] tables);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref>提供一個或多個結果集。"
    - id: loadOption
      type: System.Data.LoadOption
      description: "中的值<xref href=&quot;System.Data.LoadOption&quot;></xref>列舉，指出如何資料列已在<xref href=&quot;System.Data.DataTable&quot;></xref>內<xref href=&quot;System.Data.DataSet&quot;></xref>會結合共用相同的主索引鍵的內送資料列。"
    - id: tables
      type: System.Data.DataTable[]
      description: "陣列<xref href=&quot;System.Data.DataTable&quot;></xref>情況下，要從中載入方法會擷取名稱和命名空間的資訊。 這些資料表必須是成員<xref href=&quot;System.Data.DataTableCollection&quot;></xref>包含由此<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.DataSet.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])
  id: Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Load(IDataReader,LoadOption,String[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,String[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,String[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "填滿<xref href=&quot;System.Data.DataSet&quot;></xref>從資料來源，使用提供的值與<xref href=&quot;System.Data.IDataReader&quot;> </xref>，使用提供的內的資料表名稱的字串陣列<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>。"
  remarks: "<xref:System.Data.DataTable.Load%2A>方法提供的技巧，以便填滿單一<xref:System.Data.DataTable>從擷取的資料<xref:System.Data.IDataReader>執行個體。</xref:System.Data.IDataReader> </xref:System.Data.DataTable> </xref:System.Data.DataTable.Load%2A> 這個方法會提供相同的功能，但可讓您從多個結果集載入`IDataReader`分成多個資料表內`DataSet`。      > [!NOTE] > 載入作業將會失敗並<xref:System.InvalidOperationException>若有任何內送的來源資料行`reader`是計算資料行。</xref:System.InvalidOperationException>       `loadOption`參數可讓您指定要匯入現有的資料進行互動的資料及可以是任何值的方式<xref:System.Data.LoadOption>列舉型別。</xref:System.Data.LoadOption> 請參閱文件<xref:System.Data.DataTable.Load%2A>如需有關使用此參數的方法。</xref:System.Data.DataTable.Load%2A>       `tables`參數可讓您用來指定資料表名稱，表示對應至每一個結果集載入從讀取器的資料表順序的陣列。 `Load`方法會嘗試尋找內資料表`DataSet`陣列中的順序中的資料表名稱，找到符合的名稱。 如果找到相符的資料表，該資料表會載入目前的結果集的內容。 如果找到相符的資料表，建立資料表所使用的資料表名稱陣列中提供的名稱，並從結果集推斷新的資料表結構描述。 每個結果集之後,`Load`方法會移到下一個結果集內讀取器，直到沒有其他結果集。       與相關聯的預設命名空間`DataSet`，如果任何項目，為新建立的每個相關聯`DataTable`。 這個方法的名稱解析配置等同於後續<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法的<xref:System.Data.Common.DbDataAdapter>類別。</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  example:
  - "The following Console application example first creates tables and loads data from a reader into a <xref:System.Data.DataSet>, using the `Load` method. The example then adds tables to a <xref:System.Data.DataSet> and attempts to fill the tables with data from a <xref:System.Data.DataTableReader>. In this example, because the parameters passed to the `Load` method indicate a table name that does not exist, the `Load` method creates a new table to match the name passed as a parameter. Once the data has been loaded, the example displays the contents of all its tables in the Console window.  \n  \n [!code-vb[DataWorks DataSet.LoadString#1](~/add/codesnippet/visualbasic/f903cc41-1885-430a-b43a-_1.vb)]\n [!code-cs[DataWorks DataSet.LoadString#1](~/add/codesnippet/csharp/f903cc41-1885-430a-b43a-_1.cs)]"
  syntax:
    content: public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, string[] tables);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref>提供一個或多個結果集。"
    - id: loadOption
      type: System.Data.LoadOption
      description: "中的值<xref href=&quot;System.Data.LoadOption&quot;></xref>列舉，指出如何資料列已在<xref href=&quot;System.Data.DataTable&quot;></xref>內<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>會結合共用相同的主索引鍵的內送資料列。"
    - id: tables
      type: System.String[]
      description: "Strings 的陣列，從中<xref uid=&quot;langword_csharp_Load&quot; name=&quot;Load&quot; href=&quot;&quot;></xref>方法會擷取資料表名稱資訊。"
  overload: System.Data.DataSet.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])
  id: Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "填滿<xref href=&quot;System.Data.DataSet&quot;></xref>從資料來源，使用提供的值與<xref href=&quot;System.Data.IDataReader&quot;> </xref>，使用的陣列<xref href=&quot;System.Data.DataTable&quot;></xref>提供結構描述和命名空間資訊的執行個體。"
  remarks: "<xref:System.Data.DataTable.Load%2A>方法提供的技巧，以便填滿單一<xref:System.Data.DataTable>從擷取的資料<xref:System.Data.IDataReader>執行個體。</xref:System.Data.IDataReader> </xref:System.Data.DataTable> </xref:System.Data.DataTable.Load%2A> 這個方法會提供相同的功能，但可讓您從<xref:System.Data.IDataReader>分成多個資料表內<xref:System.Data.DataSet>.</xref:System.Data.DataSet></xref:System.Data.IDataReader>載入多個結果集      > [!NOTE] > 載入作業將會失敗並<xref:System.InvalidOperationException>若有任何內送的來源資料行`reader`是計算資料行。</xref:System.InvalidOperationException>       `loadOption`參數可讓您指定要匯入現有的資料進行互動的資料及可以是任何值的方式<xref:System.Data.LoadOption>列舉型別。</xref:System.Data.LoadOption> 請參閱文件<xref:System.Data.DataTable><xref:System.Data.DataTable.Load%2A>如需有關使用此參數的方法。</xref:System.Data.DataTable.Load%2A></xref:System.Data.DataTable>       `errorHandler`參數是<xref:System.Data.FillErrorEventHandler>載入資料時，發生錯誤時呼叫的程序是指的委派。</xref:System.Data.FillErrorEventHandler> <xref:System.Data.FillErrorEventArgs>參數傳遞至程序提供可讓您擷取發生的錯誤，目前的資料，資料列的相關資訊的屬性和<xref:System.Data.DataTable>被填入。</xref:System.Data.DataTable> </xref:System.Data.FillErrorEventArgs> 使用此委派機制，而不是簡單的 try/catch 區塊，可讓您判斷錯誤處理狀況，並繼續處理，如果您想。 <xref:System.Data.FillErrorEventArgs>參數提供<xref:System.Data.FillErrorEventArgs.Continue%2A>屬性︰ 將此屬性設定為`true`，表示處理錯誤和想来繼續處理，將屬性設定為`false`指出您想要停止處理。</xref:System.Data.FillErrorEventArgs.Continue%2A> </xref:System.Data.FillErrorEventArgs> 請注意，將屬性設`false`導致觸發要擲回例外狀況的問題將程式碼。       `tables`參數可讓您指定的陣列<xref:System.Data.DataTable>執行個體，指出資料表對應至每一個結果集從讀取器的載入順序。</xref:System.Data.DataTable> Loadmethod 填滿每個提供<xref:System.Data.DataTable>具有資料從單一結果集，從來源資料讀取器執行個體。</xref:System.Data.DataTable> 每個結果集之後，Loadmethod 會移至下一個設定中讀取器，直到沒有其他結果集的結果。       這個方法的名稱解析配置等同於後續<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法的<xref:System.Data.Common.DbDataAdapter>類別。</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  example:
  - "The following example adds a table to a <xref:System.Data.DataSet>, and then attempts to use the Load method to load data from a <xref:System.Data.DataTableReader> that contains an incompatible schema. Rather than trapping the error, this example uses a <xref:System.Data.FillErrorEventHandler> delegate to investigate and handle the error. The output is displayed in the console window.  \n  \n [!code-vb[DataWorks DataSet.Load#1](~/add/codesnippet/visualbasic/a22aaabc-2cbb-4c1f-aa4e-_1.vb)]\n [!code-cs[DataWorks DataSet.Load#1](~/add/codesnippet/csharp/a22aaabc-2cbb-4c1f-aa4e-_1.cs)]"
  syntax:
    content: public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, System.Data.DataTable[] tables);
    parameters:
    - id: reader
      type: System.Data.IDataReader
      description: "<xref href=&quot;System.Data.IDataReader&quot;> </xref>提供一個或多個結果集。"
    - id: loadOption
      type: System.Data.LoadOption
      description: "中的值<xref href=&quot;System.Data.LoadOption&quot;></xref>列舉，指出如何資料列已在<xref href=&quot;System.Data.DataTable&quot;></xref>內<xref href=&quot;System.Data.DataSet&quot;></xref>會結合共用相同的主索引鍵的內送資料列。"
    - id: errorHandler
      type: System.Data.FillErrorEventHandler
      description: "A <xref href=&quot;System.Data.FillErrorEventHandler&quot;> </xref>載入資料卻發生錯誤時要呼叫的委派。"
    - id: tables
      type: System.Data.DataTable[]
      description: "陣列<xref href=&quot;System.Data.DataTable&quot;></xref>情況下，要從中載入方法會擷取名稱和命名空間的資訊。"
  overload: System.Data.DataSet.Load*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Locale
  id: Locale
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Locale
  nameWithType: DataSet.Locale
  fullName: System.Data.DataSet.Locale
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得或設定用來比較字串時，在資料表中的地區設定資訊。"
  remarks: "地區設定屬性指定的地區設定的排序會套用。       根據預設，設定的地區設定<xref:System.Data.DataSet>也會針對每個設定的地區設定<xref:System.Data.DataTable>中的物件`DataSet`為相同的值。</xref:System.Data.DataTable> </xref:System.Data.DataSet>      > [!NOTE] > 包含運算式、 資料行中<xref:System.StringComparison>用。</xref:System.StringComparison> <xref:System.StringComparison>會被忽略。</xref:System.StringComparison>"
  example:
  - "The following example gets the <xref:System.Globalization.CultureInfo> for a <xref:System.Data.DataSet> and prints the <xref:System.Globalization.CultureInfo.DisplayName%2A> and <xref:System.Globalization.CultureInfo.EnglishName%2A> properties.  \n  \n [!code-vb[Classic WebData DataSet.Locale Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.lo_1.vb)]"
  syntax:
    content: public System.Globalization.CultureInfo Locale { get; set; }
    return:
      type: System.Globalization.CultureInfo
      description: "A <xref:System.Globalization.CultureInfo>，其中包含使用者的電腦地區設定的相關資料。</xref:System.Globalization.CultureInfo> 預設值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.Locale*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataRow[])
  id: Merge(System.Data.DataRow[])
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataRow[])
  nameWithType: DataSet.Merge(DataRow[])
  fullName: System.Data.DataSet.Merge(DataRow[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "合併的陣列<xref href=&quot;System.Data.DataRow&quot;></xref>到目前的物件<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "<xref:System.Data.DataSet.Merge%2A>方法用來合併兩個<xref:System.Data.DataSet>有大致相似的結構描述的物件。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 合併用戶端應用程式上通常用來將資料來源的最新的變更合併到現有的<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 這可讓用戶端應用程式已重新整理<xref:System.Data.DataSet>從資料來源的最新的資料。</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>結尾的一系列程序，包含驗證變更、 調解錯誤，更新資料來源的變更，以及最後重新整理現有<xref:System.Data.DataSet>.</xref:System.Data.DataSet>通常呼叫方法</xref:System.Data.DataSet.Merge%2A>       在用戶端應用程式中，是很常見的單一按鈕，讓使用者可以按一下收集變更的資料，再將它傳送回中介層元件進行驗證。 在此案例中，<xref:System.Data.DataSet.GetChanges%2A>首次叫用方法。</xref:System.Data.DataSet.GetChanges%2A> 方法會傳回第二個<xref:System.Data.DataSet>適合用來驗證和合併。</xref:System.Data.DataSet> 此第二個<xref:System.Data.DataSet>物件只包含<xref:System.Data.DataTable>與<xref:System.Data.DataRow>物件的已變更，導致原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet>子集</xref:System.Data.DataRow></xref:System.Data.DataTable></xref:System.Data.DataSet>的 這個子集通常比較小，因此更有效率地傳遞回中介層元件。 然後中, 介層元件會透過預存程序，以變更更新原始資料來源。 中介層就可以傳送回其中一個新<xref:System.Data.DataSet>（藉由執行原始查詢一次），包含原始資料和資料來源的最新的資料，或可重新傳送的任何變更，已對它從資料來源子集。</xref:System.Data.DataSet> （例如，如果資料來源會自動建立唯一的主索引鍵值，這些值可以傳播回用戶端應用程式。）在任一情況下，傳回<xref:System.Data.DataSet>可以合併至用戶端應用程式的原始<xref:System.Data.DataSet>與<xref:System.Data.DataSet.Merge%2A>方法。</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       當<xref:System.Data.DataSet.Merge%2A>呼叫方法時，兩個結構描述<xref:System.Data.DataSet>物件進行比較，因為它是可能的結構描述可能已經變更。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 例如，在企業對企業案例中，新的資料行可能已新增至 XML 結構描述自動化程序。 如果來源<xref:System.Data.DataSet>包含結構描述項目 (加入<xref:System.Data.DataColumn>物件) 中遺失目標中，結構描述項目可以藉由設定新增至目標`missingSchemaAction`引數`MissingSchemaAction.Add`。</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 在此情況下，合併<xref:System.Data.DataSet>包含新增結構描述和資料。</xref:System.Data.DataSet>       合併結構描述後, 資料會合併。       合併新的來源時<xref:System.Data.DataSet>到目標，任何來源的資料列與<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`與目標資料列具有相同的主索引鍵值相符。</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 來源的資料列<xref:System.Data.DataRowState>值`Added`會對應到新的目標資料列與相同的主索引鍵值為新的來源資料列。</xref:System.Data.DataRowState>       合併期間，會停用條件約束。 如果任何條件約束無法啟用合併，結尾<xref:System.Data.ConstraintException>產生，停用條件約束時，合併的資料都會保留下來。</xref:System.Data.ConstraintException> 在此情況下，<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`，並且所有的資料列，而不會標示錯誤。</xref:System.Data.DataSet.EnforceConstraints%2A> 必須先解決錯誤，然後再嘗試重設<xref:System.Data.DataSet.EnforceConstraints%2A>屬性`true`。</xref:System.Data.DataSet.EnforceConstraints%2A>"
  syntax:
    content: public void Merge (System.Data.DataRow[] rows);
    parameters:
    - id: rows
      type: System.Data.DataRow[]
      description: "陣列<xref uid=&quot;langword_csharp_DataRow&quot; name=&quot;DataRow&quot; href=&quot;&quot;></xref>物件合併至<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataSet)
  id: Merge(System.Data.DataSet)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataSet)
  nameWithType: DataSet.Merge(DataSet)
  fullName: System.Data.DataSet.Merge(DataSet)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "將指定的合併<xref href=&quot;System.Data.DataSet&quot;></xref>及其結構描述到目前<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>。"
  remarks: "Merge 方法用來合併兩個<xref:System.Data.DataSet>有大致相似的結構描述的物件。</xref:System.Data.DataSet> 合併用戶端應用程式上通常用來將資料來源的最新的變更合併到現有的<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 這可讓用戶端應用程式已重新整理<xref:System.Data.DataSet>從資料來源的最新的資料。</xref:System.Data.DataSet>       Merge 方法通常稱為結尾的一系列程序牽涉到驗證的變更、 調整錯誤、 變更，更新資料來源和最後重新整理現有<xref:System.Data.DataSet>.</xref:System.Data.DataSet>       在用戶端應用程式中，是很常見的單一按鈕，讓使用者可以按一下收集變更的資料，再將它傳送回中介層元件進行驗證。 在此案例中，<xref:System.Data.DataSet.GetChanges%2A>首次叫用方法。</xref:System.Data.DataSet.GetChanges%2A> 方法會傳回第二個<xref:System.Data.DataSet>適合用來驗證和合併。</xref:System.Data.DataSet> 此第二個<xref:System.Data.DataSet>物件只包含<xref:System.Data.DataTable>與<xref:System.Data.DataRow>物件的已變更，導致原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet>子集</xref:System.Data.DataRow></xref:System.Data.DataTable></xref:System.Data.DataSet>的 這個子集是容量較小時，因此更有效率地傳遞回中介層元件。 然後中, 介層元件會透過預存程序，以變更更新原始資料來源。 中介層就可以傳送回其中一個新<xref:System.Data.DataSet>（藉由執行原始查詢一次），包含原始資料和資料來源的最新的資料，或可重新傳送的任何變更，已對它從資料來源子集。</xref:System.Data.DataSet> （例如，如果資料來源會自動建立唯一的主索引鍵值，這些值可以傳播回用戶端應用程式。）在任一情況下，傳回<xref:System.Data.DataSet>可以合併至用戶端應用程式的原始<xref:System.Data.DataSet>合併方法。</xref:System.Data.DataSet> </xref:System.Data.DataSet>       當合併方法呼叫時，兩個結構描述<xref:System.Data.DataSet>物件進行比較，因為它是可能的結構描述可能已經變更。</xref:System.Data.DataSet> 例如，在企業對企業案例中，新的資料行可能已新增至 XML 結構描述自動化程序。 如果來源<xref:System.Data.DataSet>包含結構描述項目 (加入<xref:System.Data.DataColumn>物件) 中遺失目標中，結構描述項目可以藉由設定新增至目標`missingSchemaAction`引數`MissingSchemaAction.Add`。</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 在此情況下，合併<xref:System.Data.DataSet>包含新增結構描述和資料。</xref:System.Data.DataSet>       合併結構描述後, 資料會合併。       合併新的來源時<xref:System.Data.DataSet>到目標，任何來源的資料列與<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`與目標資料列具有相同的主索引鍵值相符。</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 來源的資料列`DataRowState`值`Added`會對應到新的目標資料列與相同的主索引鍵值為新的來源資料列。       合併期間，會停用條件約束。 如果任何條件約束無法啟用 「 合併 」 結尾<xref:System.Data.ConstraintException>產生，停用條件約束時，合併的資料都會保留下來。</xref:System.Data.ConstraintException> 在此情況下，<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`，並且所有的資料列，而不會標示錯誤。</xref:System.Data.DataSet.EnforceConstraints%2A> 必須先解決錯誤，然後再嘗試重設<xref:System.Data.DataSet.EnforceConstraints%2A>屬性`true`。</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example uses the <xref:System.Data.DataSet.GetChanges%2A>, Update, and Merge methods on a <xref:System.Data.DataSet>.  \n  \n [!code-vb[Classic WebData DataSet.Merge Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.me_2_1.vb)]\n [!code-cs[Classic WebData DataSet.Merge Example#1](~/add/codesnippet/csharp/m-system.data.dataset.me_2_1.cs)]"
  syntax:
    content: public void Merge (System.Data.DataSet dataSet);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>將合併的資料和結構描述。"
  overload: System.Data.DataSet.Merge*
  exceptions:
  - type: System.Data.ConstraintException
    commentId: T:System.Data.ConstraintException
    description: "無法啟用一或多個條件約束。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>dataSet</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataTable)
  id: Merge(System.Data.DataTable)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataTable)
  nameWithType: DataSet.Merge(DataTable)
  fullName: System.Data.DataSet.Merge(DataTable)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "將指定的合併<xref href=&quot;System.Data.DataTable&quot;></xref>及其結構描述到目前<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "<xref:System.Data.DataSet.Merge%2A>方法用來合併兩個<xref:System.Data.DataSet>有大致相似的結構描述的物件。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 合併用戶端應用程式上通常用來將資料來源的最新的變更合併到現有的<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 這可讓用戶端應用程式已重新整理<xref:System.Data.DataSet>從資料來源的最新的資料。</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>結尾的一系列程序，包含驗證變更、 調解錯誤，更新資料來源的變更，以及最後重新整理現有<xref:System.Data.DataSet>.</xref:System.Data.DataSet>通常呼叫方法</xref:System.Data.DataSet.Merge%2A>       在用戶端應用程式中，是很常見的單一按鈕，讓使用者可以按一下收集變更的資料，再將它傳送回中介層元件進行驗證。 在此案例中，<xref:System.Data.DataSet.GetChanges%2A>首次叫用方法。</xref:System.Data.DataSet.GetChanges%2A> 方法會傳回第二個<xref:System.Data.DataSet>適合用來驗證和合併。</xref:System.Data.DataSet> 此第二個<xref:System.Data.DataSet>物件只包含<xref:System.Data.DataTable>與<xref:System.Data.DataRow>物件的已變更，導致原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet>子集</xref:System.Data.DataRow></xref:System.Data.DataTable></xref:System.Data.DataSet>的 這個子集是容量較小時，因此更有效率地傳遞回中介層元件。 然後中, 介層元件會透過預存程序，以變更更新原始資料來源。 中介層就可以傳送回其中一個新<xref:System.Data.DataSet>（藉由執行原始查詢一次），包含原始資料和資料來源的最新的資料，或可重新傳送的任何變更，已對它從資料來源子集。</xref:System.Data.DataSet> （例如，如果資料來源會自動建立唯一的主索引鍵值，這些值可以傳播回用戶端應用程式。）在任一情況下，傳回<xref:System.Data.DataSet>可以合併至用戶端應用程式的原始<xref:System.Data.DataSet>與<xref:System.Data.DataSet.Merge%2A>方法。</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       當<xref:System.Data.DataSet.Merge%2A>呼叫方法時，兩個結構描述<xref:System.Data.DataSet>物件進行比較，因為它是可能的結構描述可能已經變更。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 例如，在企業對企業案例中，新的資料行可能已新增至 XML 結構描述自動化程序。 如果來源<xref:System.Data.DataSet>包含結構描述項目 (加入<xref:System.Data.DataColumn>物件) 中遺失目標中，結構描述項目可以藉由設定新增至目標`missingSchemaAction`引數`MissingSchemaAction.Add`。</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 在此情況下，合併<xref:System.Data.DataSet>包含新增結構描述和資料。</xref:System.Data.DataSet>       合併結構描述後, 資料會合併。       合併新的來源時<xref:System.Data.DataSet>到目標，任何來源的資料列與<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`與目標資料列具有相同的主索引鍵值相符。</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 來源的資料列`DataRowState`值`Added`會對應到新的目標資料列與相同的主索引鍵值為新的來源資料列。       合併期間，會停用條件約束。 如果任何條件約束無法啟用 「 合併 」 結尾<xref:System.Data.ConstraintException>產生，停用條件約束時，合併的資料都會保留下來。</xref:System.Data.ConstraintException> 在此情況下，<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`，並且所有的資料列，而不會標示錯誤。</xref:System.Data.DataSet.EnforceConstraints%2A> 必須先解決錯誤，然後再嘗試重設<xref:System.Data.DataSet.EnforceConstraints%2A>屬性`true`。</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. A second <xref:System.Data.DataTable> is created that is identical to the first. Two rows are added to the second table, which is then merged into the <xref:System.Data.DataSet>.  \n  \n [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.me_1_1.vb)]\n [!code-cs[Classic WebData DataSet.Merge3 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.me_1_1.cs)]"
  syntax:
    content: public void Merge (System.Data.DataTable table);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref>將合併的資料和結構描述。"
  overload: System.Data.DataSet.Merge*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>table</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)
  id: Merge(System.Data.DataSet,System.Boolean)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataSet,Boolean)
  nameWithType: DataSet.Merge(DataSet,Boolean)
  fullName: System.Data.DataSet.Merge(DataSet,Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "將指定的合併<xref href=&quot;System.Data.DataSet&quot;></xref>及其結構描述到目前<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>、 保留或捨棄任何變更，在這個<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>根據指定的引數。"
  remarks: "<xref:System.Data.DataSet.Merge%2A>方法用來合併兩個<xref:System.Data.DataSet>有大致相似的結構描述的物件。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 合併用戶端應用程式上通常用來將資料來源的最新的變更合併到現有的<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 這可讓用戶端應用程式已重新整理<xref:System.Data.DataSet>從資料來源的最新的資料。</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>結尾的一系列程序，包含驗證變更、 調解錯誤，更新資料來源的變更，以及最後重新整理現有<xref:System.Data.DataSet>.</xref:System.Data.DataSet>通常呼叫方法</xref:System.Data.DataSet.Merge%2A>       在用戶端應用程式中，是很常見的單一按鈕，讓使用者可以按一下收集變更的資料，再將它傳送回中介層元件進行驗證。 在此案例中，<xref:System.Data.DataSet.GetChanges%2A>首次叫用方法。</xref:System.Data.DataSet.GetChanges%2A> 方法會傳回第二個<xref:System.Data.DataSet>適合用來驗證和合併。</xref:System.Data.DataSet> 此第二個<xref:System.Data.DataSet>物件只包含<xref:System.Data.DataTable>與<xref:System.Data.DataRow>物件的已變更，導致原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet>子集</xref:System.Data.DataRow></xref:System.Data.DataTable></xref:System.Data.DataSet>的 這個子集是容量較小時，因此更有效率地傳遞回中介層元件。 然後中, 介層元件會透過預存程序，以變更更新原始資料來源。 中介層就可以傳送回其中一個新<xref:System.Data.DataSet>（藉由執行原始查詢一次），包含原始資料和資料來源的最新的資料，或可重新傳送的任何變更，已對它從資料來源子集。</xref:System.Data.DataSet> （例如，如果資料來源會自動建立唯一的主索引鍵值，這些值可以傳播回用戶端應用程式。）在任一情況下，傳回<xref:System.Data.DataSet>可以合併至用戶端應用程式的原始<xref:System.Data.DataSet>與<xref:System.Data.DataSet.Merge%2A>方法。</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       當<xref:System.Data.DataSet.Merge%2A>呼叫方法時，兩個結構描述<xref:System.Data.DataSet>物件進行比較，因為它是可能的結構描述可能已經變更。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 例如，在企業對企業案例中，新的資料行可能已新增至 XML 結構描述自動化程序。 如果來源<xref:System.Data.DataSet>包含結構描述項目 (加入<xref:System.Data.DataColumn>物件) 中遺失目標中，結構描述項目可以藉由設定新增至目標`missingSchemaAction`引數`MissingSchemaAction.Add`。</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 在此情況下，合併<xref:System.Data.DataSet>包含新增結構描述和資料。</xref:System.Data.DataSet>       合併結構描述後, 資料會合併。       合併新的來源時<xref:System.Data.DataSet>到目標，任何來源的資料列與<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`與目標資料列具有相同的主索引鍵值相符。</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 來源的資料列`DataRowState`值`Added`會對應到新的目標資料列與相同的主索引鍵值為新的來源資料列。       合併期間，會停用條件約束。 如果任何條件約束無法啟用 「 合併 」 結尾<xref:System.Data.ConstraintException>產生，停用條件約束時，合併的資料都會保留下來。</xref:System.Data.ConstraintException> 在此情況下，<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`，並且所有的資料列，而不會標示錯誤。</xref:System.Data.DataSet.EnforceConstraints%2A> 必須先解決錯誤，然後再嘗試重設<xref:System.Data.DataSet.EnforceConstraints%2A>屬性`true`。</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. After adding ten rows, two values are changed, and one row is added. A subset of the changed data is created using the <xref:System.Data.DataSet.GetChanges%2A> method. After reconciling errors, the subset data is merged into the original <xref:System.Data.DataSet>.  \n  \n [!code-cs[Classic WebData DataSet.GetChanges Example#1](~/add/codesnippet/csharp/m-system.data.dataset.me_0_1.cs)]\n [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.me_0_1.vb)]"
  syntax:
    content: public void Merge (System.Data.DataSet dataSet, bool preserveChanges);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>將合併的資料和結構描述。"
    - id: preserveChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留在目前的變更<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>，否則為<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)
  id: Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataRow[],Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataRow[],Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataRow[],Boolean,MissingSchemaAction)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "合併的陣列<xref href=&quot;System.Data.DataRow&quot;></xref>到目前的物件<xref href=&quot;System.Data.DataSet&quot;> </xref>、 保留或捨棄變更<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>和處理的不相容的結構描述，根據指定的引數。"
  remarks: "<xref:System.Data.DataSet.Merge%2A>方法用來合併兩個<xref:System.Data.DataSet>有大致相似的結構描述的物件。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 合併用戶端應用程式上通常用來將資料來源的最新的變更合併到現有的<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 這可讓用戶端應用程式已重新整理<xref:System.Data.DataSet>從資料來源的最新的資料。</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>結尾的一系列程序，包含驗證變更、 調解錯誤，更新資料來源的變更，以及最後重新整理現有<xref:System.Data.DataSet>.</xref:System.Data.DataSet>通常呼叫方法</xref:System.Data.DataSet.Merge%2A>       在用戶端應用程式中，是很常見的單一按鈕，讓使用者可以按一下收集變更的資料，再將它傳送回中介層元件進行驗證。 在此案例中，<xref:System.Data.DataSet.GetChanges%2A>首次叫用方法。</xref:System.Data.DataSet.GetChanges%2A> 方法會傳回第二個<xref:System.Data.DataSet>適合用來驗證和合併。</xref:System.Data.DataSet> 此第二個<xref:System.Data.DataSet>物件只包含<xref:System.Data.DataTable>與<xref:System.Data.DataRow>物件的已變更，導致原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet>子集</xref:System.Data.DataRow></xref:System.Data.DataTable></xref:System.Data.DataSet>的 這個子集是容量較小時，因此更有效率地傳遞回中介層元件。 然後中, 介層元件會透過預存程序，以變更更新原始資料來源。 中介層就可以傳送回其中一個新<xref:System.Data.DataSet>（藉由執行原始查詢一次），包含原始資料和資料來源的最新的資料，或可重新傳送的任何變更，已對它從資料來源子集。</xref:System.Data.DataSet> （例如，如果資料來源會自動建立唯一的主索引鍵值，這些值可以傳播回用戶端應用程式。）在任一情況下，傳回<xref:System.Data.DataSet>可以合併至用戶端應用程式的原始<xref:System.Data.DataSet>與<xref:System.Data.DataSet.Merge%2A>方法。</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       為了方便說明<xref:System.Data.DataSet.Merge%2A>方法，我們使用 「 目標 」 來表示目前<xref:System.Data.DataSet>，和 「 來源 」 名稱的第二個 （參數） <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 目標<xref:System.Data.DataSet>會如此命名，因為它是在其動作 （合併），就會發生的物件。</xref:System.Data.DataSet> <xref:System.Data.DataSet>稱為 「 來源 」，因為它包含的資訊不會變更，但改為合併到目前<xref:System.Data.DataSet>.</xref:System.Data.DataSet></xref:System.Data.DataSet>第二個       當<xref:System.Data.DataSet.Merge%2A>呼叫方法時，兩個結構描述<xref:System.Data.DataSet>物件進行比較，因為它是可能的結構描述可能已經變更。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 例如，在企業對企業案例中，新的資料行可能已新增至 XML 結構描述自動化程序。 如果來源<xref:System.Data.DataSet>包含結構描述項目 (加入<xref:System.Data.DataColumn>物件) 中遺失目標中，結構描述項目可以藉由設定新增至目標`missingSchemaAction`引數`MissingSchemaAction.Add`。</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 在此情況下，合併<xref:System.Data.DataSet>包含新增結構描述和資料。</xref:System.Data.DataSet>       合併結構描述後, 資料會合併。       合併新的來源時<xref:System.Data.DataSet>到目標，任何來源的資料列與<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`與目標資料列具有相同的主索引鍵值相符。</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 來源的資料列`DataRowState`值`Added`會對應到新的目標資料列與相同的主索引鍵值為新的來源資料列。       合併期間，會停用條件約束。 如果任何條件約束無法啟用 「 合併 」 結尾<xref:System.Data.ConstraintException>產生，停用條件約束時，合併的資料都會保留下來。</xref:System.Data.ConstraintException> 在此情況下，<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`，並且所有的資料列，而不會標示錯誤。</xref:System.Data.DataSet.EnforceConstraints%2A> 必須先解決錯誤，然後再嘗試重設<xref:System.Data.DataSet.EnforceConstraints%2A>屬性`true`。</xref:System.Data.DataSet.EnforceConstraints%2A>"
  syntax:
    content: public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);
    parameters:
    - id: rows
      type: System.Data.DataRow[]
      description: "陣列<xref href=&quot;System.Data.DataRow&quot;></xref>物件合併至<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>。"
    - id: preserveChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留在變更<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>，否則為<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: missingSchemaAction
      type: System.Data.MissingSchemaAction
      description: "其中一個<xref href=&quot;System.Data.MissingSchemaAction&quot;></xref>值。"
  overload: System.Data.DataSet.Merge*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)
  id: Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataSet,Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataSet,Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataSet,Boolean,MissingSchemaAction)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "將指定的合併<xref href=&quot;System.Data.DataSet&quot;></xref>及其結構描述與目前<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>、 保留或捨棄目前的變更<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>和處理的不相容的結構描述，根據指定的引數。"
  remarks: "<xref:System.Data.DataSet.Merge%2A>方法用來合併兩個<xref:System.Data.DataSet>有大致相似的結構描述的物件。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 合併用戶端應用程式上通常用來將資料來源的最新的變更合併到現有的<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 這可讓用戶端應用程式已重新整理<xref:System.Data.DataSet>從資料來源的最新的資料。</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>結尾的一系列程序，包含驗證變更、 調解錯誤，更新資料來源的變更，以及最後重新整理現有<xref:System.Data.DataSet>.</xref:System.Data.DataSet>通常呼叫方法</xref:System.Data.DataSet.Merge%2A>       在用戶端應用程式中，是很常見的單一按鈕，讓使用者可以按一下收集變更的資料，再將它傳送回中介層元件進行驗證。 在此案例中，<xref:System.Data.DataSet.GetChanges%2A>首次叫用方法。</xref:System.Data.DataSet.GetChanges%2A> 方法會傳回第二個<xref:System.Data.DataSet>適合用來驗證和合併。</xref:System.Data.DataSet> 此第二個<xref:System.Data.DataSet>物件只包含<xref:System.Data.DataTable>與<xref:System.Data.DataRow>物件的已變更，導致原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet>子集</xref:System.Data.DataRow></xref:System.Data.DataTable></xref:System.Data.DataSet>的 這個子集是容量較小時，因此更有效率地傳遞回中介層元件。 然後中, 介層元件會透過預存程序，以變更更新原始資料來源。 中介層就可以傳送回其中一個新<xref:System.Data.DataSet>（藉由執行原始查詢一次），包含原始資料和資料來源的最新的資料，或可重新傳送的任何變更，已對它從資料來源子集。</xref:System.Data.DataSet> （例如，如果資料來源會自動建立唯一的主索引鍵值，這些值可以傳播回用戶端應用程式。）在任一情況下，傳回<xref:System.Data.DataSet>可以合併至用戶端應用程式的原始<xref:System.Data.DataSet>與<xref:System.Data.DataSet.Merge%2A>方法。</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       為了方便說明<xref:System.Data.DataSet.Merge%2A>方法，我們使用 「 目標 」 來表示目前<xref:System.Data.DataSet>，和 「 來源 」 名稱的第二個 （參數） <xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 目標<xref:System.Data.DataSet>會如此命名，因為它是在其動作 （合併），就會發生的物件。</xref:System.Data.DataSet> <xref:System.Data.DataSet>稱為 「 來源 」，因為它包含的資訊不會變更，但改為合併到目前<xref:System.Data.DataSet>.</xref:System.Data.DataSet></xref:System.Data.DataSet>第二個       當<xref:System.Data.DataSet.Merge%2A>呼叫方法時，兩個結構描述<xref:System.Data.DataSet>物件進行比較，因為它是可能的結構描述可能已經變更。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 例如，在企業對企業案例中，新的資料行可能已新增至 XML 結構描述自動化程序。 如果來源<xref:System.Data.DataSet>包含結構描述項目 (加入<xref:System.Data.DataColumn>物件) 中遺失目標中，結構描述項目可以藉由設定新增至目標`missingSchemaAction`引數`MissingSchemaAction.Add`。</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 在此情況下，合併<xref:System.Data.DataSet>包含新增結構描述和資料。</xref:System.Data.DataSet>       合併結構描述後, 資料會合併。       合併新的來源時<xref:System.Data.DataSet>到目標，任何來源的資料列與<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`與目標資料列具有相同的主索引鍵值相符。</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 來源的資料列`DataRowState`值`Added`會對應到新的目標資料列與相同的主索引鍵值為新的來源資料列。       合併期間，會停用條件約束。 如果任何條件約束無法啟用 「 合併 」 結尾<xref:System.Data.ConstraintException>產生，停用條件約束時，合併的資料都會保留下來。</xref:System.Data.ConstraintException> 在此情況下，<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`，並且所有的資料列，而不會標示錯誤。</xref:System.Data.DataSet.EnforceConstraints%2A> 必須先解決錯誤，然後再嘗試重設<xref:System.Data.DataSet.EnforceConstraints%2A>屬性`true`。</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. Two values are changed, and one row is added. A subset of the changed data is created using the <xref:System.Data.DataSet.GetChanges%2A> method. After reconciling errors, a new column is added to the subset, changing the schema. When the <xref:System.Data.DataSet.Merge%2A> method is called with the `missingSchemaAction` set to `MissingSchemaAction.Add`, the new column is added to the original <xref:System.Data.DataSet> object's schema.  \n  \n [!code-cs[Classic WebData DataSet.Merge2 Example#1](~/add/codesnippet/csharp/e5f91548-401c-49b5-ab4b-_1.cs)]\n [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/add/codesnippet/visualbasic/e5f91548-401c-49b5-ab4b-_1.vb)]"
  syntax:
    content: public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>將合併的資料和結構描述。"
    - id: preserveChanges
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留在目前的變更<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>，否則為<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: missingSchemaAction
      type: System.Data.MissingSchemaAction
      description: "其中一個<xref href=&quot;System.Data.MissingSchemaAction&quot;></xref>值。"
  overload: System.Data.DataSet.Merge*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>dataSet</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  id: Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Merge(DataTable,Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataTable,Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataTable,Boolean,MissingSchemaAction)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "將指定的合併<xref href=&quot;System.Data.DataTable&quot;></xref>及其結構描述到目前<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>、 保留或捨棄變更<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;></xref>和處理的不相容的結構描述，根據指定的引數。"
  remarks: "<xref:System.Data.DataSet.Merge%2A>方法用來合併兩個<xref:System.Data.DataSet>有大致相似的結構描述的物件。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 合併用戶端應用程式上通常用來將資料來源的最新的變更合併到現有的<xref:System.Data.DataSet>.</xref:System.Data.DataSet> 這可讓用戶端應用程式已重新整理<xref:System.Data.DataSet>從資料來源的最新的資料。</xref:System.Data.DataSet>       <xref:System.Data.DataSet.Merge%2A>結尾的一系列程序，包含驗證變更、 調解錯誤，更新資料來源的變更，以及最後重新整理現有<xref:System.Data.DataSet>.</xref:System.Data.DataSet>通常呼叫方法</xref:System.Data.DataSet.Merge%2A>       Middle 用戶端應用程式，它是具有單一按鈕，讓使用者可以按一下，收集變更的資料，並送回中介層元件之前先進行驗證。 在此案例中，<xref:System.Data.DataSet.GetChanges%2A>首次叫用方法。</xref:System.Data.DataSet.GetChanges%2A> 方法會傳回第二個<xref:System.Data.DataSet>適合用來驗證和合併。</xref:System.Data.DataSet> 此第二個<xref:System.Data.DataSet>物件只包含<xref:System.Data.DataTable>與<xref:System.Data.DataRow>物件的已變更，導致原始<xref:System.Data.DataSet>.</xref:System.Data.DataSet>子集</xref:System.Data.DataRow></xref:System.Data.DataTable></xref:System.Data.DataSet>的 這個子集是容量較小時，因此更有效率地傳遞回中介層元件。 然後中, 介層元件會透過預存程序，以變更更新原始資料來源。 中介層就可以傳送回其中一個新<xref:System.Data.DataSet>（藉由執行原始查詢一次），包含原始資料和資料來源的最新的資料，或可重新傳送的任何變更，已對它從資料來源子集。</xref:System.Data.DataSet> （例如，如果資料來源會自動建立唯一的主索引鍵值，這些值可以傳播回用戶端應用程式。）在任一情況下，傳回<xref:System.Data.DataSet>可以合併至用戶端應用程式的原始<xref:System.Data.DataSet>與<xref:System.Data.DataSet.Merge%2A>方法。</xref:System.Data.DataSet.Merge%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet>       當<xref:System.Data.DataSet.Merge%2A>呼叫方法時，兩個結構描述<xref:System.Data.DataSet>物件進行比較，因為它是可能的結構描述可能已經變更。</xref:System.Data.DataSet> </xref:System.Data.DataSet.Merge%2A> 例如，在企業對企業案例中，新的資料行可能已新增至 XML 結構描述自動化程序。 如果來源<xref:System.Data.DataSet>包含結構描述項目 (加入<xref:System.Data.DataColumn>物件) 中遺失目標中，結構描述項目可以藉由設定新增至目標`missingSchemaAction`引數`MissingSchemaAction.Add`。</xref:System.Data.DataColumn> </xref:System.Data.DataSet> 在此情況下，合併<xref:System.Data.DataSet>包含新增結構描述和資料。</xref:System.Data.DataSet>       合併結構描述後, 資料會合併。       合併新的來源時<xref:System.Data.DataSet>到目標，任何來源的資料列與<xref:System.Data.DataRowState>值`Unchanged`， `Modified`，或`Deleted`與目標資料列具有相同的主索引鍵值相符。</xref:System.Data.DataRowState> </xref:System.Data.DataSet> 來源的資料列`DataRowState`值`Added`會對應到新的目標資料列與相同的主索引鍵值為新的來源資料列。       合併期間，會停用條件約束。 如果任何條件約束無法啟用 「 合併 」 結尾<xref:System.Data.ConstraintException>產生，停用條件約束時，合併的資料都會保留下來。</xref:System.Data.ConstraintException> 在此情況下，<xref:System.Data.DataSet.EnforceConstraints%2A>屬性設定為`false`，並且所有的資料列，而不會標示錯誤。</xref:System.Data.DataSet.EnforceConstraints%2A> 必須先解決錯誤，然後再嘗試重設<xref:System.Data.DataSet.EnforceConstraints%2A>屬性`true`。</xref:System.Data.DataSet.EnforceConstraints%2A>"
  example:
  - "The following example creates a simple <xref:System.Data.DataSet> with one table, two columns, and ten rows. A second <xref:System.Data.DataTable> is created that is nearly identical to the first except that a new `DataColumn` is added to the table. Two rows are added to the second table, which is then merged into the <xref:System.Data.DataSet> with the `preserveChanges` argument set to `false`, and the `missingSchemaAction` argument set to `MissingSchemaAction.Add`.  \n  \n [!code-cs[Classic WebData DataSet.Merge4 Example#1](~/add/codesnippet/csharp/a63745f5-1a9e-4fc7-9c61-_1.cs)]\n [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/add/codesnippet/visualbasic/a63745f5-1a9e-4fc7-9c61-_1.vb)]"
  syntax:
    content: public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref uid=&quot;langword_csharp_DataTable&quot; name=&quot;DataTable&quot; href=&quot;&quot;> </xref>將合併的資料和結構描述。"
    - id: preserveChanges
      type: System.Boolean
      description: "其中一個<xref href=&quot;System.Data.MissingSchemaAction&quot;></xref>值。"
    - id: missingSchemaAction
      type: System.Data.MissingSchemaAction
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要保留在變更<xref uid=&quot;langword_csharp_DataSet&quot; name=&quot;DataSet&quot; href=&quot;&quot;> </xref>，否則為<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.Merge*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>dataSet</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Data.DataSet.MergeFailed
  id: MergeFailed
  parent: System.Data.DataSet
  langs:
  - csharp
  name: MergeFailed
  nameWithType: DataSet.MergeFailed
  fullName: System.Data.DataSet.MergeFailed
  type: Event
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "發生於目標和來源<xref href=&quot;System.Data.DataRow&quot;></xref>有相同的主索引鍵值，和<xref:System.Data.DataSet.EnforceConstraints*>設為 true。</xref:System.Data.DataSet.EnforceConstraints*>"
  remarks: '如需處理事件的詳細資訊，請參閱[NIB︰ 使用事件](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67)。'
  example:
  - "The following example demonstrates the use of the MergeFailed event.  \n  \n [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/add/codesnippet/visualbasic/e-system.data.dataset.me_1.vb)]\n [!code-cs[Classic WebData DataSet.MergeFailed Example#1](~/add/codesnippet/csharp/e-system.data.dataset.me_1.cs)]"
  syntax:
    content: public event System.Data.MergeFailedEventHandler MergeFailed;
    return:
      type: System.Data.MergeFailedEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Namespace
  id: Namespace
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Namespace
  nameWithType: DataSet.Namespace
  fullName: System.Data.DataSet.Namespace
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得或設定的命名空間<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "命名空間屬性用於讀取和寫入 XML 文件到<xref:System.Data.DataSet>使用<xref:System.Data.DataSet.ReadXml%2A>， <xref:System.Data.DataSet.WriteXml%2A>， <xref:System.Data.DataSet.ReadXmlSchema%2A>，或<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet>       XML 文件的命名空間用來限定範圍的 XML 屬性和項目至<xref:System.Data.DataSet>。</xref:System.Data.DataSet>讀取時 例如，如果<xref:System.Data.DataSet>包含結構描述，已從具有命名空間&quot;mycompany 機 」 的文件和嘗試從具有不同的命名空間的文件只讀取資料，任何未對應到現有的結構描述的資料會被忽略。</xref:System.Data.DataSet>"
  example:
  - "The following example sets the <xref:System.Data.DataSet.Prefix%2A> before calling the <xref:System.Data.DataSet.ReadXml%2A> method.  \n  \n [!code-vb[Classic WebData DataSet.Namespace Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.na_1.vb)]\n [!code-cs[Classic WebData DataSet.Namespace Example#1](~/add/codesnippet/csharp/p-system.data.dataset.na_1.cs)]"
  syntax:
    content: public string Namespace { get; set; }
    return:
      type: System.String
      description: "命名空間的<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.DataSet.Namespace*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "命名空間中已經有資料。"
  platform:
  - net462
- uid: System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  id: OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: OnPropertyChanging(PropertyChangedEventArgs)
  nameWithType: DataSet.OnPropertyChanging(PropertyChangedEventArgs)
  fullName: System.Data.DataSet.OnPropertyChanging(PropertyChangedEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "引發 OnPropertyChanging 事件。"
  remarks: '引發事件會透過委派事件處理常式叫用。 如需概觀，請參閱[NIB︰ 引發事件](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)。'
  syntax:
    content: protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);
    parameters:
    - id: pcevent
      type: System.ComponentModel.PropertyChangedEventArgs
      description: "A<xref:System.ComponentModel.PropertyChangedEventArgs>包含事件資料。</xref:System.ComponentModel.PropertyChangedEventArgs>"
  overload: System.Data.DataSet.OnPropertyChanging*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)
  id: OnRemoveRelation(System.Data.DataRelation)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: OnRemoveRelation(DataRelation)
  nameWithType: DataSet.OnRemoveRelation(DataRelation)
  fullName: System.Data.DataSet.OnRemoveRelation(DataRelation)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "發生時<xref href=&quot;System.Data.DataRelation&quot;></xref>物件移除<xref href=&quot;System.Data.DataTable&quot;> </xref>。"
  remarks: "要移除的資料表限制的子類別應該覆寫這個方法"
  syntax:
    content: protected virtual void OnRemoveRelation (System.Data.DataRelation relation);
    parameters:
    - id: relation
      type: System.Data.DataRelation
      description: "<xref href=&quot;System.Data.DataRelation&quot;> </xref>被移除。"
  overload: System.Data.DataSet.OnRemoveRelation*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.OnRemoveTable(System.Data.DataTable)
  id: OnRemoveTable(System.Data.DataTable)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: OnRemoveTable(DataTable)
  nameWithType: DataSet.OnRemoveTable(DataTable)
  fullName: System.Data.DataSet.OnRemoveTable(DataTable)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "發生時<xref href=&quot;System.Data.DataTable&quot;></xref>被移除了<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "這個方法可以覆寫子類別，以限制資料表中移除。"
  example:
  - "The following example shows a class derived from the <xref:System.Data.DataSet> with the OnRemoveTable method overridden.  \n  \n [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.on_1.vb)]\n [!code-cs[Classic WebData DataSet.OnRemoveTable Example#1](~/add/codesnippet/csharp/m-system.data.dataset.on_1.cs)]"
  syntax:
    content: protected virtual void OnRemoveTable (System.Data.DataTable table);
    parameters:
    - id: table
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref>被移除。"
  overload: System.Data.DataSet.OnRemoveTable*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Prefix
  id: Prefix
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Prefix
  nameWithType: DataSet.Prefix
  fullName: System.Data.DataSet.Prefix
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得或設定 XML 前置詞別名的命名空間<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "前置詞屬性用於整個 XML 文件，以找出項目所屬的命名空間<xref:System.Data.DataSet>物件 (為設定由<xref:System.Data.DataSet.Namespace%2A>屬性)。</xref:System.Data.DataSet.Namespace%2A> </xref:System.Data.DataSet>"
  example:
  - "The following example sets the Prefix before calling the <xref:System.Data.DataSet.ReadXml%2A> method.  \n  \n [!code-vb[Classic WebData DataSet.Namespace Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.pr_1.vb)]\n [!code-cs[Classic WebData DataSet.Namespace Example#1](~/add/codesnippet/csharp/p-system.data.dataset.pr_1.cs)]"
  syntax:
    content: public string Prefix { get; set; }
    return:
      type: System.String
      description: "XML 前置詞<xref href=&quot;System.Data.DataSet&quot;></xref>命名空間。"
  overload: System.Data.DataSet.Prefix*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.RaisePropertyChanging(System.String)
  id: RaisePropertyChanging(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: RaisePropertyChanging(String)
  nameWithType: DataSet.RaisePropertyChanging(String)
  fullName: System.Data.DataSet.RaisePropertyChanging(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "傳送通知指定<xref href=&quot;System.Data.DataSet&quot;></xref>屬性即將變更。"
  syntax:
    content: protected void RaisePropertyChanging (string name);
    parameters:
    - id: name
      type: System.String
      description: "若要變更的屬性名稱。"
  overload: System.Data.DataSet.RaisePropertyChanging*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.IO.Stream)
  id: ReadXml(System.IO.Stream)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(Stream)
  nameWithType: DataSet.ReadXml(Stream)
  fullName: System.Data.DataSet.ReadXml(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "讀取 XML 結構描述和資料<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.IO.Stream?displayProperty=fullName&gt;。"
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法讀取的結構描述。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。       請注意，也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要寫入的 XML 資料，或結構描述和資料從`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定的內嵌結構描述，則內嵌結構描述會用來擴充現有的關聯式結構載入資料之前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。       如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法透過推斷延伸架構才能公開的所有資料，會引發例外狀況。      > [!NOTE] >`DataSet`不將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法的 XML 字元，例如 (&quot;_&quot;) 在序列化 xml 逸出。 `DataSet`本身只逸出 XML 項目名稱中不合法的 XML 字元，並因此可以只使用相同。 當 XML 項目名稱中的合法字元會逸出時，處理時忽略此元素。       如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`、 可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>xml 程式碼，包含非限定命名空間的項目。</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 若要讀取不合格的項目，設定`elementFormDefault`等於&quot;qualified&quot;中的 XML 結構描述，如下列範例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]> 如果的結構描述您<xref:System.Data.DataSet>包含項目嘗試讀取到結構描述時，發生例外狀況的名稱相同，但不同的類型，請在相同的命名空間，<xref:System.Data.DataSet>與<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。"
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the <xref:System.Data.DataSet.ReadXml%2A> method is used to fill it with schema and data.  \n  \n [!code-cs[Classic WebData DataSet.ReadXml1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_7_1.cs)]\n [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_7_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "衍生自<xref:System.IO.Stream>.</xref:System.IO.Stream>物件"
    return:
      type: System.Data.XmlReadMode
      description: "<xref href=&quot;System.Data.XmlReadMode&quot;> </xref>用來讀取資料。"
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.IO.TextReader)
  id: ReadXml(System.IO.TextReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(TextReader)
  nameWithType: DataSet.ReadXml(TextReader)
  fullName: System.Data.DataSet.ReadXml(TextReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "讀取 XML 結構描述和資料<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.IO.TextReader?displayProperty=fullName&gt;。"
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法讀取的結構描述。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。       請注意，也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要寫入的 XML 資料，或結構描述和資料從`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定的內嵌結構描述，則內嵌結構描述會用來擴充現有的關聯式結構載入資料之前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。       如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法透過推斷延伸架構才能公開的所有資料，會引發例外狀況。      > [!NOTE] >`DataSet`不將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法的 XML 字元，例如 (&quot;_&quot;) 在序列化 xml 逸出。 `DataSet`本身只逸出 XML 項目名稱中不合法的 XML 字元，並因此可以只使用相同。 當 XML 項目名稱中的合法字元會逸出時，處理時忽略此元素。       如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`、 可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>xml 程式碼，包含非限定命名空間的項目。</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 若要讀取不合格的項目，設定`elementFormDefault`等於&quot;qualified&quot;中的 XML 結構描述如下列範例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```類別繼承自<xref:System.IO.TextReader>類別包含<xref:System.IO.StreamReader>和<xref:System.IO.StringReader>類別。</xref:System.IO.StringReader> </xref:System.IO.StreamReader> </xref:System.IO.TextReader>      > [!NOTE] > 如果的結構描述您<xref:System.Data.DataSet>包含項目嘗試讀取到結構描述時，發生例外狀況的名稱相同，但不同的類型，請在相同的命名空間，<xref:System.Data.DataSet>與<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。"
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the <xref:System.Data.DataSet.ReadXml%2A> method is used to fill it with schema and data.  \n  \n [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_3_1.vb)]\n [!code-cs[Classic WebData DataSet.ReadXml2 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_3_1.cs)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref uid=&quot;langword_csharp_TextReader&quot; name=&quot;TextReader&quot; href=&quot;&quot;> </xref>要從其中讀取的結構描述和資料。"
    return:
      type: System.Data.XmlReadMode
      description: "<xref href=&quot;System.Data.XmlReadMode&quot;> </xref>用來讀取資料。"
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.String)
  id: ReadXml(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(String)
  nameWithType: DataSet.ReadXml(String)
  fullName: System.Data.DataSet.ReadXml(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "讀取 XML 結構描述和資料<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定的檔案。"
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法讀取的結構描述。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。       請注意，也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要寫入的 XML 資料，或結構描述和資料從`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定的內嵌結構描述，則內嵌結構描述會用來擴充現有的關聯式結構載入資料之前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。       如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法透過推斷延伸架構才能公開的所有資料，會引發例外狀況。      > [!NOTE] >`DataSet`不將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法的 XML 字元，例如 (&quot;_&quot;) 在序列化 xml 逸出。 `DataSet`本身只逸出 XML 項目名稱中不合法的 XML 字元，並因此可以只使用相同。 當 XML 項目名稱中的合法字元會逸出時，處理時忽略此元素。       如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`、 可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>xml 程式碼，包含非限定命名空間的項目。</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 若要讀取不合格的項目，設定`elementFormDefault`等於&quot;qualified&quot;中的 XML 結構描述如下列範例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]> 如果的結構描述您<xref:System.Data.DataSet>包含項目嘗試讀取到結構描述時，發生例外狀況的名稱相同，但不同的類型，請在相同的命名空間，<xref:System.Data.DataSet>與<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。"
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the <xref:System.Data.DataSet.ReadXml%2A> method is used to fill it with schema and data.  \n  \n [!code-cs[Classic WebData DataSet.ReadXml3 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_1_1.cs)]\n [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_1_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "檔案名稱 （包括路徑） 從當中讀取。"
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref>用來讀取資料。"
  overload: System.Data.DataSet.ReadXml*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>未設定為<xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>。"
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.Xml.XmlReader)
  id: ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(XmlReader)
  nameWithType: DataSet.ReadXml(XmlReader)
  fullName: System.Data.DataSet.ReadXml(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "讀取 XML 結構描述和資料<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.Xml.XmlReader?displayProperty=fullName&gt;。"
  remarks: "ReadXml 方法來讀取資料，或同時提供資料和結構描述<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法讀取的結構描述。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。       請注意，也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要寫入的 XML 資料，或結構描述和資料從`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定的內嵌結構描述，則內嵌結構描述會用來擴充現有的關聯式結構載入資料之前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。       如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法透過推斷延伸架構才能公開的所有資料，會引發例外狀況。      > [!NOTE] >`DataSet`不將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法的 XML 字元，例如 (&quot;_&quot;) 在序列化 xml 逸出。 `DataSet`本身只逸出 XML 項目名稱中不合法的 XML 字元，並因此可以只使用相同。 當 XML 項目名稱中的合法字元會逸出時，處理時忽略此元素。       如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`、 可能不會讀取資料，並呼叫 ReadXml 載入時，您可能會遇到例外狀況<xref:System.Data.DataSet>xml 程式碼，包含非限定命名空間的項目。</xref:System.Data.DataSet> </xref:System.Data.DataSet> 若要讀取不合格的項目，設定`elementFormDefault`等於&quot;qualified&quot;中的 XML 結構描述如下列範例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```       <xref:System.Xml.XmlTextReader?displayProperty=fullName>繼承自<xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader></xref:System.Xml.XmlTextReader?displayProperty=fullName>      > [!NOTE] > 如果的結構描述您<xref:System.Data.DataSet>包含項目嘗試讀取到結構描述時，發生例外狀況的名稱相同，但不同的類型，請在相同的命名空間， <xref:System.Data.DataSet>ReadXml 藉由指定與`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。"
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the ReadXml method is used to fill it with schema and data.  \n  \n [!code-cs[Classic WebData DataSet.ReadXml Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_2_1.cs)]\n [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_2_1.vb)]"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>從中讀取。</xref:System.Xml.XmlReader>"
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref>用來讀取資料。"
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)
  id: ReadXml(System.IO.Stream,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(Stream,XmlReadMode)
  nameWithType: DataSet.ReadXml(Stream,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(Stream,XmlReadMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "讀取 XML 結構描述和資料<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.IO.Stream?displayProperty=fullName&gt;和<xref href=&quot;System.Data.XmlReadMode&quot;> </xref>。"
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法讀取的結構描述。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。       同樣適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要寫入的 XML 資料，或結構描述和資料從`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。      > [!NOTE] > 當您使用 ReadXml，而且您設定<xref:System.Data.XmlReadMode>至`Diffgram`，目標內容`DataSet`和原始`DataSet`可能因為 diffgram 會產生並處理方式不同。</xref:System.Data.XmlReadMode> 如需有關 diffgram 的詳細資訊，請參閱[DiffGrams](~/add/includes/ajax-current-ext-md.md)。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定的內嵌結構描述，則內嵌結構描述會用來擴充現有的關聯式結構載入資料之前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。       如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法透過推斷延伸架構才能公開的所有資料，會引發例外狀況。      > [!NOTE] >`DataSet`不將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法的 XML 字元，例如 (&quot;_&quot;) 在序列化 xml 逸出。 `DataSet`本身只逸出 XML 項目名稱中不合法的 XML 字元，並因此可以只使用相同。 當 XML 項目名稱中的合法字元會逸出時，處理時忽略此元素。       如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`、 可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>xml 程式碼，包含非限定命名空間的項目。</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 若要讀取不合格的項目，設定`elementFormDefault`等於&quot;qualified&quot;中的 XML 結構描述如下列範例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]> 如果的結構描述您<xref:System.Data.DataSet>包含項目嘗試讀取到結構描述時，發生例外狀況的名稱相同，但不同的類型，請在相同的命名空間，<xref:System.Data.DataSet>與<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "<xref:System.IO.Stream>從中讀取。</xref:System.IO.Stream>"
    - id: mode
      type: System.Data.XmlReadMode
      description: "其中一個<xref href=&quot;System.Data.XmlReadMode&quot;></xref>值。"
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref>用來讀取資料。"
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)
  id: ReadXml(System.IO.TextReader,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(TextReader,XmlReadMode)
  nameWithType: DataSet.ReadXml(TextReader,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(TextReader,XmlReadMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "讀取 XML 結構描述和資料<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.IO.TextReader?displayProperty=fullName&gt;和<xref href=&quot;System.Data.XmlReadMode&quot;> </xref>。"
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法讀取的結構描述。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。       請注意，也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要寫入的 XML 資料，或結構描述和資料從`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定的內嵌結構描述，則內嵌結構描述會用來擴充現有的關聯式結構載入資料之前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。       如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法透過推斷延伸架構才能公開的所有資料，會引發例外狀況。      > [!NOTE] >`DataSet`不將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法的 XML 字元，例如 (&quot;_&quot;) 在序列化 xml 逸出。 `DataSet`本身只逸出 XML 項目名稱中不合法的 XML 字元，並因此可以只使用相同。 當 XML 項目名稱中的合法字元會逸出時，處理時忽略此元素。       如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`、 可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>xml 程式碼，包含非限定命名空間的項目。</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 若要讀取不合格的項目，設定`elementFormDefault`等於&quot;qualified&quot;中的 XML 結構描述如下列範例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]> 如果的結構描述您<xref:System.Data.DataSet>包含項目嘗試讀取到結構描述時，發生例外狀況的名稱相同，但不同的類型，請在相同的命名空間，<xref:System.Data.DataSet>與<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref:System.IO.TextReader>從中讀取。</xref:System.IO.TextReader>"
    - id: mode
      type: System.Data.XmlReadMode
      description: "其中一個<xref href=&quot;System.Data.XmlReadMode&quot;></xref>值。"
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref>用來讀取資料。"
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)
  id: ReadXml(System.String,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(String,XmlReadMode)
  nameWithType: DataSet.ReadXml(String,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(String,XmlReadMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "讀取 XML 結構描述和資料<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定的檔案和<xref href=&quot;System.Data.XmlReadMode&quot;> </xref>。"
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法讀取的結構描述。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。       請注意，也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要寫入的 XML 資料，或結構描述和資料從`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定的內嵌結構描述，則內嵌結構描述會用來擴充現有的關聯式結構載入資料之前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。       如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法透過推斷延伸架構才能公開的所有資料，會引發例外狀況。      > [!NOTE] >`DataSet`不將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法的 XML 字元，例如 (&quot;_&quot;) 在序列化 xml 逸出。 `DataSet`本身只逸出 XML 項目名稱中不合法的 XML 字元，並因此可以只使用相同。 當 XML 項目名稱中的合法字元會逸出時，處理時忽略此元素。       如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`、 可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>xml 程式碼，包含非限定命名空間的項目。</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 若要讀取不合格的項目，設定`elementFormDefault`等於&quot;qualified&quot;中的 XML 結構描述如下列範例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]> 如果的結構描述您<xref:System.Data.DataSet>包含項目嘗試讀取到結構描述時，發生例外狀況的名稱相同，但不同的類型，請在相同的命名空間，<xref:System.Data.DataSet>與<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);
    parameters:
    - id: fileName
      type: System.String
      description: "檔案名稱 （包括路徑） 從當中讀取。"
    - id: mode
      type: System.Data.XmlReadMode
      description: "其中一個<xref href=&quot;System.Data.XmlReadMode&quot;></xref>值。"
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref>用來讀取資料。"
  overload: System.Data.DataSet.ReadXml*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>未設定為<xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>。"
  platform:
  - net462
- uid: System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)
  id: ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXml(XmlReader,XmlReadMode)
  nameWithType: DataSet.ReadXml(XmlReader,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(XmlReader,XmlReadMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "讀取 XML 結構描述和資料<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.Xml.XmlReader?displayProperty=fullName&gt;和<xref href=&quot;System.Data.XmlReadMode&quot;> </xref>。"
  remarks: "<xref:System.Data.DataSet.ReadXml%2A>方法來讀取資料，或同時提供資料和結構描述<xref:System.Data.DataSet>從 XML 文件，而<xref:System.Data.DataSet.ReadXmlSchema%2A>方法讀取的結構描述。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> 若要讀取資料和結構描述，請使用其中一種`ReadXML`包含的多載`mode`參數，並將其值設定為`ReadSchema`。       請注意，也適用於<xref:System.Data.DataSet.WriteXml%2A>和<xref:System.Data.DataSet.WriteXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet.WriteXml%2A> 要寫入的 XML 資料，或結構描述和資料從`DataSet`，使用`WriteXml`方法。 若要寫入的結構描述，使用`WriteXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>       如果指定的內嵌結構描述，則內嵌結構描述會用來擴充現有的關聯式結構載入資料之前。 如果有任何衝突 （例如，相同的資料行定義為不同的資料型別相同資料表中） 會引發例外狀況。       如果未不指定任何內嵌結構描述，就會推斷，視需要透過關聯式結構擴充根據 XML 文件的結構。 如果無法透過推斷延伸架構才能公開的所有資料，會引發例外狀況。      > [!NOTE] >`DataSet`不將 XML 項目關聯與其對應`DataColumn`或`DataTable`合法的 XML 字元，例如 (&quot;_&quot;) 在序列化 xml 逸出。 `DataSet`本身只逸出 XML 項目名稱中不合法的 XML 字元，並因此可以只使用相同。 當 XML 項目名稱中的合法字元會逸出時，處理時忽略此元素。       如果 XML 結構描述<xref:System.Data.DataSet>包含`targetNamespace`、 可能不會讀取資料，並呼叫時，您可能會遇到例外狀況<xref:System.Data.DataSet.ReadXml%2A>載入<xref:System.Data.DataSet>xml 程式碼，包含非限定命名空間的項目。</xref:System.Data.DataSet> </xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> 若要讀取不合格的項目，設定`elementFormDefault`等於&quot;qualified&quot;中的 XML 結構描述如下列範例所示。      ```   <xsd:schema id=&quot;MyDataSet&quot;       elementFormDefault=&quot;qualified&quot;       targetNamespace=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns=&quot;http://www.tempuri.org/MyDataSet.xsd&quot;       xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;       xmlns:msdata=&quot;urn:schemas-microsoft-com:xml-msdata&quot;>   </xsd:schema>   ```      > [!NOTE]> 如果的結構描述您<xref:System.Data.DataSet>包含項目嘗試讀取到結構描述時，發生例外狀況的名稱相同，但不同的類型，請在相同的命名空間，<xref:System.Data.DataSet>與<xref:System.Data.DataSet.ReadXml%2A>藉由指定`XmlReadMode.ReadSchema`。</xref:System.Data.DataSet.ReadXml%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。"
  syntax:
    content: public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>從中讀取。</xref:System.Xml.XmlReader>"
    - id: mode
      type: System.Data.XmlReadMode
      description: "其中一個<xref href=&quot;System.Data.XmlReadMode&quot;></xref>值。"
    return:
      type: System.Data.XmlReadMode
      description: "<xref uid=&quot;langword_csharp_XmlReadMode&quot; name=&quot;XmlReadMode&quot; href=&quot;&quot;> </xref>用來讀取資料。"
  overload: System.Data.DataSet.ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSchema(System.IO.Stream)
  id: ReadXmlSchema(System.IO.Stream)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSchema(Stream)
  nameWithType: DataSet.ReadXmlSchema(Stream)
  fullName: System.Data.DataSet.ReadXmlSchema(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "讀取 XML 結構描述從指定<xref:System.IO.Stream>到<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.IO.Stream>"
  remarks: "使用<xref:System.Data.DataSet.ReadXmlSchema%2A>方法來建立<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的結構描述</xref:System.Data.DataSet.ReadXmlSchema%2A> 結構描述包含資料表、 關聯和條件約束的定義。 若要寫入的 XML 文件結構描述，請使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。</xref:System.Data.DataSet.WriteXmlSchema%2A>       使用 XSD 標準寫入 XML 結構描述。      > [!NOTE] > 如果 msdata:DataType 和 xs: type 類型不相符，就可能發生資料損毀。 將會擲不回任何例外狀況。       <xref:System.Data.DataSet.ReadXmlSchema%2A>通常會叫用<xref:System.Data.DataSet.ReadXml%2A>方法用來填滿<xref:System.Data.DataSet>.</xref:System.Data.DataSet></xref:System.Data.DataSet.ReadXml%2A>之前會叫用方法</xref:System.Data.DataSet.ReadXmlSchema%2A>       類別衍生自<xref:System.IO.Stream>類別包含<xref:System.IO.BufferedStream>， <xref:System.IO.FileStream>， <xref:System.IO.MemoryStream>，和<xref:System.Net.Sockets.NetworkStream>。</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.MemoryStream> </xref:System.IO.FileStream> </xref:System.IO.BufferedStream> </xref:System.IO.Stream>      > [!NOTE] > 如果的結構描述您<xref:System.Data.DataSet>包含元素的名稱相同，但相同的命名空間中的不同型別擲回例外狀況是當您嘗試以讀取結構描述<xref:System.Data.DataSet>與<xref:System.Data.DataSet.ReadXmlSchema%2A>.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。"
  example:
  - "The following example creates a <xref:System.IO.FileStream> object to read an XML schema with, and invokes the <xref:System.Data.DataSet.ReadXmlSchema%2A> method with the object.  \n  \n [!code-cs[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_5_1.cs)]\n [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_5_1.vb)]"
  syntax:
    content: public void ReadXmlSchema (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "<xref:System.IO.Stream>從中讀取。</xref:System.IO.Stream>"
  overload: System.Data.DataSet.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)
  id: ReadXmlSchema(System.IO.TextReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSchema(TextReader)
  nameWithType: DataSet.ReadXmlSchema(TextReader)
  fullName: System.Data.DataSet.ReadXmlSchema(TextReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "讀取 XML 結構描述從指定<xref:System.IO.TextReader>到<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.IO.TextReader>"
  remarks: "使用<xref:System.Data.DataSet.ReadXmlSchema%2A>方法來建立<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的結構描述</xref:System.Data.DataSet.ReadXmlSchema%2A> 結構描述包含資料表、 關聯和條件約束的定義。 若要寫入的 XML 文件結構描述，請使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。</xref:System.Data.DataSet.WriteXmlSchema%2A>       使用 XSD 標準寫入 XML 結構描述。      > [!NOTE] > 如果 msdata:DataType 和 xs: type 類型不相符，就可能發生資料損毀。 將會擲不回任何例外狀況。       <xref:System.Data.DataSet.ReadXmlSchema%2A>通常會叫用<xref:System.Data.DataSet.ReadXml%2A>方法用來填滿<xref:System.Data.DataSet>.</xref:System.Data.DataSet></xref:System.Data.DataSet.ReadXml%2A>之前會叫用方法</xref:System.Data.DataSet.ReadXmlSchema%2A>       類別繼承自<xref:System.IO.TextReader>類別包含<xref:System.IO.StreamReader>和<xref:System.IO.StringReader>類別。</xref:System.IO.StringReader> </xref:System.IO.StreamReader> </xref:System.IO.TextReader>      > [!NOTE] > 如果的結構描述您<xref:System.Data.DataSet>包含元素的名稱相同，但相同的命名空間中的不同型別擲回例外狀況是當您嘗試以讀取結構描述<xref:System.Data.DataSet>與<xref:System.Data.DataSet.ReadXmlSchema%2A>.</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。"
  example:
  - "The following example creates a <xref:System.IO.StreamReader> object to read a schema with, and invokes the <xref:System.Data.DataSet.ReadXmlSchema%2A> method with the object.  \n  \n [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_8_1.vb)]\n [!code-cs[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_8_1.cs)]"
  syntax:
    content: public void ReadXmlSchema (System.IO.TextReader reader);
    parameters:
    - id: reader
      type: System.IO.TextReader
      description: "<xref:System.IO.TextReader>從中讀取。</xref:System.IO.TextReader>"
  overload: System.Data.DataSet.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSchema(System.String)
  id: ReadXmlSchema(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSchema(String)
  nameWithType: DataSet.ReadXmlSchema(String)
  fullName: System.Data.DataSet.ReadXmlSchema(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "讀取 XML 結構描述從指定的檔案到<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "使用<xref:System.Data.DataSet.ReadXmlSchema%2A>方法來建立<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的結構描述</xref:System.Data.DataSet.ReadXmlSchema%2A> 結構描述包含資料表、 關聯和條件約束的定義。 若要寫入的 XML 文件結構描述，請使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。</xref:System.Data.DataSet.WriteXmlSchema%2A>       使用 XSD 標準寫入 XML 結構描述。      > [!NOTE] > 如果 msdata:DataType 和 xs: type 類型不相符，就可能發生資料損毀。 將會擲不回任何例外狀況。       <xref:System.Data.DataSet.ReadXmlSchema%2A>通常會叫用<xref:System.Data.DataSet.ReadXml%2A>方法用來填滿<xref:System.Data.DataSet>.</xref:System.Data.DataSet></xref:System.Data.DataSet.ReadXml%2A>之前會叫用方法</xref:System.Data.DataSet.ReadXmlSchema%2A>      > [!NOTE] > 如果的結構描述您<xref:System.Data.DataSet>包含項目嘗試讀取 into <xref:System.Data.DataSet> <xref:System.Data.DataSet.ReadXmlSchema%2A>.</xref:System.Data.DataSet.ReadXmlSchema%2A>與</xref:System.Data.DataSet>結構描述時，發生例外狀況的名稱相同，但不同的類型，請在相同的命名空間，</xref:System.Data.DataSet> 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。"
  example:
  - >-
    [!code-cs[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_0_1.cs)]
     [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_0_1.vb)]
  syntax:
    content: public void ReadXmlSchema (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "檔案名稱 （包括路徑），要從其中讀取。"
  overload: System.Data.DataSet.ReadXmlSchema*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>未設定為<xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>。"
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)
  id: ReadXmlSchema(System.Xml.XmlReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSchema(XmlReader)
  nameWithType: DataSet.ReadXmlSchema(XmlReader)
  fullName: System.Data.DataSet.ReadXmlSchema(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "讀取 XML 結構描述從指定<xref:System.Xml.XmlReader>到<xref href=&quot;System.Data.DataSet&quot;> </xref>。</xref:System.Xml.XmlReader>"
  remarks: "若要建立<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的結構描述使用 ReadXmlSchema 方法 結構描述包含資料表、 關聯和條件約束的定義。       使用 XSD 標準寫入 XML 結構描述。      > [!NOTE] > 如果 msdata:DataType 和 xs: type 類型不相符，就可能發生資料損毀。 將會擲不回任何例外狀況。       ReadXmlSchema 方法一般叫用<xref:System.Data.DataSet.ReadXml%2A>方法用來填滿<xref:System.Data.DataSet>.</xref:System.Data.DataSet></xref:System.Data.DataSet.ReadXml%2A>之前叫用       <xref:System.Xml.XmlReader?displayProperty=fullName>類別是抽象的。</xref:System.Xml.XmlReader?displayProperty=fullName> 類別繼承自`XmlReader`是<xref:System.Xml.XmlTextReader?displayProperty=fullName>類別。</xref:System.Xml.XmlTextReader?displayProperty=fullName>      > [!NOTE] > 如果的結構描述您<xref:System.Data.DataSet>包含元素的名稱相同，但相同的命名空間中的不同型別擲回例外狀況是當您嘗試讀取到結構描述<xref:System.Data.DataSet>與 ReadXmlSchema。</xref:System.Data.DataSet> </xref:System.Data.DataSet> 如果您使用.NET Framework 1.0 版，則不會發生這個例外狀況。"
  example:
  - "The following example creates a new <xref:System.Data.DataSet> and <xref:System.IO.FileStream?displayProperty=fullName> object. The <xref:System.IO.FileStream> object, created with a file path and file name, is used to create an <xref:System.Xml.XmlTextReader?displayProperty=fullName> that is passed as an argument to the ReadXmlSchema method.  \n  \n [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_4_1.vb)]\n [!code-cs[Classic WebData DataSet.ReadXmlSchema Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_4_1.cs)]"
  syntax:
    content: public void ReadXmlSchema (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "<xref:System.Xml.XmlReader>從中讀取。</xref:System.Xml.XmlReader>"
  overload: System.Data.DataSet.ReadXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)
  id: ReadXmlSerializable(System.Xml.XmlReader)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ReadXmlSerializable(XmlReader)
  nameWithType: DataSet.ReadXmlSerializable(XmlReader)
  fullName: System.Data.DataSet.ReadXmlSerializable(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "會忽略屬性，並傳回空的資料集。"
  syntax:
    content: protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "指定的 XML 讀取器。"
  overload: System.Data.DataSet.ReadXmlSerializable*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.RejectChanges
  id: RejectChanges
  parent: System.Data.DataSet
  langs:
  - csharp
  name: RejectChanges()
  nameWithType: DataSet.RejectChanges()
  fullName: System.Data.DataSet.RejectChanges()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "復原對所做的所有變更<xref href=&quot;System.Data.DataSet&quot;></xref>建立，以來或自從上次&lt;xref:System.Data.DataSet.AcceptChanges%2A?displayProperty=fullName&gt;呼叫。"
  remarks: "叫用呼叫的<xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName>方法上所有<xref:System.Data.DataTable>物件包含<xref:System.Data.DataSet>。</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName> RejectChanges       <xref:System.Data.DataRow>所包含之物件<xref:System.Data.DataSet>可每個被設定進入編輯模式下叫用<xref:System.Data.DataRow.BeginEdit%2A?displayProperty=fullName>方法。</xref:System.Data.DataRow.BeginEdit%2A?displayProperty=fullName> </xref:System.Data.DataSet></xref:System.Data.DataRow> 叫用後<xref:System.Data.DataRow.EndEdit%2A?displayProperty=fullName>方法，可以藉由呼叫拒絕變更<xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName>上<xref:System.Data.DataTable>要<xref:System.Data.DataRow>物件屬於。</xref:System.Data.DataRow> </xref:System.Data.DataTable> </xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName> </xref:System.Data.DataRow.EndEdit%2A?displayProperty=fullName>       當<xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName>呼叫方法時，仍在編輯模式中的任何資料列取消編輯。</xref:System.Data.DataTable.RejectChanges%2A?displayProperty=fullName> 新的資料列被移除。 修改和刪除資料列會傳回至其原始狀態 (`DataRowState.Unchanged`)。       AcceptChanges 和 RejectChanges 只會套用到<xref:System.Data.DataRow>相關的變更 (亦即`Add`， `Remove`， `Delete`，和`Modify`)。</xref:System.Data.DataRow> 它們並不適用於結構描述或結構化變更。"
  example:
  - "The following example shows a class derived from the <xref:System.Data.DataSet> class. The RejectChanges event is invoked from within a function.  \n  \n [!code-cs[Classic WebData DataSet.RejectChanges Example#1](~/add/codesnippet/csharp/m-system.data.dataset.re_6_1.cs)]\n [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.re_6_1.vb)]"
  syntax:
    content: public virtual void RejectChanges ();
    parameters: []
  overload: System.Data.DataSet.RejectChanges*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Relations
  id: Relations
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Relations
  nameWithType: DataSet.Relations
  fullName: System.Data.DataSet.Relations
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得連結資料表，並可瀏覽，從父資料表到子資料表之關聯的集合。"
  remarks: ''
  example:
  - "The following example prints the column name of all child tables through the Relations property.  \n  \n [!code-vb[Classic WebData DataSet.Relations Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.re_1.vb)]"
  syntax:
    content: public System.Data.DataRelationCollection Relations { get; }
    return:
      type: System.Data.DataRelationCollection
      description: "A <xref href=&quot;System.Data.DataRelationCollection&quot;> </xref> ，其中包含的集合<xref href=&quot;System.Data.DataRelation&quot;></xref>物件。 如果沒有傳回空的集合，則<xref href=&quot;System.Data.DataRelation&quot;></xref>物件存在。"
  overload: System.Data.DataSet.Relations*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.RemotingFormat
  id: RemotingFormat
  parent: System.Data.DataSet
  langs:
  - csharp
  name: RemotingFormat
  nameWithType: DataSet.RemotingFormat
  fullName: System.Data.DataSet.RemotingFormat
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得或設定<xref href=&quot;System.Data.SerializationFormat&quot;></xref>如<xref href=&quot;System.Data.DataSet&quot;></xref>遠端處理期間使用。"
  syntax:
    content: public System.Data.SerializationFormat RemotingFormat { get; set; }
    return:
      type: System.Data.SerializationFormat
      description: "A <xref href=&quot;System.Data.SerializationFormat&quot;></xref> object."
  overload: System.Data.DataSet.RemotingFormat*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Reset
  id: Reset
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Reset()
  nameWithType: DataSet.Reset()
  fullName: System.Data.DataSet.Reset()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "清除所有資料表，並移除所有關聯性、 外部索引的條件約束和來自資料表<xref href=&quot;System.Data.DataSet&quot;> </xref>。 子類別應該覆寫重設為還原<xref href=&quot;System.Data.DataSet&quot;></xref>為其原始狀態。"
  syntax:
    content: public virtual void Reset ();
    parameters: []
  overload: System.Data.DataSet.Reset*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.SchemaSerializationMode
  id: SchemaSerializationMode
  parent: System.Data.DataSet
  langs:
  - csharp
  name: SchemaSerializationMode
  nameWithType: DataSet.SchemaSerializationMode
  fullName: System.Data.DataSet.SchemaSerializationMode
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "Gets or sets a <xref href=&quot;System.Data.SchemaSerializationMode&quot;></xref> for a <xref href=&quot;System.Data.DataSet&quot;></xref>."
  remarks: "A <xref:System.Data.DataSet>Web 服務和遠端處理案例中，預設序列化其結構描述和執行個體資料。</xref:System.Data.DataSet> 具類型的 SchemaSerializationMode 屬性設定`DataSet`至<xref:System.Data.SchemaSerializationMode>會導致序列化裝載要排除的結構描述資訊。</xref:System.Data.SchemaSerializationMode>       <xref:System.Data.SchemaSerializationMode>支援僅針對具型別的`DataSet`。</xref:System.Data.SchemaSerializationMode> 針對不具型別的`DataSet`這個屬性只能設定為<xref:System.Data.SchemaSerializationMode>。</xref:System.Data.SchemaSerializationMode>       <xref:System.Data.SchemaSerializationMode>應該只用於在其中具類型的基礎結構描述資訊的情況下`DataTables`，`DataRelations`和`Constraints`尚未修改。</xref:System.Data.SchemaSerializationMode> 如果需要修改應該以<xref:System.Data.SchemaSerializationMode>.</xref:System.Data.SchemaSerializationMode>序列化發生、 完整的結構描述資訊       <xref:System.Data.SchemaSerializationMode>支援 2.0 版的.NET framework 或更新版本。</xref:System.Data.SchemaSerializationMode>       當<xref:System.Data.SchemaSerializationMode>設定，只有最上層的層級執行階段屬性上有<xref:System.Data.DataSet>會序列化。</xref:System.Data.DataSet> </xref:System.Data.SchemaSerializationMode> 此外，它們會序列化才發生不同的預設值。 沒有任何`Tables`，`Relations`或`Constraints`會序列化。 序列化的執行階段屬性包括<xref:System.Data.DataSet.DataSetName%2A>， <xref:System.Data.DataSet.Namespace%2A>， <xref:System.Data.DataSet.Prefix%2A>， <xref:System.Data.DataSet.Locale%2A>， <xref:System.Data.DataSet.EnforceConstraints%2A>，和<xref:System.Data.DataSet.CaseSensitive%2A>。</xref:System.Data.DataSet.CaseSensitive%2A> </xref:System.Data.DataSet.EnforceConstraints%2A> </xref:System.Data.DataSet.Locale%2A> </xref:System.Data.DataSet.Prefix%2A> </xref:System.Data.DataSet.Namespace%2A> </xref:System.Data.DataSet.DataSetName%2A> 這些屬性會序列化以確定會保留整體的執行階段資料的完整性。"
  syntax:
    content: public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }
    return:
      type: System.Data.SchemaSerializationMode
      description: "Gets or sets a <xref href=&quot;System.Data.SchemaSerializationMode&quot;></xref> for a <xref href=&quot;System.Data.DataSet&quot;></xref>."
  overload: System.Data.DataSet.SchemaSerializationMode*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ShouldSerializeRelations
  id: ShouldSerializeRelations
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ShouldSerializeRelations()
  nameWithType: DataSet.ShouldSerializeRelations()
  fullName: System.Data.DataSet.ShouldSerializeRelations()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得值，指出是否<xref:System.Data.DataSet.Relations*>屬性必須永續性。</xref:System.Data.DataSet.Relations*>"
  remarks: "您通常使用這個方法，如果您要建立的設計工具<xref:System.Data.DataSet>，或建立您自己的控制項加入<xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet>"
  example:
  - "The following examples show a class derived from the <xref:System.Data.DataSet> class. The <xref:System.Data.DataSet.Reset%2A> and ShouldSerializeRelations methods are invoked from within functions in the derived class.  \n  \n [!code-cs[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/add/codesnippet/csharp/m-system.data.dataset.sh_3_1.cs)]\n [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.sh_3_1.vb)]"
  syntax:
    content: protected virtual bool ShouldSerializeRelations ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果屬性值已變更其預設值。否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.ShouldSerializeRelations*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.ShouldSerializeTables
  id: ShouldSerializeTables
  parent: System.Data.DataSet
  langs:
  - csharp
  name: ShouldSerializeTables()
  nameWithType: DataSet.ShouldSerializeTables()
  fullName: System.Data.DataSet.ShouldSerializeTables()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得值，指出是否<xref:System.Data.DataSet.Tables*>屬性必須永續性。</xref:System.Data.DataSet.Tables*>"
  remarks: "您通常使用這個方法，您可能想要建立的設計工具時，才<xref:System.Data.DataSet>，或建立您自己的控制項加入<xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet>"
  example:
  - "The following example shows a class derived from the <xref:System.Data.DataSet> class. The ShouldSerializeTables method is called from within functions in the derived class.  \n  \n [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.sh_2_1.vb)]\n [!code-cs[Classic WebData DataSet.ShouldSerializeTables Example#1](~/add/codesnippet/csharp/m-system.data.dataset.sh_2_1.cs)]"
  syntax:
    content: protected virtual bool ShouldSerializeTables ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果屬性值已變更其預設值。否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.DataSet.ShouldSerializeTables*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Site
  id: Site
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Site
  nameWithType: DataSet.Site
  fullName: System.Data.DataSet.Site
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得或設定<xref href=&quot;System.ComponentModel.ISite&quot;></xref>如<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "站台繫結<xref:System.ComponentModel.Component>至<xref:System.ComponentModel.Container>和啟用它們之間的通訊，以及提供的方式管理其元件的容器。</xref:System.ComponentModel.Container> </xref:System.ComponentModel.Component>"
  syntax:
    content: public override System.ComponentModel.ISite Site { get; set; }
    return:
      type: System.ComponentModel.ISite
      description: "An <xref href=&quot;System.ComponentModel.ISite&quot;></xref> for the <xref href=&quot;System.Data.DataSet&quot;></xref>."
  overload: System.Data.DataSet.Site*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection
  id: System#ComponentModel#IListSource#ContainsListCollection
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataSet.System.ComponentModel.IListSource.ContainsListCollection
  fullName: System.Data.DataSet.System.ComponentModel.IListSource.ContainsListCollection
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "如需這個成員的說明，請參閱&lt;xref:System.ComponentModel.IListSource.ContainsListCollection%2A?displayProperty=fullName&gt;。"
  remarks: "這個成員是明確介面成員實作。 它可用時，才<xref:System.Data.DataSet>執行個體轉換成<xref:System.ComponentModel.IListSource>介面。</xref:System.ComponentModel.IListSource> </xref:System.Data.DataSet>"
  syntax:
    content: bool System.ComponentModel.IListSource.ContainsListCollection { get; }
    return:
      type: System.Boolean
      description: "如需這個成員的說明，請參閱&lt;xref:System.ComponentModel.IListSource.ContainsListCollection%2A?displayProperty=fullName&gt;。"
  overload: System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#ComponentModel#IListSource#GetList
  id: System#ComponentModel#IListSource#GetList
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.ComponentModel.IListSource.GetList()
  nameWithType: DataSet.System.ComponentModel.IListSource.GetList()
  fullName: System.Data.DataSet.System.ComponentModel.IListSource.GetList()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "如需這個成員的說明，請參閱&lt;xref:System.ComponentModel.IListSource.GetList%2A?displayProperty=fullName&gt;。"
  remarks: "這個成員是明確介面成員實作。 它可用時，才<xref:System.Data.DataSet>執行個體轉換成<xref:System.ComponentModel.IListSource>介面。</xref:System.ComponentModel.IListSource> </xref:System.Data.DataSet>"
  syntax:
    content: System.Collections.IList IListSource.GetList ();
    parameters: []
    return:
      type: System.Collections.IList
      description: "如需這個成員的說明，請參閱&lt;xref:System.ComponentModel.IListSource.GetList%2A?displayProperty=fullName&gt;。"
  overload: System.Data.DataSet.System#ComponentModel#IListSource#GetList*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema
  id: System#Xml#Serialization#IXmlSerializable#GetSchema
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.GetSchema()
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema()
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "如需這個成員的說明，請參閱&lt;xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A?displayProperty=fullName&gt;。"
  remarks: "這個成員是明確介面成員實作。 它可用時，才<xref:System.Data.DataSet>執行個體轉換成<xref:System.Xml.Serialization.IXmlSerializable>介面。</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();
    parameters: []
    return:
      type: System.Xml.Schema.XmlSchema
      description: "如需這個成員的說明，請參閱&lt;xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A?displayProperty=fullName&gt;。"
  overload: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  id: System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "如需這個成員的說明，請參閱&lt;xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A?displayProperty=fullName&gt;。"
  remarks: "這個成員是明確介面成員實作。 它可用時，才<xref:System.Data.DataSet>執行個體轉換成<xref:System.Xml.Serialization.IXmlSerializable>介面。</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "A <xref:System.Xml.XmlReader>.</xref:System.Xml.XmlReader>"
  overload: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  id: System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  isEii: true
  parent: System.Data.DataSet
  langs:
  - csharp
  name: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "如需這個成員的說明，請參閱&lt;xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A?displayProperty=fullName&gt;。"
  remarks: "這個成員是明確介面成員實作。 它可用時，才<xref:System.Data.DataSet>執行個體轉換成<xref:System.Xml.Serialization.IXmlSerializable>介面。</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Data.DataSet>"
  syntax:
    content: void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "A <xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter>"
  overload: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.Tables
  id: Tables
  parent: System.Data.DataSet
  langs:
  - csharp
  name: Tables
  nameWithType: DataSet.Tables
  fullName: System.Data.DataSet.Tables
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "取得集合中包含的資料表<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "若要將資料表加入至集合，使用<xref:System.Data.DataTableCollection.Add%2A><xref:System.Data.DataTableCollection>.</xref:System.Data.DataTableCollection>方法</xref:System.Data.DataTableCollection.Add%2A> 若要移除資料表，請使用<xref:System.Data.DataTableCollection.Remove%2A>方法。</xref:System.Data.DataTableCollection.Remove%2A>"
  example:
  - "The following example returns the <xref:System.Data.DataSet> object's <xref:System.Data.DataTableCollection>, and prints the columns and rows in each table.  \n  \n [!code-vb[Classic WebData DataSet.Tables Example#1](~/add/codesnippet/visualbasic/p-system.data.dataset.ta_1.vb)]\n [!code-cs[Classic WebData DataSet.Tables Example#1](~/add/codesnippet/csharp/p-system.data.dataset.ta_1.cs)]"
  syntax:
    content: public System.Data.DataTableCollection Tables { get; }
    return:
      type: System.Data.DataTableCollection
      description: "<xref href=&quot;System.Data.DataTableCollection&quot;> </xref>包含由此<xref href=&quot;System.Data.DataSet&quot;> </xref>。 如果沒有傳回空的集合，則<xref href=&quot;System.Data.DataTable&quot;></xref>物件存在。"
  overload: System.Data.DataSet.Tables*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.IO.Stream)
  id: WriteXml(System.IO.Stream)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(Stream)
  nameWithType: DataSet.WriteXml(Stream)
  fullName: System.Data.DataSet.WriteXml(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "將目前的資料寫入<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.IO.Stream?displayProperty=fullName&gt;。"
  remarks: "`WriteXml`方法提供的方式寫入資料，或同時資料和結構描述從<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會寫入的結構描述。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 寫入資料和結構描述，請使用其中一個多載，其中包含`mode`參數，並將其值設定為`WriteSchema`。       請注意，也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 讀取 XML 資料，或結構描述和資料`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  example:
  - "The following example creates a <xref:System.IO.FileStream?displayProperty=fullName> object. The object is then used with the WriteXml method to write an XML document.  \n  \n [!code-cs[Classic WebData DataSet.WriteXml Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_2_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_2_1.vb)]"
  syntax:
    content: public void WriteXml (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>物件，用來寫入至檔案。</xref:System.IO.Stream>"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.IO.TextWriter)
  id: WriteXml(System.IO.TextWriter)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(TextWriter)
  nameWithType: DataSet.WriteXml(TextWriter)
  fullName: System.Data.DataSet.WriteXml(TextWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "將目前的資料寫入<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定的<xref:System.IO.TextWriter>.</xref:System.IO.TextWriter>"
  remarks: "`WriteXml`方法提供的方式寫入資料，或同時資料和結構描述從<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會寫入的結構描述。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 寫入資料和結構描述，請使用其中一個多載，其中包含`mode`參數，並將其值設定為`WriteSchema`。       請注意，也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 讀取 XML 資料，或結構描述和資料`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.TextWriter writer);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>用來寫入的物件。</xref:System.IO.TextWriter>"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.String)
  id: WriteXml(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(String)
  nameWithType: DataSet.WriteXml(String)
  fullName: System.Data.DataSet.WriteXml(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "將目前的資料寫入<xref href=&quot;System.Data.DataSet&quot;></xref>至指定的檔案。"
  remarks: "`WriteXml`方法提供的方式寫入資料，或同時資料和結構描述從<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會寫入的結構描述。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 寫入資料和結構描述，請使用其中一個多載，其中包含`mode`參數，並將其值設定為`WriteSchema`。       請注意，也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 讀取 XML 資料，或結構描述和資料`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "檔案名稱 （包括路徑） 寫入。"
  overload: System.Data.DataSet.WriteXml*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>未設定為<xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>。"
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.Xml.XmlWriter)
  id: WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(XmlWriter)
  nameWithType: DataSet.WriteXml(XmlWriter)
  fullName: System.Data.DataSet.WriteXml(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "將目前的資料寫入<xref href=&quot;System.Data.DataSet&quot;></xref>至指定<xref:System.Xml.XmlWriter>。</xref:System.Xml.XmlWriter>"
  remarks: "`WriteXml`方法提供的方式寫入資料，或同時資料和結構描述從<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會寫入的結構描述。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 寫入資料和結構描述，請使用其中一個多載，其中包含`mode`參數，並將其值設定為`WriteSchema`。       請注意，也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 讀取 XML 資料，或結構描述和資料`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>用來寫入。</xref:System.Xml.XmlWriter>"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  id: WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(Stream,XmlWriteMode)
  nameWithType: DataSet.WriteXml(Stream,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(Stream,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "寫入目前的資料，以及選擇性結構描述，如<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定&lt;xref:System.IO.Stream?displayProperty=fullName&gt;和<xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>。 若要撰寫結構描述，設定的值<code> mode </code>參數<xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>。"
  remarks: "`WriteXml`方法提供的方式寫入資料，或同時資料和結構描述從<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會寫入的結構描述。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 若要撰寫資料和結構描述，設定`mode`參數`WriteSchema`。       請注意，也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 讀取 XML 資料，或結構描述和資料`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  syntax:
    content: public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>物件，用來寫入至檔案。</xref:System.IO.Stream>"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "其中一個<xref href=&quot;System.Data.XmlWriteMode&quot;></xref>值。"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  id: WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(TextWriter,XmlWriteMode)
  nameWithType: DataSet.WriteXml(TextWriter,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(TextWriter,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "寫入目前的資料，以及選擇性結構描述，如<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定<xref:System.IO.TextWriter>和<xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>。</xref:System.IO.TextWriter> 若要撰寫結構描述，設定的值<code> mode </code>參數<xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>。"
  remarks: "`WriteXml`方法提供的方式寫入資料，或同時資料和結構描述從<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會寫入的結構描述。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 若要撰寫資料和結構描述，設定`mode`參數`WriteSchema`。       請注意，也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 讀取 XML 資料，或結構描述和資料`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  example:
  - "The following example first creates a simple <xref:System.Data.DataSet> with one <xref:System.Data.DataTable>, two columns, and ten rows. The <xref:System.Data.DataSet> schema and data are written to disk by invoking the <xref:System.Data.DataSet.WriteXml%2A> method. A second <xref:System.Data.DataSet> is created and the <xref:System.Data.DataSet.ReadXml%2A> method is used to fill it with schema and data.  \n  \n [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_7_1.vb)]\n [!code-cs[Classic WebData DataSet.ReadXml2 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_7_1.cs)]"
  syntax:
    content: public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "A &lt;xref:System.IO.TextWriter?displayProperty=fullName&gt;用來撰寫的文件物件。"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "其中一個<xref href=&quot;System.Data.XmlWriteMode&quot;></xref>值。"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)
  id: WriteXml(System.String,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(String,XmlWriteMode)
  nameWithType: DataSet.WriteXml(String,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(String,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "寫入目前的資料，以及選擇性結構描述，如<xref href=&quot;System.Data.DataSet&quot;></xref>至指定的檔案使用指定<xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>。 若要撰寫結構描述，設定的值<code> mode </code>參數<xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>。"
  remarks: "`WriteXml`方法提供的方式寫入資料，或同時資料和結構描述從<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會寫入的結構描述。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 若要撰寫資料和結構描述，設定`mode`參數`WriteSchema`。       請注意，也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 讀取 XML 資料，或結構描述和資料`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  example:
  - "The following example uses the <xref:System.Data.DataSet.WriteXml%2A> method to write an XML document.  \n  \n [!code-cs[Classic WebData DataSet.WriteXml7 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_3_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_3_1.vb)]"
  syntax:
    content: public void WriteXml (string fileName, System.Data.XmlWriteMode mode);
    parameters:
    - id: fileName
      type: System.String
      description: "檔案名稱 （包括路徑） 寫入。"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "其中一個<xref href=&quot;System.Data.XmlWriteMode&quot;></xref>值。"
  overload: System.Data.DataSet.WriteXml*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>未設定為<xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>。"
  platform:
  - net462
- uid: System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  id: WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXml(XmlWriter,XmlWriteMode)
  nameWithType: DataSet.WriteXml(XmlWriter,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(XmlWriter,XmlWriteMode)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "寫入目前的資料，以及選擇性結構描述，如<xref href=&quot;System.Data.DataSet&quot;></xref>使用指定<xref:System.Xml.XmlWriter>和<xref href=&quot;System.Data.XmlWriteMode&quot;> </xref>。</xref:System.Xml.XmlWriter> 若要撰寫結構描述，設定的值<code> mode </code>參數<xref uid=&quot;langword_csharp_WriteSchema&quot; name=&quot;WriteSchema&quot; href=&quot;&quot;> </xref>。"
  remarks: "`WriteXml`方法提供的方式寫入資料，或同時資料和結構描述從<xref:System.Data.DataSet>XML 文件，而<xref:System.Data.DataSet.WriteXmlSchema%2A>方法會寫入的結構描述。</xref:System.Data.DataSet.WriteXmlSchema%2A> </xref:System.Data.DataSet> 若要撰寫資料和結構描述，設定`mode`參數`WriteSchema`。       請注意，也適用於<xref:System.Data.DataSet.ReadXml%2A>和<xref:System.Data.DataSet.ReadXmlSchema%2A>方法，分別。</xref:System.Data.DataSet.ReadXmlSchema%2A> </xref:System.Data.DataSet.ReadXml%2A> 讀取 XML 資料，或結構描述和資料`DataSet`，使用`ReadXml`方法。 若要讀取的結構描述，使用`ReadXmlSchema`方法。      > [!NOTE] ><xref:System.InvalidOperationException>會擲回的資料行類型`DataRow`正在讀取或寫入實作<xref:System.Dynamic.IDynamicMetaObjectProvider>，但未實作<xref:System.Xml.Serialization.IXmlSerializable>.</xref:System.Xml.Serialization.IXmlSerializable> </xref:System.Dynamic.IDynamicMetaObjectProvider> </xref:System.InvalidOperationException>"
  example:
  - "The following example creates a <xref:System.IO.FileStream?displayProperty=fullName> object that is used to create a new <xref:System.Xml.XmlTextWriter?displayProperty=fullName>. The <xref:System.Xml.XmlTextWriter> object is used with the <xref:System.Data.DataSet.WriteXml%2A> method to write an XML document.  \n  \n [!code-cs[Classic WebData DataSet.WriteXml6 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_1_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_1_1.vb)]"
  syntax:
    content: public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>用來寫入。</xref:System.Xml.XmlWriter>"
    - id: mode
      type: System.Data.XmlWriteMode
      description: "其中一個<xref href=&quot;System.Data.XmlWriteMode&quot;></xref>值。"
  overload: System.Data.DataSet.WriteXml*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.Stream)
  id: WriteXmlSchema(System.IO.Stream)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(Stream)
  nameWithType: DataSet.WriteXmlSchema(Stream)
  fullName: System.Data.DataSet.WriteXmlSchema(Stream)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "寫入<xref href=&quot;System.Data.DataSet&quot;></xref>到指定的 XML 結構描述的結構&lt;xref:System.IO.Stream?displayProperty=fullName&gt;物件。"
  remarks: "要寫入的結構描述使用 WriteXmlSchema 方法<xref:System.Data.DataSet>XML 文件。</xref:System.Data.DataSet> 結構描述包含資料表、 關聯和條件約束的定義。 若要寫入的 XML 文件結構描述，請使用 WriteXmlSchema 方法。       使用 XSD 標準寫入 XML 結構描述。       若要將資料寫入 XML 文件中，使用<xref:System.Data.DataSet.WriteXml%2A>方法。</xref:System.Data.DataSet.WriteXml%2A>       類別衍生自<xref:System.IO.Stream>類別包含<xref:System.IO.BufferedStream>， <xref:System.IO.FileStream>， <xref:System.IO.MemoryStream>，和<xref:System.Net.Sockets.NetworkStream>。</xref:System.Net.Sockets.NetworkStream> </xref:System.IO.MemoryStream> </xref:System.IO.FileStream> </xref:System.IO.BufferedStream> </xref:System.IO.Stream>"
  example:
  - "The following example creates a new <xref:System.IO.FileStream> object that is passed to the WriteXmlSchema method to write the schema to disk.  \n  \n [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_6_1.vb)]\n [!code-cs[Classic WebData DataSet.WriteXmlSchema Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_6_1.cs)]"
  syntax:
    content: public void WriteXmlSchema (System.IO.Stream stream);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "A<xref:System.IO.Stream>物件，用來寫入至檔案。</xref:System.IO.Stream>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)
  id: WriteXmlSchema(System.IO.TextWriter)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(TextWriter)
  nameWithType: DataSet.WriteXmlSchema(TextWriter)
  fullName: System.Data.DataSet.WriteXmlSchema(TextWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "寫入<xref href=&quot;System.Data.DataSet&quot;></xref>到指定的 XML 結構描述的結構<xref:System.IO.TextWriter>物件。</xref:System.IO.TextWriter>"
  remarks: "使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法來寫入的結構描述<xref:System.Data.DataSet>XML 文件。</xref:System.Data.DataSet> </xref:System.Data.DataSet.WriteXmlSchema%2A> 結構描述包含資料表、 關聯和條件約束的定義。 若要寫入的 XML 文件結構描述，請使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。</xref:System.Data.DataSet.WriteXmlSchema%2A>       使用 XSD 標準寫入 XML 結構描述。       若要將資料寫入 XML 文件中，使用<xref:System.Data.DataSet.WriteXml%2A>方法。</xref:System.Data.DataSet.WriteXml%2A>       類別和從其中衍生<xref:System.IO.TextWriter?displayProperty=fullName>類別包含<xref:System.Web.HttpWriter?displayProperty=fullName>， <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=fullName>， <xref:System.Web.UI.HtmlTextWriter?displayProperty=fullName>， <xref:System.IO.StreamWriter?displayProperty=fullName>，和<xref:System.IO.StringWriter?displayProperty=fullName>。</xref:System.IO.StringWriter?displayProperty=fullName> </xref:System.IO.StreamWriter?displayProperty=fullName> </xref:System.Web.UI.HtmlTextWriter?displayProperty=fullName> </xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=fullName> </xref:System.Web.HttpWriter?displayProperty=fullName> </xref:System.IO.TextWriter?displayProperty=fullName>"
  example:
  - "The following example creates a <xref:System.Text.StringBuilder?displayProperty=fullName> object to that is used to create a new <xref:System.IO.StringWriter?displayProperty=fullName>. The <xref:System.IO.StringWriter> is passed to the <xref:System.Data.DataSet.WriteXmlSchema%2A> method, and the resulting string is printed to the console window.  \n  \n [!code-cs[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_0_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_0_1.vb)]"
  syntax:
    content: public void WriteXmlSchema (System.IO.TextWriter writer);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "<xref:System.IO.TextWriter>用來寫入的物件。</xref:System.IO.TextWriter>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.String)
  id: WriteXmlSchema(System.String)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(String)
  nameWithType: DataSet.WriteXmlSchema(String)
  fullName: System.Data.DataSet.WriteXmlSchema(String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "寫入<xref href=&quot;System.Data.DataSet&quot;></xref>與 XML 結構描述檔案的結構。"
  remarks: "使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法來寫入的結構描述<xref:System.Data.DataSet>XML 文件。</xref:System.Data.DataSet> </xref:System.Data.DataSet.WriteXmlSchema%2A> 結構描述包含資料表、 關聯和條件約束的定義。 若要寫入的 XML 文件結構描述，請使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。</xref:System.Data.DataSet.WriteXmlSchema%2A>       使用 XSD 標準寫入 XML 結構描述。       若要將資料寫入 XML 文件中，使用<xref:System.Data.DataSet.WriteXml%2A>方法。</xref:System.Data.DataSet.WriteXml%2A>"
  example:
  - >-
    [!code-cs[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_4_1.cs)]
     [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_4_1.vb)]
  syntax:
    content: public void WriteXmlSchema (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "檔案名稱 （包括路徑） 寫入。"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "<xref href=&quot;System.Security.Permissions.FileIOPermission&quot;></xref>未設定為<xref href=&quot;System.Security.Permissions.FileIOPermissionAccess&quot;> </xref>。"
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)
  id: WriteXmlSchema(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(XmlWriter)
  nameWithType: DataSet.WriteXmlSchema(XmlWriter)
  fullName: System.Data.DataSet.WriteXmlSchema(XmlWriter)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "寫入<xref href=&quot;System.Data.DataSet&quot;></xref>與 XML 結構描述結構<xref:System.Xml.XmlWriter>物件。</xref:System.Xml.XmlWriter>"
  remarks: "使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法來寫入的結構描述<xref:System.Data.DataSet>XML 文件。</xref:System.Data.DataSet> </xref:System.Data.DataSet.WriteXmlSchema%2A> 結構描述包含資料表、 關聯和條件約束的定義。 若要寫入的 XML 文件結構描述，請使用<xref:System.Data.DataSet.WriteXmlSchema%2A>方法。</xref:System.Data.DataSet.WriteXmlSchema%2A>       使用 XSD 標準寫入 XML 結構描述。       若要將資料寫入 XML 文件中，使用<xref:System.Data.DataSet.WriteXml%2A>方法。</xref:System.Data.DataSet.WriteXml%2A>       一個類別繼承自的<xref:System.Xml.XmlWriter?displayProperty=fullName>類別是<xref:System.Xml.XmlTextWriter?displayProperty=fullName>類別。</xref:System.Xml.XmlTextWriter?displayProperty=fullName> </xref:System.Xml.XmlWriter?displayProperty=fullName>"
  example:
  - "The following example creates a new <xref:System.IO.FileStream?displayProperty=fullName> object with the specified path. The <xref:System.IO.FileStream> object is used to create an <xref:System.Xml.XMLTextWriter?displayProperty=fullName> object. The <xref:System.Data.DataSet.WriteXmlSchema%2A> method is then invoked with the <xref:System.Xml.XmlTextWriter> object to write the schema to the disk.  \n  \n [!code-cs[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/add/codesnippet/csharp/m-system.data.dataset.wr_5_1.cs)]\n [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/add/codesnippet/visualbasic/m-system.data.dataset.wr_5_1.vb)]"
  syntax:
    content: public void WriteXmlSchema (System.Xml.XmlWriter writer);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "<xref:System.Xml.XmlWriter>寫入。</xref:System.Xml.XmlWriter>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})
  id: WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(Stream,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(Stream,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(Stream,Converter<Type,String>)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "寫入<xref href=&quot;System.Data.DataSet&quot;></xref>到指定的 XML 結構描述的結構&lt;xref:System.IO.Stream?displayProperty=fullName&gt;物件。"
  syntax:
    content: public void WriteXmlSchema (System.IO.Stream stream, Converter<Type,string> multipleTargetConverter);
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "A &lt;xref:System.IO.Stream?displayProperty=fullName&gt;来寫入的物件。"
    - id: multipleTargetConverter
      type: System.Converter{System.Type,System.String}
      description: "委派，用來將轉換<xref:System.Type>字串。</xref:System.Type>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})
  id: WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(TextWriter,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(TextWriter,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(TextWriter,Converter<Type,String>)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "寫入<xref href=&quot;System.Data.DataSet&quot;></xref>指定<xref:System.IO.TextWriter>.</xref:System.IO.TextWriter>將 XML 結構描述的結構"
  syntax:
    content: public void WriteXmlSchema (System.IO.TextWriter writer, Converter<Type,string> multipleTargetConverter);
    parameters:
    - id: writer
      type: System.IO.TextWriter
      description: "A<xref:System.IO.TextWriter>要寫入的物件。</xref:System.IO.TextWriter>"
    - id: multipleTargetConverter
      type: System.Converter{System.Type,System.String}
      description: "委派，用來將轉換<xref:System.Type>字串。</xref:System.Type>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})
  id: WriteXmlSchema(System.String,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(String,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(String,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(String,Converter<Type,String>)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "寫入<xref href=&quot;System.Data.DataSet&quot;></xref>與 XML 結構描述檔案的結構。"
  syntax:
    content: public void WriteXmlSchema (string fileName, Converter<Type,string> multipleTargetConverter);
    parameters:
    - id: fileName
      type: System.String
      description: "要寫入檔案的名稱。"
    - id: multipleTargetConverter
      type: System.Converter{System.Type,System.String}
      description: "委派，用來將轉換<xref:System.Type>字串。</xref:System.Type>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})
  id: WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  langs:
  - csharp
  name: WriteXmlSchema(XmlWriter,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(XmlWriter,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(XmlWriter,Converter<Type,String>)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data
  summary: "寫入<xref href=&quot;System.Data.DataSet&quot;></xref>指定<xref:System.Xml.XmlWriter>.</xref:System.Xml.XmlWriter>將 XML 結構描述的結構"
  syntax:
    content: public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter<Type,string> multipleTargetConverter);
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "A<xref:System.Xml.XmlWriter>要寫入的物件。</xref:System.Xml.XmlWriter>"
    - id: multipleTargetConverter
      type: System.Converter{System.Type,System.String}
      description: "委派，用來將轉換<xref:System.Type>字串。</xref:System.Type>"
  overload: System.Data.DataSet.WriteXmlSchema*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.MarshalByValueComponent
  isExternal: false
  name: System.ComponentModel.MarshalByValueComponent
- uid: System.Data.ConstraintException
  parent: System.Data
  isExternal: false
  name: ConstraintException
  nameWithType: ConstraintException
  fullName: System.Data.ConstraintException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Data.DataSet.#ctor
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet()
  nameWithType: DataSet.DataSet()
  fullName: System.Data.DataSet.DataSet()
- uid: System.Data.DataSet.#ctor(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet(String)
  nameWithType: DataSet.DataSet(String)
  fullName: System.Data.DataSet.DataSet(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet(SerializationInfo,StreamingContext)
  nameWithType: DataSet.DataSet(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.DataSet(SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet(SerializationInfo,StreamingContext,Boolean)
  nameWithType: DataSet.DataSet(SerializationInfo,StreamingContext,Boolean)
  fullName: System.Data.DataSet.DataSet(SerializationInfo,StreamingContext,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Data.DataSet.AcceptChanges
  parent: System.Data.DataSet
  isExternal: false
  name: AcceptChanges()
  nameWithType: DataSet.AcceptChanges()
  fullName: System.Data.DataSet.AcceptChanges()
- uid: System.Data.DataSet.BeginInit
  parent: System.Data.DataSet
  isExternal: false
  name: BeginInit()
  nameWithType: DataSet.BeginInit()
  fullName: System.Data.DataSet.BeginInit()
- uid: System.Data.DataSet.CaseSensitive
  parent: System.Data.DataSet
  isExternal: false
  name: CaseSensitive
  nameWithType: DataSet.CaseSensitive
  fullName: System.Data.DataSet.CaseSensitive
- uid: System.Data.DataSet.Clear
  parent: System.Data.DataSet
  isExternal: false
  name: Clear()
  nameWithType: DataSet.Clear()
  fullName: System.Data.DataSet.Clear()
- uid: System.Data.DataSet.Clone
  parent: System.Data.DataSet
  isExternal: false
  name: Clone()
  nameWithType: DataSet.Clone()
  fullName: System.Data.DataSet.Clone()
- uid: System.Data.DataSet
  parent: System.Data
  isExternal: false
  name: DataSet
  nameWithType: DataSet
  fullName: System.Data.DataSet
- uid: System.Data.DataSet.Copy
  parent: System.Data.DataSet
  isExternal: false
  name: Copy()
  nameWithType: DataSet.Copy()
  fullName: System.Data.DataSet.Copy()
- uid: System.Data.DataSet.CreateDataReader
  parent: System.Data.DataSet
  isExternal: false
  name: CreateDataReader()
  nameWithType: DataSet.CreateDataReader()
  fullName: System.Data.DataSet.CreateDataReader()
- uid: System.Data.DataTableReader
  parent: System.Data
  isExternal: false
  name: DataTableReader
  nameWithType: DataTableReader
  fullName: System.Data.DataTableReader
- uid: System.Data.DataSet.CreateDataReader(System.Data.DataTable[])
  parent: System.Data.DataSet
  isExternal: false
  name: CreateDataReader(DataTable[])
  nameWithType: DataSet.CreateDataReader(DataTable[])
  fullName: System.Data.DataSet.CreateDataReader(DataTable[])
- uid: System.Data.DataTable[]
  parent: System.Data
  isExternal: false
  name: DataTable
  nameWithType: DataTable
  fullName: System.Data.DataTable[]
  spec.csharp:
  - uid: System.Data.DataTable
    name: DataTable
    nameWithType: DataTable
    fullName: DataTable[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataSet.DataSetName
  parent: System.Data.DataSet
  isExternal: false
  name: DataSetName
  nameWithType: DataSet.DataSetName
  fullName: System.Data.DataSet.DataSetName
- uid: System.Data.DataSet.DefaultViewManager
  parent: System.Data.DataSet
  isExternal: false
  name: DefaultViewManager
  nameWithType: DataSet.DefaultViewManager
  fullName: System.Data.DataSet.DefaultViewManager
- uid: System.Data.DataViewManager
  parent: System.Data
  isExternal: false
  name: DataViewManager
  nameWithType: DataViewManager
  fullName: System.Data.DataViewManager
- uid: System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: DetermineSchemaSerializationMode(XmlReader)
  nameWithType: DataSet.DetermineSchemaSerializationMode(XmlReader)
  fullName: System.Data.DataSet.DetermineSchemaSerializationMode(XmlReader)
- uid: System.Data.SchemaSerializationMode
  parent: System.Data
  isExternal: false
  name: SchemaSerializationMode
  nameWithType: SchemaSerializationMode
  fullName: System.Data.SchemaSerializationMode
- uid: System.Xml.XmlReader
  parent: System.Xml
  isExternal: true
  name: XmlReader
  nameWithType: XmlReader
  fullName: System.Xml.XmlReader
- uid: System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  nameWithType: DataSet.DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.DetermineSchemaSerializationMode(SerializationInfo,StreamingContext)
- uid: System.Data.DataSet.EndInit
  parent: System.Data.DataSet
  isExternal: false
  name: EndInit()
  nameWithType: DataSet.EndInit()
  fullName: System.Data.DataSet.EndInit()
- uid: System.Data.DataSet.EnforceConstraints
  parent: System.Data.DataSet
  isExternal: false
  name: EnforceConstraints
  nameWithType: DataSet.EnforceConstraints
  fullName: System.Data.DataSet.EnforceConstraints
- uid: System.Data.DataSet.ExtendedProperties
  parent: System.Data.DataSet
  isExternal: false
  name: ExtendedProperties
  nameWithType: DataSet.ExtendedProperties
  fullName: System.Data.DataSet.ExtendedProperties
- uid: System.Data.PropertyCollection
  parent: System.Data
  isExternal: false
  name: PropertyCollection
  nameWithType: PropertyCollection
  fullName: System.Data.PropertyCollection
- uid: System.Data.DataSet.GetChanges
  parent: System.Data.DataSet
  isExternal: false
  name: GetChanges()
  nameWithType: DataSet.GetChanges()
  fullName: System.Data.DataSet.GetChanges()
- uid: System.Data.DataSet.GetChanges(System.Data.DataRowState)
  parent: System.Data.DataSet
  isExternal: false
  name: GetChanges(DataRowState)
  nameWithType: DataSet.GetChanges(DataRowState)
  fullName: System.Data.DataSet.GetChanges(DataRowState)
- uid: System.Data.DataRowState
  parent: System.Data
  isExternal: false
  name: DataRowState
  nameWithType: DataRowState
  fullName: System.Data.DataRowState
- uid: System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)
  parent: System.Data.DataSet
  isExternal: false
  name: GetDataSetSchema(XmlSchemaSet)
  nameWithType: DataSet.GetDataSetSchema(XmlSchemaSet)
  fullName: System.Data.DataSet.GetDataSetSchema(XmlSchemaSet)
- uid: System.Xml.Schema.XmlSchemaComplexType
  parent: System.Xml.Schema
  isExternal: false
  name: XmlSchemaComplexType
  nameWithType: XmlSchemaComplexType
  fullName: System.Xml.Schema.XmlSchemaComplexType
- uid: System.Xml.Schema.XmlSchemaSet
  parent: System.Xml.Schema
  isExternal: false
  name: XmlSchemaSet
  nameWithType: XmlSchemaSet
  fullName: System.Xml.Schema.XmlSchemaSet
- uid: System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: DataSet.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.GetObjectData(SerializationInfo,StreamingContext)
- uid: System.Data.DataSet.GetSchemaSerializable
  parent: System.Data.DataSet
  isExternal: false
  name: GetSchemaSerializable()
  nameWithType: DataSet.GetSchemaSerializable()
  fullName: System.Data.DataSet.GetSchemaSerializable()
- uid: System.Xml.Schema.XmlSchema
  parent: System.Xml.Schema
  isExternal: true
  name: XmlSchema
  nameWithType: XmlSchema
  fullName: System.Xml.Schema.XmlSchema
- uid: System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: GetSerializationData(SerializationInfo,StreamingContext)
  nameWithType: DataSet.GetSerializationData(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.GetSerializationData(SerializationInfo,StreamingContext)
- uid: System.Data.DataSet.GetXml
  parent: System.Data.DataSet
  isExternal: false
  name: GetXml()
  nameWithType: DataSet.GetXml()
  fullName: System.Data.DataSet.GetXml()
- uid: System.Data.DataSet.GetXmlSchema
  parent: System.Data.DataSet
  isExternal: false
  name: GetXmlSchema()
  nameWithType: DataSet.GetXmlSchema()
  fullName: System.Data.DataSet.GetXmlSchema()
- uid: System.Data.DataSet.HasChanges
  parent: System.Data.DataSet
  isExternal: false
  name: HasChanges()
  nameWithType: DataSet.HasChanges()
  fullName: System.Data.DataSet.HasChanges()
- uid: System.Data.DataSet.HasChanges(System.Data.DataRowState)
  parent: System.Data.DataSet
  isExternal: false
  name: HasChanges(DataRowState)
  nameWithType: DataSet.HasChanges(DataRowState)
  fullName: System.Data.DataSet.HasChanges(DataRowState)
- uid: System.Data.DataSet.HasErrors
  parent: System.Data.DataSet
  isExternal: false
  name: HasErrors
  nameWithType: DataSet.HasErrors
  fullName: System.Data.DataSet.HasErrors
- uid: System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema(Stream,String[])
  nameWithType: DataSet.InferXmlSchema(Stream,String[])
  fullName: System.Data.DataSet.InferXmlSchema(Stream,String[])
- uid: System.IO.Stream
  parent: System.IO
  isExternal: true
  name: Stream
  nameWithType: Stream
  fullName: System.IO.Stream
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema(TextReader,String[])
  nameWithType: DataSet.InferXmlSchema(TextReader,String[])
  fullName: System.Data.DataSet.InferXmlSchema(TextReader,String[])
- uid: System.IO.TextReader
  parent: System.IO
  isExternal: true
  name: TextReader
  nameWithType: TextReader
  fullName: System.IO.TextReader
- uid: System.Data.DataSet.InferXmlSchema(System.String,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema(String,String[])
  nameWithType: DataSet.InferXmlSchema(String,String[])
  fullName: System.Data.DataSet.InferXmlSchema(String,String[])
- uid: System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema(XmlReader,String[])
  nameWithType: DataSet.InferXmlSchema(XmlReader,String[])
  fullName: System.Data.DataSet.InferXmlSchema(XmlReader,String[])
- uid: System.Data.DataSet.Initialized
  parent: System.Data.DataSet
  isExternal: false
  name: Initialized
  nameWithType: DataSet.Initialized
  fullName: System.Data.DataSet.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Data.DataSet.InitializeDerivedDataSet
  parent: System.Data.DataSet
  isExternal: false
  name: InitializeDerivedDataSet()
  nameWithType: DataSet.InitializeDerivedDataSet()
  fullName: System.Data.DataSet.InitializeDerivedDataSet()
- uid: System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Data.DataSet
  isExternal: false
  name: IsBinarySerialized(SerializationInfo,StreamingContext)
  nameWithType: DataSet.IsBinarySerialized(SerializationInfo,StreamingContext)
  fullName: System.Data.DataSet.IsBinarySerialized(SerializationInfo,StreamingContext)
- uid: System.Data.DataSet.IsInitialized
  parent: System.Data.DataSet
  isExternal: false
  name: IsInitialized
  nameWithType: DataSet.IsInitialized
  fullName: System.Data.DataSet.IsInitialized
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])
  parent: System.Data.DataSet
  isExternal: false
  name: Load(IDataReader,LoadOption,DataTable[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,DataTable[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,DataTable[])
- uid: System.Data.IDataReader
  parent: System.Data
  isExternal: false
  name: IDataReader
  nameWithType: IDataReader
  fullName: System.Data.IDataReader
- uid: System.Data.LoadOption
  parent: System.Data
  isExternal: false
  name: LoadOption
  nameWithType: LoadOption
  fullName: System.Data.LoadOption
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])
  parent: System.Data.DataSet
  isExternal: false
  name: Load(IDataReader,LoadOption,String[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,String[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,String[])
- uid: System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])
  parent: System.Data.DataSet
  isExternal: false
  name: Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  nameWithType: DataSet.Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
  fullName: System.Data.DataSet.Load(IDataReader,LoadOption,FillErrorEventHandler,DataTable[])
- uid: System.Data.FillErrorEventHandler
  parent: System.Data
  isExternal: false
  name: FillErrorEventHandler
  nameWithType: FillErrorEventHandler
  fullName: System.Data.FillErrorEventHandler
- uid: System.Data.DataSet.Locale
  parent: System.Data.DataSet
  isExternal: false
  name: Locale
  nameWithType: DataSet.Locale
  fullName: System.Data.DataSet.Locale
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Data.DataSet.Merge(System.Data.DataRow[])
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataRow[])
  nameWithType: DataSet.Merge(DataRow[])
  fullName: System.Data.DataSet.Merge(DataRow[])
- uid: System.Data.DataRow[]
  parent: System.Data
  isExternal: false
  name: DataRow
  nameWithType: DataRow
  fullName: System.Data.DataRow[]
  spec.csharp:
  - uid: System.Data.DataRow
    name: DataRow
    nameWithType: DataRow
    fullName: DataRow[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.DataSet.Merge(System.Data.DataSet)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataSet)
  nameWithType: DataSet.Merge(DataSet)
  fullName: System.Data.DataSet.Merge(DataSet)
- uid: System.Data.DataSet.Merge(System.Data.DataTable)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataTable)
  nameWithType: DataSet.Merge(DataTable)
  fullName: System.Data.DataSet.Merge(DataTable)
- uid: System.Data.DataTable
  parent: System.Data
  isExternal: false
  name: DataTable
  nameWithType: DataTable
  fullName: System.Data.DataTable
- uid: System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataSet,Boolean)
  nameWithType: DataSet.Merge(DataSet,Boolean)
  fullName: System.Data.DataSet.Merge(DataSet,Boolean)
- uid: System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataRow[],Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataRow[],Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataRow[],Boolean,MissingSchemaAction)
- uid: System.Data.MissingSchemaAction
  parent: System.Data
  isExternal: false
  name: MissingSchemaAction
  nameWithType: MissingSchemaAction
  fullName: System.Data.MissingSchemaAction
- uid: System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataSet,Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataSet,Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataSet,Boolean,MissingSchemaAction)
- uid: System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)
  parent: System.Data.DataSet
  isExternal: false
  name: Merge(DataTable,Boolean,MissingSchemaAction)
  nameWithType: DataSet.Merge(DataTable,Boolean,MissingSchemaAction)
  fullName: System.Data.DataSet.Merge(DataTable,Boolean,MissingSchemaAction)
- uid: System.Data.DataSet.MergeFailed
  parent: System.Data.DataSet
  isExternal: false
  name: MergeFailed
  nameWithType: DataSet.MergeFailed
  fullName: System.Data.DataSet.MergeFailed
- uid: System.Data.MergeFailedEventHandler
  parent: System.Data
  isExternal: false
  name: MergeFailedEventHandler
  nameWithType: MergeFailedEventHandler
  fullName: System.Data.MergeFailedEventHandler
- uid: System.Data.DataSet.Namespace
  parent: System.Data.DataSet
  isExternal: false
  name: Namespace
  nameWithType: DataSet.Namespace
  fullName: System.Data.DataSet.Namespace
- uid: System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)
  parent: System.Data.DataSet
  isExternal: false
  name: OnPropertyChanging(PropertyChangedEventArgs)
  nameWithType: DataSet.OnPropertyChanging(PropertyChangedEventArgs)
  fullName: System.Data.DataSet.OnPropertyChanging(PropertyChangedEventArgs)
- uid: System.ComponentModel.PropertyChangedEventArgs
  parent: System.ComponentModel
  isExternal: true
  name: PropertyChangedEventArgs
  nameWithType: PropertyChangedEventArgs
  fullName: System.ComponentModel.PropertyChangedEventArgs
- uid: System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)
  parent: System.Data.DataSet
  isExternal: false
  name: OnRemoveRelation(DataRelation)
  nameWithType: DataSet.OnRemoveRelation(DataRelation)
  fullName: System.Data.DataSet.OnRemoveRelation(DataRelation)
- uid: System.Data.DataRelation
  parent: System.Data
  isExternal: false
  name: DataRelation
  nameWithType: DataRelation
  fullName: System.Data.DataRelation
- uid: System.Data.DataSet.OnRemoveTable(System.Data.DataTable)
  parent: System.Data.DataSet
  isExternal: false
  name: OnRemoveTable(DataTable)
  nameWithType: DataSet.OnRemoveTable(DataTable)
  fullName: System.Data.DataSet.OnRemoveTable(DataTable)
- uid: System.Data.DataSet.Prefix
  parent: System.Data.DataSet
  isExternal: false
  name: Prefix
  nameWithType: DataSet.Prefix
  fullName: System.Data.DataSet.Prefix
- uid: System.Data.DataSet.RaisePropertyChanging(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: RaisePropertyChanging(String)
  nameWithType: DataSet.RaisePropertyChanging(String)
  fullName: System.Data.DataSet.RaisePropertyChanging(String)
- uid: System.Data.DataSet.ReadXml(System.IO.Stream)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(Stream)
  nameWithType: DataSet.ReadXml(Stream)
  fullName: System.Data.DataSet.ReadXml(Stream)
- uid: System.Data.XmlReadMode
  parent: System.Data
  isExternal: false
  name: XmlReadMode
  nameWithType: XmlReadMode
  fullName: System.Data.XmlReadMode
- uid: System.Data.DataSet.ReadXml(System.IO.TextReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(TextReader)
  nameWithType: DataSet.ReadXml(TextReader)
  fullName: System.Data.DataSet.ReadXml(TextReader)
- uid: System.Data.DataSet.ReadXml(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(String)
  nameWithType: DataSet.ReadXml(String)
  fullName: System.Data.DataSet.ReadXml(String)
- uid: System.Data.DataSet.ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(XmlReader)
  nameWithType: DataSet.ReadXml(XmlReader)
  fullName: System.Data.DataSet.ReadXml(XmlReader)
- uid: System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(Stream,XmlReadMode)
  nameWithType: DataSet.ReadXml(Stream,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(Stream,XmlReadMode)
- uid: System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(TextReader,XmlReadMode)
  nameWithType: DataSet.ReadXml(TextReader,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(TextReader,XmlReadMode)
- uid: System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(String,XmlReadMode)
  nameWithType: DataSet.ReadXml(String,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(String,XmlReadMode)
- uid: System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml(XmlReader,XmlReadMode)
  nameWithType: DataSet.ReadXml(XmlReader,XmlReadMode)
  fullName: System.Data.DataSet.ReadXml(XmlReader,XmlReadMode)
- uid: System.Data.DataSet.ReadXmlSchema(System.IO.Stream)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema(Stream)
  nameWithType: DataSet.ReadXmlSchema(Stream)
  fullName: System.Data.DataSet.ReadXmlSchema(Stream)
- uid: System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema(TextReader)
  nameWithType: DataSet.ReadXmlSchema(TextReader)
  fullName: System.Data.DataSet.ReadXmlSchema(TextReader)
- uid: System.Data.DataSet.ReadXmlSchema(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema(String)
  nameWithType: DataSet.ReadXmlSchema(String)
  fullName: System.Data.DataSet.ReadXmlSchema(String)
- uid: System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema(XmlReader)
  nameWithType: DataSet.ReadXmlSchema(XmlReader)
  fullName: System.Data.DataSet.ReadXmlSchema(XmlReader)
- uid: System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSerializable(XmlReader)
  nameWithType: DataSet.ReadXmlSerializable(XmlReader)
  fullName: System.Data.DataSet.ReadXmlSerializable(XmlReader)
- uid: System.Data.DataSet.RejectChanges
  parent: System.Data.DataSet
  isExternal: false
  name: RejectChanges()
  nameWithType: DataSet.RejectChanges()
  fullName: System.Data.DataSet.RejectChanges()
- uid: System.Data.DataSet.Relations
  parent: System.Data.DataSet
  isExternal: false
  name: Relations
  nameWithType: DataSet.Relations
  fullName: System.Data.DataSet.Relations
- uid: System.Data.DataRelationCollection
  parent: System.Data
  isExternal: false
  name: DataRelationCollection
  nameWithType: DataRelationCollection
  fullName: System.Data.DataRelationCollection
- uid: System.Data.DataSet.RemotingFormat
  parent: System.Data.DataSet
  isExternal: false
  name: RemotingFormat
  nameWithType: DataSet.RemotingFormat
  fullName: System.Data.DataSet.RemotingFormat
- uid: System.Data.SerializationFormat
  parent: System.Data
  isExternal: false
  name: SerializationFormat
  nameWithType: SerializationFormat
  fullName: System.Data.SerializationFormat
- uid: System.Data.DataSet.Reset
  parent: System.Data.DataSet
  isExternal: false
  name: Reset()
  nameWithType: DataSet.Reset()
  fullName: System.Data.DataSet.Reset()
- uid: System.Data.DataSet.SchemaSerializationMode
  parent: System.Data.DataSet
  isExternal: false
  name: SchemaSerializationMode
  nameWithType: DataSet.SchemaSerializationMode
  fullName: System.Data.DataSet.SchemaSerializationMode
- uid: System.Data.DataSet.ShouldSerializeRelations
  parent: System.Data.DataSet
  isExternal: false
  name: ShouldSerializeRelations()
  nameWithType: DataSet.ShouldSerializeRelations()
  fullName: System.Data.DataSet.ShouldSerializeRelations()
- uid: System.Data.DataSet.ShouldSerializeTables
  parent: System.Data.DataSet
  isExternal: false
  name: ShouldSerializeTables()
  nameWithType: DataSet.ShouldSerializeTables()
  fullName: System.Data.DataSet.ShouldSerializeTables()
- uid: System.Data.DataSet.Site
  parent: System.Data.DataSet
  isExternal: false
  name: Site
  nameWithType: DataSet.Site
  fullName: System.Data.DataSet.Site
- uid: System.ComponentModel.ISite
  parent: System.ComponentModel
  isExternal: false
  name: ISite
  nameWithType: ISite
  fullName: System.ComponentModel.ISite
- uid: System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection
  parent: System.Data.DataSet
  isExternal: false
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataSet.System.ComponentModel.IListSource.ContainsListCollection
  fullName: System.Data.DataSet.System.ComponentModel.IListSource.ContainsListCollection
- uid: System.Data.DataSet.System#ComponentModel#IListSource#GetList
  parent: System.Data.DataSet
  isExternal: false
  name: System.ComponentModel.IListSource.GetList()
  nameWithType: DataSet.System.ComponentModel.IListSource.GetList()
  fullName: System.Data.DataSet.System.ComponentModel.IListSource.GetList()
- uid: System.Collections.IList
  parent: System.Collections
  isExternal: true
  name: IList
  nameWithType: IList
  fullName: System.Collections.IList
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.GetSchema()
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema()
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema()
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader)
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
  fullName: System.Data.DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter)
- uid: System.Xml.XmlWriter
  parent: System.Xml
  isExternal: true
  name: XmlWriter
  nameWithType: XmlWriter
  fullName: System.Xml.XmlWriter
- uid: System.Data.DataSet.Tables
  parent: System.Data.DataSet
  isExternal: false
  name: Tables
  nameWithType: DataSet.Tables
  fullName: System.Data.DataSet.Tables
- uid: System.Data.DataTableCollection
  parent: System.Data
  isExternal: false
  name: DataTableCollection
  nameWithType: DataTableCollection
  fullName: System.Data.DataTableCollection
- uid: System.Data.DataSet.WriteXml(System.IO.Stream)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(Stream)
  nameWithType: DataSet.WriteXml(Stream)
  fullName: System.Data.DataSet.WriteXml(Stream)
- uid: System.Data.DataSet.WriteXml(System.IO.TextWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(TextWriter)
  nameWithType: DataSet.WriteXml(TextWriter)
  fullName: System.Data.DataSet.WriteXml(TextWriter)
- uid: System.IO.TextWriter
  parent: System.IO
  isExternal: true
  name: TextWriter
  nameWithType: TextWriter
  fullName: System.IO.TextWriter
- uid: System.Data.DataSet.WriteXml(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(String)
  nameWithType: DataSet.WriteXml(String)
  fullName: System.Data.DataSet.WriteXml(String)
- uid: System.Data.DataSet.WriteXml(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(XmlWriter)
  nameWithType: DataSet.WriteXml(XmlWriter)
  fullName: System.Data.DataSet.WriteXml(XmlWriter)
- uid: System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(Stream,XmlWriteMode)
  nameWithType: DataSet.WriteXml(Stream,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(Stream,XmlWriteMode)
- uid: System.Data.XmlWriteMode
  parent: System.Data
  isExternal: false
  name: XmlWriteMode
  nameWithType: XmlWriteMode
  fullName: System.Data.XmlWriteMode
- uid: System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(TextWriter,XmlWriteMode)
  nameWithType: DataSet.WriteXml(TextWriter,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(TextWriter,XmlWriteMode)
- uid: System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(String,XmlWriteMode)
  nameWithType: DataSet.WriteXml(String,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(String,XmlWriteMode)
- uid: System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml(XmlWriter,XmlWriteMode)
  nameWithType: DataSet.WriteXml(XmlWriter,XmlWriteMode)
  fullName: System.Data.DataSet.WriteXml(XmlWriter,XmlWriteMode)
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.Stream)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(Stream)
  nameWithType: DataSet.WriteXmlSchema(Stream)
  fullName: System.Data.DataSet.WriteXmlSchema(Stream)
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(TextWriter)
  nameWithType: DataSet.WriteXmlSchema(TextWriter)
  fullName: System.Data.DataSet.WriteXmlSchema(TextWriter)
- uid: System.Data.DataSet.WriteXmlSchema(System.String)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(String)
  nameWithType: DataSet.WriteXmlSchema(String)
  fullName: System.Data.DataSet.WriteXmlSchema(String)
- uid: System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(XmlWriter)
  nameWithType: DataSet.WriteXmlSchema(XmlWriter)
  fullName: System.Data.DataSet.WriteXmlSchema(XmlWriter)
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(Stream,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(Stream,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(Stream,Converter<Type,String>)
- uid: System.Converter{System.Type,System.String}
  parent: System
  isExternal: false
  name: Converter<Type,String>
  nameWithType: Converter<Type,String>
  fullName: System.Converter<System.Type,System.String>
  spec.csharp:
  - uid: System.Converter`2
    name: Converter
    nameWithType: Converter
    fullName: Converter<System.Type,System.String>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Type
    name: Type
    nameWithType: Type
    fullName: Type
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(TextWriter,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(TextWriter,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(TextWriter,Converter<Type,String>)
- uid: System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(String,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(String,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(String,Converter<Type,String>)
- uid: System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema(XmlWriter,Converter<Type,String>)
  nameWithType: DataSet.WriteXmlSchema(XmlWriter,Converter<Type,String>)
  fullName: System.Data.DataSet.WriteXmlSchema(XmlWriter,Converter<Type,String>)
- uid: System.Data.DataSet.#ctor*
  parent: System.Data.DataSet
  isExternal: false
  name: DataSet
  nameWithType: DataSet.DataSet
- uid: System.Data.DataSet.AcceptChanges*
  parent: System.Data.DataSet
  isExternal: false
  name: AcceptChanges
  nameWithType: DataSet.AcceptChanges
- uid: System.Data.DataSet.BeginInit*
  parent: System.Data.DataSet
  isExternal: false
  name: BeginInit
  nameWithType: DataSet.BeginInit
- uid: System.Data.DataSet.CaseSensitive*
  parent: System.Data.DataSet
  isExternal: false
  name: CaseSensitive
  nameWithType: DataSet.CaseSensitive
- uid: System.Data.DataSet.Clear*
  parent: System.Data.DataSet
  isExternal: false
  name: Clear
  nameWithType: DataSet.Clear
- uid: System.Data.DataSet.Clone*
  parent: System.Data.DataSet
  isExternal: false
  name: Clone
  nameWithType: DataSet.Clone
- uid: System.Data.DataSet.Copy*
  parent: System.Data.DataSet
  isExternal: false
  name: Copy
  nameWithType: DataSet.Copy
- uid: System.Data.DataSet.CreateDataReader*
  parent: System.Data.DataSet
  isExternal: false
  name: CreateDataReader
  nameWithType: DataSet.CreateDataReader
- uid: System.Data.DataSet.DataSetName*
  parent: System.Data.DataSet
  isExternal: false
  name: DataSetName
  nameWithType: DataSet.DataSetName
- uid: System.Data.DataSet.DefaultViewManager*
  parent: System.Data.DataSet
  isExternal: false
  name: DefaultViewManager
  nameWithType: DataSet.DefaultViewManager
- uid: System.Data.DataSet.DetermineSchemaSerializationMode*
  parent: System.Data.DataSet
  isExternal: false
  name: DetermineSchemaSerializationMode
  nameWithType: DataSet.DetermineSchemaSerializationMode
- uid: System.Data.DataSet.EndInit*
  parent: System.Data.DataSet
  isExternal: false
  name: EndInit
  nameWithType: DataSet.EndInit
- uid: System.Data.DataSet.EnforceConstraints*
  parent: System.Data.DataSet
  isExternal: false
  name: EnforceConstraints
  nameWithType: DataSet.EnforceConstraints
- uid: System.Data.DataSet.ExtendedProperties*
  parent: System.Data.DataSet
  isExternal: false
  name: ExtendedProperties
  nameWithType: DataSet.ExtendedProperties
- uid: System.Data.DataSet.GetChanges*
  parent: System.Data.DataSet
  isExternal: false
  name: GetChanges
  nameWithType: DataSet.GetChanges
- uid: System.Data.DataSet.GetDataSetSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: GetDataSetSchema
  nameWithType: DataSet.GetDataSetSchema
- uid: System.Data.DataSet.GetObjectData*
  parent: System.Data.DataSet
  isExternal: false
  name: GetObjectData
  nameWithType: DataSet.GetObjectData
- uid: System.Data.DataSet.GetSchemaSerializable*
  parent: System.Data.DataSet
  isExternal: false
  name: GetSchemaSerializable
  nameWithType: DataSet.GetSchemaSerializable
- uid: System.Data.DataSet.GetSerializationData*
  parent: System.Data.DataSet
  isExternal: false
  name: GetSerializationData
  nameWithType: DataSet.GetSerializationData
- uid: System.Data.DataSet.GetXml*
  parent: System.Data.DataSet
  isExternal: false
  name: GetXml
  nameWithType: DataSet.GetXml
- uid: System.Data.DataSet.GetXmlSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: GetXmlSchema
  nameWithType: DataSet.GetXmlSchema
- uid: System.Data.DataSet.HasChanges*
  parent: System.Data.DataSet
  isExternal: false
  name: HasChanges
  nameWithType: DataSet.HasChanges
- uid: System.Data.DataSet.HasErrors*
  parent: System.Data.DataSet
  isExternal: false
  name: HasErrors
  nameWithType: DataSet.HasErrors
- uid: System.Data.DataSet.InferXmlSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: InferXmlSchema
  nameWithType: DataSet.InferXmlSchema
- uid: System.Data.DataSet.InitializeDerivedDataSet*
  parent: System.Data.DataSet
  isExternal: false
  name: InitializeDerivedDataSet
  nameWithType: DataSet.InitializeDerivedDataSet
- uid: System.Data.DataSet.IsBinarySerialized*
  parent: System.Data.DataSet
  isExternal: false
  name: IsBinarySerialized
  nameWithType: DataSet.IsBinarySerialized
- uid: System.Data.DataSet.IsInitialized*
  parent: System.Data.DataSet
  isExternal: false
  name: IsInitialized
  nameWithType: DataSet.IsInitialized
- uid: System.Data.DataSet.Load*
  parent: System.Data.DataSet
  isExternal: false
  name: Load
  nameWithType: DataSet.Load
- uid: System.Data.DataSet.Locale*
  parent: System.Data.DataSet
  isExternal: false
  name: Locale
  nameWithType: DataSet.Locale
- uid: System.Data.DataSet.Merge*
  parent: System.Data.DataSet
  isExternal: false
  name: Merge
  nameWithType: DataSet.Merge
- uid: System.Data.DataSet.Namespace*
  parent: System.Data.DataSet
  isExternal: false
  name: Namespace
  nameWithType: DataSet.Namespace
- uid: System.Data.DataSet.OnPropertyChanging*
  parent: System.Data.DataSet
  isExternal: false
  name: OnPropertyChanging
  nameWithType: DataSet.OnPropertyChanging
- uid: System.Data.DataSet.OnRemoveRelation*
  parent: System.Data.DataSet
  isExternal: false
  name: OnRemoveRelation
  nameWithType: DataSet.OnRemoveRelation
- uid: System.Data.DataSet.OnRemoveTable*
  parent: System.Data.DataSet
  isExternal: false
  name: OnRemoveTable
  nameWithType: DataSet.OnRemoveTable
- uid: System.Data.DataSet.Prefix*
  parent: System.Data.DataSet
  isExternal: false
  name: Prefix
  nameWithType: DataSet.Prefix
- uid: System.Data.DataSet.RaisePropertyChanging*
  parent: System.Data.DataSet
  isExternal: false
  name: RaisePropertyChanging
  nameWithType: DataSet.RaisePropertyChanging
- uid: System.Data.DataSet.ReadXml*
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXml
  nameWithType: DataSet.ReadXml
- uid: System.Data.DataSet.ReadXmlSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSchema
  nameWithType: DataSet.ReadXmlSchema
- uid: System.Data.DataSet.ReadXmlSerializable*
  parent: System.Data.DataSet
  isExternal: false
  name: ReadXmlSerializable
  nameWithType: DataSet.ReadXmlSerializable
- uid: System.Data.DataSet.RejectChanges*
  parent: System.Data.DataSet
  isExternal: false
  name: RejectChanges
  nameWithType: DataSet.RejectChanges
- uid: System.Data.DataSet.Relations*
  parent: System.Data.DataSet
  isExternal: false
  name: Relations
  nameWithType: DataSet.Relations
- uid: System.Data.DataSet.RemotingFormat*
  parent: System.Data.DataSet
  isExternal: false
  name: RemotingFormat
  nameWithType: DataSet.RemotingFormat
- uid: System.Data.DataSet.Reset*
  parent: System.Data.DataSet
  isExternal: false
  name: Reset
  nameWithType: DataSet.Reset
- uid: System.Data.DataSet.SchemaSerializationMode*
  parent: System.Data.DataSet
  isExternal: false
  name: SchemaSerializationMode
  nameWithType: DataSet.SchemaSerializationMode
- uid: System.Data.DataSet.ShouldSerializeRelations*
  parent: System.Data.DataSet
  isExternal: false
  name: ShouldSerializeRelations
  nameWithType: DataSet.ShouldSerializeRelations
- uid: System.Data.DataSet.ShouldSerializeTables*
  parent: System.Data.DataSet
  isExternal: false
  name: ShouldSerializeTables
  nameWithType: DataSet.ShouldSerializeTables
- uid: System.Data.DataSet.Site*
  parent: System.Data.DataSet
  isExternal: false
  name: Site
  nameWithType: DataSet.Site
- uid: System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection*
  parent: System.Data.DataSet
  isExternal: false
  name: System.ComponentModel.IListSource.ContainsListCollection
  nameWithType: DataSet.System.ComponentModel.IListSource.ContainsListCollection
- uid: System.Data.DataSet.System#ComponentModel#IListSource#GetList*
  parent: System.Data.DataSet
  isExternal: false
  name: System.ComponentModel.IListSource.GetList
  nameWithType: DataSet.System.ComponentModel.IListSource.GetList
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.GetSchema
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.GetSchema
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml*
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.ReadXml
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.ReadXml
- uid: System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml*
  parent: System.Data.DataSet
  isExternal: false
  name: System.Xml.Serialization.IXmlSerializable.WriteXml
  nameWithType: DataSet.System.Xml.Serialization.IXmlSerializable.WriteXml
- uid: System.Data.DataSet.Tables*
  parent: System.Data.DataSet
  isExternal: false
  name: Tables
  nameWithType: DataSet.Tables
- uid: System.Data.DataSet.WriteXml*
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXml
  nameWithType: DataSet.WriteXml
- uid: System.Data.DataSet.WriteXmlSchema*
  parent: System.Data.DataSet
  isExternal: false
  name: WriteXmlSchema
  nameWithType: DataSet.WriteXmlSchema
