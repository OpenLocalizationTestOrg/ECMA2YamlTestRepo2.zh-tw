### YamlMime:ManagedReference
items:
- uid: System.Windows.Documents.TextPointer
  id: TextPointer
  children:
  - System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)
  - System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)
  - System.Windows.Documents.TextPointer.DocumentEnd
  - System.Windows.Documents.TextPointer.DocumentStart
  - System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)
  - System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)
  - System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)
  - System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)
  - System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)
  - System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)
  - System.Windows.Documents.TextPointer.HasValidLayout
  - System.Windows.Documents.TextPointer.InsertLineBreak
  - System.Windows.Documents.TextPointer.InsertParagraphBreak
  - System.Windows.Documents.TextPointer.InsertTextInRun(System.String)
  - System.Windows.Documents.TextPointer.IsAtInsertionPosition
  - System.Windows.Documents.TextPointer.IsAtLineStartPosition
  - System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)
  - System.Windows.Documents.TextPointer.LogicalDirection
  - System.Windows.Documents.TextPointer.Paragraph
  - System.Windows.Documents.TextPointer.Parent
  - System.Windows.Documents.TextPointer.ToString
  langs:
  - csharp
  name: TextPointer
  nameWithType: TextPointer
  fullName: System.Windows.Documents.TextPointer
  type: Class
  summary: "表示中的位置<xref href=&quot;System.Windows.Documents.FlowDocument&quot;></xref>或<xref href=&quot;System.Windows.Controls.TextBlock&quot;> </xref>。"
  remarks: "TextPointer 類別導入了下列詞彙:-位置-原本 TextPointer 永遠指向*位置*內容中。  請切換流程或在內容中，字元間內容項目標記，這類位置定義內容的結構。      -目前的位置-TextPointer 一律表示的位置中，因此有許多可透過 TextPointer 執行的作業是相對於目前指向的 TextPointer 的位置，因為合理的參考做為 TextPointer 所指定的位置*目前位置*。      插入位置-*插入位置*位置，而不會中斷任何語意規則相關聯的內容可能會加入新的內容。  在實務上，插入位置是在插入號可能位於所在位置的內容。  不是插入位置的有效 TextPointer 位置的範例是相鄰的兩個位置<xref:System.Windows.Documents.Paragraph>標記 (亦即，在上一段結尾標記之間的下一個段落的開頭標記)。</xref:System.Windows.Documents.Paragraph>      -符號-目的 TextPointer 作業牽涉到下列任何一個的符號會被視為*符號*:-開頭或結尾標記<xref:System.Windows.Documents.TextElement>項目。</xref:System.Windows.Documents.TextElement>          -<xref:System.Windows.UIElement>項目包含在<xref:System.Windows.Documents.InlineUIContainer>或<xref:System.Windows.Documents.BlockUIContainer>.</xref:System.Windows.Documents.BlockUIContainer> </xref:System.Windows.Documents.InlineUIContainer> </xref:System.Windows.UIElement> a  請注意，這類<xref:System.Windows.UIElement>一律會計算為一個符號，則為任何其他內容或所包含的項目<xref:System.Windows.UIElement>不會計入為符號。</xref:System.Windows.UIElement> </xref:System.Windows.UIElement>          -每個 16 位元[!INCLUDE[TLA#tla_unicode](~/add/includes/ajax-current-ext-md.md)]內文字的字元<xref:System.Windows.Documents.Run>項目。</xref:System.Windows.Documents.Run>      文字容器-A*文字容器*form 於非固定格式內容的最終框線的項目，則由 TextPointer 永遠落在的文字容器內的位置。  目前，文字容器必須是其中一個<xref:System.Windows.Documents.FlowDocument>或<xref:System.Windows.Controls.TextBlock>.</xref:System.Windows.Controls.TextBlock> </xref:System.Windows.Documents.FlowDocument>  一般而言，不支援 TextPointer 不同的文字容器中的執行個體之間的作業。      -文件-文字中的內容容器指*文件*，如同在<xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A>方法和<xref:System.Windows.Documents.TextPointer.DocumentStart%2A>和<xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>屬性。</xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> </xref:System.Windows.Documents.TextPointer.DocumentStart%2A> </xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A>       TextPointer 類別為了加速周遊和操作的內容所表示之[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]流動內容項目，則這類項目在一般情況下，衍生自<xref:System.Windows.Documents.TextElement>.</xref:System.Windows.Documents.TextElement>  某些作業，可促進 TextPointer 如下:-執行序數比較的第二個指定的位置與目前的位置。  請參閱<xref:System.Windows.Documents.TextPointer.CompareTo%2A>方法。</xref:System.Windows.Documents.TextPointer.CompareTo%2A>      -判斷目前的位置，以指定方向相鄰的內容類型。  請參閱<xref:System.Windows.Documents.TextPointer.GetPointerContext%2A>方法和<xref:System.Windows.Documents.TextPointerContext>列舉型別。</xref:System.Windows.Documents.TextPointerContext> </xref:System.Windows.Documents.TextPointer.GetPointerContext%2A>      -取得<xref:System.Windows.Documents.TextElement>的範圍或相鄰的目前位置。</xref:System.Windows.Documents.TextElement>  請參閱<xref:System.Windows.Documents.Paragraph>和<xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A>方法。</xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> </xref:System.Windows.Documents.Paragraph>      -取得目前文件的範圍限制文字容器。  請參閱<xref:System.Windows.Documents.TextPointer.Parent%2A>屬性。</xref:System.Windows.Documents.TextPointer.Parent%2A>      -取得指定的前置或後的目前位置的字元數。  請參閱<xref:System.Windows.Documents.TextPointer.GetTextInRun%2A>方法。</xref:System.Windows.Documents.TextPointer.GetTextInRun%2A>      -在目前的位置插入字元的字串。  請參閱<xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A>方法。</xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A>      -尋找內容中的行邊界。  請參閱<xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A>方法和<xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A>屬性。</xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> </xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A>      -TextPointer 的位置和符號位移之間的內容進行轉譯。  請參閱<xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A>和<xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>方法。</xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> </xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A>      -執行凙 TextPointer 位置之間視覺點擊測試和<xref:System.Windows.Point>代表相對座標表示。</xref:System.Windows.Point>      -尋找附近的插入位置，或檢查目前的位置是否為插入位置。  請參閱<xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A>和<xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>方法和<xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A>屬性。</xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> </xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> </xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A>       位置和<xref:System.Windows.Documents.TextPointer.LogicalDirection%2A>TextPointer 物件所指出是不變。</xref:System.Windows.Documents.TextPointer.LogicalDirection%2A>  當內容是編輯或修改時，TextPointer 所指定的位置就不會變更相對於與周圍文字;而是內容開始從該位置的位移會跟著調整，以反映新的相對位置內容中。  比方說，指出給定的段落開頭位置 TextPointer 會繼續以指向該段落的開頭，插入或刪除之前或之後在一段內容時，即使。       TextPointer 類別並未提供任何公用建構函式。  使用其他物件 （包括其他 TextPointer 物件） 的屬性或方法被建立 TextPointer 的執行個體。 下列清單提供一些方法和屬性，建立並傳回 TextPointer 的範例。  此清單未全部列出:-從<xref:System.Windows.Documents.TextRange>︰<xref:System.Windows.Documents.TextRange.Start%2A>和<xref:System.Windows.Documents.TextRange.End%2A>。</xref:System.Windows.Documents.TextRange.End%2A> </xref:System.Windows.Documents.TextRange.Start%2A> </xref:System.Windows.Documents.TextRange>      -   From a <xref:System.Windows.Documents.TextElement>:  <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, and <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.</xref:System.Windows.Documents.TextElement.ElementEnd%2A></xref:System.Windows.Documents.TextElement.ElementStart%2A></xref:System.Windows.Documents.TextElement.ContentEnd%2A></xref:System.Windows.Documents.TextElement.ContentStart%2A></xref:System.Windows.Documents.TextElement>      -從<xref:System.Windows.Controls.TextBlock>（文字容器）︰ <xref:System.Windows.Controls.TextBlock.ContentStart%2A>， <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>，和<xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>。</xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A> </xref:System.Windows.Controls.TextBlock.ContentEnd%2A> </xref:System.Windows.Controls.TextBlock.ContentStart%2A> </xref:System.Windows.Controls.TextBlock>      -從<xref:System.Windows.Documents.FlowDocument>（文字容器）︰ <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>，和<xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>-從現有的 TextPointer: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>， <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>， <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>，和<xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>。</xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> </xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> </xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> </xref:System.Windows.Documents.TextPointer.DocumentStart%2A> </xref:System.Windows.Documents.FlowDocument.ContentEnd%2A> </xref:System.Windows.Documents.FlowDocument.ContentStart%2A> </xref:System.Windows.Documents.FlowDocument>"
  example:
  - "The following example demonstrates how to use a TextPointer to find a position just inside of the first <xref:System.Windows.Documents.Run> element in a specified text container.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_TextPointer1](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_textpointer1)]\n [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_textpointer1)]  \n  \n The following example implements a simplistic find algorithm using TextPointer facilities.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_TextPointer2](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_textpointer2)]\n [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_textpointer2)]"
  syntax:
    content: 'public class TextPointer : System.Windows.Documents.ContentPosition'
  inheritance:
  - System.Object
  - System.Windows.Documents.ContentPosition
  implements: []
  inheritedMembers:
  - System.Windows.Documents.ContentPosition.Missing
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)
  id: CompareTo(System.Windows.Documents.TextPointer)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: CompareTo(TextPointer)
  nameWithType: TextPointer.CompareTo(TextPointer)
  fullName: System.Windows.Documents.TextPointer.CompareTo(TextPointer)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "執行序數比較目前所指定的位置之間<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>和第二個指定<xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>。"
  remarks: "值為-1 表示位置指定由目前<xref:System.Windows.Documents.TextPointer>所指定的位置之前`position`。</xref:System.Windows.Documents.TextPointer>  值為 0 指出指出的位置相等。  值為正數的 +&1; 表示位置指定由目前<xref:System.Windows.Documents.TextPointer>遵循所指定的位置`position`。</xref:System.Windows.Documents.TextPointer>"
  example:
  - "The following example demonstrates a use for this method.  In the example, the CompareTo method is used in conjunction with the <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> method to test whether a specified <xref:System.Windows.Documents.TextElement> is empty.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_getinsertionposition)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_getinsertionposition)]"
  syntax:
    content: public int CompareTo (System.Windows.Documents.TextPointer position);
    parameters:
    - id: position
      type: System.Windows.Documents.TextPointer
      description: "A <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> ，指定要比較的目前位置的位置。"
    return:
      type: System.Int32
      description: "– 1，否則目前<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>之前<code> position </code>; 如果是相同的位置 0，則 + 1 如果目前<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>遵循<code> position </code>。"
  overload: System.Windows.Documents.TextPointer.CompareTo*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>position</code>指定目前的位置與相關聯的文字容器之外的位置。"
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)
  id: DeleteTextInRun(System.Int32)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: DeleteTextInRun(Int32)
  nameWithType: TextPointer.DeleteTextInRun(Int32)
  fullName: System.Windows.Documents.TextPointer.DeleteTextInRun(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "從目前所指定的位置中刪除指定的字元數<xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>。"
  remarks: "指定正值以刪除依照目前位置的字元 (在<xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName>); 指定負值可刪除在目前位置前面的字元 (像是<xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName>)。</xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName> </xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName>       實際刪除的字元數目可能小於指定的數字`count`。  此動作會在案例其中`count`指定字元數超過要刪除的存在。"
  syntax:
    content: public int DeleteTextInRun (int count);
    parameters:
    - id: count
      type: System.Int32
      description: "要刪除的字元數從目前位置開始。 指定要刪除依照目前的位置; 字元的正數值指定要刪除在目前位置前面的字元為負值。"
    return:
      type: System.Int32
      description: "實際刪除的字元數。"
  overload: System.Windows.Documents.TextPointer.DeleteTextInRun*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "不允許文字的位置，會呼叫方法。"
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.DocumentEnd
  id: DocumentEnd
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: DocumentEnd
  nameWithType: TextPointer.DocumentEnd
  fullName: System.Windows.Documents.TextPointer.DocumentEnd
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "取得<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>中目前的位置與相關聯的文字容器內容的結尾。"
  remarks: "<xref:System.Windows.Documents.TextPointer.Parent%2A>如傳回<xref:System.Windows.Documents.TextPointer>永遠是文字容器 (<xref:System.Windows.Controls.TextBlock>或<xref:System.Windows.Documents.FlowDocument>)，而不是<xref:System.Windows.Documents.TextElement>.</xref:System.Windows.Documents.TextElement> </xref:System.Windows.Documents.FlowDocument> </xref:System.Windows.Controls.TextBlock> </xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointer.Parent%2A>"
  syntax:
    content: public System.Windows.Documents.TextPointer DocumentEnd { get; }
    return:
      type: System.Windows.Documents.TextPointer
      description: "A <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>中目前的位置與相關聯的文字容器內容的結尾。"
  overload: System.Windows.Documents.TextPointer.DocumentEnd*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.DocumentStart
  id: DocumentStart
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: DocumentStart
  nameWithType: TextPointer.DocumentStart
  fullName: System.Windows.Documents.TextPointer.DocumentStart
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "取得<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>中目前的位置與相關聯的文字容器內容的開頭。"
  remarks: "使用這個屬性所傳回工作的其他位置的相對位移基準位置為的位置。  <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A>和<xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>方法提供一個方式來轉譯位置和位置位移。</xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> </xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A>       <xref:System.Windows.Documents.TextPointer.Parent%2A>如傳回<xref:System.Windows.Documents.TextPointer>永遠是文字容器 (<xref:System.Windows.Controls.TextBlock>或<xref:System.Windows.Documents.FlowDocument>)，而不是<xref:System.Windows.Documents.TextElement>.</xref:System.Windows.Documents.TextElement> </xref:System.Windows.Documents.FlowDocument> </xref:System.Windows.Controls.TextBlock> </xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointer.Parent%2A>"
  syntax:
    content: public System.Windows.Documents.TextPointer DocumentStart { get; }
    return:
      type: System.Windows.Documents.TextPointer
      description: "A <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>中目前的位置與相關聯的文字容器內容的開頭。"
  overload: System.Windows.Documents.TextPointer.DocumentStart*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)
  id: GetAdjacentElement(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetAdjacentElement(LogicalDirection)
  nameWithType: TextPointer.GetAdjacentElement(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetAdjacentElement(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "傳回的項目，如果有的話，框線目前<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>以指定的邏輯方向。"
  remarks: "傳回的項目通常是<xref:System.Windows.Documents.TextElement>.</xref:System.Windows.Documents.TextElement>  A<xref:System.Windows.UIElement>可以時會傳回<xref:System.Windows.Documents.TextPointer>表示的位置內<xref:System.Windows.Documents.BlockUIContainer>項目或<xref:System.Windows.Documents.InlineUIContainer>項目。</xref:System.Windows.Documents.InlineUIContainer> </xref:System.Windows.Documents.BlockUIContainer> </xref:System.Windows.Documents.TextPointer> </xref:System.Windows.UIElement>"
  syntax:
    content: public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "其中一個<xref href=&quot;System.Windows.Documents.LogicalDirection&quot;></xref>值，指定要在其中搜尋的相鄰項目邏輯的方向。"
    return:
      type: System.Windows.DependencyObject
      description: "在指定的相鄰項目<code> direction </code>，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果相鄰項目不存在。"
  overload: System.Windows.Documents.TextPointer.GetAdjacentElement*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)
  id: GetCharacterRect(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetCharacterRect(LogicalDirection)
  nameWithType: TextPointer.GetCharacterRect(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetCharacterRect(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "週框方塊會傳回 (<xref href=&quot;System.Windows.Rect&quot;></xref>) 之內容的框線目前<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>以指定的邏輯方向。"
  remarks: "<xref:System.Windows.Documents.TextElement>邊緣不考慮基於此方法的內容。</xref:System.Windows.Documents.TextElement>  如果<xref:System.Windows.Documents.TextPointer>位於之前<xref:System.Windows.Documents.TextElement>邊緣，則傳回值是週框方塊的下一個非<xref:System.Windows.Documents.TextElement>內容中指定的方向。</xref:System.Windows.Documents.TextElement> </xref:System.Windows.Documents.TextElement> </xref:System.Windows.Documents.TextPointer>  不是否有任何內容以指定方向，也就是零寬度<xref:System.Windows.Rect>傳回高度比對的高度任何先前的內容。</xref:System.Windows.Rect>       這個方法所執行的作業取決於有效的配置。  必要時，這個方法會嘗試自動重新產生有效的配置，再繼續作業。  重新產生配置可能會相當耗費資源的作業。  使用<xref:System.Windows.Documents.TextPointer.HasValidLayout%2A>屬性來執行作業，可能會重新產生配置前先檢查有效的配置。</xref:System.Windows.Documents.TextPointer.HasValidLayout%2A>  如需詳細資訊，請參閱[配置](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "其中一個<xref href=&quot;System.Windows.Documents.LogicalDirection&quot;></xref>值，指定在其中尋找內容，週框方塊邏輯的方向。"
    return:
      type: System.Windows.Rect
      description: "週框方塊框線目前的內容<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>以指定的方向，或&lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt;目前，有效配置資訊是否無法使用。"
  overload: System.Windows.Documents.TextPointer.GetCharacterRect*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)
  id: GetInsertionPosition(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetInsertionPosition(LogicalDirection)
  nameWithType: TextPointer.GetInsertionPosition(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetInsertionPosition(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "傳回<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>到最接近的插入位置，以指定的邏輯方向。"
  remarks: "插入位置是的位置，而不會中斷任何語意規則相關聯的內容可能會加入新的內容。  在實務上，插入位置是在插入號可能位於所在位置的內容。  有效範例<xref:System.Windows.Documents.TextPointer>不是插入位置的位置是相鄰的兩個位置<xref:System.Windows.Documents.Paragraph>標記 (亦即，在上一段結尾標記之間的下一個段落的開頭標記)。</xref:System.Windows.Documents.Paragraph> </xref:System.Windows.Documents.TextPointer>       如果<xref:System.Windows.Documents.TextPointer>已指向有效的插入位置，但結尾標記為非空白的格式化順序直接遵循該位置，以指定的方向，則<xref:System.Windows.Documents.TextPointer>傳回此方法會調整為指向插入位置，只在格式化序列的關閉之後。</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointer>    例如，請考慮標記序列`<Bold>``a``</Bold>``b`。  請注意，有兩個字母之間的插入位置`a`和`b`— 一個之前關閉`Bold`標籤和一個直接跟在結尾`Bold`標記。  如果上呼叫 GetInsertionPosition<xref:System.Windows.Documents.TextPointer>直接在字母之後的位置`a`之前關閉作業的`Bold`標記，與`direction`的<xref:System.Windows.Documents.LogicalDirection>，傳回<xref:System.Windows.Documents.TextPointer>調整以指向剛才的字母前面的位置`b`，關閉後`Bold`標記。</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.LogicalDirection> </xref:System.Windows.Documents.TextPointer>  會進行類似的調整方向會相反邏輯工作時開啟格式標記。  這個方法會提供類似的情況下的插入位置之間的去除混淆的。       這個方法也可以用於當涉及一連串的結構化的標記是選擇插入點。 例如，在初餘額和期末段落標記之間的位置，當方向參數可用來選取下列段落的開頭處最接近插入點 (藉由指定<xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName>) 或在上一段的結尾 (藉由指定<xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName>)。</xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName> </xref:System.Windows.Documents.LogicalDirection?displayProperty=fullName>       如果指標已經插入位置，並在指定沒有任何相鄰的格式化標記`direction`，傳回<xref:System.Windows.Documents.TextPointer>呼叫<xref:System.Windows.Documents.TextPointer>.</xref:System.Windows.Documents.TextPointer>相同位置的點</xref:System.Windows.Documents.TextPointer>       可能沒有有效的插入位置有存在相對於<xref:System.Windows.Documents.TextPointer>.</xref:System.Windows.Documents.TextPointer>所指向的位置  如果參照的內容在結構上尚未完成，如所示的空白資料表或清單，也可能會發生。  在這種情況下，這個方法只會傳回<xref:System.Windows.Documents.TextPointer>為相同的位置以<xref:System.Windows.Documents.TextPointer>從呼叫這個方法。</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointer>  這個方法一律會傳回有效的<xref:System.Windows.Documents.TextPointer>.</xref:System.Windows.Documents.TextPointer>"
  example:
  - "This example shows how to use the GetInsertionPosition method to check whether a specified <xref:System.Windows.Documents.TextElement> is empty of printable content.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_getinsertionposition)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_getinsertionposition)]"
  syntax:
    content: public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "其中一個<xref href=&quot;System.Windows.Documents.LogicalDirection&quot;></xref>值，指定要在其中搜尋最接近的插入位置的邏輯的方向。"
    return:
      type: System.Windows.Documents.TextPointer
      description: "A <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>到最接近的插入位置，以指定的方向。"
  overload: System.Windows.Documents.TextPointer.GetInsertionPosition*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)
  id: GetLineStartPosition(System.Int32)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetLineStartPosition(Int32)
  nameWithType: TextPointer.GetLineStartPosition(Int32)
  fullName: System.Windows.Documents.TextPointer.GetLineStartPosition(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "傳回<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>來指定相對於目前的行首<xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>。"
  remarks: "如果<xref:System.Windows.Documents.TextPointer>指向模稜兩可的位置，例如，兩行，之間所指定的方向中的行<xref:System.Windows.Documents.TextPointer.LogicalDirection%2A>當做相對的開始行。</xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> </xref:System.Windows.Documents.TextPointer>       這個方法所執行的作業取決於有效的配置。  必要時，這個方法會嘗試自動重新產生有效的配置，再繼續作業。  重新產生配置可能會相當耗費資源的作業。  使用<xref:System.Windows.Documents.TextPointer.HasValidLayout%2A>執行作業，可能會重新產生配置前先檢查有效的配置。</xref:System.Windows.Documents.TextPointer.HasValidLayout%2A>  如需詳細資訊，請參閱[配置](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public System.Windows.Documents.TextPointer GetLineStartPosition (int count);
    parameters:
    - id: count
      type: System.Int32
      description: "判斷要傳回的開始位置的行時，略過的起始行的標記數目。 負數值指定前線條、 0 指定目前的行，以及下列行，指定正數值。"
    return:
      type: System.Windows.Documents.TextPointer
      description: "A <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>指向指定的行首 (與<xref:System.Windows.Documents.TextPointer.LogicalDirection*>設<xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref>)，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果指定的行超出範圍或否則找不到。</xref:System.Windows.Documents.TextPointer.LogicalDirection*>"
  overload: System.Windows.Documents.TextPointer.GetLineStartPosition*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)
  id: GetLineStartPosition(System.Int32,System.Int32@)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetLineStartPosition(Int32,Int32)
  nameWithType: TextPointer.GetLineStartPosition(Int32,Int32)
  fullName: System.Windows.Documents.TextPointer.GetLineStartPosition(Int32,Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "傳回<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>來指定相對於目前的行首<xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>，並報告已略過多少行。"
  remarks: "如果<xref:System.Windows.Documents.TextPointer>指向模稜兩可的位置，例如，兩行，之間所指定的方向中的行<xref:System.Windows.Documents.TextPointer.LogicalDirection%2A>屬性當做相對的開始行。</xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> </xref:System.Windows.Documents.TextPointer>"
  syntax:
    content: public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);
    parameters:
    - id: count
      type: System.Int32
      description: "判斷要傳回的開始位置的行時，略過的起始行的標記數目。 負數值指定前線條、 0 指定目前的行，以及下列行，指定正數值。"
    - id: actualCount
      type: System.Int32
      description: "這個方法傳回時，包含起始的行標記判斷要傳回的開始位置的行時略過的實際數目。  此值可能小於`count`如果的開頭或結尾的內容之前遇到中斷點會略過指定的行數。 這個參數未初始化便傳遞。"
    return:
      type: System.Windows.Documents.TextPointer
      description: "A <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>指向指定的行首 (與<xref:System.Windows.Documents.TextPointer.LogicalDirection*>設<xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref>)，或如果指定的行超出指定的行最接近一行的開頭。</xref:System.Windows.Documents.TextPointer.LogicalDirection*>"
  overload: System.Windows.Documents.TextPointer.GetLineStartPosition*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)
  id: GetNextContextPosition(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetNextContextPosition(LogicalDirection)
  nameWithType: TextPointer.GetNextContextPosition(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetNextContextPosition(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "讓指標回到指定的邏輯方向中的下一個符號。"
  remarks: "下列其中一項會被視為符號:-開頭或結尾標記<xref:System.Windows.Documents.TextElement>項目。</xref:System.Windows.Documents.TextElement>      -<xref:System.Windows.UIElement>項目中包含<xref:System.Windows.Documents.InlineUIContainer>或<xref:System.Windows.Documents.BlockUIContainer>.</xref:System.Windows.Documents.BlockUIContainer> </xref:System.Windows.Documents.InlineUIContainer> </xref:System.Windows.UIElement> a  請注意，這類<xref:System.Windows.UIElement>一律會計算為一個符號，則為任何其他內容或所包含的項目<xref:System.Windows.UIElement>不會計入為符號。</xref:System.Windows.UIElement> </xref:System.Windows.UIElement>      -16 位元[!INCLUDE[TLA#tla_unicode](~/add/includes/ajax-current-ext-md.md)]內文字的字元<xref:System.Windows.Documents.Run>項目。</xref:System.Windows.Documents.Run>       如果下一個符號是否分類為<xref:System.Windows.Documents.TextPointerContext>， <xref:System.Windows.Documents.TextPointerContext>，或<xref:System.Windows.Documents.TextPointerContext>(以<xref:System.Windows.Documents.TextPointer.GetPointerContext%2A>方法)，則<xref:System.Windows.Documents.TextPointer>傳回此方法由一個符號進階從目前的位置。</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> </xref:System.Windows.Documents.TextPointerContext> </xref:System.Windows.Documents.TextPointerContext> </xref:System.Windows.Documents.TextPointerContext>       如果下一個符號是否分類為<xref:System.Windows.Documents.TextPointerContext>，然後在<xref:System.Windows.Documents.TextPointer>傳回此方法會超過文字前進至下一個非文字符號 (也就是下一個位置<xref:System.Windows.Documents.TextPointerContext>不<xref:System.Windows.Documents.TextPointerContext>)。</xref:System.Windows.Documents.TextPointerContext> </xref:System.Windows.Documents.TextPointerContext> </xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointerContext>  確切的符號計數已超過可以事先計算方式是呼叫<xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A>方法。</xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A>"
  example:
  - "The following example demonstrates a use for this method.  The example uses the GetNextContextPosition method in conjunction with the <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> method to traverse and extract the symbols in a specified <xref:System.Windows.Documents.TextElement>.  \n  \n While the example can be used to extract a [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] structure for the contents of a given <xref:System.Windows.Documents.TextElement>, it is intended for illustrative purposes only, and should not be used in production code.  See the <xref:System.Xml> namespace for a rich set of types designed for working with and processing XML.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_getnextcontextposition)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_getnextcontextposition)]"
  syntax:
    content: public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "其中一個<xref href=&quot;System.Windows.Documents.LogicalDirection&quot;></xref>值，指定要在其中搜尋下一個符號邏輯的方向。"
    return:
      type: System.Windows.Documents.TextPointer
      description: "A <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>到要求的方向的下一個符號或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果目前<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>框線的開始或結束內容。"
  overload: System.Windows.Documents.TextPointer.GetNextContextPosition*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)
  id: GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetNextInsertionPosition(LogicalDirection)
  nameWithType: TextPointer.GetNextInsertionPosition(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetNextInsertionPosition(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "傳回<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>的下一個的插入位置，以指定的邏輯方向。"
  remarks: "*插入位置*位置，而不會中斷任何語意規則相關聯的內容可能會加入新的內容。  在實務上，插入位置是在插入號可能位於所在位置的內容。  有效範例<xref:System.Windows.Documents.TextPointer>不是插入位置的位置是相鄰的兩個位置<xref:System.Windows.Documents.Paragraph>標記 (亦即，在上一段結尾標記之間的下一個段落的開頭標記)。</xref:System.Windows.Documents.Paragraph> </xref:System.Windows.Documents.TextPointer>"
  example:
  - "The following example demonstrates a use for this method. The example uses the GetNextInsertionPosition method to traverse content element boundaries in order to count the number of <xref:System.Windows.Documents.Paragraph> elements present between two specified <xref:System.Windows.Documents.TextPointer> instances.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_getnextinsertionposition)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_getnextinsertionposition)]"
  syntax:
    content: public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "其中一個<xref href=&quot;System.Windows.Documents.LogicalDirection&quot;></xref>值，指定要在其中搜尋下一個的插入位置的邏輯的方向。"
    return:
      type: System.Windows.Documents.TextPointer
      description: "A <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>識別要求的方向下, 一步的插入位置或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果找不到任何下一步的插入位置。"
  overload: System.Windows.Documents.TextPointer.GetNextInsertionPosition*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)
  id: GetOffsetToPosition(System.Windows.Documents.TextPointer)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetOffsetToPosition(TextPointer)
  nameWithType: TextPointer.GetOffsetToPosition(TextPointer)
  fullName: System.Windows.Documents.TextPointer.GetOffsetToPosition(TextPointer)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "傳回的符號計數之間目前<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>和第二個指定<xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>。"
  remarks: "下列其中一項會被視為符號:-開頭或結尾標記<xref:System.Windows.Documents.TextElement>項目。</xref:System.Windows.Documents.TextElement>      -<xref:System.Windows.UIElement>項目中包含<xref:System.Windows.Documents.InlineUIContainer>或<xref:System.Windows.Documents.BlockUIContainer>.</xref:System.Windows.Documents.BlockUIContainer> </xref:System.Windows.Documents.InlineUIContainer> </xref:System.Windows.UIElement> a  請注意，這類<xref:System.Windows.UIElement>一律會計算為一個符號，則為任何其他內容或所包含的項目<xref:System.Windows.UIElement>不會計入為符號。</xref:System.Windows.UIElement> </xref:System.Windows.UIElement>      -16 位元[!INCLUDE[TLA#tla_unicode](~/add/includes/ajax-current-ext-md.md)]內文字的字元<xref:System.Windows.Documents.Run>項目。</xref:System.Windows.Documents.Run>"
  example:
  - "The following example demonstrates a use for this method. The example uses the GetOffsetToPosition method to find the offsets for two <xref:System.Windows.Documents.TextPointer> instances, and then uses this information to save and restore the selection in a <xref:System.Windows.Controls.RichTextBox>.  The example assumes that the contents of the <xref:System.Windows.Controls.RichTextBox> have not changed between a selection save and a selection restore.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_getoffsettoposition)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_getoffsettoposition)]"
  syntax:
    content: public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);
    parameters:
    - id: position
      type: System.Windows.Documents.TextPointer
      description: "A <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> ，指定要尋找的距離 （以符號） 的位置。"
    return:
      type: System.Int32
      description: "相對的數字的符號之間目前<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>和<code> position </code>。  負數的值，指出目前<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>遵循所指定的位置<code> position </code>，0 表示位置相等，而正數的值，指出目前<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>所指定的位置之前<code> position </code>。"
  overload: System.Windows.Documents.TextPointer.GetOffsetToPosition*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>position</code>指定目前的位置與相關聯的文字容器之外的位置。"
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)
  id: GetPointerContext(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetPointerContext(LogicalDirection)
  nameWithType: TextPointer.GetPointerContext(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetPointerContext(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "傳回內容的類別指標至目前相鄰<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>以指定的邏輯方向。"
  remarks: ''
  example:
  - "The following example demonstrates a use for this method. The example uses the GetPointerContext method to implement an algorithm for calculating the balance of opening and closing element tags between two specified <xref:System.Windows.Documents.TextPointer> positions.  Each opening element tag is counted as +1, and each closing element tag is counted as –1.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_getoffsettoposition2)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_getoffsettoposition2)]"
  syntax:
    content: public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "其中一個<xref href=&quot;System.Windows.Documents.LogicalDirection&quot;></xref>值，指定邏輯的方向，以決定相鄰內容類別。"
    return:
      type: System.Windows.Documents.TextPointerContext
      description: "其中一個<xref href=&quot;System.Windows.Documents.TextPointerContext&quot;></xref>值，表示相鄰的內容，以指定的邏輯方向的分類。"
  overload: System.Windows.Documents.TextPointer.GetPointerContext*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)
  id: GetPositionAtOffset(System.Int32)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetPositionAtOffset(Int32)
  nameWithType: TextPointer.GetPositionAtOffset(Int32)
  fullName: System.Windows.Documents.TextPointer.GetPositionAtOffset(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "傳回<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>至指定的位移，符號，從目前的開頭中所指定的位置<xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>。"
  remarks: "下列其中一項會被視為符號:-開頭或結尾標記<xref:System.Windows.Documents.TextElement>項目。</xref:System.Windows.Documents.TextElement>      -<xref:System.Windows.UIElement>項目中包含<xref:System.Windows.Documents.InlineUIContainer>或<xref:System.Windows.Documents.BlockUIContainer>.</xref:System.Windows.Documents.BlockUIContainer> </xref:System.Windows.Documents.InlineUIContainer> </xref:System.Windows.UIElement> a  請注意，這類<xref:System.Windows.UIElement>一律會計算為一個符號，則為任何其他內容或所包含的項目<xref:System.Windows.UIElement>不會計入為符號。</xref:System.Windows.UIElement> </xref:System.Windows.UIElement>      -16 位元[!INCLUDE[TLA#tla_unicode](~/add/includes/ajax-current-ext-md.md)]內文字的字元<xref:System.Windows.Documents.Run>項目。</xref:System.Windows.Documents.Run>"
  example:
  - "The following example demonstrates a use for this method. The example uses the GetPositionAtOffset method to implement a pair of methods, one to calculate the offset to a specified position relative to any hosting paragraph, and the other to return a <xref:System.Windows.Documents.TextPointer> to a specified offset in a specified paragraph.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_getpositionatoffset)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_getpositionatoffset)]"
  syntax:
    content: public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);
    parameters:
    - id: offset
      type: System.Int32
      description: "以符號，這是要計算並傳回位置的位移。  位置位移為負數，如果計算中所指出的相反邏輯方向<xref:System.Windows.Documents.TextPointer.LogicalDirection*>屬性。</xref:System.Windows.Documents.TextPointer.LogicalDirection*>"
    return:
      type: System.Windows.Documents.TextPointer
      description: "A <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>至指定的位移所指定的位置或<xref uid=&quot;langword_csharp_ null &quot; name=&quot; null &quot; href=&quot;&quot;></xref>如果找不到任何對應的位置。"
  overload: System.Windows.Documents.TextPointer.GetPositionAtOffset*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)
  id: GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetPositionAtOffset(Int32,LogicalDirection)
  nameWithType: TextPointer.GetPositionAtOffset(Int32,LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetPositionAtOffset(Int32,LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "傳回<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>至指定的位移，符號，從目前的開頭中所指定的位置<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>和指定的方向。"
  remarks: "下列其中一項會被視為符號:-開頭或結尾標記<xref:System.Windows.Documents.TextElement>項目。</xref:System.Windows.Documents.TextElement>      -<xref:System.Windows.UIElement>項目中包含<xref:System.Windows.Documents.InlineUIContainer>或<xref:System.Windows.Documents.BlockUIContainer>.</xref:System.Windows.Documents.BlockUIContainer> </xref:System.Windows.Documents.InlineUIContainer> </xref:System.Windows.UIElement> a  請注意，這類<xref:System.Windows.UIElement>一律會計算為一個符號，則為任何其他內容或所包含的項目<xref:System.Windows.UIElement>不會計入為符號。</xref:System.Windows.UIElement> </xref:System.Windows.UIElement>      -16 位元[!INCLUDE[TLA#tla_unicode](~/add/includes/ajax-current-ext-md.md)]內文字的字元<xref:System.Windows.Documents.Run>項目。</xref:System.Windows.Documents.Run>"
  syntax:
    content: public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: offset
      type: System.Int32
      description: "以符號，這是要計算並傳回位置的位移。  如果位移為負數，傳回<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>位於目前<xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>; 否則它會遵循。"
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "其中一個<xref href=&quot;System.Windows.Documents.LogicalDirection&quot;></xref>值，指定傳回之邏輯的方向<xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>。"
    return:
      type: System.Windows.Documents.TextPointer
      description: "A <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>至指定的位移所指定的位置或<xref uid=&quot;langword_csharp_ null &quot; name=&quot; null &quot; href=&quot;&quot;></xref>如果位移超出內容的結尾。"
  overload: System.Windows.Documents.TextPointer.GetPositionAtOffset*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)
  id: GetTextInRun(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetTextInRun(LogicalDirection)
  nameWithType: TextPointer.GetTextInRun(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetTextInRun(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "傳回字串，包含要與目前鄰近的任何文字<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>以指定的邏輯方向。"
  remarks: "這個方法會傳回只執行不中斷的執行的文字。  如果任何符號類型以外，不會傳回<xref:System.Windows.Documents.TextPointerContext>相鄰目前<xref:System.Windows.Documents.TextPointer>中指定的方向。</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointerContext>  同樣地，文字只會傳回至下一個非文字符號。"
  example:
  - "The following example demonstrates a use for this method. The example uses the GetTextInRun method to implement a simple text extractor.  The method returns a string concatenation of all text between two specified <xref:System.Windows.Documents.TextPointer> instances.  \n  \n While the example can be used to extract any text between two <xref:System.Windows.Documents.TextPointer> instances, it is intended for illustrative purposes only, and should not be used in production code.  Use the <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=fullName> property instead.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_GetTextInRun](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_gettextinrun)]\n [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_gettextinrun)]"
  syntax:
    content: public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "其中一個<xref href=&quot;System.Windows.Documents.LogicalDirection&quot;></xref>指定邏輯，以尋找並傳回任何相鄰的文字方向的值。"
    return:
      type: System.String
      description: "字串，包含任何相鄰的文字，以指定的邏輯方向，或&lt;xref:System.String?displayProperty=fullName&gt;如果找不到任何相鄰的文字。"
  overload: System.Windows.Documents.TextPointer.GetTextInRun*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)
  id: GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetTextInRun(LogicalDirection,Char[],Int32,Int32)
  nameWithType: TextPointer.GetTextInRun(LogicalDirection,Char[],Int32,Int32)
  fullName: System.Windows.Documents.TextPointer.GetTextInRun(LogicalDirection,Char[],Int32,Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "將指定的最大字元數複製從任何相鄰的文字，以指定的方向為呼叫端提供的字元陣列。"
  remarks: "這個方法會傳回只執行不中斷的執行的文字。  如果任何符號類型以外，不會傳回<xref:System.Windows.Documents.TextPointerContext>相鄰目前<xref:System.Windows.Documents.TextPointer>中指定的方向。</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointerContext>  同樣地，文字只會傳回至下一個非文字符號。"
  syntax:
    content: public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "其中一個<xref href=&quot;System.Windows.Documents.LogicalDirection&quot;></xref>指定邏輯，以尋找並複製任何相鄰的文字方向的值。"
    - id: textBuffer
      type: System.Char[]
      description: "複製到其中的任何文字緩衝區。"
    - id: startIndex
      type: System.Int32
      description: "中的索引`textBuffer`中要開始複製的書寫文字。"
    - id: count
      type: System.Int32
      description: "要複製的字元數目上限。"
    return:
      type: System.Int32
      description: "實際複製的字元數<code> textBuffer </code>。"
  overload: System.Windows.Documents.TextPointer.GetTextInRun*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>startIndex</code>小於 0 或大於<xref:System.Array.Length*>屬性<code>textBuffer</code>。       -<code>count</code>小於 0 或大於區內的剩餘空間<code>textBuffer</code>(<code>textBuffer</code>。<xref:System.Array.Length*> 減<code>startIndex</code>)。"
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)
  id: GetTextRunLength(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: GetTextRunLength(LogicalDirection)
  nameWithType: TextPointer.GetTextRunLength(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetTextRunLength(LogicalDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "傳回目前之間的 Unicode 字元數<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>和下一步的非文字符號，以指定的邏輯方向。"
  remarks: "下列其中一項會被視為符號:-開頭或結尾標記<xref:System.Windows.Documents.TextElement>項目。</xref:System.Windows.Documents.TextElement>      -<xref:System.Windows.UIElement>項目中包含<xref:System.Windows.Documents.InlineUIContainer>或<xref:System.Windows.Documents.BlockUIContainer>.</xref:System.Windows.Documents.BlockUIContainer> </xref:System.Windows.Documents.InlineUIContainer> </xref:System.Windows.UIElement> a  請注意，這類<xref:System.Windows.UIElement>一律會計算為一個符號，則為任何其他內容或所包含的項目<xref:System.Windows.UIElement>不會計入為符號。</xref:System.Windows.UIElement> </xref:System.Windows.UIElement>      -16 位元[!INCLUDE[TLA#tla_unicode](~/add/includes/ajax-current-ext-md.md)]內文字的字元<xref:System.Windows.Documents.Run>項目。</xref:System.Windows.Documents.Run>"
  syntax:
    content: public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Documents.LogicalDirection
      description: "其中一個<xref href=&quot;System.Windows.Documents.LogicalDirection&quot;></xref>值，指定要在其中計算的字元數邏輯的方向。"
    return:
      type: System.Int32
      description: "目前之間的 Unicode 字元的數目<xref href=&quot;System.Windows.Documents.TextPointer&quot;></xref>和下一個非文字符號。  這個數字可能是 0，如果沒有相鄰的文字。"
  overload: System.Windows.Documents.TextPointer.GetTextRunLength*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.HasValidLayout
  id: HasValidLayout
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: HasValidLayout
  nameWithType: TextPointer.HasValidLayout
  fullName: System.Windows.Documents.TextPointer.HasValidLayout
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "取得值，指出目前的位置與相關聯的文字容器是否具有有效 （最新） 的配置。"
  remarks: "如有必要，取決於有效的配置的作業 (例如<xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A>方法，<xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A>方法，和<xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A>屬性) 嘗試自動重新產生有效的配置，再繼續作業。</xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> </xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> </xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A>  重新產生配置可能會相當耗費資源的作業。  使用這個屬性來執行作業，可能會重新產生配置前先檢查有效的配置。  如需詳細資訊，請參閱[配置](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public bool HasValidLayout { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果版面配置是最新且有效。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Documents.TextPointer.HasValidLayout*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.InsertLineBreak
  id: InsertLineBreak
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: InsertLineBreak()
  nameWithType: TextPointer.InsertLineBreak()
  fullName: System.Windows.Documents.TextPointer.InsertLineBreak()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "在目前的位置插入分行符號。"
  syntax:
    content: public System.Windows.Documents.TextPointer InsertLineBreak ();
    parameters: []
    return:
      type: System.Windows.Documents.TextPointer
      description: "A <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>放置之後立即<xref href=&quot;System.Windows.Documents.LineBreak&quot;></xref>這個方法所插入的項目。"
  overload: System.Windows.Documents.TextPointer.InsertLineBreak*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.InsertParagraphBreak
  id: InsertParagraphBreak
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: InsertParagraphBreak()
  nameWithType: TextPointer.InsertParagraphBreak()
  fullName: System.Windows.Documents.TextPointer.InsertParagraphBreak()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "在目前的位置插入分段符號。"
  remarks: "如果目前的位置內的現有時，呼叫此方法<xref:System.Windows.Documents.Paragraph>項目、 現有段落和它所包含的任何內容，已分成兩個段落，目前的位置。</xref:System.Windows.Documents.Paragraph>  如果目前的位置不在現有的段落內時呼叫這個方法時，會插入新的空白段落。  如果這個方法呼叫的位置不適合進行分割，或插入段落 (例如，如果目前的位置是在<xref:System.Windows.Documents.Hyperlink>項目)，會擲回例外狀況。</xref:System.Windows.Documents.Hyperlink>"
  syntax:
    content: public System.Windows.Documents.TextPointer InsertParagraphBreak ();
    parameters: []
    return:
      type: System.Windows.Documents.TextPointer
      description: "A <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref>開頭 (<xref:System.Windows.Documents.TextElement.ContentStart*>) 的新的段落。</xref:System.Windows.Documents.TextElement.ContentStart*>"
  overload: System.Windows.Documents.TextPointer.InsertParagraphBreak*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無法以容納新的段落，例如，範圍中的分割位置呼叫這個方法<xref href=&quot;System.Windows.Documents.Hyperlink&quot;></xref>或<xref href=&quot;System.Windows.Documents.InlineUIContainer&quot;> </xref>。"
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.InsertTextInRun(System.String)
  id: InsertTextInRun(System.String)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: InsertTextInRun(String)
  nameWithType: TextPointer.InsertTextInRun(String)
  fullName: System.Windows.Documents.TextPointer.InsertTextInRun(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "將指定的文字插入至文字<xref href=&quot;System.Windows.Documents.Run&quot;></xref>在目前的位置。"
  remarks: "如果<xref:System.Windows.Documents.TextPointer>範圍不是由<xref:System.Windows.Documents.Run>項目，<xref:System.Windows.Documents.Run>插入連同`textData`。</xref:System.Windows.Documents.Run> </xref:System.Windows.Documents.Run> </xref:System.Windows.Documents.TextPointer>"
  syntax:
    content: public void InsertTextInRun (string textData);
    parameters:
    - id: textData
      type: System.String
      description: "要插入的文字。"
  overload: System.Windows.Documents.TextPointer.InsertTextInRun*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "目前的位置不在<xref href=&quot;System.Windows.Documents.Run&quot;></xref>項目。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>textData</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.IsAtInsertionPosition
  id: IsAtInsertionPosition
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: IsAtInsertionPosition
  nameWithType: TextPointer.IsAtInsertionPosition
  fullName: System.Windows.Documents.TextPointer.IsAtInsertionPosition
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "取得值，指出目前位置是否為插入位置。"
  remarks: "插入位置是的位置，而不會中斷任何語意規則相關聯的內容可能會加入新的內容。  在實務上，插入位置是在插入號可能位於所在位置的內容。  有效範例<xref:System.Windows.Documents.TextPointer>不是插入位置的位置是相鄰的兩個位置<xref:System.Windows.Documents.Paragraph>標記 (亦即，在上一段結尾標記之間的下一個段落的開頭標記)。</xref:System.Windows.Documents.Paragraph> </xref:System.Windows.Documents.TextPointer>"
  syntax:
    content: public bool IsAtInsertionPosition { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果目前的位置插入位置。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Documents.TextPointer.IsAtInsertionPosition*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.IsAtLineStartPosition
  id: IsAtLineStartPosition
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: IsAtLineStartPosition
  nameWithType: TextPointer.IsAtLineStartPosition
  fullName: System.Windows.Documents.TextPointer.IsAtLineStartPosition
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "取得值，指出目前的位置是否在一行的開頭。"
  remarks: "如果<xref:System.Windows.Documents.TextPointer>指向模稜兩可的位置，例如，兩行，之間所指定的方向中的行<xref:System.Windows.Documents.TextPointer.LogicalDirection%2A>屬性當做相對的開始行。</xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> </xref:System.Windows.Documents.TextPointer>       這個屬性所執行的作業取決於有效的配置。  必要時，這個方法會嘗試自動重新產生有效的配置，再繼續作業。  重新產生配置可能會相當耗費資源的作業。  使用<xref:System.Windows.Documents.TextPointer.HasValidLayout%2A>屬性來執行作業，可能會重新產生配置前先檢查有效的配置。</xref:System.Windows.Documents.TextPointer.HasValidLayout%2A>  如需詳細資訊，請參閱[配置](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public bool IsAtLineStartPosition { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果目前位置的行開頭否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Documents.TextPointer.IsAtLineStartPosition*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)
  id: IsInSameDocument(System.Windows.Documents.TextPointer)
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: IsInSameDocument(TextPointer)
  nameWithType: TextPointer.IsInSameDocument(TextPointer)
  fullName: System.Windows.Documents.TextPointer.IsInSameDocument(TextPointer)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "指出是否為目前的位置相同的文字容器中指定的位置。"
  remarks: "大部分的作業牽涉到多個<xref:System.Windows.Documents.TextPointer>執行個體才有效，如果有問題的執行個體表示相同的文字容器範圍中的位置。</xref:System.Windows.Documents.TextPointer>  例如<xref:System.Windows.Documents.TextPointer.CompareTo%2A>和<xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A>方法不能與<xref:System.Windows.Documents.TextPointer>到目前的位置與相關聯的文字容器之外的位置。</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> </xref:System.Windows.Documents.TextPointer.CompareTo%2A>  使用這個方法可讓您確認指定<xref:System.Windows.Documents.TextPointer>與這類作業的目前位置相容。</xref:System.Windows.Documents.TextPointer>"
  example:
  - "The following example demonstrates a use for this method.  The example uses the IsInSameDocument method to check whether a specified <xref:System.Windows.Documents.TextPointer> is positioned between two other specified <xref:System.Windows.Documents.TextPointer> instances in a situation when there is no guarantee that all three positions belong to the same text container.  \n  \n [!code-cs[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#_textpointer_isinsamedocument)]\n [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#_textpointer_isinsamedocument)]"
  syntax:
    content: public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);
    parameters:
    - id: textPosition
      type: System.Windows.Documents.TextPointer
      description: "A <xref href=&quot;System.Windows.Documents.TextPointer&quot;> </xref> ，指定要比較的目前位置的位置。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<code> textPosition </code>指出的位置時，在相同的文字容器中與目前的位置; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Documents.TextPointer.IsInSameDocument*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>textPosition</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.LogicalDirection
  id: LogicalDirection
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: LogicalDirection
  nameWithType: TextPointer.LogicalDirection
  fullName: System.Windows.Documents.TextPointer.LogicalDirection
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "取得與目前用來區分目前位置相關聯的內容所在位置相關聯的邏輯方向。"
  remarks: "如何使用這個屬性，例如<xref:System.Windows.Documents.LogicalDirection>的<xref:System.Windows.Documents.TextPointer>傳回點擊測試方法會將兩個字元的文字之間叫用。</xref:System.Windows.Documents.TextPointer> </xref:System.Windows.Documents.LogicalDirection> 邏輯方向指定這兩個字元的實際點擊 — 左邊或右邊。"
  syntax:
    content: public System.Windows.Documents.LogicalDirection LogicalDirection { get; }
    return:
      type: System.Windows.Documents.LogicalDirection
      description: "<xref href=&quot;System.Windows.Documents.LogicalDirection&quot;> </xref>目前的位置與相關聯的值。"
  overload: System.Windows.Documents.TextPointer.LogicalDirection*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.Paragraph
  id: Paragraph
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: Paragraph
  nameWithType: TextPointer.Paragraph
  fullName: System.Windows.Documents.TextPointer.Paragraph
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "如果有的話，請取得範圍的目前位置的段落。"
  syntax:
    content: public System.Windows.Documents.Paragraph Paragraph { get; }
    return:
      type: System.Windows.Documents.Paragraph
      description: "<xref href=&quot;System.Windows.Documents.Paragraph&quot;> </xref>的範圍目前的位置，或<xref uid=&quot;langword_csharp_ null &quot; name=&quot; null &quot; href=&quot;&quot;></xref>如果沒有這類段落存在。"
  overload: System.Windows.Documents.TextPointer.Paragraph*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.Parent
  id: Parent
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: Parent
  nameWithType: TextPointer.Parent
  fullName: System.Windows.Documents.TextPointer.Parent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "取得範圍的目前位置的邏輯父代。"
  syntax:
    content: public System.Windows.DependencyObject Parent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "範圍的目前位置邏輯父代。"
  overload: System.Windows.Documents.TextPointer.Parent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Documents.TextPointer.ToString
  id: ToString
  parent: System.Windows.Documents.TextPointer
  langs:
  - csharp
  name: ToString()
  nameWithType: TextPointer.ToString()
  fullName: System.Windows.Documents.TextPointer.ToString()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows.Documents
  summary: "這個類型或成員支援[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]基礎結構，不適合直接從您的程式碼使用。"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "代表物件的字串。"
  overload: System.Windows.Documents.TextPointer.ToString*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Documents.ContentPosition
  isExternal: false
  name: System.Windows.Documents.ContentPosition
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: CompareTo(TextPointer)
  nameWithType: TextPointer.CompareTo(TextPointer)
  fullName: System.Windows.Documents.TextPointer.CompareTo(TextPointer)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Documents.TextPointer
  parent: System.Windows.Documents
  isExternal: false
  name: TextPointer
  nameWithType: TextPointer
  fullName: System.Windows.Documents.TextPointer
- uid: System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: DeleteTextInRun(Int32)
  nameWithType: TextPointer.DeleteTextInRun(Int32)
  fullName: System.Windows.Documents.TextPointer.DeleteTextInRun(Int32)
- uid: System.Windows.Documents.TextPointer.DocumentEnd
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: DocumentEnd
  nameWithType: TextPointer.DocumentEnd
  fullName: System.Windows.Documents.TextPointer.DocumentEnd
- uid: System.Windows.Documents.TextPointer.DocumentStart
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: DocumentStart
  nameWithType: TextPointer.DocumentStart
  fullName: System.Windows.Documents.TextPointer.DocumentStart
- uid: System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetAdjacentElement(LogicalDirection)
  nameWithType: TextPointer.GetAdjacentElement(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetAdjacentElement(LogicalDirection)
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.Documents.LogicalDirection
  parent: System.Windows.Documents
  isExternal: false
  name: LogicalDirection
  nameWithType: LogicalDirection
  fullName: System.Windows.Documents.LogicalDirection
- uid: System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetCharacterRect(LogicalDirection)
  nameWithType: TextPointer.GetCharacterRect(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetCharacterRect(LogicalDirection)
- uid: System.Windows.Rect
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
- uid: System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetInsertionPosition(LogicalDirection)
  nameWithType: TextPointer.GetInsertionPosition(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetInsertionPosition(LogicalDirection)
- uid: System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetLineStartPosition(Int32)
  nameWithType: TextPointer.GetLineStartPosition(Int32)
  fullName: System.Windows.Documents.TextPointer.GetLineStartPosition(Int32)
- uid: System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetLineStartPosition(Int32,Int32)
  nameWithType: TextPointer.GetLineStartPosition(Int32,Int32)
  fullName: System.Windows.Documents.TextPointer.GetLineStartPosition(Int32,Int32)
- uid: System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetNextContextPosition(LogicalDirection)
  nameWithType: TextPointer.GetNextContextPosition(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetNextContextPosition(LogicalDirection)
- uid: System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetNextInsertionPosition(LogicalDirection)
  nameWithType: TextPointer.GetNextInsertionPosition(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetNextInsertionPosition(LogicalDirection)
- uid: System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetOffsetToPosition(TextPointer)
  nameWithType: TextPointer.GetOffsetToPosition(TextPointer)
  fullName: System.Windows.Documents.TextPointer.GetOffsetToPosition(TextPointer)
- uid: System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetPointerContext(LogicalDirection)
  nameWithType: TextPointer.GetPointerContext(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetPointerContext(LogicalDirection)
- uid: System.Windows.Documents.TextPointerContext
  parent: System.Windows.Documents
  isExternal: false
  name: TextPointerContext
  nameWithType: TextPointerContext
  fullName: System.Windows.Documents.TextPointerContext
- uid: System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetPositionAtOffset(Int32)
  nameWithType: TextPointer.GetPositionAtOffset(Int32)
  fullName: System.Windows.Documents.TextPointer.GetPositionAtOffset(Int32)
- uid: System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetPositionAtOffset(Int32,LogicalDirection)
  nameWithType: TextPointer.GetPositionAtOffset(Int32,LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetPositionAtOffset(Int32,LogicalDirection)
- uid: System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetTextInRun(LogicalDirection)
  nameWithType: TextPointer.GetTextInRun(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetTextInRun(LogicalDirection)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetTextInRun(LogicalDirection,Char[],Int32,Int32)
  nameWithType: TextPointer.GetTextInRun(LogicalDirection,Char[],Int32,Int32)
  fullName: System.Windows.Documents.TextPointer.GetTextInRun(LogicalDirection,Char[],Int32,Int32)
- uid: System.Char[]
  parent: System
  isExternal: true
  name: Char
  nameWithType: Char
  fullName: System.Char[]
  spec.csharp:
  - uid: System.Char
    name: Char
    nameWithType: Char
    fullName: Char[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetTextRunLength(LogicalDirection)
  nameWithType: TextPointer.GetTextRunLength(LogicalDirection)
  fullName: System.Windows.Documents.TextPointer.GetTextRunLength(LogicalDirection)
- uid: System.Windows.Documents.TextPointer.HasValidLayout
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: HasValidLayout
  nameWithType: TextPointer.HasValidLayout
  fullName: System.Windows.Documents.TextPointer.HasValidLayout
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Documents.TextPointer.InsertLineBreak
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: InsertLineBreak()
  nameWithType: TextPointer.InsertLineBreak()
  fullName: System.Windows.Documents.TextPointer.InsertLineBreak()
- uid: System.Windows.Documents.TextPointer.InsertParagraphBreak
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: InsertParagraphBreak()
  nameWithType: TextPointer.InsertParagraphBreak()
  fullName: System.Windows.Documents.TextPointer.InsertParagraphBreak()
- uid: System.Windows.Documents.TextPointer.InsertTextInRun(System.String)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: InsertTextInRun(String)
  nameWithType: TextPointer.InsertTextInRun(String)
  fullName: System.Windows.Documents.TextPointer.InsertTextInRun(String)
- uid: System.Windows.Documents.TextPointer.IsAtInsertionPosition
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: IsAtInsertionPosition
  nameWithType: TextPointer.IsAtInsertionPosition
  fullName: System.Windows.Documents.TextPointer.IsAtInsertionPosition
- uid: System.Windows.Documents.TextPointer.IsAtLineStartPosition
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: IsAtLineStartPosition
  nameWithType: TextPointer.IsAtLineStartPosition
  fullName: System.Windows.Documents.TextPointer.IsAtLineStartPosition
- uid: System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: IsInSameDocument(TextPointer)
  nameWithType: TextPointer.IsInSameDocument(TextPointer)
  fullName: System.Windows.Documents.TextPointer.IsInSameDocument(TextPointer)
- uid: System.Windows.Documents.TextPointer.LogicalDirection
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: LogicalDirection
  nameWithType: TextPointer.LogicalDirection
  fullName: System.Windows.Documents.TextPointer.LogicalDirection
- uid: System.Windows.Documents.TextPointer.Paragraph
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: Paragraph
  nameWithType: TextPointer.Paragraph
  fullName: System.Windows.Documents.TextPointer.Paragraph
- uid: System.Windows.Documents.Paragraph
  parent: System.Windows.Documents
  isExternal: false
  name: Paragraph
  nameWithType: Paragraph
  fullName: System.Windows.Documents.Paragraph
- uid: System.Windows.Documents.TextPointer.Parent
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: Parent
  nameWithType: TextPointer.Parent
  fullName: System.Windows.Documents.TextPointer.Parent
- uid: System.Windows.Documents.TextPointer.ToString
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: ToString()
  nameWithType: TextPointer.ToString()
  fullName: System.Windows.Documents.TextPointer.ToString()
- uid: System.Windows.Documents.TextPointer.CompareTo*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: CompareTo
  nameWithType: TextPointer.CompareTo
- uid: System.Windows.Documents.TextPointer.DeleteTextInRun*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: DeleteTextInRun
  nameWithType: TextPointer.DeleteTextInRun
- uid: System.Windows.Documents.TextPointer.DocumentEnd*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: DocumentEnd
  nameWithType: TextPointer.DocumentEnd
- uid: System.Windows.Documents.TextPointer.DocumentStart*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: DocumentStart
  nameWithType: TextPointer.DocumentStart
- uid: System.Windows.Documents.TextPointer.GetAdjacentElement*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetAdjacentElement
  nameWithType: TextPointer.GetAdjacentElement
- uid: System.Windows.Documents.TextPointer.GetCharacterRect*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetCharacterRect
  nameWithType: TextPointer.GetCharacterRect
- uid: System.Windows.Documents.TextPointer.GetInsertionPosition*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetInsertionPosition
  nameWithType: TextPointer.GetInsertionPosition
- uid: System.Windows.Documents.TextPointer.GetLineStartPosition*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetLineStartPosition
  nameWithType: TextPointer.GetLineStartPosition
- uid: System.Windows.Documents.TextPointer.GetNextContextPosition*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetNextContextPosition
  nameWithType: TextPointer.GetNextContextPosition
- uid: System.Windows.Documents.TextPointer.GetNextInsertionPosition*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetNextInsertionPosition
  nameWithType: TextPointer.GetNextInsertionPosition
- uid: System.Windows.Documents.TextPointer.GetOffsetToPosition*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetOffsetToPosition
  nameWithType: TextPointer.GetOffsetToPosition
- uid: System.Windows.Documents.TextPointer.GetPointerContext*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetPointerContext
  nameWithType: TextPointer.GetPointerContext
- uid: System.Windows.Documents.TextPointer.GetPositionAtOffset*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetPositionAtOffset
  nameWithType: TextPointer.GetPositionAtOffset
- uid: System.Windows.Documents.TextPointer.GetTextInRun*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetTextInRun
  nameWithType: TextPointer.GetTextInRun
- uid: System.Windows.Documents.TextPointer.GetTextRunLength*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: GetTextRunLength
  nameWithType: TextPointer.GetTextRunLength
- uid: System.Windows.Documents.TextPointer.HasValidLayout*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: HasValidLayout
  nameWithType: TextPointer.HasValidLayout
- uid: System.Windows.Documents.TextPointer.InsertLineBreak*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: InsertLineBreak
  nameWithType: TextPointer.InsertLineBreak
- uid: System.Windows.Documents.TextPointer.InsertParagraphBreak*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: InsertParagraphBreak
  nameWithType: TextPointer.InsertParagraphBreak
- uid: System.Windows.Documents.TextPointer.InsertTextInRun*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: InsertTextInRun
  nameWithType: TextPointer.InsertTextInRun
- uid: System.Windows.Documents.TextPointer.IsAtInsertionPosition*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: IsAtInsertionPosition
  nameWithType: TextPointer.IsAtInsertionPosition
- uid: System.Windows.Documents.TextPointer.IsAtLineStartPosition*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: IsAtLineStartPosition
  nameWithType: TextPointer.IsAtLineStartPosition
- uid: System.Windows.Documents.TextPointer.IsInSameDocument*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: IsInSameDocument
  nameWithType: TextPointer.IsInSameDocument
- uid: System.Windows.Documents.TextPointer.LogicalDirection*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: LogicalDirection
  nameWithType: TextPointer.LogicalDirection
- uid: System.Windows.Documents.TextPointer.Paragraph*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: Paragraph
  nameWithType: TextPointer.Paragraph
- uid: System.Windows.Documents.TextPointer.Parent*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: Parent
  nameWithType: TextPointer.Parent
- uid: System.Windows.Documents.TextPointer.ToString*
  parent: System.Windows.Documents.TextPointer
  isExternal: false
  name: ToString
  nameWithType: TextPointer.ToString
