### YamlMime:ManagedReference
items:
- uid: System.Threading.ThreadPool
  id: ThreadPool
  children:
  - System.Threading.ThreadPool.BindHandle(System.IntPtr)
  - System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  - System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  - System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  - System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  - System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  - System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  - System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  langs:
  - csharp
  name: ThreadPool
  nameWithType: ThreadPool
  fullName: System.Threading.ThreadPool
  type: Class
  summary: "提供執行緒集區，可用來執行工作、 張貼工作項目、 處理非同步 I/O、 代表其他執行緒等候，以及處理計時器。"
  remarks: "許多應用程式建立大部分的時間在睡眠狀態，等候事件發生的執行緒。 其他執行緒可能會進入休眠狀態，才能定期喚醒輪詢變更或更新狀態資訊。 執行緒集區可讓您藉由提供您的系統所管理的背景工作執行緒集區的應用程式更有效率地使用執行緒。 使用執行緒集區執行緒的作業的範例包括下列:-當您建立<xref:System.Threading.Tasks.Task>或<xref:System.Threading.Tasks.Task%601>執行緒集區執行緒上執行排定工作預設以非同步方式執行某些工作的物件。</xref:System.Threading.Tasks.Task%601> </xref:System.Threading.Tasks.Task>      非同步計時器會使用執行緒集區。 執行緒集區執行緒執行回呼<xref:System.Threading.Timer?displayProperty=fullName>類別，並且引發的事件<xref:System.Timers.Timer?displayProperty=fullName>類別。</xref:System.Timers.Timer?displayProperty=fullName> </xref:System.Threading.Timer?displayProperty=fullName>      -當您使用已註冊之等候控制代碼時，系統執行緒會監視的狀態，等候控制代碼。 等候作業完成時，執行緒集區的背景工作執行緒會執行對應的回呼函式。      -當您呼叫<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>加入佇列的方法，以便在執行緒集區執行緒上執行的方法。</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 您可以傳遞方法<xref:System.Threading.WaitCallback>委派。</xref:System.Threading.WaitCallback>   委派的簽章<CodeContentPlaceHolder>0</CodeContentPlaceHolder><CodeContentPlaceHolder>1</CodeContentPlaceHolder>其中`state`是物件，包含要由委派所使用的資料。    實際的資料可以傳遞給委派，藉由呼叫<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>方法。</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      > [!NOTE] > 中的 managed 的執行緒集區執行緒為背景執行緒。 也就是說，其<xref:System.Threading.Thread.IsBackground%2A>屬性`true`。</xref:System.Threading.Thread.IsBackground%2A> 這表示執行緒集區中的執行緒不會保留所有前景執行緒都結束後執行的應用程式。      > [!IMPORTANT] > 當執行緒集區重複使用的執行緒時，它不會清除執行緒區域儲存區中，或標示的欄位中的資料<xref:System.ThreadStaticAttribute>屬性。</xref:System.ThreadStaticAttribute> 因此，當方法會檢查執行緒區域儲存區或欄位，會標記為<xref:System.ThreadStaticAttribute>屬性，它找到的值可能會留下的執行緒集區執行緒的先前使用。</xref:System.ThreadStaticAttribute>       您也可以將與等候作業的執行緒集區不相關的工作項目佇列。 若要要求在執行緒集區的執行緒所處理的工作項目，呼叫<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 這個方法會將參數當成方法或委派，會選取從執行緒集區的執行緒所呼叫的參考。 沒有任何取消的工作項目已加入佇列的方法。       計時器佇列中的計時器和已註冊之等候作業也會使用執行緒集區。 在執行緒集區佇列及其回呼函式。       沒有一個執行緒集區，每個處理序。 開頭為[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]，處理程序的執行緒集區的預設大小取決於許多因素，例如虛擬位址空間的大小。 處理程序可以呼叫<xref:System.Threading.ThreadPool.GetMaxThreads%2A>方法，以判斷執行緒數目。</xref:System.Threading.ThreadPool.GetMaxThreads%2A> 執行緒集區中的執行緒數目可以透過變更<xref:System.Threading.ThreadPool.SetMaxThreads%2A>方法。</xref:System.Threading.ThreadPool.SetMaxThreads%2A> 每個執行緒使用的預設堆疊大小，並執行預設的優先權。      > [!NOTE] > 裝載.NET Framework 的 unmanaged 程式碼可以使用變更的執行緒集區大小`CorSetMaxThreads`函式，mscoree.h 檔案中定義。       執行緒集區視需要提供新的背景工作執行緒或 I/O 完成執行緒直到達到每個類別目錄的最小值。 當達到最小值時，執行緒集區可以在該分類建立額外的執行緒，或等候部分工作完成。 開頭為[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]，執行緒集區會建立並終結背景工作執行緒，以便最佳化輸送量，輸送量的定義為每個時間單位完成的工作數目。 執行緒太少可能不會進行最有效地利用可用資源，而執行緒太多可能增加資源爭用的情況。      > [!NOTE] > 較低需求時，執行緒集區執行緒的實際數目可能低於最小值。       您可以使用<xref:System.Threading.ThreadPool.GetMinThreads%2A>方法，以取得這些最小值。</xref:System.Threading.ThreadPool.GetMinThreads%2A>      > [!CAUTION] > 您可以使用<xref:System.Threading.ThreadPool.SetMinThreads%2A>方法，以增加的執行緒數目下限。</xref:System.Threading.ThreadPool.SetMinThreads%2A> 不過，不必要地增加這些值可能會造成效能問題。 如果太多的工作會啟動一次，所有工作可能都會變慢。 在大部分情況下執行緒集區會執行更好使用它自己的演算法來配置執行緒。"
  example:
  - "In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits. The `ThreadProc` method simply displays a message.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/t-system.threading.threa_5_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/t-system.threading.threa_5_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/t-system.threading.threa_5_1.cs)]  \n  \n If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method, the main thread exits before         method runs on the thread pool thread.  The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.  (This         is a simple example of a race condition.)"
  syntax:
    content: public static class ThreadPool
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  id: BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將繫結到的作業系統控制代碼<xref href=&quot;System.Threading.ThreadPool&quot;> </xref>。"
  syntax:
    content: public static bool BindHandle (IntPtr osHandle);
    parameters:
    - id: osHandle
      type: System.IntPtr
      description: "<xref:System.IntPtr>，持有控制代碼。</xref:System.IntPtr> 控制代碼必須已經對 unmanaged 側的重疊 I/O 開啟。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果控制代碼已繫結。，否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  id: BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "將繫結到的作業系統控制代碼<xref href=&quot;System.Threading.ThreadPool&quot;> </xref>。"
  remarks: "`osHandle`參數應該是的<xref:Microsoft.Win32.SafeHandles.SafeFileHandle>，而後者衍生自抽象<xref:System.Runtime.InteropServices.SafeHandle>類別。</xref:System.Runtime.InteropServices.SafeHandle> </xref:Microsoft.Win32.SafeHandles.SafeFileHandle>"
  syntax:
    content: public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);
    parameters:
    - id: osHandle
      type: System.Runtime.InteropServices.SafeHandle
      description: "A <xref:System.Runtime.InteropServices.SafeHandle>，持有作業系統控制代碼。</xref:System.Runtime.InteropServices.SafeHandle> 控制代碼必須已經對 unmanaged 側的重疊 I/O 開啟。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果控制代碼已繫結。，否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.ThreadPool.BindHandle*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>osHandle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  id: GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "擷取所傳回的執行緒集區執行緒的數目上限之間的差異<xref:System.Threading.ThreadPool.GetMaxThreads*>方法，以及目前作用中數字。</xref:System.Threading.ThreadPool.GetMaxThreads*>"
  remarks: "GetAvailableThreads 傳回時，所指定的變數`workerThreads`包含額外的背景工作執行緒，可以啟動，且指定的變數`completionPortThreads`包含可啟動的其他非同步 I/O 執行緒數目。       如果沒有可用的執行緒，其他的執行緒集區要求繼續佇列，直到可以使用執行緒集區執行緒為止。"
  example:
  - "The following example displays the number of worker threads and I/O threads available when a simple app is started.  \n  \n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/csharp/m-system.threading.threa_23_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/add/codesnippet/visualbasic/m-system.threading.threa_23_1.vb)]"
  syntax:
    content: public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "可用的工作者執行緒數目。"
    - id: completionPortThreads
      type: System.Int32
      description: "可用非同步 I/O 執行緒數目。"
  overload: System.Threading.ThreadPool.GetAvailableThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  id: GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "擷取可並行使用之執行緒集區的要求數目。 超過該數目的所有要求會都繼續佇列，直到可以使用執行緒集區執行緒為止。"
  remarks: "GetMaxThreads 傳回時，所指定的變數`workerThreads`包含背景工作執行緒集區中允許的執行緒和變數所指定的最大數目`completionPortThreads`包含執行緒集區中允許的非同步 I/O 執行緒最大數目。       您可以使用<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>方法，以判斷在任何指定時間的執行緒集區執行緒的實際數目。</xref:System.Threading.ThreadPool.GetAvailableThreads%2A>       您可以使用<xref:System.Threading.ThreadPool.SetMaxThreads%2A>在執行緒集區中設定的工作者執行緒和非同步 I/O 執行緒數目上限。</xref:System.Threading.ThreadPool.SetMaxThreads%2A>       您可以將佇列無數個執行緒集區要求可讓系統記憶體。 如果沒有更多超過執行緒集區執行緒的要求，其他要求會繼續佇列，直到可以使用執行緒集區執行緒為止。"
  example:
  - "The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool. A work item is queued that uses `FileStream` to asynchronously write to two files. The callback methods are timed to overlap. A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.  \n  \n [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_14_1.cpp)]\n [!code-cs[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_14_1.cs)]\n [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_14_1.vb)]"
  syntax:
    content: public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "執行緒集區中的背景工作執行緒的數目上限。"
    - id: completionPortThreads
      type: System.Int32
      description: "執行緒集區中的非同步 I/O 執行緒的數目上限。"
  overload: System.Threading.ThreadPool.GetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  id: GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "隨著提出新要求，切換至管理執行緒建立和解構的演算法之前，請擷取執行緒集區視需要建立的執行緒的最小數目。"
  remarks: "執行緒集區視需要提供新的背景工作執行緒或 I/O 完成執行緒直到達到每個類別目錄的最小值。 根據預設，執行緒的最小數目設定為在系統上的處理器數目。 當達到最小值時，執行緒集區可以在該分類建立額外的執行緒，或等候部分工作完成。 開頭為[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]，執行緒集區會建立並終結執行緒，以便最佳化輸送量，輸送量的定義為每個時間單位完成的工作數目。 執行緒太少可能不會進行最有效地利用可用資源，而執行緒太多可能增加資源爭用的情況。      > [!NOTE] > 較低需求時，執行緒集區執行緒的實際數目可能低於最小值。"
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_20_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_20_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_20_1.cpp)]"
  syntax:
    content: public static void GetMinThreads (out int workerThreads, out int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "這個方法傳回時，包含執行緒集區視需要建立的背景工作執行緒最小數目。"
    - id: completionPortThreads
      type: System.Int32
      description: "這個方法傳回時，包含執行緒集區視需要建立的非同步 I/O 執行緒最小數目。"
  overload: System.Threading.ThreadPool.GetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  id: QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "排入佇列執行的方法。 使用執行緒集區執行緒時，就會執行這個方法。"
  remarks: "您可以放置在類別定義方法，或者您可以使用的執行個體欄位中排入佇列的方法所需的資料<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>多載會接受物件，其中包含必要的資料。</xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>      > [!NOTE] > 可以省略 Visual Basic 使用者<xref:System.Threading.WaitCallback>建構函式，並只是使用`AddressOf`運算子，將回呼方法傳遞至<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>。</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.WaitCallback> Visual Basic 會自動呼叫正確的委派建構函式。      ## 版本資訊中的.NET Framework 2.0 版中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>屬性值會傳播至背景工作執行緒排入佇列使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 在舊版中，主體的資訊不會傳播。"
  example:
  - "The following example uses the QueueUserWorkItem method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available. No task information is supplied with this overload. Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/cpp/m-system.threading.threa_22_1.cpp)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/visualbasic/m-system.threading.threa_22_1.vb)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem0#1](~/add/codesnippet/csharp/m-system.threading.threa_22_1.cs)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref>表示要執行的方法。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果方法成功排入佇列。<xref:System.NotSupportedException>無法佇列工作項目便會擲回。</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "裝載 common language runtime (CLR)，與主機不支援此動作。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "對於執行，方法排入佇列，並指定物件，其中包含要方法所使用的資料。 使用執行緒集區執行緒時，就會執行這個方法。"
  remarks: "如果回呼方法需要複雜的資料，您可以定義要包含資料的類別。      > [!NOTE] > 可以省略 Visual Basic 使用者<xref:System.Threading.WaitCallback>建構函式，並只是使用`AddressOf`運算子，將回呼方法傳遞至 QueueUserWorkItem。</xref:System.Threading.WaitCallback> Visual Basic 會自動呼叫正確的委派建構函式。      ## 版本資訊中的.NET Framework 2.0 版中，<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>屬性值會傳播至背景工作執行緒排入佇列使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 在舊版中，主體的資訊不會傳播。"
  example:
  - "The following example shows how to create an object that contains task information. It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.  \n  \n [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/cpp/9389ae71-aa49-4ceb-9b0a-_1.cpp)]\n [!code-cs[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/csharp/9389ae71-aa49-4ceb-9b0a-_1.cs)]\n [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/add/codesnippet/visualbasic/9389ae71-aa49-4ceb-9b0a-_1.vb)]"
  syntax:
    content: public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref>代表要執行的方法。"
    - id: state
      type: System.Object
      description: "物件，包含要方法所使用的資料。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果方法成功排入佇列。<xref:System.NotSupportedException>無法佇列工作項目便會擲回。</xref:System.NotSupportedException>"
  overload: System.Threading.ThreadPool.QueueUserWorkItem*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "裝載 common language runtime (CLR)，與主機不支援此動作。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "註冊要等候的委派<xref:System.Threading.WaitHandle>，以毫秒為單位指定逾時值的 32 位元帶正負號的整數。</xref:System.Threading.WaitHandle>"
  remarks: "完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，以釋放等候控制代碼的參考。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我們建議一律呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使您指定`true`如`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 記憶體回收會更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，而非根據 已註冊之等候控制代碼的完成項。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       RegisterWaitForSingleObject 方法排入佇列的執行緒集區指定的委派。 下列其中之一發生時，背景工作執行緒將會執行委派:-指定的物件處於信號狀態。      -逾時間隔經過的。       RegisterWaitForSingleObject 方法會檢查指定之物件的<xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle>的目前狀態 如果未發出信號，物件狀態，方法會註冊等候作業。 等候作業是由執行緒集區的執行緒執行。 委派是物件的狀態變成發出信號，或超過逾時間隔時，工作者執行緒所執行。 如果`timeOutInterval`參數不是 0 （零） 和`executeOnlyOnce`參數是`false`，每次事件發出信號，或超過逾時間隔會重設的計時器。      > [!IMPORTANT] > 使用<xref:System.Threading.Mutex>如`waitObject`不提供互斥回呼，因為基礎的 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，因此每個回呼會在個別的執行緒集區執行緒上分派。</xref:System.Threading.Mutex> 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>最大計數為 1。</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       若要取消的等候作業，請呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       等候執行緒會使用 Win32`WaitForMultipleObjects`函式監視已註冊之等候作業。 因此，如果您必須使用相同的原生作業系統控制代碼 registerwaitforsingleobject 的多個呼叫中，您必須重複使用 Win32 控制代碼`DuplicateHandle`函式。 請注意，您應該不轉盤式事件物件傳遞至 RegisterWaitForSingleObject，因為等候執行緒可能會偵測事件發出信號之前會重設。       在傳回之前函式會修改某些類型的同步處理物件的狀態。 只針對其信號的狀態造成要滿足等候條件的物件進行修改。 例如，一個號誌計數就會減少一個。      ## 以.NET Framework 2.0 版中，開始的版本資訊<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>屬性值會傳播至背景工作執行緒排入佇列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 在舊版中，主體的資訊不會傳播。"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>註冊。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>非<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref>時要呼叫的委派`waitObject`參數會收到信號。"
    - id: state
      type: System.Object
      description: "物件，傳遞給委派。"
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "以毫秒為單位的逾時。 如果`millisecondsTimeOutInterval`參數為 0 （零），函式會測試物件的狀態，並立即傳回。 如果`millisecondsTimeOutInterval`為-1，永遠不會超過函式的逾時間隔。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示執行緒將不再等候`waitObject`參數之後被呼叫的委派。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示每當等候作業完成之前等候已取消註冊計時器都會重設。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>封裝原生控制代碼。"
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>參數為小於-1。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "註冊要等候的委派<xref:System.Threading.WaitHandle>，以毫秒為單位指定逾時值的 64 位元帶正負號的整數。</xref:System.Threading.WaitHandle>"
  remarks: "完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，以釋放等候控制代碼的參考。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我們建議一律呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使您指定`true`如`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 記憶體回收會更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，而非根據 已註冊之等候控制代碼的完成項。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       RegisterWaitForSingleObject 方法排入佇列的執行緒集區指定的委派。 下列其中之一發生時，背景工作執行緒將會執行委派:-指定的物件處於信號狀態。      -逾時間隔經過的。       RegisterWaitForSingleObject 方法會檢查指定之物件的<xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle>的目前狀態 如果未發出信號，物件狀態，方法會註冊等候作業。 等候作業是由執行緒集區的執行緒執行。 委派是物件的狀態變成發出信號，或超過逾時間隔時，工作者執行緒所執行。 如果`timeOutInterval`參數不是 0 （零） 和`executeOnlyOnce`參數是`false`，每次事件發出信號，或超過逾時間隔會重設的計時器。      > [!IMPORTANT] > 使用<xref:System.Threading.Mutex>如`waitObject`不提供互斥回呼，因為基礎的 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，因此每個回呼會在個別的執行緒集區執行緒上分派。</xref:System.Threading.Mutex> 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>最大計數為 1。</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       若要取消的等候作業，請呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       等候執行緒會使用 Win32`WaitForMultipleObjects`函式監視已註冊之等候作業。 因此，如果您必須使用相同的原生作業系統控制代碼 registerwaitforsingleobject 的多個呼叫中，您必須重複使用 Win32 控制代碼`DuplicateHandle`函式。 請注意，您應該不轉盤式事件物件傳遞至 RegisterWaitForSingleObject，因為等候執行緒可能會偵測事件發出信號之前會重設。       在傳回之前函式會修改某些類型的同步處理物件的狀態。 只針對其信號的狀態造成要滿足等候條件的物件進行修改。 例如，一個號誌計數就會減少一個。      ## 以.NET Framework 2.0 版中，開始的版本資訊<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>屬性值會傳播至背景工作執行緒排入佇列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 在舊版中，主體的資訊不會傳播。"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>註冊。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>非<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref>時要呼叫的委派`waitObject`參數會收到信號。"
    - id: state
      type: System.Object
      description: "物件會傳遞給委派。"
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "以毫秒為單位的逾時。 如果`millisecondsTimeOutInterval`參數為 0 （零），函式會測試物件的狀態，並立即傳回。 如果`millisecondsTimeOutInterval`為-1，永遠不會超過函式的逾時間隔。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示執行緒將不再等候`waitObject`參數之後被呼叫的委派。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示每當等候作業完成之前等候已取消註冊計時器都會重設。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>封裝原生控制代碼。"
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>參數為小於-1。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "註冊要等候的委派<xref:System.Threading.WaitHandle>，並指定<xref:System.TimeSpan>逾時值。</xref:System.TimeSpan> </xref:System.Threading.WaitHandle>"
  remarks: "完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，以釋放等候控制代碼的參考。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我們建議一律呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使您指定`true`如`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 記憶體回收會更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，而非根據 已註冊之等候控制代碼的完成項。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       RegisterWaitForSingleObject 方法排入佇列的執行緒集區指定的委派。 下列其中之一發生時，背景工作執行緒將會執行委派:-指定的物件處於信號狀態。      -逾時間隔經過的。       RegisterWaitForSingleObject 方法會檢查指定之物件的<xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle>的目前狀態 如果未發出信號，物件狀態，方法會註冊等候作業。 等候作業是由執行緒集區的執行緒執行。 委派是物件的狀態變成發出信號，或超過逾時間隔時，工作者執行緒所執行。 如果`timeOutInterval`參數不是 0 （零） 和`executeOnlyOnce`參數是`false`，每次事件發出信號，或超過逾時間隔會重設的計時器。      > [!IMPORTANT] > 使用<xref:System.Threading.Mutex>如`waitObject`不提供互斥回呼，因為基礎的 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，因此每個回呼會在個別的執行緒集區執行緒上分派。</xref:System.Threading.Mutex> 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>最大計數為 1。</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       若要取消的等候作業，請呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       等候執行緒會使用 Win32`WaitForMultipleObjects`函式監視已註冊之等候作業。 因此，如果您必須使用相同的原生作業系統控制代碼 registerwaitforsingleobject 的多個呼叫中，您必須重複使用 Win32 控制代碼`DuplicateHandle`函式。 請注意，您應該不轉盤式事件物件傳遞至 RegisterWaitForSingleObject，因為等候執行緒可能會偵測事件發出信號之前會重設。       在傳回之前函式會修改某些類型的同步處理物件的狀態。 只針對其信號的狀態造成要滿足等候條件的物件進行修改。 例如，一個號誌計數就會減少一個。      ## 以.NET Framework 2.0 版中，開始的版本資訊<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>屬性值會傳播至背景工作執行緒排入佇列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 在舊版中，主體的資訊不會傳播。"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>註冊。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>非<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref>時要呼叫的委派`waitObject`參數會收到信號。"
    - id: state
      type: System.Object
      description: "物件會傳遞給委派。"
    - id: timeout
      type: System.TimeSpan
      description: "表示<xref:System.TimeSpan>。</xref:System.TimeSpan>的逾時值 如果`timeout`為 0 （零），函式會測試物件的狀態，並立即傳回。 如果`timeout`為-1，永遠不會超過函式的逾時間隔。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示執行緒將不再等候`waitObject`參數之後被呼叫的委派。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示每當等候作業完成之前等候已取消註冊計時器都會重設。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>封裝原生控制代碼。"
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> timeout </code>參數為小於-1。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code> timeout </code>參數大於&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "註冊要等候的委派<xref:System.Threading.WaitHandle>，以毫秒為單位指定逾時值的 32 位元不帶正負號的整數。</xref:System.Threading.WaitHandle>"
  remarks: "完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，以釋放等候控制代碼的參考。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我們建議一律呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使您指定`true`如`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 記憶體回收會更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，而非根據 已註冊之等候控制代碼的完成項。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法排入佇列的執行緒集區指定的委派。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 下列其中之一發生時，背景工作執行緒將會執行委派:-指定的物件處於信號狀態。      -逾時間隔經過的。       <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法會檢查指定的物件的<xref:System.Threading.WaitHandle>.</xref:System.Threading.WaitHandle>的目前狀態</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 如果未發出信號，物件狀態，方法會註冊等候作業。 等候作業是由執行緒集區的執行緒執行。 委派是物件的狀態變成發出信號，或超過逾時間隔時，工作者執行緒所執行。 如果`timeOutInterval`參數不是 0 （零） 和`executeOnlyOnce`參數是`false`，每次事件發出信號，或超過逾時間隔會重設的計時器。      > [!IMPORTANT] > 使用<xref:System.Threading.Mutex>如`waitObject`不提供互斥回呼，因為基礎的 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，因此每個回呼會在個別的執行緒集區執行緒上分派。</xref:System.Threading.Mutex> 而不是<xref:System.Threading.Mutex>，使用<xref:System.Threading.Semaphore>最大計數為 1。</xref:System.Threading.Semaphore> </xref:System.Threading.Mutex>       若要取消的等候作業，請呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>       等候執行緒會使用 Win32`WaitForMultipleObjects`函式監視已註冊之等候作業。 因此，如果您必須使用相同的原生作業系統控制代碼，在多個呼叫<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，您必須重複使用 Win32 控制代碼`DuplicateHandle`函式。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 請注意，您不應該轉盤式事件物件傳遞至<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>，因為等候執行緒可能無法偵測出事件發出信號之前會重設。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>       在傳回之前函式會修改某些類型的同步處理物件的狀態。 只針對其信號的狀態造成要滿足等候條件的物件進行修改。 例如，一個號誌計數就會減少一個。      ## 以.NET Framework 2.0 版中，開始的版本資訊<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>屬性值會傳播至背景工作執行緒排入佇列使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 在舊版中，主體的資訊不會傳播。"
  example:
  - "The following example shows how to use the RegisterWaitForSingleObject method to execute a specified callback method when a specified wait handle is signaled. In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.  \n  \n The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes. The example creates a `TaskInfo` object and assigns it some string data. The <xref:System.Threading.RegisteredWaitHandle> that is returned by the RegisterWaitForSingleObject method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.  \n  \n In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the RegisterWaitForSingleObject method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.  \n  \n When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked. The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred. If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks. In the case of a time-out, the task continues to wait. The `WaitProc` method ends by printing a message to the console.  \n  \n [!code-cs[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/csharp/2f901dc9-3ce0-4cdc-bf06-_1.cs)]\n [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/cpp/2f901dc9-3ce0-4cdc-bf06-_1.cpp)]\n [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/add/codesnippet/visualbasic/2f901dc9-3ce0-4cdc-bf06-_1.vb)]"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>註冊。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>非<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "<xref href=&quot;System.Threading.WaitOrTimerCallback&quot;> </xref>時要呼叫的委派`waitObject`參數會收到信號。"
    - id: state
      type: System.Object
      description: "物件會傳遞給委派。"
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "以毫秒為單位的逾時。 如果`millisecondsTimeOutInterval`參數為 0 （零），函式會測試物件的狀態，並立即傳回。 如果`millisecondsTimeOutInterval`為-1，永遠不會超過函式的逾時間隔。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示執行緒將不再等候`waitObject`參數之後被呼叫的委派。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示每當等候作業完成之前等候已取消註冊計時器都會重設。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref> ，可用來取消已註冊之等候作業。"
  overload: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>參數為小於-1。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  id: SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "可以同時為作用中的執行緒集區設定要求的數目。 超過該數目的所有要求會都繼續佇列，直到可以使用執行緒集區執行緒為止。"
  remarks: "您無法設定背景工作執行緒或 I/O 完成執行緒的最大數目的數字小於電腦上的處理器數目。 若要判斷有多少處理器，擷取的值<xref:System.Environment.ProcessorCount%2A?displayProperty=fullName>屬性。</xref:System.Environment.ProcessorCount%2A?displayProperty=fullName> 此外，您無法設定背景工作執行緒或 I/O 完成執行緒來比對應的最小背景工作執行緒數目較小的數字或 I/O 完成執行緒的最大數目。 若要判斷最小執行緒集區大小，請呼叫<xref:System.Threading.ThreadPool.GetMinThreads%2A>方法。</xref:System.Threading.ThreadPool.GetMinThreads%2A>       如果裝載 common language runtime，例如藉由網際網路資訊服務 (IIS) 或 SQL Server，主機可以限制或阻止變更執行緒集區大小。       變更執行緒集區中的執行緒數目上限時，請務必小心。 而獲益的程式碼，所做的變更可能造成負面影響您使用的程式碼程式庫。       設定執行緒集區大小太大，可能會造成效能問題。 如果同時執行太多執行緒，工作切換額外負荷會變成的重要因素。"
  syntax:
    content: public static bool SetMaxThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "執行緒集區中的背景工作執行緒的數目上限。"
    - id: completionPortThreads
      type: System.Int32
      description: "執行緒集區中的非同步 I/O 執行緒的數目上限。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果變更成功。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.ThreadPool.SetMaxThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  id: SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "隨著提出新要求，切換至管理執行緒建立和解構的演算法之前，請設定執行緒集區視需要建立的執行緒的最小數目。"
  remarks: "執行緒集區視需要提供新的背景工作執行緒或 I/O 完成執行緒直到達到每個類別目錄的最小值。 當達到最小值時，執行緒集區可以在該分類建立額外的執行緒，或等候部分工作完成。 開頭為[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]，執行緒集區會建立並終結執行緒，以便最佳化輸送量，輸送量的定義為每個時間單位完成的工作數目。 執行緒太少可能不會進行最有效地利用可用資源，而執行緒太多可能增加資源爭用的情況。       當需求很低時，執行緒集區執行緒的實際數目可能低於最小值。       如果您指定為負數或大於的使用中執行緒集區執行緒的數目上限的數字 (使用取得<xref:System.Threading.ThreadPool.GetMaxThreads%2A>)，傳回 SetMinThreads`false`也不會變更其中一個最小值。</xref:System.Threading.ThreadPool.GetMaxThreads%2A>      > [!CAUTION] > 根據預設，執行緒的最小數目設定為在系統上的處理器數目。 SetMinThreads 方法可用來增加最小的數字 ofthreads。 不過，不必要地增加這些值可能會造成效能問題。 如果太多的工作會啟動一次，所有工作可能都會變慢。 在大部分情況下，執行緒集區會執行更好使用它自己的演算法來配置執行緒。 減少至低於的處理器數目也會降低效能的最小值。"
  example:
  - "The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  \n  \n [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/visualbasic/m-system.threading.threa_10_1.vb)]\n [!code-cs[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/csharp/m-system.threading.threa_10_1.cs)]\n [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/add/codesnippet/cpp/m-system.threading.threa_10_1.cpp)]"
  syntax:
    content: public static bool SetMinThreads (int workerThreads, int completionPortThreads);
    parameters:
    - id: workerThreads
      type: System.Int32
      description: "視需要建立執行緒集區的背景工作執行緒最小數目。"
    - id: completionPortThreads
      type: System.Int32
      description: "執行緒集區視需要建立的非同步 I/O 執行緒最小數目。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果變更成功。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.ThreadPool.SetMinThreads*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  id: UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "重疊的 I/O 作業執行排入佇列。"
  remarks: "如需有關使用原生 Win32 資訊重疊的 I/O，請參閱 <<c0>類別<xref:System.Threading.NativeOverlapped>結構，而`OVERLAPPED`Win32 平台 SDK 中的結構。</xref:System.Threading.NativeOverlapped>       > [!CAUTION] > 使用 UnsafeQueueNativeOverlapped 方法可能不小心開啟安全性漏洞。 程式碼存取安全性會根據堆疊中的所有呼叫端的權限的權限檢查。 當工作在執行緒集區執行緒使用 UnsafeQueueNativeOverlapped 排入佇列時，執行緒集區執行緒的堆疊中沒有實際的呼叫端的內容。 惡意程式碼可能可以利用此選項可避免權限檢查。"
  syntax:
    content: public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);
    parameters:
    - id: overlapped
      type: System.Threading.NativeOverlapped*
      description: "<xref href=&quot;System.Threading.NativeOverlapped&quot;> </xref>佇列的結構。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果作業已成功排入 I/O 完成連接埠。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  exceptions: []
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  id: UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "排入佇列的執行緒集區中，指定的委派，但不是會傳播至背景工作執行緒的呼叫堆疊。"
  remarks: "不同於<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>UnsafeQueueUserWorkItem 的方法，並不會傳播至背景工作執行緒的呼叫堆疊。</xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 這可讓程式碼會遺失呼叫堆疊，因此提高其安全性權限。      > [!CAUTION] > 使用 UnsafeQueueUserWorkItem 不慎無法開啟安全性漏洞。 程式碼存取安全性會根據堆疊中的所有呼叫端的權限的權限檢查。 當工作在執行緒集區執行緒使用 UnsafeQueueUserWorkItem 排入佇列時，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。 惡意程式碼可能可以利用此選項可避免權限檢查。"
  syntax:
    content: public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);
    parameters:
    - id: callBack
      type: System.Threading.WaitCallback
      description: "A <xref href=&quot;System.Threading.WaitCallback&quot;> </xref>代表在執行緒集區中的執行緒選取工作項目時叫用的委派。"
    - id: state
      type: System.Object
      description: "已傳遞給委派服務時，執行緒集區的物件。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果方法成功。<xref:System.OutOfMemoryException>無法佇列工作項目便會擲回。</xref:System.OutOfMemoryException>"
  overload: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "遇到記憶體不足的狀況。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "無法佇列工作項目。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "註冊要等候的委派<xref:System.Threading.WaitHandle>，使用 32 位元帶正負號的整數逾時值以毫秒為單位。</xref:System.Threading.WaitHandle> 這個方法不會傳播至背景工作執行緒的呼叫堆疊。"
  remarks: "不同於<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>UnsafeRegisterWaitForSingleObject 的方法，並不會傳播至背景工作執行緒的呼叫堆疊。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 這可讓程式碼會遺失呼叫堆疊，因此提高其安全性權限。      > [!CAUTION] > 使用 UnsafeRegisterWaitForSingleObject 不慎無法開啟安全性漏洞。 程式碼存取安全性會根據堆疊中的所有呼叫端的權限的權限檢查。 當工作在執行緒集區執行緒使用 UnsafeRegisterWaitForSingleObject 排入佇列時，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。 惡意程式碼可能可以利用此選項可避免權限檢查。       使用<xref:System.Threading.Mutex>如`waitObject`不提供互斥回呼，因為基礎的 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，因此每個回呼會在個別的執行緒集區執行緒上分派。</xref:System.Threading.Mutex>       完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，以釋放等候控制代碼的參考。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我們建議一律呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使您指定`true`如`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 記憶體回收會更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，而非根據 已註冊之等候控制代碼的完成項。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>註冊。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>非<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "時要呼叫的委派`waitObject`參數會收到信號。"
    - id: state
      type: System.Object
      description: "物件，傳遞給委派。"
    - id: millisecondsTimeOutInterval
      type: System.Int32
      description: "以毫秒為單位的逾時。 如果`millisecondsTimeOutInterval`參數為 0 （零），函式會測試物件的狀態，並立即傳回。 如果`millisecondsTimeOutInterval`為-1，永遠不會超過函式的逾時間隔。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示執行緒將不再等候`waitObject`參數之後被呼叫的委派。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示每當等候作業完成之前等候已取消註冊計時器都會重設。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>可以用來取消已註冊之等候作業的物件。"
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>參數為小於-1。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "註冊要等候的委派<xref:System.Threading.WaitHandle>，以毫秒為單位指定逾時值的 64 位元帶正負號的整數。</xref:System.Threading.WaitHandle> 這個方法不會傳播至背景工作執行緒的呼叫堆疊。"
  remarks: "不同於<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>UnsafeRegisterWaitForSingleObject 的方法，並不會傳播至背景工作執行緒的呼叫堆疊。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 這可讓程式碼會遺失呼叫堆疊，因此提高其安全性權限。      > [!CAUTION] > 使用 UnsafeRegisterWaitForSingleObject 不慎無法開啟安全性漏洞。 程式碼存取安全性會根據堆疊中的所有呼叫端的權限的權限檢查。 當工作在執行緒集區執行緒使用 UnsafeRegisterWaitForSingleObject 排入佇列時，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。 惡意程式碼可能可以利用此選項可避免權限檢查。       使用<xref:System.Threading.Mutex>如`waitObject`不提供互斥回呼，因為基礎的 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，因此每個回呼會在個別的執行緒集區執行緒上分派。</xref:System.Threading.Mutex>       完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，以釋放等候控制代碼的參考。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我們建議一律呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使您指定`true`如`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 記憶體回收會更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，而非根據 已註冊之等候控制代碼的完成項。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>註冊。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>非<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "時要呼叫的委派`waitObject`參數會收到信號。"
    - id: state
      type: System.Object
      description: "物件，傳遞給委派。"
    - id: millisecondsTimeOutInterval
      type: System.Int64
      description: "以毫秒為單位的逾時。 如果`millisecondsTimeOutInterval`參數為 0 （零），函式會測試物件的狀態，並立即傳回。 如果`millisecondsTimeOutInterval`為-1，永遠不會超過函式的逾時間隔。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示執行緒將不再等候`waitObject`參數之後被呼叫的委派。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示每當等候作業完成之前等候已取消註冊計時器都會重設。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>可以用來取消已註冊之等候作業的物件。"
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> millisecondsTimeOutInterval </code>參數為小於-1。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "註冊要等候的委派<xref:System.Threading.WaitHandle>，並指定<xref:System.TimeSpan>逾時值。</xref:System.TimeSpan> </xref:System.Threading.WaitHandle> 這個方法不會傳播至背景工作執行緒的呼叫堆疊。"
  remarks: "不同於<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>UnsafeRegisterWaitForSingleObject 的方法，並不會傳播至背景工作執行緒的呼叫堆疊。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 這可讓程式碼會遺失呼叫堆疊，因此提高其安全性權限。      > [!CAUTION] > 使用 UnsafeRegisterWaitForSingleObject 不慎無法開啟安全性漏洞。 程式碼存取安全性會根據堆疊中的所有呼叫端的權限的權限檢查。 當工作在執行緒集區執行緒使用 UnsafeRegisterWaitForSingleObject 排入佇列時，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。 惡意程式碼可能可以利用此選項可避免權限檢查。       使用<xref:System.Threading.Mutex>如`waitObject`不提供互斥回呼，因為基礎的 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，因此每個回呼會在個別的執行緒集區執行緒上分派。</xref:System.Threading.Mutex>       完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，以釋放等候控制代碼的參考。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我們建議一律呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使您指定`true`如`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 記憶體回收會更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，而非根據 已註冊之等候控制代碼的完成項。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>註冊。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>非<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "時要呼叫的委派`waitObject`參數會收到信號。"
    - id: state
      type: System.Object
      description: "物件，傳遞給委派。"
    - id: timeout
      type: System.TimeSpan
      description: "表示<xref:System.TimeSpan>。</xref:System.TimeSpan>的逾時值 如果`timeout`為 0 （零），函式會測試物件的狀態，並立即傳回。 如果`timeout`為-1，永遠不會超過函式的逾時間隔。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示執行緒將不再等候`waitObject`參數之後被呼叫的委派。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示每當等候作業完成之前等候已取消註冊計時器都會重設。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>可以用來取消已註冊之等候作業的物件。"
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> timeout </code>參數為小於-1。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code> timeout </code>參數大於&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  id: UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  langs:
  - csharp
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Threading
  summary: "註冊要等候的委派<xref:System.Threading.WaitHandle>，以毫秒為單位指定逾時值的 32 位元不帶正負號的整數。</xref:System.Threading.WaitHandle> 這個方法不會傳播至背景工作執行緒的呼叫堆疊。"
  remarks: "不同於<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>UnsafeRegisterWaitForSingleObject 的方法，並不會傳播至背景工作執行緒的呼叫堆疊。</xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 這可讓程式碼會遺失呼叫堆疊，因此提高其安全性權限。      > [!CAUTION] > 使用 UnsafeRegisterWaitForSingleObject 不慎無法開啟安全性漏洞。 程式碼存取安全性會根據堆疊中的所有呼叫端的權限的權限檢查。 當工作在執行緒集區執行緒使用 UnsafeRegisterWaitForSingleObject 排入佇列時，執行緒集區執行緒的堆疊不會有實際的呼叫端的內容。 惡意程式碼可能可以利用此選項可避免權限檢查。       使用<xref:System.Threading.Mutex>如`waitObject`不提供互斥回呼，因為基礎的 Win32 API 會使用預設`WT_EXECUTEDEFAULT`旗標，因此每個回呼會在個別的執行緒集區執行緒上分派。</xref:System.Threading.Mutex>       完畢時使用<xref:System.Threading.RegisteredWaitHandle>這個方法傳回時，請呼叫其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，以釋放等候控制代碼的參考。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> </xref:System.Threading.RegisteredWaitHandle> 我們建議一律呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，即使您指定`true`如`executeOnlyOnce`。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName> 記憶體回收會更有效率地如果您呼叫<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>方法，而非根據 已註冊之等候控制代碼的完成項。</xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=fullName>"
  syntax:
    content: public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
    parameters:
    - id: waitObject
      type: System.Threading.WaitHandle
      description: "<xref:System.Threading.WaitHandle>註冊。</xref:System.Threading.WaitHandle> 使用<xref:System.Threading.WaitHandle>非<xref:System.Threading.Mutex>.</xref:System.Threading.Mutex> </xref:System.Threading.WaitHandle>"
    - id: callBack
      type: System.Threading.WaitOrTimerCallback
      description: "時要呼叫的委派`waitObject`參數會收到信號。"
    - id: state
      type: System.Object
      description: "物件，傳遞給委派。"
    - id: millisecondsTimeOutInterval
      type: System.UInt32
      description: "以毫秒為單位的逾時。 如果`millisecondsTimeOutInterval`參數為 0 （零），函式會測試物件的狀態，並立即傳回。 如果`millisecondsTimeOutInterval`為-1，永遠不會超過函式的逾時間隔。"
    - id: executeOnlyOnce
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示執行緒將不再等候`waitObject`參數之後被呼叫的委派。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示每當等候作業完成之前等候已取消註冊計時器都會重設。"
    return:
      type: System.Threading.RegisteredWaitHandle
      description: "<xref href=&quot;System.Threading.RegisteredWaitHandle&quot;> </xref>可以用來取消已註冊之等候作業的物件。"
  overload: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ApplicationException
  parent: System
  isExternal: false
  name: ApplicationException
  nameWithType: ApplicationException
  fullName: System.ApplicationException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.Threading.ThreadPool.BindHandle(System.IntPtr)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(IntPtr)
  nameWithType: ThreadPool.BindHandle(IntPtr)
  fullName: System.Threading.ThreadPool.BindHandle(IntPtr)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle(SafeHandle)
  nameWithType: ThreadPool.BindHandle(SafeHandle)
  fullName: System.Threading.ThreadPool.BindHandle(SafeHandle)
- uid: System.Runtime.InteropServices.SafeHandle
  parent: System.Runtime.InteropServices
  isExternal: true
  name: SafeHandle
  nameWithType: SafeHandle
  fullName: System.Runtime.InteropServices.SafeHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads(Int32,Int32)
  nameWithType: ThreadPool.GetAvailableThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetAvailableThreads(Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.GetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.GetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback)
- uid: System.Threading.WaitCallback
  parent: System.Threading
  isExternal: false
  name: WaitCallback
  nameWithType: WaitCallback
  fullName: System.Threading.WaitCallback
- uid: System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.QueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.QueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.RegisteredWaitHandle
  parent: System.Threading
  isExternal: false
  name: RegisteredWaitHandle
  nameWithType: RegisteredWaitHandle
  fullName: System.Threading.RegisteredWaitHandle
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: true
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Threading.WaitOrTimerCallback
  parent: System.Threading
  isExternal: false
  name: WaitOrTimerCallback
  nameWithType: WaitOrTimerCallback
  fullName: System.Threading.WaitOrTimerCallback
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMaxThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMaxThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads(Int32,Int32)
  nameWithType: ThreadPool.SetMinThreads(Int32,Int32)
  fullName: System.Threading.ThreadPool.SetMinThreads(Int32,Int32)
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped(NativeOverlapped*)
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
  fullName: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(NativeOverlapped*)
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem(WaitCallback,Object)
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
  fullName: System.Threading.ThreadPool.UnsafeQueueUserWorkItem(WaitCallback,Object)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
  fullName: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)
- uid: System.Threading.ThreadPool.BindHandle*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: BindHandle
  nameWithType: ThreadPool.BindHandle
- uid: System.Threading.ThreadPool.GetAvailableThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetAvailableThreads
  nameWithType: ThreadPool.GetAvailableThreads
- uid: System.Threading.ThreadPool.GetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMaxThreads
  nameWithType: ThreadPool.GetMaxThreads
- uid: System.Threading.ThreadPool.GetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: GetMinThreads
  nameWithType: ThreadPool.GetMinThreads
- uid: System.Threading.ThreadPool.QueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: QueueUserWorkItem
  nameWithType: ThreadPool.QueueUserWorkItem
- uid: System.Threading.ThreadPool.RegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: RegisterWaitForSingleObject
  nameWithType: ThreadPool.RegisterWaitForSingleObject
- uid: System.Threading.ThreadPool.SetMaxThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMaxThreads
  nameWithType: ThreadPool.SetMaxThreads
- uid: System.Threading.ThreadPool.SetMinThreads*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: SetMinThreads
  nameWithType: ThreadPool.SetMinThreads
- uid: System.Threading.ThreadPool.UnsafeQueueNativeOverlapped*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueNativeOverlapped
  nameWithType: ThreadPool.UnsafeQueueNativeOverlapped
- uid: System.Threading.ThreadPool.UnsafeQueueUserWorkItem*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeQueueUserWorkItem
  nameWithType: ThreadPool.UnsafeQueueUserWorkItem
- uid: System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject*
  parent: System.Threading.ThreadPool
  isExternal: false
  name: UnsafeRegisterWaitForSingleObject
  nameWithType: ThreadPool.UnsafeRegisterWaitForSingleObject
