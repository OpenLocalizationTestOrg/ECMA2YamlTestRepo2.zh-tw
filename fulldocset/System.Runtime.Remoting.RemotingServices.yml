### YamlMime:ManagedReference
items:
- uid: System.Runtime.Remoting.RemotingServices
  id: RemotingServices
  children:
  - System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  - System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  - System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  - System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  - System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  - System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  - System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  - System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  - System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  - System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  - System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  - System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  - System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  - System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  - System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  langs:
  - csharp
  name: RemotingServices
  nameWithType: RemotingServices
  fullName: System.Runtime.Remoting.RemotingServices
  type: Class
  summary: "提供數種方法使用和發行遠端物件和 proxy。 這個類別無法被繼承。"
  remarks: "除非您處理的問題，例如啟用、 生命週期管理或交易的服務提供者，您不需要區分 proxy 參考的物件參考。 遠端執行功能基礎結構會使用 transparent proxy 的印象遠端物件位於用戶端的空間。 Proxy 會對它們在遠端位置的實際物件的呼叫轉送達到這個目的。"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public static class RemotingServices
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  id: Connect(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Connect(Type,String)
  nameWithType: RemotingServices.Connect(Type,String)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "建立 proxy 的已知物件，指定<xref:System.Type>和 URL。</xref:System.Type>"
  remarks: "傳回的 proxy 物件指向所指定的已知物件服務的端點。 在 proxy 上呼叫方法之前，會透過網路不傳送任何訊息。"
  example:
  - "The following code example demonstrates how to use the Connect method to create a proxy to a well-known object.  \n  \n [!code-cpp[RemotingServices.BasicSample#1](~/add/codesnippet/cpp/m-system.runtime.remotin_104_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#1](~/add/codesnippet/csharp/m-system.runtime.remotin_104_1.cs)]\n [!code-vb[RemotingServices.BasicSample#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_104_1.vb)]"
  syntax:
    content: public static object Connect (Type classToProxy, string url);
    parameters:
    - id: classToProxy
      type: System.Type
      description: "<xref:System.Type>的已知的物件，您要連接的伺服器端。</xref:System.Type>"
    - id: url
      type: System.String
      description: "Server 類別的 URL。"
    return:
      type: System.Object
      description: "指定的已知物件所服務的端點會指向遠端物件的 proxy。"
  overload: System.Runtime.Remoting.RemotingServices.Connect*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  id: Connect(System.Type,System.String,System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Connect(Type,String,Object)
  nameWithType: RemotingServices.Connect(Type,String,Object)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "建立 proxy 的已知物件，指定<xref:System.Type>，URL 和通道特定資料。</xref:System.Type>"
  remarks: "傳回的 proxy 物件指向所指定的已知物件服務的端點。 在 proxy 上呼叫方法之前，會透過網路不傳送任何訊息。       `data`物件用來傳達資訊給通道，並傳遞給<xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=fullName>方法。</xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=fullName>"
  syntax:
    content: public static object Connect (Type classToProxy, string url, object data);
    parameters:
    - id: classToProxy
      type: System.Type
      description: "<xref:System.Type>您要連接的已知物件。</xref:System.Type>"
    - id: url
      type: System.String
      description: "已知物件的 URL。"
    - id: data
      type: System.Object
      description: "通道特定的資料。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Object
      description: "Proxy，指向要求的已知物件所服務的端點。"
  overload: System.Runtime.Remoting.RemotingServices.Connect*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  id: Disconnect(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Disconnect(MarshalByRefObject)
  nameWithType: RemotingServices.Disconnect(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Disconnect(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "停止接收任何其他訊息，透過已註冊的遠端處理通道物件。"
  remarks: ''
  example:
  - "The following code example demonstrates how to use the Disconnect method to disconnect an object from the remoting channels.  \n  \n [!code-cpp[RemotingServices.BasicSample#2](~/add/codesnippet/cpp/m-system.runtime.remotin_81_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#2](~/add/codesnippet/csharp/m-system.runtime.remotin_81_1.cs)]\n [!code-vb[RemotingServices.BasicSample#2](~/add/codesnippet/visualbasic/m-system.runtime.remotin_81_1.vb)]"
  syntax:
    content: public static bool Disconnect (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "若要中斷其通道物件。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果物件已與中斷連線的已註冊的遠端處理通道可順利啟動。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Runtime.Remoting.RemotingServices.Disconnect*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>obj</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> obj </code>參數是的 proxy。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "直接呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  id: ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  nameWithType: RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  fullName: System.Runtime.Remoting.RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "連接到指定的遠端物件，並執行提供<xref href=&quot;System.Runtime.Remoting.Messaging.IMethodCallMessage&quot;></xref>在其上。"
  remarks: "目前的方法用於在特殊情況下，伺服器將指定的方法呼叫轉送至另一個，可能是遠端物件。 呼叫端會在適當的內容時，才可以呼叫這個方法。"
  example:
  - "The following code example demonstrates how to use the ExecuteMessage method to forward method calls to remote objects.  \n  \n [!code-cs[RemotingServices.ExecuteMessage#1](~/add/codesnippet/csharp/491f5c62-582d-42d8-b526-_1.cs)]\n [!code-cpp[RemotingServices.ExecuteMessage#1](~/add/codesnippet/cpp/491f5c62-582d-42d8-b526-_1.cpp)]\n [!code-vb[RemotingServices.ExecuteMessage#1](~/add/codesnippet/visualbasic/491f5c62-582d-42d8-b526-_1.vb)]"
  syntax:
    content: public static System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage (MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);
    parameters:
    - id: target
      type: System.MarshalByRefObject
      description: "您想要呼叫其方法之遠端物件。"
    - id: reqMsg
      type: System.Runtime.Remoting.Messaging.IMethodCallMessage
      description: "要指定遠端物件的方法的方法呼叫訊息。"
    return:
      type: System.Runtime.Remoting.Messaging.IMethodReturnMessage
      description: "遠端方法的回應。"
  overload: System.Runtime.Remoting.RemotingServices.ExecuteMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "立即呼叫者沒有基礎結構的權限。"
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "物件的原生內容以外的內容呼叫的方法。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  id: GetEnvoyChainForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetEnvoyChainForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "傳回將訊息傳送至指定的 proxy 所代表的遠端物件時，應使用的 envoy 接收鏈結。"
  remarks: "Envoy 接收是傳送與接收<xref:System.Runtime.Remoting.ObjRef>物件傳回給該物件的訊息時所使用。</xref:System.Runtime.Remoting.ObjRef> 目前的方法會傳回物件的 proxy 與物件本身之間的通訊期間所使用的 envoy 接收。"
  syntax:
    content: public static System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "要求 envoy 接收的遠端物件的 proxy 相關聯。"
    return:
      type: System.Runtime.Remoting.Messaging.IMessageSink
      description: "指定的 proxy 與相關聯的 envoy 接收的鏈結。"
  overload: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "立即呼叫者沒有基礎結構的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  id: GetLifetimeService(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetLifetimeService(MarshalByRefObject)
  nameWithType: RemotingServices.GetLifetimeService(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetLifetimeService(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "傳回指定之物件的存留期原則會控制的存留時間服務物件。"
  remarks: "預設存留時間服務傳回的物件將<xref:System.Runtime.Remoting.Lifetime.ILease>.</xref:System.Runtime.Remoting.Lifetime.ILease>類型的物件 如果`obj`參數是`null`，方法會傳回`null`。"
  example:
  - "The following code example demonstrates how to use the GetLifetimeService method to get a lifetime lease for the specified object.  \n  \n [!code-cpp[RemotingServices.TimerSample#1](~/add/codesnippet/cpp/a7d2891c-3dad-448c-949c-_1.cpp)]\n [!code-cs[RemotingServices.TimerSample#1](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_1.cs)]\n [!code-vb[RemotingServices.TimerSample#1](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_1.vb)]  \n  \n To compile and run this example, you will need to compile and run a server, timerserver.exe, and compile a shared library, timerservice.dll.  \n  \n The source for timerserver.exe follows:  \n  \n [!code-vb[RemotingServices.TimerSample#2](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_2.vb)]\n [!code-cs[RemotingServices.TimerSample#2](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_2.cs)]  \n  \n The source for timerservice.dll follows:  \n  \n [!code-vb[RemotingServices.TimerSample#3](~/add/codesnippet/visualbasic/a7d2891c-3dad-448c-949c-_3.vb)]\n [!code-cs[RemotingServices.TimerSample#3](~/add/codesnippet/csharp/a7d2891c-3dad-448c-949c-_3.cs)]"
  syntax:
    content: public static object GetLifetimeService (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "若要取得的存留期服務物件。"
    return:
      type: System.Object
      description: "物件，可控制的存留期<code> obj </code>。"
  overload: System.Runtime.Remoting.RemotingServices.GetLifetimeService*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "立即呼叫者沒有基礎結構的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetMethodBaseFromMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "傳回方法的基底從給定<xref href=&quot;System.Runtime.Remoting.Messaging.IMethodMessage&quot;> </xref>。"
  remarks: "這會決定從基底方法<xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A>， <xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A>，和<xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A>屬性<xref:System.Runtime.Remoting.Messaging.IMethodMessage>並且由類別實作<xref:System.Runtime.Remoting.Messaging.IMethodMessage>介面。</xref:System.Runtime.Remoting.Messaging.IMethodMessage> </xref:System.Runtime.Remoting.Messaging.IMethodMessage> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature%2A> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodName%2A> </xref:System.Runtime.Remoting.Messaging.IMethodMessage.TypeName%2A> 取用者<xref:System.Runtime.Remoting.Messaging.IMethodMessage>類別應該參考<xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=fullName>屬性。</xref:System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase%2A?displayProperty=fullName> </xref:System.Runtime.Remoting.Messaging.IMethodMessage>"
  syntax:
    content: public static System.Reflection.MethodBase GetMethodBaseFromMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "方法的訊息，以擷取來自基底的方法。"
    return:
      type: System.Reflection.MethodBase
      description: "從擷取的方法基底<code> msg </code>參數。"
  overload: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "請立即呼叫者沒有基礎結構的權限，或至少一個呼叫堆疊中較高層的呼叫端沒有擷取非公用成員的型別資訊的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjectData(Object,SerializationInfo,StreamingContext)
  nameWithType: RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "將指定的封送處理所參考的物件序列化為提供<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>。"
  syntax:
    content: public static void GetObjectData (object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: obj
      type: System.Object
      description: "要序列化的物件。"
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>成序列化物件。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "來源和序列化的目的地。"
  overload: System.Runtime.Remoting.RemotingServices.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>obj</code> or <code>info</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "立即呼叫者沒有基礎結構的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  id: GetObjectUri(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjectUri(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjectUri(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectUri(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "擷取指定物件的 URI。"
  remarks: ''
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/visualbasic/318892c3-7b62-40bd-9e3b-_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/csharp/318892c3-7b62-40bd-9e3b-_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#18](~/add/codesnippet/cpp/318892c3-7b62-40bd-9e3b-_1.cpp)]
  syntax:
    content: public static string GetObjectUri (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "<xref href=&quot;System.MarshalByRefObject&quot;> </xref>要求 URI。"
    return:
      type: System.String
      description: "如果有的話，指定之物件的 URI 或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果物件已不尚未被封送處理。"
  overload: System.Runtime.Remoting.RemotingServices.GetObjectUri*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "立即呼叫者沒有基礎結構的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  id: GetObjRefForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetObjRefForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "傳回<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>表示從指定的 proxy 的遠端物件。"
  remarks: "A<xref:System.Runtime.Remoting.ObjRef>是用來在應用程式定義域界限間傳送的物件參考的物件的序列化表示法。</xref:System.Runtime.Remoting.ObjRef> 建立<xref:System.Runtime.Remoting.ObjRef>的物件稱為封送處理。</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>可以另一個應用程式定義域透過通道傳送，（可能是在另一個處理序或電腦）。</xref:System.Runtime.Remoting.ObjRef> 在其他應用程式網域中，一次<xref:System.Runtime.Remoting.ObjRef>必須剖析以建立物件，通常會連接至實際物件的 proxy。</xref:System.Runtime.Remoting.ObjRef> 這項作業稱為解封送處理。 期間解封送處理，<xref:System.Runtime.Remoting.ObjRef>剖析擷取的方法資訊的遠端物件和透明 proxy 和<xref:System.Runtime.Remoting.Proxies.RealProxy>會建立物件。</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef>       A<xref:System.Runtime.Remoting.ObjRef>包含描述的資訊<xref:System.Type>和封送處理物件的類別，可唯一識別特定物件執行個體和通訊的 URI 相關如何連線到遠端應用程式物件的位置資訊。</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>"
  example:
  - "The following code example demonstrates how to get a <xref:System.Runtime.Remoting.ObjRef> instance for the specified object.  \n  \n [!code-cpp[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/cpp/d6ce9a9a-8ec9-4559-9b2d-_1.cpp)]\n [!code-vb[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/visualbasic/d6ce9a9a-8ec9-4559-9b2d-_1.vb)]\n [!code-cs[RemotingServices.GetObjRefForProxy#1](~/add/codesnippet/csharp/d6ce9a9a-8ec9-4559-9b2d-_1.cs)]"
  syntax:
    content: public static System.Runtime.Remoting.ObjRef GetObjRefForProxy (MarshalByRefObject obj);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "連接至您想要建立的物件的 proxy <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>的。"
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "A <xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>表示指定的 proxy 連接到遠端的物件或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果物件或 proxy 有無法封送處理。"
  overload: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "立即呼叫者沒有基礎結構的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  id: GetRealProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetRealProxy(Object)
  nameWithType: RemotingServices.GetRealProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.GetRealProxy(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "傳回實際備份指定的傳輸 proxy 的 proxy。"
  remarks: "使用物件之間任何一種遠端界限的用戶端實際上正在使用 transparent proxy 物件。 透明 proxy 可讓您以為實際物件位於用戶端的空間。 它的做法是轉送實際使用的遠端執行功能基礎結構的物件上所進行的呼叫。       透明 proxy 受到所支援的型別<xref:System.Runtime.Remoting.Proxies.RealProxy>.</xref:System.Runtime.Remoting.Proxies.RealProxy>受管理的執行階段類別的執行個體 <xref:System.Runtime.Remoting.Proxies.RealProxy>實作從傳輸 proxy 轉送作業所需的功能的一部分。</xref:System.Runtime.Remoting.Proxies.RealProxy>       Proxy 物件繼承的受管理的物件，例如記憶體回收相關聯的語意，支援的成員和方法，且可以擴充為新的類別。 Proxy 會做為遠端物件 (透明 proxy)，位於同一個類別的物件，同時也是受管理的物件。"
  syntax:
    content: public static System.Runtime.Remoting.Proxies.RealProxy GetRealProxy (object proxy);
    parameters:
    - id: proxy
      type: System.Object
      description: "Transparent proxy。"
    return:
      type: System.Runtime.Remoting.Proxies.RealProxy
      description: "Real proxy 執行個體可支援透明的 proxy。"
  overload: System.Runtime.Remoting.RemotingServices.GetRealProxy*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "立即呼叫者沒有基礎結構的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  id: GetServerTypeForUri(System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetServerTypeForUri(String)
  nameWithType: RemotingServices.GetServerTypeForUri(String)
  fullName: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "傳回<xref:System.Type>物件與指定的 URI。</xref:System.Type>"
  remarks: "因為遠端服務識別使用 Uri 的端點，GetServerTypeForUri 方法會很有用的遠端執行功能基礎結構 （例如，通道接收、 動態接收和內容接收） 使用隨插即用組件<xref:System.Runtime.Remoting.Messaging.IMessage>物件，因為目前的方法會傳回相關聯的類型物件，從 URI。</xref:System.Runtime.Remoting.Messaging.IMessage>"
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/visualbasic/m-system.runtime.remotin_84_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/csharp/m-system.runtime.remotin_84_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#7](~/add/codesnippet/cpp/m-system.runtime.remotin_84_1.cpp)]
  syntax:
    content: public static Type GetServerTypeForUri (string URI);
    parameters:
    - id: URI
      type: System.String
      description: "物件的 URI 其<xref:System.Type>要求。</xref:System.Type>"
    return:
      type: System.Type
      description: "<xref:System.Type>物件與指定的 URI。</xref:System.Type>"
  overload: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "請立即呼叫者沒有基礎結構的權限，或至少一個呼叫堆疊中較高層的呼叫端沒有擷取非公用成員的型別資訊的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: GetSessionIdForMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "擷取訊息的工作階段識別碼。"
  remarks: "相同的工作階段識別碼可能會傳回相同的應用程式中的物件，但這個方法永遠不會傳回不同的遠端應用程式中的兩個物件相同的工作階段識別碼。       如需工作階段和工作階段識別碼所識別的詳細資訊，請參閱 ASP.Net [ASP.NET 工作階段狀態概觀](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates how to get the session ID string for the current session.  \n  \n [!code-cs[RemotingServices.ExecuteMessage#1](~/add/codesnippet/csharp/b83444fc-48c3-47e9-b264-_1.cs)]\n [!code-cpp[RemotingServices.ExecuteMessage#1](~/add/codesnippet/cpp/b83444fc-48c3-47e9-b264-_1.cpp)]\n [!code-vb[RemotingServices.ExecuteMessage#1](~/add/codesnippet/visualbasic/b83444fc-48c3-47e9-b264-_1.vb)]"
  syntax:
    content: public static string GetSessionIdForMethodMessage (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "<xref href=&quot;System.Runtime.Remoting.Messaging.IMethodMessage&quot;> </xref>要求工作階段識別碼。"
    return:
      type: System.String
      description: "可唯一識別目前工作階段的工作階段識別碼字串。"
  overload: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "立即呼叫者沒有基礎結構的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  id: IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsMethodOverloaded(IMethodMessage)
  nameWithType: RemotingServices.IsMethodOverloaded(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(IMethodMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "傳回布林值，指出是否為多載中指定的訊息的方法。"
  syntax:
    content: public static bool IsMethodOverloaded (System.Runtime.Remoting.Messaging.IMethodMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMethodMessage
      description: "包含有問題的方法呼叫的訊息。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果呼叫方法<code> msg </code>多載，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "立即呼叫者沒有基礎結構的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  id: IsObjectOutOfAppDomain(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsObjectOutOfAppDomain(Object)
  nameWithType: RemotingServices.IsObjectOutOfAppDomain(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "傳回布林值，指出指定的傳輸 proxy 所指定的物件是否包含在呼叫目前方法的物件不同的應用程式定義域。"
  remarks: "如需應用程式定義域的詳細資訊，請參閱[應用程式定義域](http://msdn.microsoft.com/en-us/39e57d07-a740-4cd4-ae82-e119ea3856c1)。"
  example:
  - >-
    [!code-cpp[RemotingServices IsObject Snippets#1](~/add/codesnippet/cpp/m-system.runtime.remotin_103_1.cpp)]
     [!code-vb[RemotingServices IsObject Snippets#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_103_1.vb)]
     [!code-cs[RemotingServices IsObject Snippets#1](~/add/codesnippet/csharp/m-system.runtime.remotin_103_1.cs)]
  syntax:
    content: public static bool IsObjectOutOfAppDomain (object tp);
    parameters:
    - id: tp
      type: System.Object
      description: "要檢查的物件。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果物件是從目前的應用程式定義域。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  id: IsObjectOutOfContext(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsObjectOutOfContext(Object)
  nameWithType: RemotingServices.IsObjectOutOfContext(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "傳回布林值，指出指定之 proxy 所表示的物件是否包含在呼叫目前方法的物件不同的內容。"
  remarks: "內容是已排序的屬性，定義環境所在的物件序列。 內容的物件設定為需要某些自動服務，這類同步處理、 交易，在 just-in-time 啟動、 安全性和等等的啟用程序期間建立。 多個物件可以即時內容中。"
  example:
  - >-
    [!code-cpp[RemotingServices IsObject Snippets#1](~/add/codesnippet/cpp/m-system.runtime.remotin_37_1.cpp)]
     [!code-vb[RemotingServices IsObject Snippets#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_37_1.vb)]
     [!code-cs[RemotingServices IsObject Snippets#1](~/add/codesnippet/csharp/m-system.runtime.remotin_37_1.cs)]
  syntax:
    content: public static bool IsObjectOutOfContext (object tp);
    parameters:
    - id: tp
      type: System.Object
      description: "要檢查的物件。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果物件是從目前的內容。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  id: IsOneWay(System.Reflection.MethodBase)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsOneWay(MethodBase)
  nameWithType: RemotingServices.IsOneWay(MethodBase)
  fullName: System.Runtime.Remoting.RemotingServices.IsOneWay(MethodBase)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "傳回布林值，指出指定的訊息中指定的用戶端呼叫該方法是否正在等候伺服器完成之前繼續執行的處理方法。"
  remarks: "單向方法呼叫時，用戶端不會等待伺服器來完成處理訊息。 用戶端方法會傳回不知道應用程式在伺服器將會成功處理訊息。 將方法標記為一種方式使用<xref:System.Runtime.Remoting.Messaging.OneWayAttribute>.</xref:System.Runtime.Remoting.Messaging.OneWayAttribute>       單向方法不能有傳回值或任何 out 參數。"
  example:
  - >-
    [!code-vb[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/visualbasic/e9c4a9fc-d92a-4e43-97a5-_1.vb)]
     [!code-cs[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/csharp/e9c4a9fc-d92a-4e43-97a5-_1.cs)]
     [!code-cpp[System.Runtime.Remoting.RemotingServices#2](~/add/codesnippet/cpp/e9c4a9fc-d92a-4e43-97a5-_1.cpp)]
  syntax:
    content: public static bool IsOneWay (System.Reflection.MethodBase method);
    parameters:
    - id: method
      type: System.Reflection.MethodBase
      description: "有問題的方法。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果此方法是一種方式;否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Runtime.Remoting.RemotingServices.IsOneWay*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "立即呼叫者沒有基礎結構的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  id: IsTransparentProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: IsTransparentProxy(Object)
  nameWithType: RemotingServices.IsTransparentProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "傳回布林值，指出指定的物件是否為 transparent proxy 或實際的物件。"
  remarks: "使用物件之間任何一種遠端界限的用戶端實際上正在使用 transparent proxy 物件。 透明 proxy 可讓您以為實際物件位於用戶端的空間。 它的做法是轉送實際使用的遠端執行功能基礎結構的物件上所進行的呼叫。       透明 proxy 是本身的型別<xref:System.Runtime.Remoting.Proxies.RealProxy>.</xref:System.Runtime.Remoting.Proxies.RealProxy>受管理的執行階段類別的執行個體所裝載 <xref:System.Runtime.Remoting.Proxies.RealProxy>實作從傳輸 proxy 轉送作業所需的功能的一部分。</xref:System.Runtime.Remoting.Proxies.RealProxy> Proxy 物件繼承的受管理的物件，例如記憶體回收相關聯的語意，支援的成員和方法，且可以擴充為新的類別。 因此 proxy 具有雙重本質。一方面它必須做為遠端物件 (透明 proxy)，位於同一個類別的物件，而且是在其他受管理的物件本身。       可以使用 proxy 物件，而不考慮<xref:System.AppDomain>.</xref:System.AppDomain>內任何遠端處理細分 應用程式不需要區分 proxy 參考和物件參考。 不過，處理問題，例如啟動服務提供者，存留期管理與交易需要進行這類差異。"
  example:
  - "The following code example demonstrates the use of the IsTransparentProxy method to determine whether an object is a proxy or a real object. For the complete example code, see the example for the <xref:System.Runtime.Remoting.Messaging.AsyncResult> class.  \n  \n [!code-cpp[AsyncResult.NewExamples#6](~/add/codesnippet/cpp/m-system.runtime.remotin_47_1.cpp)]\n [!code-vb[AsyncResult.NewExamples#6](~/add/codesnippet/visualbasic/m-system.runtime.remotin_47_1.vb)]\n [!code-cs[AsyncResult.NewExamples#6](~/add/codesnippet/csharp/m-system.runtime.remotin_47_1.cs)]"
  syntax:
    content: public static bool IsTransparentProxy (object proxy);
    parameters:
    - id: proxy
      type: System.Object
      description: "若要檢查物件的參考。"
    return:
      type: System.Boolean
      description: "布林值，指出是否在指定的物件<code> proxy </code>參數為 transparent proxy 或實際的物件。"
  overload: System.Runtime.Remoting.RemotingServices.IsTransparentProxy*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  id: LogRemotingStage(System.Int32)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: LogRemotingStage(Int32)
  nameWithType: RemotingServices.LogRemotingStage(Int32)
  fullName: System.Runtime.Remoting.RemotingServices.LogRemotingStage(Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "遠端服務交換外部的偵錯工具中所記錄的階段。"
  remarks: "A`&quot;REMOTING_PERF&quot;`前置處理符號套用至方法使用<xref:System.Diagnostics.ConditionalAttribute>屬性。</xref:System.Diagnostics.ConditionalAttribute>"
  syntax:
    content: public static void LogRemotingStage (int stage);
    parameters:
    - id: stage
      type: System.Int32
      description: "內部定義的常數，識別遠端服務交換的階段。"
  overload: System.Runtime.Remoting.RemotingServices.LogRemotingStage*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  id: Marshal(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "會採用<xref href=&quot;System.MarshalByRefObject&quot;> </xref>、 登錄它的遠端執行功能基礎結構，並將它的執行個體轉換為<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>類別。"
  remarks: "A<xref:System.Runtime.Remoting.ObjRef>是用來在應用程式定義域界限間傳送的物件參考的物件的序列化表示法。</xref:System.Runtime.Remoting.ObjRef> 建立<xref:System.Runtime.Remoting.ObjRef>的物件稱為封送處理。</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>可以另一個應用程式定義域透過通道傳送，（可能是在另一個處理序或電腦）。</xref:System.Runtime.Remoting.ObjRef> 在其他應用程式網域中，一次<xref:System.Runtime.Remoting.ObjRef>必須剖析以建立物件，通常會連接至實際物件的 proxy。</xref:System.Runtime.Remoting.ObjRef> 這項作業稱為解封送處理。       A<xref:System.Runtime.Remoting.ObjRef>包含描述的資訊<xref:System.Type>和封送處理物件的類別，可唯一識別特定物件執行個體和通訊的 URI 相關如何連線到遠端執行功能細分物件所在的位置資訊。</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       在封送處理，會使用從目前的執行緒內容，不是內容時所使用的物件建立。 如果 URI 並未明確設定的<xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A>方法，它會自動產生遠端身分識別基礎結構。</xref:System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal%2A>       您無法將與 proxy 的 URI 關聯的兩個原因︰ 在伺服器端物件，它表示，產生 URI 或物件為已知，在此情況下 URI 為已知。 基於這個理由，如果`Obj`參數為 proxy，將會擲回例外狀況。 自訂 proxy 被放寬這項限制，因為傳輸 proxy 會被視為伺服器物件。"
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "要轉換的物件。"
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "執行個體<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>表示中指定的物件類別<code> Obj </code>參數。"
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code> Obj </code>參數是物件的 proxy。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  id: Marshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "將給定<xref href=&quot;System.MarshalByRefObject&quot;></xref>的執行個體<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>類別使用指定的 URI。"
  remarks: "A<xref:System.Runtime.Remoting.ObjRef>是用來在應用程式定義域界限間傳送的物件參考的物件的序列化表示法。</xref:System.Runtime.Remoting.ObjRef> 建立<xref:System.Runtime.Remoting.ObjRef>的物件稱為封送處理。</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>可以另一個應用程式定義域透過通道傳送，（可能是在另一個處理序或電腦）。</xref:System.Runtime.Remoting.ObjRef> 在其他應用程式網域中，一次<xref:System.Runtime.Remoting.ObjRef>必須剖析以建立物件，通常會連接至實際物件的 proxy。</xref:System.Runtime.Remoting.ObjRef> 這項作業稱為解封送處理。       A<xref:System.Runtime.Remoting.ObjRef>包含描述的資訊<xref:System.Type>和封送處理物件的類別，可唯一識別特定物件執行個體和通訊的 URI 相關如何連線到遠端執行功能細分物件所在的位置資訊。</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       在封送處理，會使用從目前的執行緒內容，不是內容時所使用的物件建立。       您無法將與 proxy 的 URI 關聯的兩個原因︰ 在伺服器端物件，它表示，產生 URI 或物件為已知，在此情況下 URI 為已知。 基於這個理由，如果`Obj`參數為 proxy，將會擲回例外狀況。 自訂 proxy 被放寬這項限制，因為傳輸 proxy 會被視為伺服器物件。"
  example:
  - "The following code example demonstrates how to use the current <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> method to marshal a specified object.  \n  \n [!code-cpp[RemotingServices.BasicSample#2](~/add/codesnippet/cpp/01236a8e-f8c3-4b7b-875d-_1.cpp)]\n [!code-cs[RemotingServices.BasicSample#2](~/add/codesnippet/csharp/01236a8e-f8c3-4b7b-875d-_1.cs)]\n [!code-vb[RemotingServices.BasicSample#2](~/add/codesnippet/visualbasic/01236a8e-f8c3-4b7b-875d-_1.vb)]"
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string URI);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "要轉換的物件。"
    - id: URI
      type: System.String
      description: "指定的 URI，用來初始化新<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "執行個體<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>表示中指定的物件類別<code> Obj </code>參數。"
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>Obj</code>物件 proxy，而<code>URI</code>參數不是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  id: Marshal(System.MarshalByRefObject,System.String,System.Type)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Marshal(MarshalByRefObject,String,Type)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String,Type)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String,Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "會採用<xref href=&quot;System.MarshalByRefObject&quot;></xref>並將它轉換成的執行個體<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>類別具有指定的 URI，以及提供<xref:System.Type>.</xref:System.Type>"
  remarks: "A<xref:System.Runtime.Remoting.ObjRef>是用來在應用程式定義域界限間傳送的物件參考的物件的序列化表示法。</xref:System.Runtime.Remoting.ObjRef> 建立<xref:System.Runtime.Remoting.ObjRef>的物件稱為封送處理。</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>可以另一個應用程式定義域透過通道傳送，（可能是在另一個處理序或電腦）。</xref:System.Runtime.Remoting.ObjRef> 在其他應用程式網域中，一次<xref:System.Runtime.Remoting.ObjRef>必須剖析以建立物件，通常會連接至實際物件的 proxy。</xref:System.Runtime.Remoting.ObjRef> 這項作業稱為解封送處理。       A<xref:System.Runtime.Remoting.ObjRef>包含描述的資訊<xref:System.Type>和封送處理物件的類別，可唯一識別特定物件執行個體和通訊的 URI 相關如何連線到遠端執行功能細分物件所在的位置資訊。</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       指定<xref:System.Type>由遠端執行功能基礎結構用來限制公開的類型階層的範圍。</xref:System.Type> 比方說，如果物件 A 衍生自物件 B，衍生自物件 C，稱為<xref:System.Runtime.Remoting.RemotingServices.Marshal%2A>，然後用戶端可以轉型 proxy 之間 C 和 B，但不是屬於 a。      封送處理期間從目前的執行緒內容，則不是內容時所使用的物件建立。</xref:System.Runtime.Remoting.RemotingServices.Marshal%2A>       您無法將與 proxy 的 URI 關聯的兩個原因︰ 在伺服器端物件，它表示，產生 URI 或物件為已知，在此情況下 URI 為已知。 基於這個理由，如果`Obj`參數為 proxy，將會擲回例外狀況。 自訂 proxy 被放寬這項限制，因為傳輸 proxy 會被視為伺服器物件。"
  syntax:
    content: public static System.Runtime.Remoting.ObjRef Marshal (MarshalByRefObject Obj, string ObjURI, Type RequestedType);
    parameters:
    - id: Obj
      type: System.MarshalByRefObject
      description: "要轉換的物件<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>。"
    - id: ObjURI
      type: System.String
      description: "URI 中指定的物件`Obj`參數與封送處理。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    - id: RequestedType
      type: System.Type
      description: "<xref:System.Type>`Obj`封送處理為。</xref:System.Type> Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    return:
      type: System.Runtime.Remoting.ObjRef
      description: "執行個體<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>表示中指定的物件類別<code> Obj </code>參數。"
  overload: System.Runtime.Remoting.RemotingServices.Marshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>Obj</code>是為遠端物件的 proxy 和<code>ObjUri</code>參數不是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  id: SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: SetObjectUriForMarshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "設定的後續呼叫 URI<xref:System.Runtime.Remoting.RemotingServices.Marshal*>方法。</xref:System.Runtime.Remoting.RemotingServices.Marshal*>"
  remarks: "The URI set by the current method is used when marshaling the given object.  \n  \n After marshaling, the URI of the specified object is set to the string in the `uri` parameter appended onto the <xref:System.Guid> of the current <xref:System.AppDomain>.  \n  \n If the current application is listening on an HTTP port, then both the string specified in the `uri` parameter and the `uri` string appended onto the <xref:System.Guid> of the current <xref:System.AppDomain> route to the specified object. For example, if the application is listening on HTTP port 9000, then both http://localhost:9000/objectUri, and http://localhost:9000/\\<appdomainguid>/objectUri route to the object specified in the `obj` parameter."
  example:
  - "The following code example demonstrates how to set the URI that will be used by the <xref:System.Runtime.Remoting.RemotingServices.Marshal%2A> method when marshaling the specified object.  \n  \n [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/cpp/2ed6d271-806d-4778-95aa-_1.cpp)]\n [!code-cs[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/csharp/2ed6d271-806d-4778-95aa-_1.cs)]\n [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/add/codesnippet/visualbasic/2ed6d271-806d-4778-95aa-_1.vb)]"
  syntax:
    content: public static void SetObjectUriForMarshal (MarshalByRefObject obj, string uri);
    parameters:
    - id: obj
      type: System.MarshalByRefObject
      description: "若要設定的 URI 物件。"
    - id: uri
      type: System.String
      description: "若要指派給指定的物件 URI。"
  overload: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal*
  exceptions:
  - type: System.Runtime.Remoting.RemotingException
    commentId: T:System.Runtime.Remoting.RemotingException
    description: "<code>obj</code>是本機的物件，具有已封送處理，或在已呼叫過目前的方法。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  id: Unmarshal(System.Runtime.Remoting.ObjRef)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Unmarshal(ObjRef)
  nameWithType: RemotingServices.Unmarshal(ObjRef)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "會採用<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>並建立不使用 proxy 物件。"
  remarks: "A<xref:System.Runtime.Remoting.ObjRef>是用來在應用程式定義域界限間傳送的物件參考的物件的序列化表示法。</xref:System.Runtime.Remoting.ObjRef> 建立<xref:System.Runtime.Remoting.ObjRef>的物件稱為封送處理。</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>可以另一個應用程式定義域透過通道傳送，（可能是在另一個處理序或電腦）。</xref:System.Runtime.Remoting.ObjRef> 在其他應用程式網域中，一次<xref:System.Runtime.Remoting.ObjRef>必須剖析以建立物件，通常會連接至實際物件的 proxy。</xref:System.Runtime.Remoting.ObjRef> 這項作業稱為解封送處理。 期間解封送處理，<xref:System.Runtime.Remoting.ObjRef>剖析擷取的方法資訊的遠端物件和透明 proxy 和<xref:System.Runtime.Remoting.Proxies.RealProxy>會建立物件。</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef> 內容的已剖析<xref:System.Runtime.Remoting.ObjRef>會先傳輸 proxy 向通用語言執行平台新增至傳輸 proxy。</xref:System.Runtime.Remoting.ObjRef>       A<xref:System.Runtime.Remoting.ObjRef>包含描述的資訊<xref:System.Type>和封送處理物件的類別，可唯一識別特定物件執行個體和通訊的 URI 相關如何連線到遠端執行功能細分物件所在的位置資訊。</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>"
  example:
  - "The following code example demonstrates how to unmarshal an object.  \n  \n [!code-vb[RemotingServices.Unmarshal#2](~/add/codesnippet/visualbasic/b4be8871-533a-4641-8763-_1.vb)]\n [!code-cpp[RemotingServices.Unmarshal#2](~/add/codesnippet/cpp/b4be8871-533a-4641-8763-_1.cpp)]\n [!code-cs[RemotingServices.Unmarshal#2](~/add/codesnippet/csharp/b4be8871-533a-4641-8763-_1.cs)]"
  syntax:
    content: public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef);
    parameters:
    - id: objectRef
      type: System.Runtime.Remoting.ObjRef
      description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> ，代表為其建立 proxy 的遠端物件。"
    return:
      type: System.Object
      description: "物件的 proxy，給定<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>代表。"
  overload: System.Runtime.Remoting.RemotingServices.Unmarshal*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>中指定的執行個體<code> objectRef </code>參數不是語式正確。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  id: Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  parent: System.Runtime.Remoting.RemotingServices
  langs:
  - csharp
  name: Unmarshal(ObjRef,Boolean)
  nameWithType: RemotingServices.Unmarshal(ObjRef,Boolean)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "會採用<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>並建立精簡至伺服器的類型不使用，proxy 物件。"
  remarks: "A<xref:System.Runtime.Remoting.ObjRef>是用來在應用程式定義域界限間傳送的物件參考的物件的序列化表示法。</xref:System.Runtime.Remoting.ObjRef> 建立<xref:System.Runtime.Remoting.ObjRef>的物件稱為封送處理。</xref:System.Runtime.Remoting.ObjRef> <xref:System.Runtime.Remoting.ObjRef>可以另一個應用程式定義域透過通道傳送，（可能是在另一個處理序或電腦）。</xref:System.Runtime.Remoting.ObjRef> 在其他應用程式網域中，一次<xref:System.Runtime.Remoting.ObjRef>必須剖析以建立物件，通常會連接至實際物件的 proxy。</xref:System.Runtime.Remoting.ObjRef> 這項作業稱為解封送處理。 期間解封送處理，<xref:System.Runtime.Remoting.ObjRef>剖析擷取的方法資訊的遠端物件和透明 proxy 和<xref:System.Runtime.Remoting.Proxies.RealProxy>會建立物件。</xref:System.Runtime.Remoting.Proxies.RealProxy> </xref:System.Runtime.Remoting.ObjRef> 內容的已剖析<xref:System.Runtime.Remoting.ObjRef>會先傳輸 proxy 向通用語言執行平台新增至傳輸 proxy。</xref:System.Runtime.Remoting.ObjRef>       A<xref:System.Runtime.Remoting.ObjRef>包含描述的資訊<xref:System.Type>和封送處理物件的類別，可唯一識別特定物件執行個體和通訊的 URI 相關如何連線到遠端執行功能細分物件所在的位置資訊。</xref:System.Type> </xref:System.Runtime.Remoting.ObjRef>       最初建立時，proxy 是型別<xref:System.MarshalByRefObject>.</xref:System.MarshalByRefObject> 您將它轉換成不同的類型，遠端執行功能基礎結構會追蹤的最常使用的型別，以避免不必要地載入型別。"
  syntax:
    content: public static object Unmarshal (System.Runtime.Remoting.ObjRef objectRef, bool fRefine);
    parameters:
    - id: objectRef
      type: System.Runtime.Remoting.ObjRef
      description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref> ，代表為其建立 proxy 的遠端物件。"
    - id: fRefine
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要精簡 proxy 伺服器; 上的類型否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Object
      description: "物件的 proxy，給定<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;></xref>代表。"
  overload: System.Runtime.Remoting.RemotingServices.Unmarshal*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref href=&quot;System.Runtime.Remoting.ObjRef&quot;> </xref>中指定的執行個體<code> objectRef </code>參數不是語式正確。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Runtime.Remoting.RemotingException
  parent: System.Runtime.Remoting
  isExternal: false
  name: RemotingException
  nameWithType: RemotingException
  fullName: System.Runtime.Remoting.RemotingException
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect(Type,String)
  nameWithType: RemotingServices.Connect(Type,String)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Runtime.Remoting.RemotingServices.Connect(System.Type,System.String,System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect(Type,String,Object)
  nameWithType: RemotingServices.Connect(Type,String,Object)
  fullName: System.Runtime.Remoting.RemotingServices.Connect(Type,String,Object)
- uid: System.Runtime.Remoting.RemotingServices.Disconnect(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Disconnect(MarshalByRefObject)
  nameWithType: RemotingServices.Disconnect(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Disconnect(MarshalByRefObject)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.MarshalByRefObject
  parent: System
  isExternal: false
  name: MarshalByRefObject
  nameWithType: MarshalByRefObject
  fullName: System.MarshalByRefObject
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage(System.MarshalByRefObject,System.Runtime.Remoting.Messaging.IMethodCallMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  nameWithType: RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
  fullName: System.Runtime.Remoting.RemotingServices.ExecuteMessage(MarshalByRefObject,IMethodCallMessage)
- uid: System.Runtime.Remoting.Messaging.IMethodReturnMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodReturnMessage
  nameWithType: IMethodReturnMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodReturnMessage
- uid: System.Runtime.Remoting.Messaging.IMethodCallMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodCallMessage
  nameWithType: IMethodCallMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodCallMessage
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetEnvoyChainForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy(MarshalByRefObject)
- uid: System.Runtime.Remoting.Messaging.IMessageSink
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMessageSink
  nameWithType: IMessageSink
  fullName: System.Runtime.Remoting.Messaging.IMessageSink
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetLifetimeService(MarshalByRefObject)
  nameWithType: RemotingServices.GetLifetimeService(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetLifetimeService(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetMethodBaseFromMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage(IMethodMessage)
- uid: System.Reflection.MethodBase
  parent: System.Reflection
  isExternal: true
  name: MethodBase
  nameWithType: MethodBase
  fullName: System.Reflection.MethodBase
- uid: System.Runtime.Remoting.Messaging.IMethodMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMethodMessage
  nameWithType: IMethodMessage
  fullName: System.Runtime.Remoting.Messaging.IMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData(System.Object,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectData(Object,SerializationInfo,StreamingContext)
  nameWithType: RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectData(Object,SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectUri(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjectUri(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjectUri(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjRefForProxy(MarshalByRefObject)
  nameWithType: RemotingServices.GetObjRefForProxy(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy(MarshalByRefObject)
- uid: System.Runtime.Remoting.ObjRef
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjRef
  nameWithType: ObjRef
  fullName: System.Runtime.Remoting.ObjRef
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetRealProxy(Object)
  nameWithType: RemotingServices.GetRealProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.GetRealProxy(Object)
- uid: System.Runtime.Remoting.Proxies.RealProxy
  parent: System.Runtime.Remoting.Proxies
  isExternal: false
  name: RealProxy
  nameWithType: RealProxy
  fullName: System.Runtime.Remoting.Proxies.RealProxy
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetServerTypeForUri(String)
  nameWithType: RemotingServices.GetServerTypeForUri(String)
  fullName: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri(String)
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetSessionIdForMethodMessage(IMethodMessage)
  nameWithType: RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage(IMethodMessage)
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsMethodOverloaded(IMethodMessage)
  nameWithType: RemotingServices.IsMethodOverloaded(IMethodMessage)
  fullName: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded(IMethodMessage)
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfAppDomain(Object)
  nameWithType: RemotingServices.IsObjectOutOfAppDomain(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain(Object)
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfContext(Object)
  nameWithType: RemotingServices.IsObjectOutOfContext(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext(Object)
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay(System.Reflection.MethodBase)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsOneWay(MethodBase)
  nameWithType: RemotingServices.IsOneWay(MethodBase)
  fullName: System.Runtime.Remoting.RemotingServices.IsOneWay(MethodBase)
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(System.Object)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsTransparentProxy(Object)
  nameWithType: RemotingServices.IsTransparentProxy(Object)
  fullName: System.Runtime.Remoting.RemotingServices.IsTransparentProxy(Object)
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage(System.Int32)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: LogRemotingStage(Int32)
  nameWithType: RemotingServices.LogRemotingStage(Int32)
  fullName: System.Runtime.Remoting.RemotingServices.LogRemotingStage(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject)
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String)
- uid: System.Runtime.Remoting.RemotingServices.Marshal(System.MarshalByRefObject,System.String,System.Type)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal(MarshalByRefObject,String,Type)
  nameWithType: RemotingServices.Marshal(MarshalByRefObject,String,Type)
  fullName: System.Runtime.Remoting.RemotingServices.Marshal(MarshalByRefObject,String,Type)
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(System.MarshalByRefObject,System.String)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: SetObjectUriForMarshal(MarshalByRefObject,String)
  nameWithType: RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
  fullName: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal(MarshalByRefObject,String)
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal(ObjRef)
  nameWithType: RemotingServices.Unmarshal(ObjRef)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef)
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal(System.Runtime.Remoting.ObjRef,System.Boolean)
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal(ObjRef,Boolean)
  nameWithType: RemotingServices.Unmarshal(ObjRef,Boolean)
  fullName: System.Runtime.Remoting.RemotingServices.Unmarshal(ObjRef,Boolean)
- uid: System.Runtime.Remoting.RemotingServices.Connect*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Connect
  nameWithType: RemotingServices.Connect
- uid: System.Runtime.Remoting.RemotingServices.Disconnect*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Disconnect
  nameWithType: RemotingServices.Disconnect
- uid: System.Runtime.Remoting.RemotingServices.ExecuteMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: ExecuteMessage
  nameWithType: RemotingServices.ExecuteMessage
- uid: System.Runtime.Remoting.RemotingServices.GetEnvoyChainForProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetEnvoyChainForProxy
  nameWithType: RemotingServices.GetEnvoyChainForProxy
- uid: System.Runtime.Remoting.RemotingServices.GetLifetimeService*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetLifetimeService
  nameWithType: RemotingServices.GetLifetimeService
- uid: System.Runtime.Remoting.RemotingServices.GetMethodBaseFromMethodMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetMethodBaseFromMethodMessage
  nameWithType: RemotingServices.GetMethodBaseFromMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.GetObjectData*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectData
  nameWithType: RemotingServices.GetObjectData
- uid: System.Runtime.Remoting.RemotingServices.GetObjectUri*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjectUri
  nameWithType: RemotingServices.GetObjectUri
- uid: System.Runtime.Remoting.RemotingServices.GetObjRefForProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetObjRefForProxy
  nameWithType: RemotingServices.GetObjRefForProxy
- uid: System.Runtime.Remoting.RemotingServices.GetRealProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetRealProxy
  nameWithType: RemotingServices.GetRealProxy
- uid: System.Runtime.Remoting.RemotingServices.GetServerTypeForUri*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetServerTypeForUri
  nameWithType: RemotingServices.GetServerTypeForUri
- uid: System.Runtime.Remoting.RemotingServices.GetSessionIdForMethodMessage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: GetSessionIdForMethodMessage
  nameWithType: RemotingServices.GetSessionIdForMethodMessage
- uid: System.Runtime.Remoting.RemotingServices.IsMethodOverloaded*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsMethodOverloaded
  nameWithType: RemotingServices.IsMethodOverloaded
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfAppDomain*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfAppDomain
  nameWithType: RemotingServices.IsObjectOutOfAppDomain
- uid: System.Runtime.Remoting.RemotingServices.IsObjectOutOfContext*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsObjectOutOfContext
  nameWithType: RemotingServices.IsObjectOutOfContext
- uid: System.Runtime.Remoting.RemotingServices.IsOneWay*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsOneWay
  nameWithType: RemotingServices.IsOneWay
- uid: System.Runtime.Remoting.RemotingServices.IsTransparentProxy*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: IsTransparentProxy
  nameWithType: RemotingServices.IsTransparentProxy
- uid: System.Runtime.Remoting.RemotingServices.LogRemotingStage*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: LogRemotingStage
  nameWithType: RemotingServices.LogRemotingStage
- uid: System.Runtime.Remoting.RemotingServices.Marshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Marshal
  nameWithType: RemotingServices.Marshal
- uid: System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: SetObjectUriForMarshal
  nameWithType: RemotingServices.SetObjectUriForMarshal
- uid: System.Runtime.Remoting.RemotingServices.Unmarshal*
  parent: System.Runtime.Remoting.RemotingServices
  isExternal: false
  name: Unmarshal
  nameWithType: RemotingServices.Unmarshal
