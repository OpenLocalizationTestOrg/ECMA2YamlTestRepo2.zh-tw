### YamlMime:ManagedReference
items:
- uid: System.Windows.FrameworkContentElement
  id: FrameworkContentElement
  children:
  - System.Windows.FrameworkContentElement.#ctor
  - System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  - System.Windows.FrameworkContentElement.BeginInit
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  - System.Windows.FrameworkContentElement.BindingGroup
  - System.Windows.FrameworkContentElement.BindingGroupProperty
  - System.Windows.FrameworkContentElement.BringIntoView
  - System.Windows.FrameworkContentElement.ContextMenu
  - System.Windows.FrameworkContentElement.ContextMenuClosing
  - System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  - System.Windows.FrameworkContentElement.ContextMenuOpening
  - System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  - System.Windows.FrameworkContentElement.ContextMenuProperty
  - System.Windows.FrameworkContentElement.Cursor
  - System.Windows.FrameworkContentElement.CursorProperty
  - System.Windows.FrameworkContentElement.DataContext
  - System.Windows.FrameworkContentElement.DataContextChanged
  - System.Windows.FrameworkContentElement.DataContextProperty
  - System.Windows.FrameworkContentElement.DefaultStyleKey
  - System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  - System.Windows.FrameworkContentElement.EndInit
  - System.Windows.FrameworkContentElement.FindName(System.String)
  - System.Windows.FrameworkContentElement.FindResource(System.Object)
  - System.Windows.FrameworkContentElement.FocusVisualStyle
  - System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  - System.Windows.FrameworkContentElement.ForceCursor
  - System.Windows.FrameworkContentElement.ForceCursorProperty
  - System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  - System.Windows.FrameworkContentElement.GetUIParentCore
  - System.Windows.FrameworkContentElement.Initialized
  - System.Windows.FrameworkContentElement.InputScope
  - System.Windows.FrameworkContentElement.InputScopeProperty
  - System.Windows.FrameworkContentElement.IsInitialized
  - System.Windows.FrameworkContentElement.IsLoaded
  - System.Windows.FrameworkContentElement.Language
  - System.Windows.FrameworkContentElement.LanguageProperty
  - System.Windows.FrameworkContentElement.Loaded
  - System.Windows.FrameworkContentElement.LoadedEvent
  - System.Windows.FrameworkContentElement.LogicalChildren
  - System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  - System.Windows.FrameworkContentElement.Name
  - System.Windows.FrameworkContentElement.NameProperty
  - System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  - System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  - System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  - System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  - System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  - System.Windows.FrameworkContentElement.OverridesDefaultStyle
  - System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  - System.Windows.FrameworkContentElement.Parent
  - System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  - System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  - System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  - System.Windows.FrameworkContentElement.Resources
  - System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  - System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  - System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  - System.Windows.FrameworkContentElement.ShouldSerializeResources
  - System.Windows.FrameworkContentElement.ShouldSerializeStyle
  - System.Windows.FrameworkContentElement.SourceUpdated
  - System.Windows.FrameworkContentElement.Style
  - System.Windows.FrameworkContentElement.StyleProperty
  - System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.FrameworkContentElement.Tag
  - System.Windows.FrameworkContentElement.TagProperty
  - System.Windows.FrameworkContentElement.TargetUpdated
  - System.Windows.FrameworkContentElement.TemplatedParent
  - System.Windows.FrameworkContentElement.ToolTip
  - System.Windows.FrameworkContentElement.ToolTipClosing
  - System.Windows.FrameworkContentElement.ToolTipClosingEvent
  - System.Windows.FrameworkContentElement.ToolTipOpening
  - System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  - System.Windows.FrameworkContentElement.ToolTipProperty
  - System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  - System.Windows.FrameworkContentElement.Unloaded
  - System.Windows.FrameworkContentElement.UnloadedEvent
  - System.Windows.FrameworkContentElement.UnregisterName(System.String)
  - System.Windows.FrameworkContentElement.UpdateDefaultStyle
  langs:
  - csharp
  name: FrameworkContentElement
  nameWithType: FrameworkContentElement
  fullName: System.Windows.FrameworkContentElement
  type: Class
  summary: "FrameworkContentElement 是 WPF 架構層級實作，以及延伸<xref href=&quot;System.Windows.ContentElement&quot;></xref>基底類別。 FrameworkContentElement 加入對其他輸入[!INCLUDE[TLA#tla_api#plural](~/add/includes/tlasharptla-apisharpplural-md.md)]（包括工具提示和操作功能表）、 分鏡腳本、 資料繫結、 樣式支援，以及邏輯樹狀結構協助程式的資料內容[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]。"
  remarks: "FrameworkContentElement 並未尚未定義自己的轉譯行為。具現化程式碼或標記中的實際 FrameworkContentElement 類別執行個體可能會但會顯示在中為 nothing[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]應用程式[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]。 類別需要 FrameworkContentElement 子項目，做為其內容的模型的一部分，或是在 FrameworkContentElement 衍生類別必須提供呈現邏輯。       FrameworkContentElement 刻意平行設計很多相同[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)] <xref:System.Windows.FrameworkElement>.</xref:System.Windows.FrameworkElement>為 請注意，某些[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]上找到<xref:System.Windows.FrameworkElement>不會有 FrameworkContentElement 的對等項目。</xref:System.Windows.FrameworkElement> 有幾個<xref:System.Windows.FrameworkElement>[!INCLUDE[TLA2#tla_api#plural](~/add/includes/tla2sharptla-apisharpplural-md.md)]有的功能，例如幾何表示法或版面配置，哪些不相關的 FrameworkContentElement。</xref:System.Windows.FrameworkElement>       大部分的現有 FrameworkContentElement 衍生的類別中將可以找到<xref:System.Windows.Documents>命名空間。</xref:System.Windows.Documents> 許多這些衍生類別實作非固定格式文件模型項的目。 某些衍生的類別，例如<xref:System.Windows.Documents.Hyperlink>有一些控制項類似的功能，但是，這類控制項類似的項目仍然可以參與非固定格式文件模型衍生自 FrameworkContentElement。</xref:System.Windows.Documents.Hyperlink>"
  syntax:
    content: >-
      [System.Windows.Markup.RuntimeNameProperty("Name")]

      [System.Windows.Markup.UsableDuringInitialization(true)]

      [System.Windows.Markup.XmlLangProperty("Language")]

      [System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))]

      public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  - System.Windows.DependencyObject
  - System.Windows.ContentElement
  implements:
  - System.ComponentModel.ISupportInitialize
  - System.Windows.IFrameworkInputElement
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)
  - System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.AllowDrop
  - System.Windows.ContentElement.AllowDropProperty
  - System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)
  - System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.ContentElement.AreAnyTouchesCaptured
  - System.Windows.ContentElement.AreAnyTouchesCapturedProperty
  - System.Windows.ContentElement.AreAnyTouchesCapturedWithin
  - System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty
  - System.Windows.ContentElement.AreAnyTouchesDirectlyOver
  - System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty
  - System.Windows.ContentElement.AreAnyTouchesOver
  - System.Windows.ContentElement.AreAnyTouchesOverProperty
  - System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)
  - System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)
  - System.Windows.ContentElement.CaptureMouse
  - System.Windows.ContentElement.CaptureStylus
  - System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)
  - System.Windows.ContentElement.CommandBindings
  - System.Windows.ContentElement.DragEnter
  - System.Windows.ContentElement.DragEnterEvent
  - System.Windows.ContentElement.DragLeave
  - System.Windows.ContentElement.DragLeaveEvent
  - System.Windows.ContentElement.DragOver
  - System.Windows.ContentElement.DragOverEvent
  - System.Windows.ContentElement.Drop
  - System.Windows.ContentElement.DropEvent
  - System.Windows.ContentElement.Focus
  - System.Windows.ContentElement.Focusable
  - System.Windows.ContentElement.FocusableChanged
  - System.Windows.ContentElement.FocusableProperty
  - System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)
  - System.Windows.ContentElement.GiveFeedback
  - System.Windows.ContentElement.GiveFeedbackEvent
  - System.Windows.ContentElement.GotFocus
  - System.Windows.ContentElement.GotFocusEvent
  - System.Windows.ContentElement.GotKeyboardFocus
  - System.Windows.ContentElement.GotKeyboardFocusEvent
  - System.Windows.ContentElement.GotMouseCapture
  - System.Windows.ContentElement.GotMouseCaptureEvent
  - System.Windows.ContentElement.GotStylusCapture
  - System.Windows.ContentElement.GotStylusCaptureEvent
  - System.Windows.ContentElement.GotTouchCapture
  - System.Windows.ContentElement.GotTouchCaptureEvent
  - System.Windows.ContentElement.HasAnimatedProperties
  - System.Windows.ContentElement.InputBindings
  - System.Windows.ContentElement.IsEnabled
  - System.Windows.ContentElement.IsEnabledChanged
  - System.Windows.ContentElement.IsEnabledCore
  - System.Windows.ContentElement.IsEnabledProperty
  - System.Windows.ContentElement.IsFocused
  - System.Windows.ContentElement.IsFocusedProperty
  - System.Windows.ContentElement.IsInputMethodEnabled
  - System.Windows.ContentElement.IsKeyboardFocused
  - System.Windows.ContentElement.IsKeyboardFocusedChanged
  - System.Windows.ContentElement.IsKeyboardFocusedProperty
  - System.Windows.ContentElement.IsKeyboardFocusWithin
  - System.Windows.ContentElement.IsKeyboardFocusWithinChanged
  - System.Windows.ContentElement.IsKeyboardFocusWithinProperty
  - System.Windows.ContentElement.IsMouseCaptured
  - System.Windows.ContentElement.IsMouseCapturedChanged
  - System.Windows.ContentElement.IsMouseCapturedProperty
  - System.Windows.ContentElement.IsMouseCaptureWithin
  - System.Windows.ContentElement.IsMouseCaptureWithinChanged
  - System.Windows.ContentElement.IsMouseCaptureWithinProperty
  - System.Windows.ContentElement.IsMouseDirectlyOver
  - System.Windows.ContentElement.IsMouseDirectlyOverChanged
  - System.Windows.ContentElement.IsMouseDirectlyOverProperty
  - System.Windows.ContentElement.IsMouseOver
  - System.Windows.ContentElement.IsMouseOverProperty
  - System.Windows.ContentElement.IsStylusCaptured
  - System.Windows.ContentElement.IsStylusCapturedChanged
  - System.Windows.ContentElement.IsStylusCapturedProperty
  - System.Windows.ContentElement.IsStylusCaptureWithin
  - System.Windows.ContentElement.IsStylusCaptureWithinChanged
  - System.Windows.ContentElement.IsStylusCaptureWithinProperty
  - System.Windows.ContentElement.IsStylusDirectlyOver
  - System.Windows.ContentElement.IsStylusDirectlyOverChanged
  - System.Windows.ContentElement.IsStylusDirectlyOverProperty
  - System.Windows.ContentElement.IsStylusOver
  - System.Windows.ContentElement.IsStylusOverProperty
  - System.Windows.ContentElement.KeyDown
  - System.Windows.ContentElement.KeyDownEvent
  - System.Windows.ContentElement.KeyUp
  - System.Windows.ContentElement.KeyUpEvent
  - System.Windows.ContentElement.LostFocus
  - System.Windows.ContentElement.LostFocusEvent
  - System.Windows.ContentElement.LostKeyboardFocus
  - System.Windows.ContentElement.LostKeyboardFocusEvent
  - System.Windows.ContentElement.LostMouseCapture
  - System.Windows.ContentElement.LostMouseCaptureEvent
  - System.Windows.ContentElement.LostStylusCapture
  - System.Windows.ContentElement.LostStylusCaptureEvent
  - System.Windows.ContentElement.LostTouchCapture
  - System.Windows.ContentElement.LostTouchCaptureEvent
  - System.Windows.ContentElement.MouseDown
  - System.Windows.ContentElement.MouseDownEvent
  - System.Windows.ContentElement.MouseEnter
  - System.Windows.ContentElement.MouseEnterEvent
  - System.Windows.ContentElement.MouseLeave
  - System.Windows.ContentElement.MouseLeaveEvent
  - System.Windows.ContentElement.MouseLeftButtonDown
  - System.Windows.ContentElement.MouseLeftButtonDownEvent
  - System.Windows.ContentElement.MouseLeftButtonUp
  - System.Windows.ContentElement.MouseLeftButtonUpEvent
  - System.Windows.ContentElement.MouseMove
  - System.Windows.ContentElement.MouseMoveEvent
  - System.Windows.ContentElement.MouseRightButtonDown
  - System.Windows.ContentElement.MouseRightButtonDownEvent
  - System.Windows.ContentElement.MouseRightButtonUp
  - System.Windows.ContentElement.MouseRightButtonUpEvent
  - System.Windows.ContentElement.MouseUp
  - System.Windows.ContentElement.MouseUpEvent
  - System.Windows.ContentElement.MouseWheel
  - System.Windows.ContentElement.MouseWheelEvent
  - System.Windows.ContentElement.OnCreateAutomationPeer
  - System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)
  - System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)
  - System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)
  - System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)
  - System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)
  - System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)
  - System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)
  - System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)
  - System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)
  - System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)
  - System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)
  - System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)
  - System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)
  - System.Windows.ContentElement.PreviewDragEnter
  - System.Windows.ContentElement.PreviewDragEnterEvent
  - System.Windows.ContentElement.PreviewDragLeave
  - System.Windows.ContentElement.PreviewDragLeaveEvent
  - System.Windows.ContentElement.PreviewDragOver
  - System.Windows.ContentElement.PreviewDragOverEvent
  - System.Windows.ContentElement.PreviewDrop
  - System.Windows.ContentElement.PreviewDropEvent
  - System.Windows.ContentElement.PreviewGiveFeedback
  - System.Windows.ContentElement.PreviewGiveFeedbackEvent
  - System.Windows.ContentElement.PreviewGotKeyboardFocus
  - System.Windows.ContentElement.PreviewGotKeyboardFocusEvent
  - System.Windows.ContentElement.PreviewKeyDown
  - System.Windows.ContentElement.PreviewKeyDownEvent
  - System.Windows.ContentElement.PreviewKeyUp
  - System.Windows.ContentElement.PreviewKeyUpEvent
  - System.Windows.ContentElement.PreviewLostKeyboardFocus
  - System.Windows.ContentElement.PreviewLostKeyboardFocusEvent
  - System.Windows.ContentElement.PreviewMouseDown
  - System.Windows.ContentElement.PreviewMouseDownEvent
  - System.Windows.ContentElement.PreviewMouseLeftButtonDown
  - System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent
  - System.Windows.ContentElement.PreviewMouseLeftButtonUp
  - System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent
  - System.Windows.ContentElement.PreviewMouseMove
  - System.Windows.ContentElement.PreviewMouseMoveEvent
  - System.Windows.ContentElement.PreviewMouseRightButtonDown
  - System.Windows.ContentElement.PreviewMouseRightButtonDownEvent
  - System.Windows.ContentElement.PreviewMouseRightButtonUp
  - System.Windows.ContentElement.PreviewMouseRightButtonUpEvent
  - System.Windows.ContentElement.PreviewMouseUp
  - System.Windows.ContentElement.PreviewMouseUpEvent
  - System.Windows.ContentElement.PreviewMouseWheel
  - System.Windows.ContentElement.PreviewMouseWheelEvent
  - System.Windows.ContentElement.PreviewQueryContinueDrag
  - System.Windows.ContentElement.PreviewQueryContinueDragEvent
  - System.Windows.ContentElement.PreviewStylusButtonDown
  - System.Windows.ContentElement.PreviewStylusButtonDownEvent
  - System.Windows.ContentElement.PreviewStylusButtonUp
  - System.Windows.ContentElement.PreviewStylusButtonUpEvent
  - System.Windows.ContentElement.PreviewStylusDown
  - System.Windows.ContentElement.PreviewStylusDownEvent
  - System.Windows.ContentElement.PreviewStylusInAirMove
  - System.Windows.ContentElement.PreviewStylusInAirMoveEvent
  - System.Windows.ContentElement.PreviewStylusInRange
  - System.Windows.ContentElement.PreviewStylusInRangeEvent
  - System.Windows.ContentElement.PreviewStylusMove
  - System.Windows.ContentElement.PreviewStylusMoveEvent
  - System.Windows.ContentElement.PreviewStylusOutOfRange
  - System.Windows.ContentElement.PreviewStylusOutOfRangeEvent
  - System.Windows.ContentElement.PreviewStylusSystemGesture
  - System.Windows.ContentElement.PreviewStylusSystemGestureEvent
  - System.Windows.ContentElement.PreviewStylusUp
  - System.Windows.ContentElement.PreviewStylusUpEvent
  - System.Windows.ContentElement.PreviewTextInput
  - System.Windows.ContentElement.PreviewTextInputEvent
  - System.Windows.ContentElement.PreviewTouchDown
  - System.Windows.ContentElement.PreviewTouchDownEvent
  - System.Windows.ContentElement.PreviewTouchMove
  - System.Windows.ContentElement.PreviewTouchMoveEvent
  - System.Windows.ContentElement.PreviewTouchUp
  - System.Windows.ContentElement.PreviewTouchUpEvent
  - System.Windows.ContentElement.QueryContinueDrag
  - System.Windows.ContentElement.QueryContinueDragEvent
  - System.Windows.ContentElement.QueryCursor
  - System.Windows.ContentElement.QueryCursorEvent
  - System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)
  - System.Windows.ContentElement.ReleaseAllTouchCaptures
  - System.Windows.ContentElement.ReleaseMouseCapture
  - System.Windows.ContentElement.ReleaseStylusCapture
  - System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)
  - System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)
  - System.Windows.ContentElement.ShouldSerializeCommandBindings
  - System.Windows.ContentElement.ShouldSerializeInputBindings
  - System.Windows.ContentElement.StylusButtonDown
  - System.Windows.ContentElement.StylusButtonDownEvent
  - System.Windows.ContentElement.StylusButtonUp
  - System.Windows.ContentElement.StylusButtonUpEvent
  - System.Windows.ContentElement.StylusDown
  - System.Windows.ContentElement.StylusDownEvent
  - System.Windows.ContentElement.StylusEnter
  - System.Windows.ContentElement.StylusEnterEvent
  - System.Windows.ContentElement.StylusInAirMove
  - System.Windows.ContentElement.StylusInAirMoveEvent
  - System.Windows.ContentElement.StylusInRange
  - System.Windows.ContentElement.StylusInRangeEvent
  - System.Windows.ContentElement.StylusLeave
  - System.Windows.ContentElement.StylusLeaveEvent
  - System.Windows.ContentElement.StylusMove
  - System.Windows.ContentElement.StylusMoveEvent
  - System.Windows.ContentElement.StylusOutOfRange
  - System.Windows.ContentElement.StylusOutOfRangeEvent
  - System.Windows.ContentElement.StylusSystemGesture
  - System.Windows.ContentElement.StylusSystemGestureEvent
  - System.Windows.ContentElement.StylusUp
  - System.Windows.ContentElement.StylusUpEvent
  - System.Windows.ContentElement.TextInput
  - System.Windows.ContentElement.TextInputEvent
  - System.Windows.ContentElement.TouchDown
  - System.Windows.ContentElement.TouchDownEvent
  - System.Windows.ContentElement.TouchEnter
  - System.Windows.ContentElement.TouchEnterEvent
  - System.Windows.ContentElement.TouchesCaptured
  - System.Windows.ContentElement.TouchesCapturedWithin
  - System.Windows.ContentElement.TouchesDirectlyOver
  - System.Windows.ContentElement.TouchesOver
  - System.Windows.ContentElement.TouchLeave
  - System.Windows.ContentElement.TouchLeaveEvent
  - System.Windows.ContentElement.TouchMove
  - System.Windows.ContentElement.TouchMoveEvent
  - System.Windows.ContentElement.TouchUp
  - System.Windows.ContentElement.TouchUpEvent
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)
  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.DependencyObjectType
  - System.Windows.DependencyObject.Equals(System.Object)
  - System.Windows.DependencyObject.GetHashCode
  - System.Windows.DependencyObject.GetLocalValueEnumerator
  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.IsSealed
  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)
  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)
  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)
  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.#ctor
  id: '#ctor'
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FrameworkContentElement()
  nameWithType: FrameworkContentElement.FrameworkContentElement()
  fullName: System.Windows.FrameworkContentElement.FrameworkContentElement()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.FrameworkContentElement&quot;></xref>類別。"
  syntax:
    content: public FrameworkContentElement ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  id: AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: AddLogicalChild(Object)
  nameWithType: FrameworkContentElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.AddLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "將所提供項目加入為這個項目之子系。"
  remarks: "這個方法可以擲回例外狀況，如果呼叫時之邏輯樹狀結構正在反覆執行另一個處理序一次。       大部分<xref:System.Windows.FrameworkContentElement>衍生類別專用的公開集合負責內含項目 (例如，<xref:System.Windows.Documents.Span.Inlines%2A><xref:System.Windows.Documents.Span>類別;<xref:System.Windows.Documents.Section.Blocks%2A>上<xref:System.Windows.Documents.Section>類別)。</xref:System.Windows.Documents.Section> </xref:System.Windows.Documents.Section.Blocks%2A> </xref:System.Windows.Documents.Span> </xref:System.Windows.Documents.Span.Inlines%2A> </xref:System.Windows.FrameworkContentElement> 您通常可以避免不需要直接操作之邏輯樹狀結構，如果您改為衍生自這些類別。 使用內容項目的邏輯樹狀結構是進階的案例可能需要特殊的剖析器或特殊<xref:System.Windows.FrameworkElement>，可做為父轉譯項目 （內容主機）。</xref:System.Windows.FrameworkElement>       如需有關如何使用<xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>和 AddLogicalChild，請參閱[中 WPF 樹狀架構](~/add/includes/ajax-current-ext-md.md)。</xref:System.Windows.FrameworkContentElement.LogicalChildren%2A>"
  syntax:
    content: protected void AddLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "要加入的子項目。"
  overload: System.Windows.FrameworkContentElement.AddLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginInit
  id: BeginInit
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginInit()
  nameWithType: FrameworkContentElement.BeginInit()
  fullName: System.Windows.FrameworkContentElement.BeginInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化項目之前呼叫。"
  syntax:
    content: public virtual void BeginInit ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "開始所提供的分鏡腳本中所包含的動作順序。"
  remarks: "請勿使用簽章`isControllable`，參數，或指定該參數時， `false`，一旦達到&quot;填滿 」 期間，會移除相關聯的動畫時間軸時鐘。 因此動畫無法重新啟動之後執行一次。 請注意，控制動畫也需要分鏡腳本是具名或程式碼內的執行個體可存取。"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "若要開始分鏡腳本。"
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "開始使用選項指定如果屬性已有動畫效果應該會發生什麼提供分鏡腳本中所包含的動作順序。"
  remarks: "請勿使用簽章`isControllable`，參數，或指定該參數時， `false`，一旦達到&quot;填滿 」 期間，會移除相關聯的動畫時間軸時鐘。 因此動畫無法重新啟動之後執行一次。 請注意，控制動畫也需要分鏡腳本是具名或程式碼內的執行個體可存取。      ## 撰寫 HandoffBehavior 時使用您套用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>屬性使用<xref:System.Windows.Media.Animation.HandoffBehavior><xref:System.Windows.Media.Animation.HandoffBehavior>，任何<xref:System.Windows.Media.Animation.Clock>之前與該屬性相關聯的物件會繼續耗用系統資源; 計時系統不會自動移除時鐘。</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       若要避免發生效能問題，當您藉由套用大量時鐘<xref:System.Windows.Media.Animation.HandoffBehavior>，在它們完成之後，您應該從動畫屬性移除組成的時鐘。</xref:System.Windows.Media.Animation.HandoffBehavior> 有數種方式可移除時鐘:-若要從屬性移除所有時鐘，請使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>動畫物件的方法。</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 指定的第一個參數，要繪製之屬性和`null`做為第二個。 這會從屬性移除所有動畫時鐘。      -若要移除<xref:System.Windows.Media.Animation.AnimationClock>的時鐘，清單中使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>屬性<xref:System.Windows.Media.Animation.AnimationClock>來擷取<xref:System.Windows.Media.Animation.ClockController>，然後呼叫此<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法的<xref:System.Windows.Media.Animation.ClockController>。</xref:System.Windows.Media.Animation.ClockController></xref:System.Windows.Media.Animation.ClockController.Remove%2A></xref:System.Windows.Media.Animation.ClockController></xref:System.Windows.Media.Animation.AnimationClock></xref:System.Windows.Media.Animation.Clock.Controller%2A></xref:System.Windows.Media.Animation.AnimationClock>特定 這通常是<xref:System.Windows.Media.Animation.Clock.Completed>時鐘的事件處理常式。</xref:System.Windows.Media.Animation.Clock.Completed> 請注意，只有根時鐘可以控制<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>子時鐘的屬性會傳回`null`。</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> 也請注意，<xref:System.Windows.Media.Animation.Clock.Completed>是否有效的持續時間的時鐘永遠不會引發事件。</xref:System.Windows.Media.Animation.Clock.Completed>  在此情況下，使用者必須決定何時呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       這是主要的動畫長的存留期的物件上的問題。  記憶體回收物件時，也會中斷其時鐘和記憶體回收。       如需時鐘物件的詳細資訊，請參閱[動畫和計時系統概觀](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "若要開始分鏡腳本。"
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "描述使用分鏡腳本中所述的屬性已有動畫效果的行為在列舉值。"
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  id: BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "開始提供分鏡腳本的指定狀態後啟動動畫控制項中所包含的動作順序。"
  remarks: "請勿使用簽章`isControllable`，參數，或指定該參數時， `false`，一旦達到&quot;填滿 」 期間，會移除相關聯的動畫時間軸時鐘。 因此動畫無法重新啟動之後執行一次。 請注意，控制動畫也需要分鏡腳本是具名或程式碼內的執行個體可存取。      ## 撰寫 HandoffBehavior 時使用您套用<xref:System.Windows.Media.Animation.Storyboard>， <xref:System.Windows.Media.Animation.AnimationTimeline>，或<xref:System.Windows.Media.Animation.AnimationClock>屬性使用<xref:System.Windows.Media.Animation.HandoffBehavior><xref:System.Windows.Media.Animation.HandoffBehavior>，任何<xref:System.Windows.Media.Animation.Clock>之前與該屬性相關聯的物件會繼續耗用系統資源; 計時系統不會自動移除這些時鐘。</xref:System.Windows.Media.Animation.Clock> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.HandoffBehavior> </xref:System.Windows.Media.Animation.AnimationClock> </xref:System.Windows.Media.Animation.AnimationTimeline> </xref:System.Windows.Media.Animation.Storyboard>       若要避免發生效能問題，當您藉由套用大量時鐘<xref:System.Windows.Media.Animation.HandoffBehavior>，在它們完成之後，您應該從動畫屬性移除組成的時鐘。</xref:System.Windows.Media.Animation.HandoffBehavior> 有數種方式可移除時鐘:-若要從屬性移除所有時鐘，請使用<xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29>或<xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29>動畫物件的方法。</xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> </xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> 指定的第一個參數，要繪製之屬性和`null`做為第二個。 這會從屬性移除所有動畫時鐘。      -若要移除<xref:System.Windows.Media.Animation.AnimationClock>的時鐘，清單中使用<xref:System.Windows.Media.Animation.Clock.Controller%2A>屬性<xref:System.Windows.Media.Animation.AnimationClock>來擷取<xref:System.Windows.Media.Animation.ClockController>，然後呼叫此<xref:System.Windows.Media.Animation.ClockController.Remove%2A>方法的<xref:System.Windows.Media.Animation.ClockController>。</xref:System.Windows.Media.Animation.ClockController></xref:System.Windows.Media.Animation.ClockController.Remove%2A></xref:System.Windows.Media.Animation.ClockController></xref:System.Windows.Media.Animation.AnimationClock></xref:System.Windows.Media.Animation.Clock.Controller%2A></xref:System.Windows.Media.Animation.AnimationClock>特定 這通常是<xref:System.Windows.Media.Animation.Clock.Completed>時鐘的事件處理常式。</xref:System.Windows.Media.Animation.Clock.Completed> 請注意，只有根時鐘可以控制<xref:System.Windows.Media.Animation.ClockController>;<xref:System.Windows.Media.Animation.Clock.Controller%2A>子時鐘的屬性會傳回`null`。</xref:System.Windows.Media.Animation.Clock.Controller%2A> </xref:System.Windows.Media.Animation.ClockController> 也請注意，<xref:System.Windows.Media.Animation.Clock.Completed>是否有效的持續時間的時鐘永遠不會引發事件。</xref:System.Windows.Media.Animation.Clock.Completed>  在此情況下，使用者必須決定何時呼叫<xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</xref:System.Windows.Media.Animation.ClockController.Remove%2A>       這是主要的動畫長的存留期的物件上的問題。  記憶體回收物件時，也會中斷其時鐘和記憶體回收。       如需時鐘物件的詳細資訊，請參閱[動畫和計時系統概觀](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);
    parameters:
    - id: storyboard
      type: System.Windows.Media.Animation.Storyboard
      description: "若要開始分鏡腳本。"
    - id: handoffBehavior
      type: System.Windows.Media.Animation.HandoffBehavior
      description: "描述使用分鏡腳本中所述的屬性已有動畫效果的行為在列舉值。"
    - id: isControllable
      type: System.Boolean
      description: "宣告動畫是否可控制 （暫停） 啟動後。"
  overload: System.Windows.FrameworkContentElement.BeginStoryboard*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BindingGroup
  id: BindingGroup
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
  fullName: System.Windows.FrameworkContentElement.BindingGroup
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定<xref href=&quot;System.Windows.Data.BindingGroup&quot;></xref>所用的項目。"
  remarks: "A<xref:System.Windows.Data.BindingGroup>可以用來驗證物件的多個屬性的值。</xref:System.Windows.Data.BindingGroup> 例如，假設應用程式會提示使用者輸入的位址，然後填入型別的物件`Address`，其中包含屬性`Street`， `City`， `ZipCode`，和`Country`，與使用者提供的值。 應用程式必須包含四個面板<xref:System.Windows.Controls.TextBox>控制項，其中每個繫結至其中一個物件的屬性。</xref:System.Windows.Controls.TextBox> 您可以使用<xref:System.Windows.Controls.ValidationRule>中<xref:System.Windows.Data.BindingGroup>驗證`Address`物件。</xref:System.Windows.Data.BindingGroup> </xref:System.Windows.Controls.ValidationRule> 例如，<xref:System.Windows.Controls.ValidationRule>可以確保，郵遞區號就是有效的地址的國家/地區。</xref:System.Windows.Controls.ValidationRule>       子項目會繼承<xref:System.Windows.Data.BindingGroup>從其父項目，就如同任何其他可繼承的屬性。</xref:System.Windows.Data.BindingGroup>      <a name=&quot;dependencyPropertyInfo_BindingGroup&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  |中繼資料屬性設定為**true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.BindingGroupProperty>"
  syntax:
    content: public System.Windows.Data.BindingGroup BindingGroup { get; set; }
    return:
      type: System.Windows.Data.BindingGroup
      description: "<xref href=&quot;System.Windows.Data.BindingGroup&quot;> </xref>所用的項目。"
  overload: System.Windows.FrameworkContentElement.BindingGroup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BindingGroupProperty
  id: BindingGroupProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BindingGroupProperty
  nameWithType: FrameworkContentElement.BindingGroupProperty
  fullName: System.Windows.FrameworkContentElement.BindingGroupProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkContentElement.BindingGroup*>相依性屬性。</xref:System.Windows.FrameworkContentElement.BindingGroup*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty BindingGroupProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.BringIntoView
  id: BringIntoView
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: BringIntoView()
  nameWithType: FrameworkContentElement.BringIntoView()
  fullName: System.Windows.FrameworkContentElement.BringIntoView()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "嘗試將這個項目帶入檢視中，它包含在任何可捲動區域內。"
  remarks: "藉由呼叫這個方法，您實際上會呼叫<xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A>上任何父可捲動區域包含的項目 (父系很可能是<xref:System.Windows.FrameworkElement>，而非<xref:System.Windows.FrameworkContentElement>)。</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.FrameworkElement> </xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> 如果這個項目不包含在可捲動區域，仍然會引發事件，但會有任何作用。"
  syntax:
    content: public void BringIntoView ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.BringIntoView*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenu
  id: ContextMenu
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
  fullName: System.Windows.FrameworkContentElement.ContextMenu
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定透過要求的操作功能表時應該出現操作功能表項目的[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]從這個項目中。"
  remarks: "<a name=&quot;dependencyPropertyInfo_ContextMenu&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  |中繼資料屬性設定為`true`|None |</xref:System.Windows.FrameworkContentElement.ContextMenuProperty>"
  example:
  - "The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.  \n  \n [!code-xml[ContentElementsSmorgasbord#ContextMenu](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page1.xaml#contextmenu)]"
  syntax:
    content: public System.Windows.Controls.ContextMenu ContextMenu { get; set; }
    return:
      type: System.Windows.Controls.ContextMenu
      description: "這個項目會使用內容功能表。"
  overload: System.Windows.FrameworkContentElement.ContextMenu*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuClosing
  id: ContextMenuClosing
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuClosing
  nameWithType: FrameworkContentElement.ContextMenuClosing
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "項目上的任何操作功能表關閉之前發生。"
  remarks: "若要隱藏關閉內容功能表的 事件處理常式應將其標記為已處理。       若要使用此事件為<xref:System.Windows.EventTrigger>在樣式中，您必須參考的基礎服務的事件識別項︰ [!code-xml [CorePseudocode #FEContextMenuClosing](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuclosing) ] (需要這種使用方式，因為上的事件實作<xref:System.Windows.FrameworkContentElement>，會公開基礎的服務事件不會正確對應 ContextMenuClosing 識別項，以便用於觸發程序)。</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_ContextMenuClosing&quot;></a># # 路由事件資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  |路由策略 |反昇 |  |委派 |<xref:System.Windows.Controls.ContextMenuEventHandler>|</xref:System.Windows.Controls.ContextMenuEventHandler></xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>"
  example:
  - "The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown). The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  id: ContextMenuClosingEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuClosingEvent
  nameWithType: FrameworkContentElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuClosing&quot;> </xref> [路由傳送事件概觀](~/add/includes/ajax-current-ext-md.md)。"
  remarks: "註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然後可以用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 識別項物件包含的識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuOpening
  id: ContextMenuOpening
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuOpening
  nameWithType: FrameworkContentElement.ContextMenuOpening
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "項目上的任何操作功能表開啟時發生。"
  remarks: "若要手動開啟內容功能表，為已處理的事件處理常式時，應該標記相關的事件。 否則，現有的值<xref:System.Windows.FrameworkContentElement.ContextMenu%2A>屬性會用來自動開啟內容功能表。</xref:System.Windows.FrameworkContentElement.ContextMenu%2A> 標記處理的事件會有效地取消的預設動作，並可能得以重設的<xref:System.Windows.FrameworkContentElement.ContextMenu%2A>屬性，然後開啟新的<xref:System.Windows.Controls.ContextMenu>。</xref:System.Windows.Controls.ContextMenu></xref:System.Windows.FrameworkContentElement.ContextMenu%2A>的值 不過，是您應該注意的時間問題。 為了完全取代透過 ContextMenuOpening 處理常式的內容功能表，初始的內容功能表不得為 null 或空白。 或者，您可能需要處理事件，並手動開啟新的內容功能表。 如需詳細資訊，請參閱[如何︰ 處理 ContextMenuOpening 事件](~/add/includes/ajax-current-ext-md.md)。       若要使用此事件為<xref:System.Windows.EventTrigger>在樣式中，您必須參考的基礎服務的事件識別項︰ [!code-xml [CorePseudocode #FEContextMenuOpening](~/add/codesnippet/xaml/CorePseudocode/pseudocode.xaml#fecontextmenuopening) ] (需要這種使用方式，因為上的事件實作<xref:System.Windows.FrameworkContentElement>，會公開基礎的服務事件不會正確對應 ContextMenuOpening 識別項，以便用於觸發程序)。</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_ContextMenuOpening&quot;></a># # 路由事件資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  |路由策略 |反昇 |  |委派 |<xref:System.Windows.Controls.ContextMenuEventHandler>|</xref:System.Windows.Controls.ContextMenuEventHandler></xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;
    return:
      type: System.Windows.Controls.ContextMenuEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  id: ContextMenuOpeningEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkContentElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuOpening&quot;> </xref> [路由傳送事件概觀](~/add/includes/ajax-current-ext-md.md)。"
  remarks: "註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然後可以用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 識別項物件包含的識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ContextMenuProperty
  id: ContextMenuProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ContextMenuProperty
  nameWithType: FrameworkContentElement.ContextMenuProperty
  fullName: System.Windows.FrameworkContentElement.ContextMenuProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkContentElement.ContextMenu*>相依性屬性。</xref:System.Windows.FrameworkContentElement.ContextMenu*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ContextMenuProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Cursor
  id: Cursor
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
  fullName: System.Windows.FrameworkContentElement.Cursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定當滑鼠指標位於此項目上方時所顯示的游標。"
  remarks: "設定這個屬性時[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]、[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]處理器依賴的型別轉換<xref:System.Windows.Input.Cursor>類別來評估的字串。</xref:System.Windows.Input.Cursor> 提供的字串應評估為<xref:System.Windows.Input.CursorType>值。</xref:System.Windows.Input.CursorType> 請參閱<xref:System.Windows.Input.Cursor>如需詳細資訊。</xref:System.Windows.Input.Cursor>       這個屬性所建立的資料指標將還是不會顯示當滑鼠指標位在這個項目也是取決於值的<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>屬性。</xref:System.Windows.FrameworkContentElement.ForceCursor%2A> 此外，事件相關的考量，例如使用中拖曳滑鼠擷取、 文字編輯模式中的控制項，並依此類推，也會影響資料指標具有較高的優先順序比您指定這個屬性的值。       若要還原的此屬性設定為最終的預設行為，將它設定為`null`一次。       `null`預設真的表示實際的資料指標的值判斷此處延後，應該從別處取得。 如果透過任何程式設計的值，從任何來源，預設資料指標不看到[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]應用程式將會箭號。       每次移動滑鼠停留[!INCLUDE[TLA2#tla_winclient](~/add/includes/tla2sharptla-winclient-md.md)]應用程式引發<xref:System.Windows.ContentElement.QueryCursor>事件。</xref:System.Windows.ContentElement.QueryCursor> 事件反昇，且此路由上的任何項目都有機會處理事件，並設定透過此事件的引數的資料指標的值。 如果發生這種情況，事件處理，而且引數中已變更的值會優先於任何層級，資料指標屬性的值除非<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>設定。</xref:System.Windows.FrameworkContentElement.ForceCursor%2A>       如果不建立自訂游標，通常您設定此屬性設為靜態屬性的值<xref:System.Windows.Input.Cursors>類別。</xref:System.Windows.Input.Cursors>       設定<xref:System.Windows.Input.Cursor>自訂值中未啟用部分信任。</xref:System.Windows.Input.Cursor> 如需有關自訂的資料指標的詳細資訊，請參閱[輸入概觀](~/add/includes/ajax-current-ext-md.md)。      <a name=&quot;dependencyPropertyInfo_Cursor&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.CursorProperty>|  |中繼資料屬性設定為`true`|None |</xref:System.Windows.FrameworkContentElement.CursorProperty>"
  example:
  - "The following example sets the cursor to a custom value.  \n  \n [!code-cs[cursors#ChangeCursorsSample](~/add/codesnippet/csharp/cursors/Window1.xaml.cs#changecursorssample)]\n [!code-vb[cursors#ChangeCursorsSample](~/add/codesnippet/visualbasic/cursors/Window1.xaml.vb#changecursorssample)]"
  syntax:
    content: public System.Windows.Input.Cursor Cursor { get; set; }
    return:
      type: System.Windows.Input.Cursor
      description: "要顯示的游標。 預設值定義為<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>每個此相依性屬性。 不過，實際的預設值，在執行階段將來自各種不同的因素。"
  overload: System.Windows.FrameworkContentElement.Cursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.CursorProperty
  id: CursorProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: CursorProperty
  nameWithType: FrameworkContentElement.CursorProperty
  fullName: System.Windows.FrameworkContentElement.CursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkContentElement.Cursor*>相依性屬性。</xref:System.Windows.FrameworkContentElement.Cursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty CursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContext
  id: DataContext
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
  fullName: System.Windows.FrameworkContentElement.DataContext
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定參與資料繫結中時的資料內容的項目。"
  remarks: "*資料內容*是一種概念，可讓項目繼承其父項目，用於繫結，以及其他特性，例如路徑的繫結的繫結來源的相關資訊。       資料內容設為直接[!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)]物件，並將該物件的內容來評估的繫結。 或者，您可以將資料內容設<xref:System.Windows.Data.DataSourceProvider>物件。</xref:System.Windows.Data.DataSourceProvider>       這個相依性屬性會繼承屬性值。 如果有子項目，以透過本機值或樣式建立的 DataContext 的任何其他值，對屬性系統會設定要指派此值與最接近的父元素的 DataContext 值的值。       或者，您可以使用下列的屬性之一<xref:System.Windows.Data.Binding>類別來明確指定繫結來源︰ <xref:System.Windows.Data.Binding.ElementName%2A>， <xref:System.Windows.Data.Binding.Source%2A>，或<xref:System.Windows.Data.Binding.RelativeSource%2A>.</xref:System.Windows.Data.Binding.RelativeSource%2A> </xref:System.Windows.Data.Binding.Source%2A> </xref:System.Windows.Data.Binding.ElementName%2A> </xref:System.Windows.Data.Binding> 如需詳細資訊，請參閱[How to︰ 指定的繫結來源](~/add/includes/ajax-current-ext-md.md)。       在[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]，DataContext 最常設為<xref:System.Windows.Data.Binding>宣告。</xref:System.Windows.Data.Binding> 您可以使用屬性項目語法或屬性語法。 在範例中，此頁面上顯示屬性語法。 您也可以在程式碼中設定 DataContext。      <a name=&quot;xamlPropertyElementUsage_DataContext&quot;></a># # XAML 屬性項目用法```   <object>     <object.DataContext>       <dataContextObject />     </object.DataContext>   </object>   ``` <a name=&quot;xamlAttributeUsage_DataContext&quot;> </a> # # XAML 屬性使用方式```   <object DataContext=&quot;bindingUsage&quot;/>   - or -   <object DataContext=&quot;{resourceExtension contextResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_DataContext&quot;> </a> # # XAML 值*dataContextObject*直接內嵌的物件做為父項目中的任何繫結的資料內容。             一般而言，這個物件是<xref:System.Windows.Data.Binding>或另一個<xref:System.Windows.Data.BindingBase>子類別。</xref:System.Windows.Data.BindingBase> </xref:System.Windows.Data.Binding> 或者，任何未經處理資料[!INCLUDE[TLA2#tla_clr](~/add/includes/tla2sharptla-clr-md.md)]物件適用於繫結，可能會放在這裡，以實際的繫結稍後所定義的類型。       *bindingUsage*評估為適當的資料內容的繫結使用方式。 如需詳細資訊，請參閱[繫結標記延伸](~/add/includes/ajax-current-ext-md.md)。       *resourceExtension*下列其中之一︰ `StaticResource`，或`DynamicResource`。 定義為資源中之物件的未經處理資料時，就會使用這種使用方式。 請參閱[XAML 資源](~/add/includes/ajax-current-ext-md.md)。       *contextResourceKey* <xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>內從所要求之物件的金鑰識別碼      <a name=&quot;dependencyPropertyInfo_DataContext&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.DataContextProperty>"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as DataContext, and setting the binding path to a property within it.  \n  \n [!code-cs[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#datacontext)]\n [!code-vb[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#datacontext)]"
  syntax:
    content: public object DataContext { get; set; }
    return:
      type: System.Object
      description: "要做為資料內容的物件。"
  overload: System.Windows.FrameworkContentElement.DataContext*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContextChanged
  id: DataContextChanged
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContextChanged
  nameWithType: FrameworkContentElement.DataContextChanged
  fullName: System.Windows.FrameworkContentElement.DataContextChanged
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "這個項目的資料內容變更時發生。"
  remarks: "如需資料內容和資料繫結的說明，請參閱[資料繫結概觀](~/add/includes/ajax-current-ext-md.md)。      > [!IMPORTANT] > 項目時<xref:System.Windows.FrameworkContentElement.DataContext%2A>可能受影響的變更，這個項目上的所有資料繫結屬性。</xref:System.Windows.FrameworkContentElement.DataContext%2A> 這適用於任何項目之子代項目的目前的項目繼承的資料內容，以及目前的項目本身。 所有此類繫結重新解譯新<xref:System.Windows.FrameworkContentElement.DataContext%2A>以反映新的值繫結中。</xref:System.Windows.FrameworkContentElement.DataContext%2A> 並不保證進行這些變更，相對於 DataContextChanged 事件的引發順序。  事件之後，或以任何混合事件之前發生的變更。"
  syntax:
    content: public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;
    return:
      type: System.Windows.DependencyPropertyChangedEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DataContextProperty
  id: DataContextProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DataContextProperty
  nameWithType: FrameworkContentElement.DataContextProperty
  fullName: System.Windows.FrameworkContentElement.DataContextProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkContentElement.DataContext*>相依性屬性。</xref:System.Windows.FrameworkContentElement.DataContext*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty DataContextProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey
  id: DefaultStyleKey
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKey
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定要用來尋找樣式範本，此控制項在佈景主題中的索引鍵。"
  remarks: "透過任何其直接 setter 通常未設定此屬性。 相反地，您會覆寫這個相依性屬性的特定類型的中繼資料每次建立新的子類別。 當您子類別化，此時會呼叫<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>方法針對<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>控制項子類別的靜態建構函式中的識別項，。</xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> </xref:System.Windows.DependencyProperty.OverrideMetadata%2A>       比方說，這類的內嵌類別<xref:System.Windows.Documents.Bold>確實具有超過覆寫 DefaultStyleKey 中的中繼資料的靜態建構函式，很少實作和公開數個執行個體建構函式。</xref:System.Windows.Documents.Bold> 項目，以事實<xref:System.Windows.Documents.Bold>標記改善<xref:System.Windows.Documents.TextElement.FontWeight%2A>屬性<xref:System.Windows.FontWeights.Bold%2A>實作內設定至 DefaultStyleKey 的預設值所參考的佈景主題樣式`typeof(Bold)`。</xref:System.Windows.FontWeights.Bold%2A> </xref:System.Windows.Documents.TextElement.FontWeight%2A> </xref:System.Windows.Documents.Bold>       如果您想要您的項目或故意不使用佈景主題樣式的控制項，設定<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>屬性`true`。</xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A>      <a name=&quot;dependencyPropertyInfo_DefaultStyleKey&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>"
  syntax:
    content: protected object DefaultStyleKey { get; set; }
    return:
      type: System.Object
      description: "樣式索引鍵。 佈景主題樣式查閱一部分正常運作，這個值必須是<xref:System.Type>要加上樣式的項目。</xref:System.Type> <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>已接受的值，針對特定案例。請參閱 < 備註 >。"
  overload: System.Windows.FrameworkContentElement.DefaultStyleKey*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  id: DefaultStyleKeyProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkContentElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkContentElement.DefaultStyleKey*>相依性屬性。</xref:System.Windows.FrameworkContentElement.DefaultStyleKey*>"
  syntax:
    content: protected static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.EndInit
  id: EndInit
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: EndInit()
  nameWithType: FrameworkContentElement.EndInit()
  fullName: System.Windows.FrameworkContentElement.EndInit()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "項目初始化之後，立即呼叫。"
  remarks: "實作這個方法以提供您的項目初始化期間載入處理序的項目時應該發生的特殊處理。       您的實作應該呼叫基底實作，因為基底 （預設值） 實作設定追蹤的初始設定部分內部旗標。       如果<xref:System.Windows.FrameworkContentElement.BeginInit%2A>之前已呼叫過，基底實作將會引發<xref:System.Windows.FrameworkContentElement.Initialized>事件。</xref:System.Windows.FrameworkContentElement.Initialized> </xref:System.Windows.FrameworkContentElement.BeginInit%2A> 否則，如果<xref:System.Windows.FrameworkContentElement.BeginInit%2A>，不會呼叫也不可以是取決於是否<xref:System.Windows.FrameworkContentElement.BeginInit%2A>已呼叫，不會引發事件。</xref:System.Windows.FrameworkContentElement.BeginInit%2A> </xref:System.Windows.FrameworkContentElement.BeginInit%2A>"
  syntax:
    content: public virtual void EndInit ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FindName(System.String)
  id: FindName(System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FindName(String)
  nameWithType: FrameworkContentElement.FindName(String)
  fullName: System.Windows.FrameworkContentElement.FindName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "尋找具有所提供的識別項名稱的項目。"
  remarks: "如果這個項目具有子項目，這些子項目會遞迴搜尋所有要求的具名項目。"
  example:
  - "The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.  \n  \n [!code-cs[ContentElementsSmorgasbord#FindName](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#findname)]\n [!code-vb[ContentElementsSmorgasbord#FindName](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#findname)]"
  syntax:
    content: public object FindName (string name);
    parameters:
    - id: name
      type: System.String
      description: "要搜尋之項目的名稱。"
    return:
      type: System.Object
      description: "要求的項目。 可能是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果找不到任何相符的元素。"
  overload: System.Windows.FrameworkContentElement.FindName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: FrameworkContentElement.FindResource(Object)
  fullName: System.Windows.FrameworkContentElement.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "搜尋具有指定之索引鍵，並將之資源會擲回例外狀況，如果找不到要求的資源。"
  remarks: "> [!IMPORTANT]> 如果找不到機碼中呼叫這個方法，會擲回例外狀況。 如果您不想處理例外狀況，此情況下的，您應該改為呼叫<xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</xref:System.Windows.FrameworkContentElement.TryFindResource%2A> <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>傳回`null`當找到，任何資源，並不會擲回例外狀況。</xref:System.Windows.FrameworkContentElement.TryFindResource%2A>       如果呼叫的項目上找不到資源，父樹狀結構會搜尋使用的邏輯樹狀結構，在樹狀結構的相同方式搜尋的若資源所要求在執行階段的金鑰。       通常您會立即傳回值轉換為您嘗試使用傳回的資源值設定屬性的型別。"
  example:
  - "The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.  \n  \n [!code-cs[ContentElementsSmorgasbord#FindResource](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#findresource)]\n [!code-vb[ContentElementsSmorgasbord#FindResource](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#findresource)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "要尋找之資源的索引鍵識別碼。"
    return:
      type: System.Object
      description: "找到的資源，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果找不到任何相符的資源 (也會擲回例外狀況如果<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>)。"
  overload: System.Windows.FrameworkContentElement.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "找不到要求的資源索引鍵。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceKey</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle
  id: FocusVisualStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定物件，可自訂外觀、 效果或其他樣式特性，捕捉到鍵盤焦點時，會套用至這個項目。"
  remarks: "設定這個屬性時[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]、 樣式幾乎都定義為資源，而非內嵌的項目，而且該資源通常參照為<xref:System.Windows.StaticResourceExtension>.</xref:System.Windows.StaticResourceExtension>       請注意，這個屬性會影響視覺外觀，但不會報告，在中繼資料。 這是因為視覺外觀變更是事件驅動和在任何時候，可能不適用，因此通常不應報告中繼資料中的任何視覺效果或版面配置資訊。       在概念上，套用至控制項的焦點視覺行為應該保持一致項目。 如果您正在撰寫整個佈景主題，只變更焦點視覺化樣式為最實用的方式，來強制執行一致性。 在個別的樣式，而非佈景主題的部分設定這個屬性不是預定的使用方式，這個屬性，因為它可能會造成混淆的使用者經驗，關於鍵盤焦點。 如果您打算是刻意不一致的佈景主題的項目特定行為，更好的方法是使用觸發程序在樣式為個別的輸入的狀態的屬性，例如<xref:System.Windows.UIElement.IsFocused%2A>或<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>，以及若要這樣做不以視覺化方式會干擾任何現有的焦點視覺化樣式的方式。</xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A> </xref:System.Windows.UIElement.IsFocused%2A> FocusVisualStyle 和替代焦點屬性的設計用意的資訊，請參閱[樣式的焦點在控制項和 FocusVisualStyle](~/add/includes/ajax-current-ext-md.md)。      <a name=&quot;xamlAttributeUsage_FocusVisualStyle&quot;></a># # XAML 屬性使用方式```   <object FocusVisualStyle=&quot;{resourceExtension styleResourceKey}&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_FocusVisualStyle&quot;> </a> # # XAML 屬性項目用法<a name=&quot;xamlValues_FocusVisualStyle&quot;> </a> # # XAML 值*resourceExtension*下列其中之一:、 或。       請參閱[XAML 資源](~/add/includes/ajax-current-ext-md.md)。       *styleResourceKey*識別所要求的樣式的索引鍵。 索引鍵參考<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>中現有的資源      > [!NOTE] > 屬性項目語法是可行，但不是建議。 請參閱[內嵌樣式和樣板](~/add/includes/ajax-current-ext-md.md)。  使用繫結參考或<xref:System.Windows.Data.Binding>也是可行的但不常見。</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_FocusVisualStyle&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  |中繼資料屬性設定為`true`|None |</xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>"
  syntax:
    content: public System.Windows.Style FocusVisualStyle { get; set; }
    return:
      type: System.Windows.Style
      description: "若要將焦點套用樣式。 相依性屬性中所宣告的預設值是空的靜態<xref href=&quot;System.Windows.Style&quot;> </xref>。 不過，在執行階段有效的值是通常 （但並非一定） 提供佈景主題支援為控制項的樣式。"
  overload: System.Windows.FrameworkContentElement.FocusVisualStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  id: FocusVisualStyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: FocusVisualStyleProperty
  nameWithType: FrameworkContentElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkContentElement.FocusVisualStyle*>相依性屬性。</xref:System.Windows.FrameworkContentElement.FocusVisualStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ForceCursor
  id: ForceCursor
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
  fullName: System.Windows.FrameworkContentElement.ForceCursor
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，指出是否此<xref href=&quot;System.Windows.FrameworkContentElement&quot;></xref>應強制[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]來呈現宣告由這個執行個體的資料指標<xref:System.Windows.FrameworkContentElement.Cursor*>屬性。</xref:System.Windows.FrameworkContentElement.Cursor*>"
  remarks: "此屬性設定為`true`將會覆寫的子項目所建立的資料指標喜好設定。 這樣做，一般應用程式[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]可能會造成混淆的使用者，特別是如果子元素嘗試以指定資料指標。 設定<xref:System.Windows.FrameworkElement.ForceCursor%2A>中控制項的子類別化或複合 （compositing） 的情況下更適當。</xref:System.Windows.FrameworkElement.ForceCursor%2A>      <a name=&quot;dependencyPropertyInfo_ForceCursor&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  |中繼資料屬性設定為`true`|None |</xref:System.Windows.FrameworkContentElement.ForceCursorProperty>"
  example:
  - "The following example forces the cursor while over the element.  \n  \n [!code-xml[ForceCursor#ForceCursor](~/add/codesnippet/xaml/forcecursor/default.xaml#forcecursor)]"
  syntax:
    content: public bool ForceCursor { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要強制使用此執行個體的這個項目上方的資料指標簡報的設定 （包括所有子系項目上）; 資料指標否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkContentElement.ForceCursor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ForceCursorProperty
  id: ForceCursorProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ForceCursorProperty
  nameWithType: FrameworkContentElement.ForceCursorProperty
  fullName: System.Windows.FrameworkContentElement.ForceCursorProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkContentElement.ForceCursor*>相依性屬性。</xref:System.Windows.FrameworkContentElement.ForceCursor*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ForceCursorProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  id: GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkContentElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkContentElement.GetBindingExpression(DependencyProperty)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得<xref href=&quot;System.Windows.Data.BindingExpression&quot;></xref>指定的屬性繫結。"
  remarks: ''
  example:
  - "The following example retrieves a binding by querying a property.  \n  \n [!code-cs[ContentElementsSmorgasbord#GetBindingExpression](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#getbindingexpression)]\n [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#getbindingexpression)]"
  syntax:
    content: public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "目標<xref href=&quot;System.Windows.DependencyProperty&quot;></xref>要從中取得繫結。"
    return:
      type: System.Windows.Data.BindingExpression
      description: "傳回<xref href=&quot;System.Windows.Data.BindingExpression&quot;></xref>如果目標是資料繫結; 否則<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkContentElement.GetBindingExpression*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.GetUIParentCore
  id: GetUIParentCore
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: GetUIParentCore()
  nameWithType: FrameworkContentElement.GetUIParentCore()
  fullName: System.Windows.FrameworkContentElement.GetUIParentCore()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "如果沒有視覺父代，則傳回此項目的替代邏輯父。 在此情況下， <xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref>父系一定是相同的值<xref:System.Windows.FrameworkContentElement.Parent*>屬性。</xref:System.Windows.FrameworkContentElement.Parent*>"
  remarks: "預設實作會傳回預期的單一視覺父代。 自訂實作可能會傳回替代的父代關聯性。"
  syntax:
    content: protected override System.Windows.DependencyObject GetUIParentCore ();
    parameters: []
    return:
      type: System.Windows.DependencyObject
      description: "傳回的項目以外<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>每當這個方法的 WPF 架構層級實作具有非視覺父連線時。"
  overload: System.Windows.FrameworkContentElement.GetUIParentCore*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Initialized
  id: Initialized
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Initialized
  nameWithType: FrameworkContentElement.Initialized
  fullName: System.Windows.FrameworkContentElement.Initialized
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "發生時這<xref href=&quot;System.Windows.FrameworkContentElement&quot;></xref>已初始化。 與其中的值<xref:System.Windows.FrameworkContentElement.IsInitialized*>屬性從變更<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref> （或未定義） 至<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。</xref:System.Windows.FrameworkContentElement.IsInitialized*>"
  remarks: "此事件將在每次引發<xref:System.Windows.FrameworkContentElement.EndInit%2A>或<xref:System.Windows.FrameworkContentElement.OnInitialized%2A>呼叫的方法。</xref:System.Windows.FrameworkContentElement.OnInitialized%2A> </xref:System.Windows.FrameworkContentElement.EndInit%2A> 這些方法無法呼叫由審慎的程式碼，或藉由[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]載入程序。"
  syntax:
    content: public event EventHandler Initialized;
    return:
      type: System.EventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.InputScope
  id: InputScope
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
  fullName: System.Windows.FrameworkContentElement.InputScope
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定所使用的輸入內容<xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref>。"
  remarks: "這個相依性屬性會繼承屬性值。 如果有任何其他值作為具有子元素<xref:System.Windows.FrameworkElement.InputScope%2A>建立透過本機值或樣式，對屬性系統將會設定為值<xref:System.Windows.FrameworkElement.InputScope%2A>指派此值與最接近的父項目的值。</xref:System.Windows.FrameworkElement.InputScope%2A> </xref:System.Windows.FrameworkElement.InputScope%2A>       雖然[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]語法使用量列為和語法上允許中, 設定這個屬性[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]並不常見。      <a name=&quot;dependencyPropertyInfo_InputScope&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.InputScopeProperty>"
  syntax:
    content: public System.Windows.Input.InputScope InputScope { get; set; }
    return:
      type: System.Windows.Input.InputScope
      description: "輸入的範圍，修改替代的輸入方法中輸入的解譯方式。 預設值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> （結果會在預設的命令處理）。"
  overload: System.Windows.FrameworkContentElement.InputScope*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.InputScopeProperty
  id: InputScopeProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: InputScopeProperty
  nameWithType: FrameworkContentElement.InputScopeProperty
  fullName: System.Windows.FrameworkContentElement.InputScopeProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkContentElement.InputScope*>相依性屬性。</xref:System.Windows.FrameworkContentElement.InputScope*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty InputScopeProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.IsInitialized
  id: IsInitialized
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
  fullName: System.Windows.FrameworkContentElement.IsInitialized
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得值，指出是否已是藉由載入以初始化這個項目[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]，或是明確地其<xref:System.Windows.FrameworkContentElement.EndInit*>呼叫方法。</xref:System.Windows.FrameworkContentElement.EndInit*>"
  remarks: "這個屬性也可能`true`如果這個項目已移動項目樹狀目錄中如有新的父項目，並因此變成一次重新載入。"
  syntax:
    content: public bool IsInitialized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果項目初始化每個先前提及的載入或方法呼叫。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkContentElement.IsInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.IsLoaded
  id: IsLoaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
  fullName: System.Windows.FrameworkContentElement.IsLoaded
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得值，指出這個項目是否已載入的簡報。"
  remarks: "新建構的執行個體中，這個屬性一開始`false`，且會維持`true`一旦設為`true`，即使後續程式碼中移除。"
  example:
  - "The following example code uses IsLoaded as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler. That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.  \n  \n [!code-cs[ContentElementsSmorgasbord#IsLoaded](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#isloaded)]\n [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#isloaded)]"
  syntax:
    content: public bool IsLoaded { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果目前的項目連結至項目樹狀結構，並且已呈現;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果項目已永遠不會附加到載入的項目樹狀結構。"
  overload: System.Windows.FrameworkContentElement.IsLoaded*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Language
  id: Language
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Language
  nameWithType: FrameworkContentElement.Language
  fullName: System.Windows.FrameworkContentElement.Language
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定套用至個別項目的當地語系化/全球化語言資訊。"
  remarks: "字串格式會依照 RFC 3066 標準。 例如，美國英文是&quot;EN-US&quot;。 請參閱<xref:System.Windows.Markup.XmlLanguage>如需值和格式。</xref:System.Windows.Markup.XmlLanguage>       這個相依性屬性會繼承屬性值。 如果有任何其他值作為具有子元素<xref:System.Windows.FrameworkElement.Language%2A>建立透過本機值或樣式，對屬性系統將會設定為值<xref:System.Windows.FrameworkElement.Language%2A>指派此值與最接近的父項目的值。</xref:System.Windows.FrameworkElement.Language%2A> </xref:System.Windows.FrameworkElement.Language%2A>      <a name=&quot;dependencyPropertyInfo_CultureInfo&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|</xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> </xref:System.Windows.FrameworkContentElement.LanguageProperty>"
  syntax:
    content: public System.Windows.Markup.XmlLanguage Language { get; set; }
    return:
      type: System.Windows.Markup.XmlLanguage
      description: "這個項目的文化特性資訊。 預設值是<xref href=&quot;System.Windows.Markup.XmlLanguage&quot;></xref>執行個體，其<xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>值設定為字串&quot;EN-US&quot;。</xref:System.Windows.Markup.XmlLanguage.IetfLanguageTag*>"
  overload: System.Windows.FrameworkContentElement.Language*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LanguageProperty
  id: LanguageProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LanguageProperty
  nameWithType: FrameworkContentElement.LanguageProperty
  fullName: System.Windows.FrameworkContentElement.LanguageProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkContentElement.Language*>相依性屬性。</xref:System.Windows.FrameworkContentElement.Language*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty LanguageProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Loaded
  id: Loaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Loaded
  nameWithType: FrameworkContentElement.Loaded
  fullName: System.Windows.FrameworkContentElement.Loaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "項目已配置版面、 呈現以及可以互動時發生。"
  remarks: "直接路由的事件不會遵循路由，才會處理在引發相同的項目內。 直接路由的事件並支援其他路由的事件的行為︰ 它們支援可存取的處理常式集合中，且可用來當作<xref:System.Windows.EventTrigger>樣式。</xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_Loaded&quot;></a># # 路由事件資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  |路由策略 |直接 |  |委派 |<xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkContentElement.LoadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Loaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LoadedEvent
  id: LoadedEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LoadedEvent
  nameWithType: FrameworkContentElement.LoadedEvent
  fullName: System.Windows.FrameworkContentElement.LoadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref href=&quot;System.Windows.FrameworkContentElement.Loaded&quot;> </xref> [路由傳送事件概觀](~/add/includes/ajax-current-ext-md.md)。"
  remarks: "註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然後可以用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 識別項物件包含的識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent LoadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.LogicalChildren
  id: LogicalChildren
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
  fullName: System.Windows.FrameworkContentElement.LogicalChildren
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得邏輯子項這個元素的元素的列舉值。"
  remarks: "如需有關如何使用 LogicalChildren 和<xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>，請參閱[中 WPF 樹狀架構](~/add/includes/ajax-current-ext-md.md)。</xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>"
  syntax:
    content: protected virtual System.Collections.IEnumerator LogicalChildren { get; }
    return:
      type: System.Collections.IEnumerator
      description: "此項目的邏輯子項目列舉值。"
  overload: System.Windows.FrameworkContentElement.LogicalChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  id: MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkContentElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkContentElement.MoveFocus(TraversalRequest)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "將鍵盤焦點從這個項目移至另一個項目。"
  syntax:
    content: public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);
    parameters:
    - id: request
      type: System.Windows.Input.TraversalRequest
      description: "重點是要移動，做為列舉值的方向。"
    return:
      type: System.Boolean
      description: "傳回<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果已成功; 移動焦點<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果的方向會與目標項目會指定不存在。"
  overload: System.Windows.FrameworkContentElement.MoveFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Name
  id: Name
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Name
  nameWithType: FrameworkContentElement.Name
  fullName: System.Windows.FrameworkContentElement.Name
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定項目的識別名稱。 此名稱提供執行個體參考，以便程式設計的程式碼後置，例如事件處理常式程式碼，可以參考項目剖析期間建構之後[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。"
  remarks: "這個屬性的最常見的用法時，才能指定[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]標記中的項目名稱。       這個屬性基本上會提供 WPF 架構層級方便的屬性來設定[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)] [X:name 指示詞](~/add/includes/ajax-current-ext-md.md)。       從程式碼取得名稱並不常見，因為如果已經在程式碼中有適當的參考，您可以直接呼叫方法，而且項目上的屬性參考，且通常需要名稱。 例外狀況是發生在字串中具有某些多載意義，例如是否要顯示在該名稱很有用[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]。 也不建議設定名稱從程式碼，如果從標記設定原始名稱，並變更屬性並不會變更的物件參考。 這類物件的參考會建立期間，會明確地建立基礎名稱範圍時，才[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]載入。       您必須特別呼叫<xref:System.Windows.FrameworkContentElement.RegisterName%2A>上已載入元素的 Name 屬性進行有效的變更。</xref:System.Windows.FrameworkContentElement.RegisterName%2A>       設定名稱從程式碼是重要的一個值得注意的案例是命名分鏡腳本將針對執行的項目。 您可以註冊之前，可能也需要具現化，並指派<xref:System.Windows.NameScope>執行個體。</xref:System.Windows.NameScope> 請參閱 < 範例 > 一節中，或[概觀腳本](~/add/includes/ajax-current-ext-md.md)。       設定名稱從程式碼受到限制的應用程式，但更常見，特別是如果您採用頁面會重新載入到應用程式，執行階段程式碼不一定是程式碼後置的個別頁面瀏覽模型依名稱查閱項目。 公用程式方法<xref:System.Windows.FrameworkContentElement.FindName%2A>，這是可從任何<xref:System.Windows.FrameworkContentElement>，可以找到項目邏輯樹狀結構以遞迴方式依名稱的任何項目。</xref:System.Windows.FrameworkContentElement> </xref:System.Windows.FrameworkContentElement.FindName%2A> 您可以使用或<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>靜態方法<xref:System.Windows.LogicalTreeHelper>，這也會做為引數的名稱字串。</xref:System.Windows.LogicalTreeHelper> </xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>       常用根項目 (<xref:System.Windows.Window>，<xref:System.Windows.Controls.Page>例如) 實作的介面<xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.Controls.Page> </xref:System.Windows.Window> 此介面的實作應該強制執行的名稱是其範圍內模稜兩可。      <a name=&quot;dependencyPropertyInfo_Name&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.NameProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|</xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> </xref:System.Windows.FrameworkContentElement.NameProperty>"
  syntax:
    content: public string Name { get; set; }
    return:
      type: System.String
      description: "項目的名稱。"
  overload: System.Windows.FrameworkContentElement.Name*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.NameProperty
  id: NameProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: NameProperty
  nameWithType: FrameworkContentElement.NameProperty
  fullName: System.Windows.FrameworkContentElement.NameProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkContentElement.Name*>相依性屬性。</xref:System.Windows.FrameworkContentElement.Name*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty NameProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "叫用每當<xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuClosing&quot;></xref>路由的事件到達其路由中的這個類別。 實作這個方法可為此事件加入類別處理。"
  remarks: "This method has no default implementation. You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers. Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "提供事件的相關資料。"
  overload: System.Windows.FrameworkContentElement.OnContextMenuClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  id: OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "叫用每當<xref href=&quot;System.Windows.FrameworkContentElement.ContextMenuOpening&quot;></xref>路由的事件到達其路由中的這個類別。 實作這個方法可為此事件加入類別處理。"
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ContextMenuEventArgs
      description: "事件的事件資料。"
  overload: System.Windows.FrameworkContentElement.OnContextMenuOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  id: OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "類別處理常式<xref href=&quot;System.Windows.ContentElement.GotFocus&quot;></xref>事件。"
  remarks: "這個類別處理常式這個項目上設定適當的焦點行為，如果從這個項目產生事件。 如果事件的來源是在樹狀目錄中的另一個項目，此處理常式沒有任何作用。       若要變更這些預設焦點行為，您的項目上，覆寫這個方法。"
  syntax:
    content: protected override void OnGotFocus (System.Windows.RoutedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.RoutedEventArgs
      description: "事件的事件資料。"
  overload: System.Windows.FrameworkContentElement.OnGotFocus*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  id: OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkContentElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkContentElement.OnInitialized(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.FrameworkContentElement.Initialized&quot;></xref>事件。 這個方法會叫用每當<xref:System.Windows.FrameworkContentElement.IsInitialized*>設<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。</xref:System.Windows.FrameworkContentElement.IsInitialized*>"
  remarks: "此虛擬方法的預設實作會引發事件，如本主題稍早所述。 覆寫應呼叫 base （），以保留此行為。       請注意，<xref:System.Windows.FrameworkContentElement.IsInitialized%2A>屬性是唯讀的。</xref:System.Windows.FrameworkContentElement.IsInitialized%2A> 因此，您無法設定，如此一來強制初始化行為。 初始化設定旨在只有完成[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]架構。"
  syntax:
    content: protected virtual void OnInitialized (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "事件的事件資料。"
  overload: System.Windows.FrameworkContentElement.OnInitialized*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  id: OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "叫用每當上任何相依性屬性的有效值<xref href=&quot;System.Windows.FrameworkContentElement&quot;></xref>已更新。 引數參數中報告變更的特定相依性屬性。 覆寫<xref:System.Windows.DependencyObject.OnPropertyChanged*>.</xref:System.Windows.DependencyObject.OnPropertyChanged*>"
  remarks: "這個方法不是偵測一般的屬性變更或失效。 它改為僅供修改的一般失效模式如果已知廣泛分類屬性的特定資訊。       這可能會叫用方法多次物件的存留期間。 因此，達到更佳的效能，如果您覆寫特定屬性的中繼資料，然後將附加<xref:System.Windows.CoerceValueCallback>或<xref:System.Windows.PropertyChangedCallback>個別屬性的函式。</xref:System.Windows.PropertyChangedCallback> </xref:System.Windows.CoerceValueCallback> 不過，您會使用這個方法如果<xref:System.Windows.FrameworkContentElement>包含大量的值相互關聯的相依性屬性，或如果它包含邏輯，例如轉譯行為，必須重新執行的幾個相關的屬性失效的情況。</xref:System.Windows.FrameworkContentElement>       請注意，相同具名`OnPropertyChanged`方法具有不同簽章 (參數類型是<xref:System.ComponentModel.PropertyChangedEventArgs>) 可以出現在數個類別。</xref:System.ComponentModel.PropertyChangedEventArgs> 確認`OnPropertyChanged`用於資料物件通知，而且是<xref:System.ComponentModel.INotifyPropertyChanged>。</xref:System.ComponentModel.INotifyPropertyChanged>合約的一部分"
  syntax:
    content: protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.DependencyPropertyChangedEventArgs
      description: "事件資料，描述變更，包括舊的和新值的屬性。"
  overload: System.Windows.FrameworkContentElement.OnPropertyChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  id: OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkContentElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkContentElement.OnStyleChanged(Style,Style)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "樣式，正在使用此項目變更時叫用。"
  remarks: "這個方法沒有設定注意樣式變更狀況的內部旗標的預設實作。"
  syntax:
    content: protected virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);
    parameters:
    - id: oldStyle
      type: System.Windows.Style
      description: "舊樣式。"
    - id: newStyle
      type: System.Windows.Style
      description: "新的樣式。"
  overload: System.Windows.FrameworkContentElement.OnStyleChanged*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "叫用每當<xref href=&quot;System.Windows.FrameworkContentElement.ToolTipClosing&quot;></xref>路由的事件到達其路由中的這個類別。 實作這個方法可為此事件加入類別處理。"
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "提供事件的相關資料。"
  overload: System.Windows.FrameworkContentElement.OnToolTipClosing*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  id: OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "叫用每當<xref href=&quot;System.Windows.FrameworkContentElement.ToolTipOpening&quot;></xref>路由的事件到達其路由中的這個類別。 實作這個方法可為此事件加入類別處理。"
  remarks: "This method has no default implementation. You should still call base() in case an intermediate class in the inheritance has implemented this method.  \n  \n The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/add/includes/tlasharptla-clr-md.md)] event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler. In this case the matching event is a routed event. The implementation pattern of the On\\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases). Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route. One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route."
  syntax:
    content: protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Controls.ToolTipEventArgs
      description: "提供事件的相關資料。"
  overload: System.Windows.FrameworkContentElement.OnToolTipOpening*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  id: OverridesDefaultStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定值，指出這個項目是否包含來自佈景主題樣式的樣式屬性。"
  remarks: "這個屬性的最常見的用法是提供佈景主題樣式的樣式 setter 內間接使用。      <a name=&quot;dependencyPropertyInfo_OverridesDefaultStyle&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>"
  syntax:
    content: public bool OverridesDefaultStyle { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個項目不會使用佈景主題樣式屬性。樣式產生的所有屬性都來自於本機應用程式樣式和佈景主題樣式屬性不會套用。 <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>如果應用程式樣式套用第一次，然後佈景主題樣式適用於應用程式樣式中未明確設定的屬性。"
  overload: System.Windows.FrameworkContentElement.OverridesDefaultStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  id: OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkContentElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle*>相依性屬性。</xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Parent
  id: Parent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Parent
  nameWithType: FrameworkContentElement.Parent
  fullName: System.Windows.FrameworkContentElement.Parent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得這個項目的邏輯樹狀結構父代。"
  remarks: "請注意，根據您的應用程式功能，有可能變更邏輯父項目，可以保留此屬性的值不會反映該變更。 您通常應該取得的值之前您需要它。       請參閱[中 WPF 樹狀架構](~/add/includes/ajax-current-ext-md.md)如需有關周遊邏輯樹狀結構和案例適當項目探索朝向這種方式。       對屬性系統有可能重新計算項目的所有屬性值時，它會重設父代，因為有些屬性是繼承的處理邏輯樹狀結構的值。 <xref:System.Windows.FrameworkContentElement.DataContext%2A>可套用的項目會重設父代時，也可以變更繫結。</xref:System.Windows.FrameworkContentElement.DataContext%2A>       變更項目的父代通常只是透過操作的集合，使用專用新增或移除方法，或透過設定內容屬性的項目。       使用父屬性的最常見的案例是要取得的參考，然後以取得各種<xref:System.Windows.FrameworkContentElement>屬性值從父代。</xref:System.Windows.FrameworkContentElement> 範本，將範本最終的父代`null`。 若要取得略過此點，並將延伸至邏輯樹狀結構實際套用的範本，使用<xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>"
  example:
  - "The following example checks to see whether the Parent of a <xref:System.Windows.Documents.TextPointer> is of a particular type.  \n  \n [!code-cs[TextPointer_snippets#FCEParent](~/add/codesnippet/csharp/TextPointer_Snippets/Window1.xaml.cs#fceparent)]\n [!code-vb[TextPointer_snippets#FCEParent](~/add/codesnippet/visualbasic/textpointer_snippets/window1.xaml.vb#fceparent)]"
  syntax:
    content: public System.Windows.DependencyObject Parent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "這個項目的邏輯父代。"
  overload: System.Windows.FrameworkContentElement.Parent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  id: PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "判斷下一個項目將會收到焦點相對於所提供的焦點移動的方向，這個項目，但實際上不會移動焦點。 這個方法已密封且無法覆寫。"
  remarks: "<xref:System.Windows.FrameworkContentElement.MoveFocus%2A>是實際移動焦點的相關的方法。</xref:System.Windows.FrameworkContentElement.MoveFocus%2A>"
  syntax:
    content: public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);
    parameters:
    - id: direction
      type: System.Windows.Input.FocusNavigationDirection
      description: "判斷預期焦點變更方向。"
    return:
      type: System.Windows.DependencyObject
      description: "如果焦點實際上周遊，專注的下一個項目會移至。 可能會傳回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果焦點無法提供的方向移動相對於這個項目。"
  overload: System.Windows.FrameworkContentElement.PredictFocus*
  exceptions:
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: 'Specified one of the following directions in the <xref href=&quot;System.Windows.Input.TraversalRequest&quot;></xref>: <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>, <xref href=&quot;System.Windows.Input.FocusNavigationDirection&quot;></xref>. 這些指示不合法的 PredictFocus (它們是合法的但<xref:System.Windows.FrameworkContentElement.MoveFocus*>)。</xref:System.Windows.FrameworkContentElement.MoveFocus*>'
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  id: RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: RegisterName(String,Object)
  nameWithType: FrameworkContentElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkContentElement.RegisterName(String,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "提供存取子，可簡化存取<xref:System.Windows.NameScope>註冊方法。</xref:System.Windows.NameScope>"
  remarks: "這個方法是呼叫<xref:System.Windows.NameScope.RegisterName%2A>.</xref:System.Windows.NameScope.RegisterName%2A>便利的方法 實作會檢查後續的父項目，直到找到適用於<xref:System.Windows.NameScope>實作中，找到所尋找的項目，用來實作<xref:System.Windows.Markup.INameScope>.</xref:System.Windows.Markup.INameScope> </xref:System.Windows.NameScope> 如需命名範圍的詳細資訊，請參閱[WPF XAML Namescopes](~/add/includes/ajax-current-ext-md.md)。       呼叫 RegisterName 會需要正確的應用程式程式碼中建立時的動畫分鏡腳本連結。 這是因為其中一個索引鍵的分鏡腳本屬性<xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>，會使用執行階段名稱查詢，而不是能夠充分目標項目的參考。</xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> 即使該元素是可供參考從程式碼存取，也是如此。 如需有關為什麼您需要註冊的分鏡腳本目標名稱的詳細資訊，請參閱[概觀腳本](~/add/includes/ajax-current-ext-md.md)。 表示內容項目會比動畫在控制項上，較不常見[概觀腳本](../Topic/Storyboards%20Overview.md)專注於控制案例。"
  syntax:
    content: public void RegisterName (string name, object scopedElement);
    parameters:
    - id: name
      type: System.String
      description: "使用指定的名稱 / 物件對應的名稱。"
    - id: scopedElement
      type: System.Object
      description: "對應的物件。"
  overload: System.Windows.FrameworkContentElement.RegisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  id: RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkContentElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.RemoveLogicalChild(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "從這個項目的邏輯樹狀結構中移除指定的項目。"
  remarks: "這[!INCLUDE[TLA#tla_api](~/add/includes/tlasharptla-api-md.md)]大致上是相關的類別衍生的案例中，加入支援的子集合時。       大部分<xref:System.Windows.FrameworkContentElement>衍生類別專用的公開集合負責內含項目 (例如，<xref:System.Windows.Documents.Span.Inlines%2A><xref:System.Windows.Documents.Span>類別;<xref:System.Windows.Documents.Section.Blocks%2A>上<xref:System.Windows.Documents.Section>類別)。</xref:System.Windows.Documents.Section> </xref:System.Windows.Documents.Section.Blocks%2A> </xref:System.Windows.Documents.Span> </xref:System.Windows.Documents.Span.Inlines%2A> </xref:System.Windows.FrameworkContentElement> 通常衍生自這些類別可以避免不需要直接操作之邏輯樹狀結構。"
  syntax:
    content: protected void RemoveLogicalChild (object child);
    parameters:
    - id: child
      type: System.Object
      description: "要移除的項目。"
  overload: System.Windows.FrameworkContentElement.RemoveLogicalChild*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Resources
  id: Resources
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Resources
  nameWithType: FrameworkContentElement.Resources
  fullName: System.Windows.FrameworkContentElement.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定目前的本機定義的資源字典。"
  remarks: "可以完全或部分中定義的資源字典[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]通常會建立為屬性項目，且通常是針對任何個別頁面或應用程式的根項目。 放置在此層級的資源字典，可以更輕鬆地尋找個別的子系中的項目頁面 （或從任何頁面上，在應用程式的情況下）。 在大部分的應用程式案例中，我們建議樣式定義做為物件項目內的資源字典，或定義為外部資源，以便可以是獨立的整個樣式資源 （這種方式有助於劃分設計從開發人員責任分隔需要加以編輯的實體檔案）。       請注意，這個屬性會傳回直接在該元素中宣告的資源字典。 這是不同於實際資源對應程序，其中的子元素可以存取任何遞迴地向上搜尋每個父項目中所定義的資源。       資源也可以從集合中的程式碼所參考，但請注意在中建立資源[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]絕對不會之前之後存取<xref:System.Windows.FrameworkContentElement.Loaded>宣告字典的項目就會引發。</xref:System.Windows.FrameworkContentElement.Loaded> 事實上，資源會以非同步方式剖析，而且甚至<xref:System.Windows.FrameworkContentElement.Loaded>事件可確保您可以參考[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]定義資源。</xref:System.Windows.FrameworkContentElement.Loaded> 因此您應該通常只存取[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]資源定義為一部分的執行階段程式碼，或透過其他[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]技術，例如樣式或屬性值的資源擴充功能參考。 當您透過程式碼存取資源時，它是基本上等同於從進行參考[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]。       基礎<xref:System.Windows.ResourceDictionary>支援加入、 移除，或使用程式碼來查詢集合中的資源所需的方法。</xref:System.Windows.ResourceDictionary> 資源屬性是可設定為支援完全取代為新項目的資源集合的案例或不同<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>       請注意，[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]所示的語法不包括<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>的項目 這是隱含的集合語法; 的範例可以省略標記，表示集合項目。 會改為指定做為項目加入至集合的項目。 如需有關隱含的集合和[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]，請參閱[XAML 語法的詳細資料](~/add/includes/ajax-current-ext-md.md)。 一種情況下，<xref:System.Windows.ResourceDictionary>仍然有項目就是引進合併的字典，在此情況下是否有通常該<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>任何子項目時，明確指定</xref:System.Windows.ResourceDictionary>的位置 如需詳細資訊，請參閱[合併資源字典](~/add/includes/ajax-current-ext-md.md)。      <a name=&quot;xamlPropertyElementUsage_Resources&quot;></a># # XAML 屬性項目用法```   <object>     <object.Resources>       oneOrMoreResourceElements     </object.Resources>   </object>   ``` <a name=&quot;xamlValues_Resources&quot;> </a> # # XAML 值*oneOrMoreResourceElements*一或多個物件項目，其中每個定義的資源。       每個資源屬性的項目在每個<xref:System.Windows.ResourceDictionary>值必須是唯一的[X:key 指示詞](~/add/includes/ajax-current-ext-md.md)，做為唯一索引鍵從<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>擷取值時</xref:System.Windows.ResourceDictionary>"
  example:
  - "The following example establishes a Resources collection on a <xref:System.Windows.Documents.FlowDocument> root element. <xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.  \n  \n [!code-xml[ContentElementsSmorgasbord#FCEResources](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page2.xaml#fceresources)]"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "目前在本機定義的資源。 這是的資源，其中索引鍵會存取資源字典中的字典。"
  overload: System.Windows.FrameworkContentElement.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  id: SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "將繫結附加至這個項目，根據提供的來源屬性名稱當做資料來源的路徑限定性條件。"
  remarks: "這個方法是便利的方法用於呼叫<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>，然後傳遞做為目前的執行個體<xref:System.Windows.DependencyObject>，並建立新<xref:System.Windows.Data.Binding>依據提供`path`參數。</xref:System.Windows.Data.Binding> </xref:System.Windows.DependencyObject> </xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName> 此簽章是更方便，如果您要建立簡單的預設繫結。 如果您要指定非預設的條件，任何繫結屬性，或想要使用<xref:System.Windows.Data.MultiBinding>或<xref:System.Windows.Data.PriorityBinding>，您應該使用<xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29>簽章。</xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> </xref:System.Windows.Data.PriorityBinding> </xref:System.Windows.Data.MultiBinding>"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.  \n  \n [!code-cs[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#datacontext)]\n [!code-vb[ContentElementsSmorgasbord#DataContext](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#datacontext)]"
  syntax:
    content: public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "識別繫結的屬性。"
    - id: path
      type: System.String
      description: "來源屬性名稱或用來繫結屬性的路徑。"
    return:
      type: System.Windows.Data.BindingExpression
      description: "記錄繫結的條件。 這個傳回值可用於錯誤檢查。"
  overload: System.Windows.FrameworkContentElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  id: SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "將繫結附加至這個項目，根據提供的繫結物件。"
  remarks: "這個方法是便利的方法<xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>，然後傳遞目前的執行個體，作為<xref:System.Windows.DependencyObject>.</xref:System.Windows.DependencyObject></xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=fullName>函式呼叫"
  example:
  - "The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.  \n  \n [!code-cs[ContentElementsSmorgasbord#SetBinding](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#setbinding)]\n [!code-vb[ContentElementsSmorgasbord#SetBinding](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#setbinding)]"
  syntax:
    content: public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "識別繫結的屬性。"
    - id: binding
      type: System.Windows.Data.BindingBase
      description: "表示資料繫結。"
    return:
      type: System.Windows.Data.BindingExpressionBase
      description: "記錄繫結的條件。 這個傳回值可用於錯誤檢查。"
  overload: System.Windows.FrameworkContentElement.SetBinding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  id: SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "搜尋具有指定名稱的資源，並設定其資源參考指定之屬性。"
  remarks: "資源參考是可讓您使用類似[DynamicResource 標記延伸](~/add/includes/ajax-current-ext-md.md)標記中。 資源參考建立內部的運算式，提供執行階段的延遲為基礎的指定屬性的值。 每次您的資源字典表示變更的值，透過內部事件，或目前的項目重設父代重新評估運算式 （父代變更會變更的字典查閱路徑）。"
  syntax:
    content: public void SetResourceReference (System.Windows.DependencyProperty dp, object name);
    parameters:
    - id: dp
      type: System.Windows.DependencyProperty
      description: "繫結至資源屬性。"
    - id: name
      type: System.Object
      description: "資源的名稱。"
  overload: System.Windows.FrameworkContentElement.SetResourceReference*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources
  id: ShouldSerializeResources
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ShouldSerializeResources()
  nameWithType: FrameworkContentElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeResources()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "傳回序列化程序是否應序列化<xref:System.Windows.FrameworkContentElement.Resources*>此類別的執行個體上的屬性</xref:System.Windows.FrameworkContentElement.Resources*>的內容"
  remarks: "這會傳回`true`，只要在本機<xref:System.Windows.FrameworkContentElement.Resources%2A>.</xref:System.Windows.FrameworkContentElement.Resources%2A>沒有至少一個索引鍵的資源"
  syntax:
    content: public bool ShouldSerializeResources ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Windows.FrameworkContentElement.Resources*>屬性值應該序列化，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Windows.FrameworkContentElement.Resources*>"
  overload: System.Windows.FrameworkContentElement.ShouldSerializeResources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle
  id: ShouldSerializeStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ShouldSerializeStyle()
  nameWithType: FrameworkContentElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "傳回序列化程序是否應序列化<xref:System.Windows.FrameworkContentElement.Style*>此類別的執行個體上的屬性</xref:System.Windows.FrameworkContentElement.Style*>的內容"
  remarks: "這會傳回`true`如果<xref:System.Windows.Style>本機設定。</xref:System.Windows.Style>"
  syntax:
    content: public bool ShouldSerializeStyle ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Windows.FrameworkContentElement.Style*>屬性值應該序列化，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Windows.FrameworkContentElement.Style*>"
  overload: System.Windows.FrameworkContentElement.ShouldSerializeStyle*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.SourceUpdated
  id: SourceUpdated
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: SourceUpdated
  nameWithType: FrameworkContentElement.SourceUpdated
  fullName: System.Windows.FrameworkContentElement.SourceUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "當任何相關聯的資料來源加入之繫結的這個項目變更時發生。"
  remarks: "此事件介面<xref:System.Windows.Data.Binding.SourceUpdated>引發任何事件<xref:System.Windows.Data.Binding>與這個項目相關聯。</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.SourceUpdated>      <a name=&quot;xamlAttributeUsage_SourceUpdated&quot;></a># # XAML 屬性使用方式```   <object SourceUpdated=&quot;EventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> SourceUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Style
  id: Style
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Style
  nameWithType: FrameworkContentElement.Style
  fullName: System.Windows.FrameworkContentElement.Style
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定這個項目所使用的樣式。"
  remarks: "目前的樣式，通常是由預設樣式來自主題設定，或從通常由在網頁或應用程式層級 （隱含樣式） 的資源套用至該類型的物件的樣式。 這個屬性不會設定或傳回預設 （佈景主題） 樣式，但會傳回隱含樣式或明確的樣式。 在隱含或明確樣式的情況下，樣式是做為資源的存取，或在本機定義並不重要。       設定樣式會有一些限制。 您可以將整個樣式屬性重設為 新<xref:System.Windows.Style>在任何時間，這會強制配置重新編輯畫。</xref:System.Windows.Style> 不過，一旦該樣式會放在使用中載入的項目，<xref:System.Windows.Style>應該被視為已密封。</xref:System.Windows.Style> 嘗試變更的任何個別的使用中樣式屬性 (例如在集合內的任何項目<xref:System.Windows.Style.Setters%2A>)，會擲回例外狀況。</xref:System.Windows.Style.Setters%2A> 標記中定義的樣式會被視為正在使用中，一旦載入時將它從資源字典 （資源），或載入它包含在的頁面 （適用於內嵌樣式）。       樣式是具有特殊的優先順序的相依性屬性。 本機設定樣式通常都是在運作的最高的優先順序屬性系統中。 如果此時樣式是 null 時，載入屬性系統會檢查隱含樣式為定義該類型指定的資源。 樣式時仍 null 在此步驟之後，然後樣式來自預設 （佈景主題） 的樣式，但樣式屬性值中不會傳回預設樣式。 請參閱[相依性屬性的值優先順序](~/add/includes/ajax-current-ext-md.md)。      <a name=&quot;xamlAttributeUsage_Style&quot;></a># # XAML 屬性使用方式```   <object Style=&quot;{resourceExtension StyleResourceKey}&quot;/>   ``` <a name=&quot;xamlValues_Style&quot;> </a> # # XAML 值*resourceExtension*下列其中之一:、 或。       請參閱[XAML 資源](~/add/includes/ajax-current-ext-md.md)。       *styleResourceKey*識別所要求的樣式的索引鍵。 索引鍵參考<xref:System.Windows.ResourceDictionary>.</xref:System.Windows.ResourceDictionary>中現有的資源      > [!NOTE] > 屬性項目語法是可行，但不是建議。 請參閱[內嵌樣式和樣板](~/add/includes/ajax-current-ext-md.md)。  使用繫結參考或<xref:System.Windows.Data.Binding>也是可行的但不常見。</xref:System.Windows.Data.Binding>      <a name=&quot;dependencyPropertyInfo_Style&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.StyleProperty>|  |中繼資料屬性設定為`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|</xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> </xref:System.Windows.FrameworkContentElement.StyleProperty>"
  example:
  - "The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.  \n  \n [!code-xml[ContentElementsSmorgasbord#FCEResources](~/add/codesnippet/xaml/ContentElementsSmorgasbord/page2.xaml#fceresources)]"
  syntax:
    content: public System.Windows.Style Style { get; set; }
    return:
      type: System.Windows.Style
      description: "已套用的非預設樣式項目，如果有的話。 否則， <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。 預設建構預設<xref href=&quot;System.Windows.FrameworkContentElement&quot;></xref>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkContentElement.Style*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.StyleProperty
  id: StyleProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: StyleProperty
  nameWithType: FrameworkContentElement.StyleProperty
  fullName: System.Windows.FrameworkContentElement.StyleProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkContentElement.Style*>相依性屬性。</xref:System.Windows.FrameworkContentElement.Style*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty StyleProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "如需這個成員的說明，請參閱<xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>方法。</xref:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable*>"
  remarks: "這個成員是明確介面成員實作。 它可用時，才<xref:System.Windows.FrameworkContentElement>執行個體轉換成<xref:System.Windows.Markup.IQueryAmbient>介面。</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.FrameworkContentElement>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "要求的環境屬性的名稱。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<code> propertyName </code>可用，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Tag
  id: Tag
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Tag
  nameWithType: FrameworkContentElement.Tag
  fullName: System.Windows.FrameworkContentElement.Tag
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定可以用來儲存這個項目相關的自訂資訊的任意物件值。"
  remarks: "這個屬性相當於在其他標籤屬性[!INCLUDE[TLA#tla_ms](~/add/includes/tlasharptla-ms-md.md)]程式設計模型，例如[!INCLUDE[TLA#tla_vba](~/add/includes/ajax-current-ext-md.md)]或[!INCLUDE[TLA#tla_winforms](~/add/includes/ajax-current-ext-md.md)]。 它被用來提供已存在的位置來儲存任何項目相關的一些基本自訂資訊，而不未強制子類別化的應用程式開發人員。      <a name=&quot;xamlValues_Tag&quot;></a># # XAML 的值，因為這個屬性會採用物件，您將需要以設定標記屬性使用屬性項目用法[!INCLUDE[TLA#tla_xaml](~/add/includes/tlasharptla-xaml-md.md)]至具有已知與內建型別轉換子，例如字串的物件以外的任何項目。 這種方式中使用的物件通常不是標準內[!INCLUDE[TLA#tla_winclient](~/add/includes/ajax-current-ext-md.md)]命名空間，因此可能需要為了引進，做為外部命名空間的命名空間對應[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]項目。      <a name=&quot;dependencyPropertyInfo_Tag&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.TagProperty>|  |中繼資料屬性設定為`true`|None |</xref:System.Windows.FrameworkContentElement.TagProperty>"
  syntax:
    content: public object Tag { get; set; }
    return:
      type: System.Object
      description: "預定的值。 這個屬性就沒有預設值。"
  overload: System.Windows.FrameworkContentElement.Tag*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TagProperty
  id: TagProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TagProperty
  nameWithType: FrameworkContentElement.TagProperty
  fullName: System.Windows.FrameworkContentElement.TagProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkContentElement.Tag*>相依性屬性。</xref:System.Windows.FrameworkContentElement.Tag*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty TagProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TargetUpdated
  id: TargetUpdated
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TargetUpdated
  nameWithType: FrameworkContentElement.TargetUpdated
  fullName: System.Windows.FrameworkContentElement.TargetUpdated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "當任何相關聯的目標屬性參與之繫結的這個項目變更時發生。"
  remarks: "此事件介面<xref:System.Windows.Data.Binding.TargetUpdated>引發任何事件<xref:System.Windows.Data.Binding>與這個項目相關聯。</xref:System.Windows.Data.Binding> </xref:System.Windows.Data.Binding.TargetUpdated> 這通常表示有問題的繫結是雙向繫結和繫結的相依性屬性 affirms 的任何驗證或快取的配置屬性支援先前的屬性值失效。       此事件的事件引數會通知您繫結屬性已變更。      <a name=&quot;xamlAttributeUsage_TargetUpdated&quot;></a># # XAML 屬性使用方式```   <object TargetUpdated=&quot;EventHandler&quot;/>   ```"
  syntax:
    content: public event EventHandler<System.Windows.Data.DataTransferEventArgs> TargetUpdated;
    return:
      type: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TemplatedParent
  id: TemplatedParent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
  fullName: System.Windows.FrameworkContentElement.TemplatedParent
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得這個項目的範本父代參考。 如果未透過範本建立的項目，這個屬性無關。"
  remarks: "範本是範本的內容會一次建立的實際共用的物件。 因此，如果您取得的項目，以來自範本的物件參考時，您可能會發現明顯的邏輯樹狀結構不會到達頁面根。 若要連接至邏輯樹狀結構頁面的這類的範本參考，您應該取得 TemplatedParent 值，並繼續瀏覽所需的項目樹狀結構。       通常會 TemplatedParent`null`一般物件，因為如果您透過一般方式在應用程式中取得的物件參考，從頁面，該項目可能不建立從範本。 情況下，可能不會 TemplatedParent`null`會包含作業，例如點擊測試的事件處理某些低階的輸入事件，或使用列舉值，可能會傳回來自範本的項目。"
  syntax:
    content: public System.Windows.DependencyObject TemplatedParent { get; }
    return:
      type: System.Windows.DependencyObject
      description: "項目其<xref href=&quot;System.Windows.FrameworkTemplate&quot;> </xref> <xref:System.Windows.FrameworkTemplate.VisualTree*>造成要建立這個項目。</xref:System.Windows.FrameworkTemplate.VisualTree*> 這個值通常是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>; 請參閱 < 備註 >。"
  overload: System.Windows.FrameworkContentElement.TemplatedParent*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTip
  id: ToolTip
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
  fullName: System.Windows.FrameworkContentElement.ToolTip
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定顯示在這個項目的工具提示物件[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]。"
  remarks: "如果這個屬性的值屬於型別<xref:System.Windows.Controls.ToolTip>，就是將用於工具提示[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]。</xref:System.Windows.Controls.ToolTip>  如果值為任何其他型別，則該值會用作*內容*如<xref:System.Windows.Controls.ToolTip>提供 （建構） 系統。</xref:System.Windows.Controls.ToolTip> 如需詳細資訊，請參閱<xref:System.Windows.Controls.ToolTipService>.</xref:System.Windows.Controls.ToolTipService> 服務類別提供可用來進一步自訂工具提示的附加的屬性。      <a name=&quot;xamlAttributeUsage_ToolTip&quot;></a># # XAML 屬性使用方式```   <object ToolTip=&quot;toolTipContent&quot;/>   ``` <a name=&quot;xamlPropertyElementUsage_ToolTip&quot;> </a> # # XAML 屬性項目用法```   <object>     <object.ToolTip>       <ToolTip .../>     </object.ToolTip>   </object>   - or -   <object>     <object.ToolTip>       toolTipObjectContent     </object.ToolTip>   </object>   ``` <a name=&quot;xamlValues_ToolTip&quot;> </a> # # XAML 值*toolTipContent*工具提示會顯示文字的字串。                   *toolTipObjectContent*是用來做為內容<xref:System.Windows.FrameworkContentElement>.</xref:System.Windows.FrameworkContentElement>物件項目表單中所提供的某些物件 通常這會是<xref:System.Windows.FrameworkElement>或其他一些建立工具提示中，最後會包含文字內容的複合 （compositing） 配置的複合 （compositing） 的項目。</xref:System.Windows.FrameworkElement> 在這種用法，<xref:System.Windows.Controls.ToolTip>元素建立隱含從已剖析[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]，而*toolTipObjectContent*內容設定為其<xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName>屬性。</xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=fullName> </xref:System.Windows.Controls.ToolTip>       `ToolTip`.../>    See <xref:System.Windows.Controls.ToolTip>.</xref:System.Windows.Controls.ToolTip>      <a name=&quot;dependencyPropertyInfo_ToolTip&quot;></a># # 相依性屬性資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  |中繼資料屬性設定為`true`|None |</xref:System.Windows.FrameworkContentElement.ToolTipProperty>"
  example:
  - "The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.  \n  \n [!code-cs[TableSnippets2#_Table_RowGroups_ManipRows](~/add/codesnippet/csharp/TableSnippets2/Window1.xaml.cs#_table_rowgroups_maniprows)]\n [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/add/codesnippet/visualbasic/tablesnippets2/window1.xaml.vb#_table_rowgroups_maniprows)]"
  syntax:
    content: public object ToolTip { get; set; }
    return:
      type: System.Object
      description: "工具提示物件。 為什麼這個參數已不強類型的詳細資訊，請參閱以下的 < 備註 >。"
  overload: System.Windows.FrameworkContentElement.ToolTip*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipClosing
  id: ToolTipClosing
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipClosing
  nameWithType: FrameworkContentElement.ToolTipClosing
  fullName: System.Windows.FrameworkContentElement.ToolTipClosing
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "項目上的任何工具提示關閉之前發生。"
  remarks: "若要隱藏關閉工具提示，此事件處理常式應將其標記為已處理。       此事件不可以是<xref:System.Windows.EventTrigger>樣式。</xref:System.Windows.EventTrigger> 這是因為此事件的識別項欄位會重複使用的服務，不會公開事件上的 新增/移除方法中的實作。      <a name=&quot;routedEventInfo_ToolTipClosing&quot;></a># # 路由事件資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  |路由策略 |直接 |  |委派 |<xref:System.Windows.Controls.ToolTipEventHandler>|</xref:System.Windows.Controls.ToolTipEventHandler></xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  id: ToolTipClosingEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipClosingEvent
  nameWithType: FrameworkContentElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref href=&quot;System.Windows.FrameworkContentElement.ToolTipClosing&quot;> </xref> [路由傳送事件概觀](~/add/includes/ajax-current-ext-md.md)。"
  remarks: "註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然後可以用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 識別項物件包含的識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipOpening
  id: ToolTipOpening
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipOpening
  nameWithType: FrameworkContentElement.ToolTipOpening
  fullName: System.Windows.FrameworkContentElement.ToolTipOpening
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "項目上的任何工具提示開啟時發生。"
  remarks: "若要以手動方式開啟工具提示，為已處理的事件處理常式時，應該標記相關的事件。 否則，值<xref:System.Windows.FrameworkContentElement.ToolTip%2A>屬性會用來自動開啟內容功能表。</xref:System.Windows.FrameworkContentElement.ToolTip%2A> 標記處理的事件會有效地取消的預設動作，並可能得以重設的<xref:System.Windows.FrameworkContentElement.ToolTip%2A>屬性，然後開啟新的<xref:System.Windows.Controls.ContextMenu>。</xref:System.Windows.Controls.ContextMenu></xref:System.Windows.FrameworkContentElement.ToolTip%2A>的值 請注意是否，不會引發這個事件<xref:System.Windows.FrameworkContentElement.ToolTip%2A>為 null 參考或其他未設定。</xref:System.Windows.FrameworkContentElement.ToolTip%2A>       此事件不可以是<xref:System.Windows.EventTrigger>樣式。</xref:System.Windows.EventTrigger> 這是因為此事件的識別項欄位會重複使用的服務，不會公開事件上的 新增/移除方法中的實作。      <a name=&quot;routedEventInfo_ToolTipOpening&quot;></a># # 路由事件資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  |路由策略 |直接 |  |委派 |<xref:System.Windows.Controls.ToolTipEventHandler>|</xref:System.Windows.Controls.ToolTipEventHandler></xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>"
  syntax:
    content: public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;
    return:
      type: System.Windows.Controls.ToolTipEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  id: ToolTipOpeningEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipOpeningEvent
  nameWithType: FrameworkContentElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref href=&quot;System.Windows.FrameworkContentElement.ToolTipOpening&quot;> </xref> [路由傳送事件概觀](~/add/includes/ajax-current-ext-md.md)。"
  remarks: "註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然後可以用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 識別項物件包含的識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.ToolTipProperty
  id: ToolTipProperty
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: ToolTipProperty
  nameWithType: FrameworkContentElement.ToolTipProperty
  fullName: System.Windows.FrameworkContentElement.ToolTipProperty
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref:System.Windows.FrameworkContentElement.ToolTip*>相依性屬性。</xref:System.Windows.FrameworkContentElement.ToolTip*>"
  syntax:
    content: public static readonly System.Windows.DependencyProperty ToolTipProperty;
    return:
      type: System.Windows.DependencyProperty
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: FrameworkContentElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkContentElement.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "搜尋的資源，以指定的索引鍵，並傳回該資源，如果找到。"
  remarks: "如果呼叫的項目上找不到資源，父樹狀結構中搜尋樹狀結構的相同方式，使用邏輯樹狀目錄中，如果在執行階段的索引鍵所要求的動態資源參考的搜尋。       通常您會立即傳回值轉換為您嘗試使用傳回的資源值設定屬性的型別。       <xref:System.Windows.FrameworkContentElement.FindResource%2A>方法具有類似的行為不同之處在於它將會擲回例外狀況在未使用提供的索引鍵中尋找資源的情況下。</xref:System.Windows.FrameworkContentElement.FindResource%2A>"
  example:
  - "The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.  \n  \n [!code-cs[ContentElementsSmorgasbord#TryFindResource](~/add/codesnippet/csharp/ContentElementsSmorgasbord/page1.xaml.cs#tryfindresource)]\n [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/add/codesnippet/visualbasic/contentelementssmorgasbord/page1.xaml.vb#tryfindresource)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "要尋找之資源的索引鍵識別碼。"
    return:
      type: System.Object
      description: "找到的資源。 如果找不到任何資源， <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>傳回。"
  overload: System.Windows.FrameworkContentElement.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.Unloaded
  id: Unloaded
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: Unloaded
  nameWithType: FrameworkContentElement.Unloaded
  fullName: System.Windows.FrameworkContentElement.Unloaded
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "載入項目的項目樹狀結構中移除項目時發生。"
  remarks: "直接路由的事件不會遵循路由，才會處理在引發相同的項目內。 直接路由的事件並支援其他路由的事件的行為︰ 它們支援可存取的處理常式集合中，且可用來當作<xref:System.Windows.EventTrigger>樣式。</xref:System.Windows.EventTrigger>      <a name=&quot;routedEventInfo_Unloaded&quot;></a># # 路由事件資訊 | | |  |-|-|  |識別項欄位 |<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  |路由策略 |直接 |  |委派 |<xref:System.Windows.RoutedEventHandler>|</xref:System.Windows.RoutedEventHandler></xref:System.Windows.FrameworkContentElement.UnloadedEvent>"
  syntax:
    content: public event System.Windows.RoutedEventHandler Unloaded;
    return:
      type: System.Windows.RoutedEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UnloadedEvent
  id: UnloadedEvent
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UnloadedEvent
  nameWithType: FrameworkContentElement.UnloadedEvent
  fullName: System.Windows.FrameworkContentElement.UnloadedEvent
  type: Field
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "識別<xref href=&quot;System.Windows.FrameworkContentElement.Unloaded&quot;> </xref> [路由傳送事件概觀](~/add/includes/ajax-current-ext-md.md)。"
  remarks: "註冊路由的事件時，會建立事件的識別項物件 (請參閱<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>)，然後可以用來加入類別處理常式 (請參閱<xref:System.Windows.EventManager.RegisterClassHandler%2A>)。</xref:System.Windows.EventManager.RegisterClassHandler%2A> </xref:System.Windows.EventManager.RegisterRoutedEvent%2A> 識別項物件包含的識別名稱、 擁有者類型、 處理常式類型、 路由策略和公用程式方法新增擁有者的事件。"
  syntax:
    content: public static readonly System.Windows.RoutedEvent UnloadedEvent;
    return:
      type: System.Windows.RoutedEvent
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UnregisterName(System.String)
  id: UnregisterName(System.String)
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UnregisterName(String)
  nameWithType: FrameworkContentElement.UnregisterName(String)
  fullName: System.Windows.FrameworkContentElement.UnregisterName(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "簡化存取<xref:System.Windows.NameScope>取消註冊方法。</xref:System.Windows.NameScope>"
  remarks: "您只需要取消註冊名稱如果您想要重新註冊該相同名稱的另一個項目。"
  syntax:
    content: public void UnregisterName (string name);
    parameters:
    - id: name
      type: System.String
      description: "從目前的範圍中移除之名稱-物件組的名稱。"
  overload: System.Windows.FrameworkContentElement.UnregisterName*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle
  id: UpdateDefaultStyle
  parent: System.Windows.FrameworkContentElement
  langs:
  - csharp
  name: UpdateDefaultStyle()
  nameWithType: FrameworkContentElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkContentElement.UpdateDefaultStyle()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "重新套用至目前的預設樣式<xref href=&quot;System.Windows.FrameworkContentElement&quot;> </xref>。"
  syntax:
    content: public void UpdateDefaultStyle ();
    parameters: []
  overload: System.Windows.FrameworkContentElement.UpdateDefaultStyle*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.ContentElement
  isExternal: false
  name: System.Windows.ContentElement
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ComponentModel.InvalidEnumArgumentException
  parent: System.ComponentModel
  isExternal: false
  name: InvalidEnumArgumentException
  nameWithType: InvalidEnumArgumentException
  fullName: System.ComponentModel.InvalidEnumArgumentException
- uid: System.Windows.FrameworkContentElement.#ctor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FrameworkContentElement()
  nameWithType: FrameworkContentElement.FrameworkContentElement()
  fullName: System.Windows.FrameworkContentElement.FrameworkContentElement()
- uid: System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: AddLogicalChild(Object)
  nameWithType: FrameworkContentElement.AddLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.AddLogicalChild(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.FrameworkContentElement.BeginInit
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginInit()
  nameWithType: FrameworkContentElement.BeginInit()
  fullName: System.Windows.FrameworkContentElement.BeginInit()
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard)
- uid: System.Windows.Media.Animation.Storyboard
  parent: System.Windows.Media.Animation
  isExternal: false
  name: Storyboard
  nameWithType: Storyboard
  fullName: System.Windows.Media.Animation.Storyboard
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior)
- uid: System.Windows.Media.Animation.HandoffBehavior
  parent: System.Windows.Media.Animation
  isExternal: false
  name: HandoffBehavior
  nameWithType: HandoffBehavior
  fullName: System.Windows.Media.Animation.HandoffBehavior
- uid: System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  nameWithType: FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
  fullName: System.Windows.FrameworkContentElement.BeginStoryboard(Storyboard,HandoffBehavior,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.FrameworkContentElement.BindingGroup
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
  fullName: System.Windows.FrameworkContentElement.BindingGroup
- uid: System.Windows.Data.BindingGroup
  parent: System.Windows.Data
  isExternal: false
  name: BindingGroup
  nameWithType: BindingGroup
  fullName: System.Windows.Data.BindingGroup
- uid: System.Windows.FrameworkContentElement.BindingGroupProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroupProperty
  nameWithType: FrameworkContentElement.BindingGroupProperty
  fullName: System.Windows.FrameworkContentElement.BindingGroupProperty
- uid: System.Windows.DependencyProperty
  parent: System.Windows
  isExternal: false
  name: DependencyProperty
  nameWithType: DependencyProperty
  fullName: System.Windows.DependencyProperty
- uid: System.Windows.FrameworkContentElement.BringIntoView
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BringIntoView()
  nameWithType: FrameworkContentElement.BringIntoView()
  fullName: System.Windows.FrameworkContentElement.BringIntoView()
- uid: System.Windows.FrameworkContentElement.ContextMenu
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
  fullName: System.Windows.FrameworkContentElement.ContextMenu
- uid: System.Windows.Controls.ContextMenu
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenu
  nameWithType: ContextMenu
  fullName: System.Windows.Controls.ContextMenu
- uid: System.Windows.FrameworkContentElement.ContextMenuClosing
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuClosing
  nameWithType: FrameworkContentElement.ContextMenuClosing
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosing
- uid: System.Windows.Controls.ContextMenuEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventHandler
  nameWithType: ContextMenuEventHandler
  fullName: System.Windows.Controls.ContextMenuEventHandler
- uid: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuClosingEvent
  nameWithType: FrameworkContentElement.ContextMenuClosingEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuClosingEvent
- uid: System.Windows.RoutedEvent
  parent: System.Windows
  isExternal: false
  name: RoutedEvent
  nameWithType: RoutedEvent
  fullName: System.Windows.RoutedEvent
- uid: System.Windows.FrameworkContentElement.ContextMenuOpening
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuOpening
  nameWithType: FrameworkContentElement.ContextMenuOpening
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpening
- uid: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuOpeningEvent
  nameWithType: FrameworkContentElement.ContextMenuOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ContextMenuOpeningEvent
- uid: System.Windows.FrameworkContentElement.ContextMenuProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenuProperty
  nameWithType: FrameworkContentElement.ContextMenuProperty
  fullName: System.Windows.FrameworkContentElement.ContextMenuProperty
- uid: System.Windows.FrameworkContentElement.Cursor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
  fullName: System.Windows.FrameworkContentElement.Cursor
- uid: System.Windows.Input.Cursor
  parent: System.Windows.Input
  isExternal: false
  name: Cursor
  nameWithType: Cursor
  fullName: System.Windows.Input.Cursor
- uid: System.Windows.FrameworkContentElement.CursorProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: CursorProperty
  nameWithType: FrameworkContentElement.CursorProperty
  fullName: System.Windows.FrameworkContentElement.CursorProperty
- uid: System.Windows.FrameworkContentElement.DataContext
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
  fullName: System.Windows.FrameworkContentElement.DataContext
- uid: System.Windows.FrameworkContentElement.DataContextChanged
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContextChanged
  nameWithType: FrameworkContentElement.DataContextChanged
  fullName: System.Windows.FrameworkContentElement.DataContextChanged
- uid: System.Windows.DependencyPropertyChangedEventHandler
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventHandler
  nameWithType: DependencyPropertyChangedEventHandler
  fullName: System.Windows.DependencyPropertyChangedEventHandler
- uid: System.Windows.FrameworkContentElement.DataContextProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContextProperty
  nameWithType: FrameworkContentElement.DataContextProperty
  fullName: System.Windows.FrameworkContentElement.DataContextProperty
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKey
- uid: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKeyProperty
  nameWithType: FrameworkContentElement.DefaultStyleKeyProperty
  fullName: System.Windows.FrameworkContentElement.DefaultStyleKeyProperty
- uid: System.Windows.FrameworkContentElement.EndInit
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: EndInit()
  nameWithType: FrameworkContentElement.EndInit()
  fullName: System.Windows.FrameworkContentElement.EndInit()
- uid: System.Windows.FrameworkContentElement.FindName(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindName(String)
  nameWithType: FrameworkContentElement.FindName(String)
  fullName: System.Windows.FrameworkContentElement.FindName(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.FrameworkContentElement.FindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindResource(Object)
  nameWithType: FrameworkContentElement.FindResource(Object)
  fullName: System.Windows.FrameworkContentElement.FindResource(Object)
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyle
- uid: System.Windows.Style
  parent: System.Windows
  isExternal: false
  name: Style
  nameWithType: Style
  fullName: System.Windows.Style
- uid: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyleProperty
  nameWithType: FrameworkContentElement.FocusVisualStyleProperty
  fullName: System.Windows.FrameworkContentElement.FocusVisualStyleProperty
- uid: System.Windows.FrameworkContentElement.ForceCursor
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
  fullName: System.Windows.FrameworkContentElement.ForceCursor
- uid: System.Windows.FrameworkContentElement.ForceCursorProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursorProperty
  nameWithType: FrameworkContentElement.ForceCursorProperty
  fullName: System.Windows.FrameworkContentElement.ForceCursorProperty
- uid: System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetBindingExpression(DependencyProperty)
  nameWithType: FrameworkContentElement.GetBindingExpression(DependencyProperty)
  fullName: System.Windows.FrameworkContentElement.GetBindingExpression(DependencyProperty)
- uid: System.Windows.Data.BindingExpression
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpression
  nameWithType: BindingExpression
  fullName: System.Windows.Data.BindingExpression
- uid: System.Windows.FrameworkContentElement.GetUIParentCore
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetUIParentCore()
  nameWithType: FrameworkContentElement.GetUIParentCore()
  fullName: System.Windows.FrameworkContentElement.GetUIParentCore()
- uid: System.Windows.DependencyObject
  parent: System.Windows
  isExternal: false
  name: DependencyObject
  nameWithType: DependencyObject
  fullName: System.Windows.DependencyObject
- uid: System.Windows.FrameworkContentElement.Initialized
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Initialized
  nameWithType: FrameworkContentElement.Initialized
  fullName: System.Windows.FrameworkContentElement.Initialized
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.FrameworkContentElement.InputScope
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
  fullName: System.Windows.FrameworkContentElement.InputScope
- uid: System.Windows.Input.InputScope
  parent: System.Windows.Input
  isExternal: false
  name: InputScope
  nameWithType: InputScope
  fullName: System.Windows.Input.InputScope
- uid: System.Windows.FrameworkContentElement.InputScopeProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScopeProperty
  nameWithType: FrameworkContentElement.InputScopeProperty
  fullName: System.Windows.FrameworkContentElement.InputScopeProperty
- uid: System.Windows.FrameworkContentElement.IsInitialized
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
  fullName: System.Windows.FrameworkContentElement.IsInitialized
- uid: System.Windows.FrameworkContentElement.IsLoaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
  fullName: System.Windows.FrameworkContentElement.IsLoaded
- uid: System.Windows.FrameworkContentElement.Language
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Language
  nameWithType: FrameworkContentElement.Language
  fullName: System.Windows.FrameworkContentElement.Language
- uid: System.Windows.Markup.XmlLanguage
  parent: System.Windows.Markup
  isExternal: false
  name: XmlLanguage
  nameWithType: XmlLanguage
  fullName: System.Windows.Markup.XmlLanguage
- uid: System.Windows.FrameworkContentElement.LanguageProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LanguageProperty
  nameWithType: FrameworkContentElement.LanguageProperty
  fullName: System.Windows.FrameworkContentElement.LanguageProperty
- uid: System.Windows.FrameworkContentElement.Loaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Loaded
  nameWithType: FrameworkContentElement.Loaded
  fullName: System.Windows.FrameworkContentElement.Loaded
- uid: System.Windows.RoutedEventHandler
  parent: System.Windows
  isExternal: false
  name: RoutedEventHandler
  nameWithType: RoutedEventHandler
  fullName: System.Windows.RoutedEventHandler
- uid: System.Windows.FrameworkContentElement.LoadedEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LoadedEvent
  nameWithType: FrameworkContentElement.LoadedEvent
  fullName: System.Windows.FrameworkContentElement.LoadedEvent
- uid: System.Windows.FrameworkContentElement.LogicalChildren
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
  fullName: System.Windows.FrameworkContentElement.LogicalChildren
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: MoveFocus(TraversalRequest)
  nameWithType: FrameworkContentElement.MoveFocus(TraversalRequest)
  fullName: System.Windows.FrameworkContentElement.MoveFocus(TraversalRequest)
- uid: System.Windows.Input.TraversalRequest
  parent: System.Windows.Input
  isExternal: false
  name: TraversalRequest
  nameWithType: TraversalRequest
  fullName: System.Windows.Input.TraversalRequest
- uid: System.Windows.FrameworkContentElement.Name
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Name
  nameWithType: FrameworkContentElement.Name
  fullName: System.Windows.FrameworkContentElement.Name
- uid: System.Windows.FrameworkContentElement.NameProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: NameProperty
  nameWithType: FrameworkContentElement.NameProperty
  fullName: System.Windows.FrameworkContentElement.NameProperty
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuClosing(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuClosing(ContextMenuEventArgs)
- uid: System.Windows.Controls.ContextMenuEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ContextMenuEventArgs
  nameWithType: ContextMenuEventArgs
  fullName: System.Windows.Controls.ContextMenuEventArgs
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuOpening(ContextMenuEventArgs)
  nameWithType: FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnContextMenuOpening(ContextMenuEventArgs)
- uid: System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnGotFocus(RoutedEventArgs)
  nameWithType: FrameworkContentElement.OnGotFocus(RoutedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnGotFocus(RoutedEventArgs)
- uid: System.Windows.RoutedEventArgs
  parent: System.Windows
  isExternal: false
  name: RoutedEventArgs
  nameWithType: RoutedEventArgs
  fullName: System.Windows.RoutedEventArgs
- uid: System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnInitialized(EventArgs)
  nameWithType: FrameworkContentElement.OnInitialized(EventArgs)
  fullName: System.Windows.FrameworkContentElement.OnInitialized(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)
  nameWithType: FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnPropertyChanged(DependencyPropertyChangedEventArgs)
- uid: System.Windows.DependencyPropertyChangedEventArgs
  parent: System.Windows
  isExternal: false
  name: DependencyPropertyChangedEventArgs
  nameWithType: DependencyPropertyChangedEventArgs
  fullName: System.Windows.DependencyPropertyChangedEventArgs
- uid: System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnStyleChanged(Style,Style)
  nameWithType: FrameworkContentElement.OnStyleChanged(Style,Style)
  fullName: System.Windows.FrameworkContentElement.OnStyleChanged(Style,Style)
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipClosing(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipClosing(ToolTipEventArgs)
- uid: System.Windows.Controls.ToolTipEventArgs
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventArgs
  nameWithType: ToolTipEventArgs
  fullName: System.Windows.Controls.ToolTipEventArgs
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipOpening(ToolTipEventArgs)
  nameWithType: FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
  fullName: System.Windows.FrameworkContentElement.OnToolTipOpening(ToolTipEventArgs)
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyleProperty
  nameWithType: FrameworkContentElement.OverridesDefaultStyleProperty
  fullName: System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty
- uid: System.Windows.FrameworkContentElement.Parent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkContentElement.Parent
  fullName: System.Windows.FrameworkContentElement.Parent
- uid: System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: PredictFocus(FocusNavigationDirection)
  nameWithType: FrameworkContentElement.PredictFocus(FocusNavigationDirection)
  fullName: System.Windows.FrameworkContentElement.PredictFocus(FocusNavigationDirection)
- uid: System.Windows.Input.FocusNavigationDirection
  parent: System.Windows.Input
  isExternal: false
  name: FocusNavigationDirection
  nameWithType: FocusNavigationDirection
  fullName: System.Windows.Input.FocusNavigationDirection
- uid: System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RegisterName(String,Object)
  nameWithType: FrameworkContentElement.RegisterName(String,Object)
  fullName: System.Windows.FrameworkContentElement.RegisterName(String,Object)
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RemoveLogicalChild(Object)
  nameWithType: FrameworkContentElement.RemoveLogicalChild(Object)
  fullName: System.Windows.FrameworkContentElement.RemoveLogicalChild(Object)
- uid: System.Windows.FrameworkContentElement.Resources
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkContentElement.Resources
  fullName: System.Windows.FrameworkContentElement.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding(DependencyProperty,String)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,String)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,String)
- uid: System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding(DependencyProperty,BindingBase)
  nameWithType: FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
  fullName: System.Windows.FrameworkContentElement.SetBinding(DependencyProperty,BindingBase)
- uid: System.Windows.Data.BindingExpressionBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingExpressionBase
  nameWithType: BindingExpressionBase
  fullName: System.Windows.Data.BindingExpressionBase
- uid: System.Windows.Data.BindingBase
  parent: System.Windows.Data
  isExternal: false
  name: BindingBase
  nameWithType: BindingBase
  fullName: System.Windows.Data.BindingBase
- uid: System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetResourceReference(DependencyProperty,Object)
  nameWithType: FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
  fullName: System.Windows.FrameworkContentElement.SetResourceReference(DependencyProperty,Object)
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeResources()
  nameWithType: FrameworkContentElement.ShouldSerializeResources()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeResources()
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeStyle()
  nameWithType: FrameworkContentElement.ShouldSerializeStyle()
  fullName: System.Windows.FrameworkContentElement.ShouldSerializeStyle()
- uid: System.Windows.FrameworkContentElement.SourceUpdated
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SourceUpdated
  nameWithType: FrameworkContentElement.SourceUpdated
  fullName: System.Windows.FrameworkContentElement.SourceUpdated
- uid: System.EventHandler{System.Windows.Data.DataTransferEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<DataTransferEventArgs>
  nameWithType: EventHandler<DataTransferEventArgs>
  fullName: System.EventHandler<System.Windows.Data.DataTransferEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Windows.Data.DataTransferEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Windows.Data.DataTransferEventArgs
    name: DataTransferEventArgs
    nameWithType: DataTransferEventArgs
    fullName: DataTransferEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Windows.FrameworkContentElement.Style
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Style
  nameWithType: FrameworkContentElement.Style
  fullName: System.Windows.FrameworkContentElement.Style
- uid: System.Windows.FrameworkContentElement.StyleProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: StyleProperty
  nameWithType: FrameworkContentElement.StyleProperty
  fullName: System.Windows.FrameworkContentElement.StyleProperty
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Windows.FrameworkContentElement.Tag
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkContentElement.Tag
  fullName: System.Windows.FrameworkContentElement.Tag
- uid: System.Windows.FrameworkContentElement.TagProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TagProperty
  nameWithType: FrameworkContentElement.TagProperty
  fullName: System.Windows.FrameworkContentElement.TagProperty
- uid: System.Windows.FrameworkContentElement.TargetUpdated
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TargetUpdated
  nameWithType: FrameworkContentElement.TargetUpdated
  fullName: System.Windows.FrameworkContentElement.TargetUpdated
- uid: System.Windows.FrameworkContentElement.TemplatedParent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
  fullName: System.Windows.FrameworkContentElement.TemplatedParent
- uid: System.Windows.FrameworkContentElement.ToolTip
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
  fullName: System.Windows.FrameworkContentElement.ToolTip
- uid: System.Windows.FrameworkContentElement.ToolTipClosing
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipClosing
  nameWithType: FrameworkContentElement.ToolTipClosing
  fullName: System.Windows.FrameworkContentElement.ToolTipClosing
- uid: System.Windows.Controls.ToolTipEventHandler
  parent: System.Windows.Controls
  isExternal: false
  name: ToolTipEventHandler
  nameWithType: ToolTipEventHandler
  fullName: System.Windows.Controls.ToolTipEventHandler
- uid: System.Windows.FrameworkContentElement.ToolTipClosingEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipClosingEvent
  nameWithType: FrameworkContentElement.ToolTipClosingEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipClosingEvent
- uid: System.Windows.FrameworkContentElement.ToolTipOpening
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipOpening
  nameWithType: FrameworkContentElement.ToolTipOpening
  fullName: System.Windows.FrameworkContentElement.ToolTipOpening
- uid: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipOpeningEvent
  nameWithType: FrameworkContentElement.ToolTipOpeningEvent
  fullName: System.Windows.FrameworkContentElement.ToolTipOpeningEvent
- uid: System.Windows.FrameworkContentElement.ToolTipProperty
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTipProperty
  nameWithType: FrameworkContentElement.ToolTipProperty
  fullName: System.Windows.FrameworkContentElement.ToolTipProperty
- uid: System.Windows.FrameworkContentElement.TryFindResource(System.Object)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: FrameworkContentElement.TryFindResource(Object)
  fullName: System.Windows.FrameworkContentElement.TryFindResource(Object)
- uid: System.Windows.FrameworkContentElement.Unloaded
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Unloaded
  nameWithType: FrameworkContentElement.Unloaded
  fullName: System.Windows.FrameworkContentElement.Unloaded
- uid: System.Windows.FrameworkContentElement.UnloadedEvent
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnloadedEvent
  nameWithType: FrameworkContentElement.UnloadedEvent
  fullName: System.Windows.FrameworkContentElement.UnloadedEvent
- uid: System.Windows.FrameworkContentElement.UnregisterName(System.String)
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnregisterName(String)
  nameWithType: FrameworkContentElement.UnregisterName(String)
  fullName: System.Windows.FrameworkContentElement.UnregisterName(String)
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UpdateDefaultStyle()
  nameWithType: FrameworkContentElement.UpdateDefaultStyle()
  fullName: System.Windows.FrameworkContentElement.UpdateDefaultStyle()
- uid: System.Windows.FrameworkContentElement.#ctor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FrameworkContentElement
  nameWithType: FrameworkContentElement.FrameworkContentElement
- uid: System.Windows.FrameworkContentElement.AddLogicalChild*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: AddLogicalChild
  nameWithType: FrameworkContentElement.AddLogicalChild
- uid: System.Windows.FrameworkContentElement.BeginInit*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginInit
  nameWithType: FrameworkContentElement.BeginInit
- uid: System.Windows.FrameworkContentElement.BeginStoryboard*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BeginStoryboard
  nameWithType: FrameworkContentElement.BeginStoryboard
- uid: System.Windows.FrameworkContentElement.BindingGroup*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BindingGroup
  nameWithType: FrameworkContentElement.BindingGroup
- uid: System.Windows.FrameworkContentElement.BringIntoView*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: BringIntoView
  nameWithType: FrameworkContentElement.BringIntoView
- uid: System.Windows.FrameworkContentElement.ContextMenu*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ContextMenu
  nameWithType: FrameworkContentElement.ContextMenu
- uid: System.Windows.FrameworkContentElement.Cursor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Cursor
  nameWithType: FrameworkContentElement.Cursor
- uid: System.Windows.FrameworkContentElement.DataContext*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DataContext
  nameWithType: FrameworkContentElement.DataContext
- uid: System.Windows.FrameworkContentElement.DefaultStyleKey*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: DefaultStyleKey
  nameWithType: FrameworkContentElement.DefaultStyleKey
- uid: System.Windows.FrameworkContentElement.EndInit*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: EndInit
  nameWithType: FrameworkContentElement.EndInit
- uid: System.Windows.FrameworkContentElement.FindName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindName
  nameWithType: FrameworkContentElement.FindName
- uid: System.Windows.FrameworkContentElement.FindResource*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FindResource
  nameWithType: FrameworkContentElement.FindResource
- uid: System.Windows.FrameworkContentElement.FocusVisualStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: FocusVisualStyle
  nameWithType: FrameworkContentElement.FocusVisualStyle
- uid: System.Windows.FrameworkContentElement.ForceCursor*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ForceCursor
  nameWithType: FrameworkContentElement.ForceCursor
- uid: System.Windows.FrameworkContentElement.GetBindingExpression*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetBindingExpression
  nameWithType: FrameworkContentElement.GetBindingExpression
- uid: System.Windows.FrameworkContentElement.GetUIParentCore*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: GetUIParentCore
  nameWithType: FrameworkContentElement.GetUIParentCore
- uid: System.Windows.FrameworkContentElement.InputScope*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: InputScope
  nameWithType: FrameworkContentElement.InputScope
- uid: System.Windows.FrameworkContentElement.IsInitialized*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsInitialized
  nameWithType: FrameworkContentElement.IsInitialized
- uid: System.Windows.FrameworkContentElement.IsLoaded*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: IsLoaded
  nameWithType: FrameworkContentElement.IsLoaded
- uid: System.Windows.FrameworkContentElement.Language*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Language
  nameWithType: FrameworkContentElement.Language
- uid: System.Windows.FrameworkContentElement.LogicalChildren*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: LogicalChildren
  nameWithType: FrameworkContentElement.LogicalChildren
- uid: System.Windows.FrameworkContentElement.MoveFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: MoveFocus
  nameWithType: FrameworkContentElement.MoveFocus
- uid: System.Windows.FrameworkContentElement.Name*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Name
  nameWithType: FrameworkContentElement.Name
- uid: System.Windows.FrameworkContentElement.OnContextMenuClosing*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuClosing
  nameWithType: FrameworkContentElement.OnContextMenuClosing
- uid: System.Windows.FrameworkContentElement.OnContextMenuOpening*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnContextMenuOpening
  nameWithType: FrameworkContentElement.OnContextMenuOpening
- uid: System.Windows.FrameworkContentElement.OnGotFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnGotFocus
  nameWithType: FrameworkContentElement.OnGotFocus
- uid: System.Windows.FrameworkContentElement.OnInitialized*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnInitialized
  nameWithType: FrameworkContentElement.OnInitialized
- uid: System.Windows.FrameworkContentElement.OnPropertyChanged*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnPropertyChanged
  nameWithType: FrameworkContentElement.OnPropertyChanged
- uid: System.Windows.FrameworkContentElement.OnStyleChanged*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnStyleChanged
  nameWithType: FrameworkContentElement.OnStyleChanged
- uid: System.Windows.FrameworkContentElement.OnToolTipClosing*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipClosing
  nameWithType: FrameworkContentElement.OnToolTipClosing
- uid: System.Windows.FrameworkContentElement.OnToolTipOpening*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OnToolTipOpening
  nameWithType: FrameworkContentElement.OnToolTipOpening
- uid: System.Windows.FrameworkContentElement.OverridesDefaultStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: OverridesDefaultStyle
  nameWithType: FrameworkContentElement.OverridesDefaultStyle
- uid: System.Windows.FrameworkContentElement.Parent*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Parent
  nameWithType: FrameworkContentElement.Parent
- uid: System.Windows.FrameworkContentElement.PredictFocus*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: PredictFocus
  nameWithType: FrameworkContentElement.PredictFocus
- uid: System.Windows.FrameworkContentElement.RegisterName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RegisterName
  nameWithType: FrameworkContentElement.RegisterName
- uid: System.Windows.FrameworkContentElement.RemoveLogicalChild*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: RemoveLogicalChild
  nameWithType: FrameworkContentElement.RemoveLogicalChild
- uid: System.Windows.FrameworkContentElement.Resources*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Resources
  nameWithType: FrameworkContentElement.Resources
- uid: System.Windows.FrameworkContentElement.SetBinding*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetBinding
  nameWithType: FrameworkContentElement.SetBinding
- uid: System.Windows.FrameworkContentElement.SetResourceReference*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: SetResourceReference
  nameWithType: FrameworkContentElement.SetResourceReference
- uid: System.Windows.FrameworkContentElement.ShouldSerializeResources*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeResources
  nameWithType: FrameworkContentElement.ShouldSerializeResources
- uid: System.Windows.FrameworkContentElement.ShouldSerializeStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ShouldSerializeStyle
  nameWithType: FrameworkContentElement.ShouldSerializeStyle
- uid: System.Windows.FrameworkContentElement.Style*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Style
  nameWithType: FrameworkContentElement.Style
- uid: System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: FrameworkContentElement.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.FrameworkContentElement.Tag*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: Tag
  nameWithType: FrameworkContentElement.Tag
- uid: System.Windows.FrameworkContentElement.TemplatedParent*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TemplatedParent
  nameWithType: FrameworkContentElement.TemplatedParent
- uid: System.Windows.FrameworkContentElement.ToolTip*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: ToolTip
  nameWithType: FrameworkContentElement.ToolTip
- uid: System.Windows.FrameworkContentElement.TryFindResource*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: TryFindResource
  nameWithType: FrameworkContentElement.TryFindResource
- uid: System.Windows.FrameworkContentElement.UnregisterName*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UnregisterName
  nameWithType: FrameworkContentElement.UnregisterName
- uid: System.Windows.FrameworkContentElement.UpdateDefaultStyle*
  parent: System.Windows.FrameworkContentElement
  isExternal: false
  name: UpdateDefaultStyle
  nameWithType: FrameworkContentElement.UpdateDefaultStyle
