### YamlMime:ManagedReference
items:
- uid: System.IO.Log.LogRecordSequence
  id: LogRecordSequence
  children:
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  - System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  - System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  - System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.BaseSequenceNumber
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.LogRecordSequence.CreateReservationCollection
  - System.IO.Log.LogRecordSequence.Dispose
  - System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.LogRecordSequence.Flush
  - System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.LastSequenceNumber
  - System.IO.Log.LogRecordSequence.LogStore
  - System.IO.Log.LogRecordSequence.MaximumRecordLength
  - System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.LogRecordSequence.ReadRestartAreas
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.LogRecordSequence.ReservedBytes
  - System.IO.Log.LogRecordSequence.RestartSequenceNumber
  - System.IO.Log.LogRecordSequence.RetryAppend
  - System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.TailPinned
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: LogRecordSequence
  nameWithType: LogRecordSequence
  fullName: System.IO.Log.LogRecordSequence
  type: Class
  summary: "代表儲存在記錄順序<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
  remarks: "LogRecordSequence 類別提供一般記錄檔系統 (CLFS) 記錄頂端的記錄順序介面的實作。 除了標準的記錄導向功能，它會提供一個原則模型來避免記錄檔已滿狀況，以及在同一實體檔案上的用戶端進行多工。 它使用<xref:System.IO.Log.LogStore>類別，可提供介面，來直接操作和管理 CLFS 記錄檔。</xref:System.IO.Log.LogStore> 之間的關聯性<xref:System.IO.Log.LogStore>類別及 LogRecordSequence 類別是類似於磁碟檔案之間的關聯性和<xref:System.IO.FileStream>物件。</xref:System.IO.FileStream> </xref:System.IO.Log.LogStore> 磁碟檔案提供實際的儲存區，且具有 「 長度 」 和 「 上次存取時間; 等屬性<xref:System.IO.FileStream>物件提供的檢視，可以用來讀取和寫入該檔案</xref:System.IO.FileStream>時 同樣地，<xref:System.IO.Log.LogStore>類別也具有原則和延伸磁碟區; 集合等屬性及 LogRecordSequence 類別提供讀取和寫入資料的記錄導向機制。</xref:System.IO.Log.LogStore>"
  example:
  - "This example shows how to use the LogRecordSequence class:  \n  \n [!code-cs[S_UELogRecordSequence#0](~/add/codesnippet/csharp/t-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#0](~/add/codesnippet/visualbasic/t-system.io.log.logrecor_1.vb)]"
  syntax:
    content: 'public sealed class LogRecordSequence : IDisposable, System.IO.Log.IRecordSequence'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  - System.IO.Log.IRecordSequence
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  id: '#ctor(System.IO.Log.LogStore)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>與指定的記錄存放區的類別。"
  remarks: "緩衝區大小決定了可以附加或讀取之記錄的大小上限。 在此建構函式，設定預設值 64。 需要的緩衝區數量設為 10。"
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>這個記錄順序應該使用。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>logStore</code>不正確。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>與指定之路徑的記錄存放區和存取模式的類別。"
  remarks: "這個建構函式初始化新<xref:System.IO.Log.LogRecordSequence>新<xref:System.IO.Log.LogStore>以指定的路徑和模式所開啟的物件。</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> 已授與它讀/寫存取存放區，且共用讀取權限開啟的存放區。"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "若要開啟的記錄存放區基底檔案的相對或絕對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值，決定如何開啟或建立存放區。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)。       -或-<code>path</code>只包含空格。       -或-<code>path</code>包含一或多個無效的字元。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含無效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到檔案。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟記錄存放區時發生 I/O 錯誤。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支援這項作業。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>無法使用，因為未安裝必要的通用記錄檔系統 (CLFS) 元件。 CLFS 元件適用於您的平台，如果安裝或使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>類別。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  id: '#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>類別指定的記錄存放區，每個記錄的緩衝區大小和緩衝區數目。"
  remarks: "如果您想要指定的值，請使用這個建構函式`bufferSize`和`bufferCount`而不要使用預設值為 64 的`bufferSize`和 10 `bufferCount`。"
  syntax:
    content: public LogRecordSequence (System.IO.Log.LogStore logStore, int bufferSize, int bufferCount);
    parameters:
    - id: logStore
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>這個記錄順序應該使用。"
    - id: bufferSize
      type: System.Int32
      description: "需要的緩衝區大小，以位元組為單位。 緩衝區大小決定了可以附加或讀取之記錄的大小上限。"
    - id: bufferCount
      type: System.Int32
      description: "需要的緩衝區數量。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>logStore</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize </code>是負值或零。       -或-<code>bufferCount</code>是負值或零。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>與指定之路徑的記錄存放區以及存取和共用模式的類別。"
  remarks: "這個建構函式初始化新<xref:System.IO.Log.LogRecordSequence>新<xref:System.IO.Log.LogStore>以指定的路徑、 模式和存取所開啟的物件。</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> 共用讀取權限來開啟的存放區。"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "若要開啟的記錄存放區基底檔案的相對或絕對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值，決定如何開啟或建立存放區。"
    - id: access
      type: System.IO.FileAccess
      description: "其中一個<xref href=&quot;System.IO.FileAccess&quot;></xref>值，決定如何存取檔案所<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)。       -或-<code>path</code>只包含空格。       -或-<code>path</code>包含一或多個無效的字元。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含無效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到檔案。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟記錄存放區時發生 I/O 錯誤。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支援這項作業。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>無法使用，因為未安裝必要的通用記錄檔系統 (CLFS) 元件。 CLFS 元件適用於您的平台，如果安裝或使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>類別。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>與指定之路徑的記錄存放區和存取模式的類別。"
  remarks: "這個建構函式初始化新<xref:System.IO.Log.LogRecordSequence>新<xref:System.IO.Log.LogStore>以指定的路徑、 模式和存取所開啟的物件。</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> 共用指定的存取權限來開啟的存放區。"
  example:
  - "This example shows how to use this <xref:System.IO.Log.LogRecordSequence> constructor:  \n  \n [!code-cs[S_UELogRecordSequence#1](~/add/codesnippet/csharp/5a33f64b-b9a0-4b07-9df4-_1.cs)]\n [!code-vb[S_UELogRecordSequence#1](~/add/codesnippet/visualbasic/5a33f64b-b9a0-4b07-9df4-_1.vb)]"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "若要開啟的記錄存放區基底檔案的相對或絕對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值，決定如何開啟或建立存放區。"
    - id: access
      type: System.IO.FileAccess
      description: "其中一個<xref href=&quot;System.IO.FileAccess&quot;></xref>值，決定如何存取檔案所<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
    - id: share
      type: System.IO.FileShare
      description: "其中一個<xref href=&quot;System.IO.FileShare&quot;></xref>值，決定如何在處理序之間共用記錄存放區。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)。       -或-<code>path</code>只包含空格。       -或-<code>path</code>包含一或多個無效的字元。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含無效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到檔案。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟記錄存放區時發生 I/O 錯誤。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支援這項作業。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>無法使用，因為未安裝必要的通用記錄檔系統 (CLFS) 元件。 CLFS 元件適用於您的平台，如果安裝或使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>類別。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>類別使用的記錄存放區、 檔案權限、 存取和共用模式，以及緩衝區大小和記錄計數指定路徑。"
  remarks: "這個建構函式初始化新<xref:System.IO.Log.LogRecordSequence>新<xref:System.IO.Log.LogStore>以指定的路徑、 模式和存取所開啟的物件。</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogRecordSequence> 共用指定的存取權限來開啟的存放區。"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount);
    parameters:
    - id: path
      type: System.String
      description: "若要開啟的記錄存放區基底檔案的相對或絕對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值，決定如何開啟或建立存放區。"
    - id: access
      type: System.IO.FileAccess
      description: "其中一個<xref href=&quot;System.IO.FileAccess&quot;></xref>值，決定如何存取檔案所<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
    - id: share
      type: System.IO.FileShare
      description: "其中一個<xref href=&quot;System.IO.FileShare&quot;></xref>值，決定如何在處理序之間共用記錄存放區。"
    - id: bufferSize
      type: System.Int32
      description: "需要的緩衝區大小，以位元組為單位。 緩衝區大小決定了可以附加或讀取之記錄的大小上限。"
    - id: bufferCount
      type: System.Int32
      description: "需要的緩衝區數量。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)。       -或-<code>path</code>只包含空格。       -或-<code>path</code>包含一或多個無效的字元。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含無效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到檔案。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟記錄存放區時發生 I/O 錯誤。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支援這項作業。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>無法使用，因為未安裝必要的通用記錄檔系統 (CLFS) 元件。 CLFS 元件適用於您的平台，如果安裝或使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>類別。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>類別。"
  syntax:
    content: public LogRecordSequence (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, int bufferCount, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "若要開啟的記錄存放區基底檔案的相對或絕對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "有效<xref href=&quot;System.IO.FileMode&quot;></xref>值，決定如何開啟或建立存放區。"
    - id: access
      type: System.IO.FileAccess
      description: "有效<xref href=&quot;System.IO.FileAccess&quot;></xref>值，決定如何存取記錄存放區。"
    - id: share
      type: System.IO.FileShare
      description: "有效<xref href=&quot;System.IO.FileShare&quot;></xref>決定如何在處理序之間共用記錄存放區的值。"
    - id: bufferSize
      type: System.Int32
      description: "需要的緩衝區大小，以位元組為單位。 緩衝區大小決定了可以附加或讀取之記錄的大小上限。"
    - id: bufferCount
      type: System.Int32
      description: "需要的緩衝區數量。"
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "有效<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>值，指定要設定新建立的存放區上，如果必須建立存放區的安全性。"
  overload: System.IO.Log.LogRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "所指定的檔案<code> path </code>不正確。       -或者-指定的記錄存放區檔案名稱無效。       - <code> mode </code>的值為<xref href=&quot;System.IO.FileMode&quot;> </xref>，也不能沒有寫入存取權。       - <code> mode </code>的值為<xref href=&quot;System.IO.FileMode&quot;> </xref>，也不能沒有寫入存取權。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個引數超出範圍。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "所指定的檔案<code> path </code>找不到。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -所指定的檔案<code> path </code>無法存取，因為它正在使用中另一個處理序。       -所指定的檔案<code> path </code>無法建立，因為檔案或目錄已存在。       -或者-記錄檔的控制代碼無法繫結至執行緒集區。       -或者-指定的記錄檔格式或版本無效。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支援這項作業。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>無法使用，因為未安裝必要的通用記錄檔系統 (CLFS) 元件。 CLFS 元件適用於您的平台，如果安裝或使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>類別。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "向前移的記錄檔的基底序號。 這個方法無法被繼承。"
  remarks: "這個方法通常用於<xref:System.IO.Log.LogRecordSequence.TailPinned>事件來釋放記錄中的空間。</xref:System.IO.Log.LogRecordSequence.TailPinned> <xref:System.IO.Log.LogRecordSequence.TailPinned>事件表示順序 （也就是基底序號） 的結尾必須往前移動以釋放空間。</xref:System.IO.Log.LogRecordSequence.TailPinned> 釋出空間，可透過寫入重新啟動區域使用<xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>方法，或是截斷記錄檔與使用 AdvanceBaseSequenceNumber 方法前進到所指定的記錄檔的基底序號`newBaseSequenceNumber`參數。</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A> 在範例 > 一節中的程式碼範例示範第二種方法。       請注意，呼叫這個方法是設定新基底的序列數字使用相同<xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>方法，不同之處在於不重新啟動記錄寫入記錄檔。</xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the AdvanceBaseSequenceNumber method with the <xref:System.IO.Log.LogRecordSequence.TailPinned> event to free up space in a log sequence.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "指定新的基底<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>記錄檔。 必須介於目前基底序號和記錄檔的最後一個序號之間的範圍 （含） 之間。"
  overload: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>無效，無法對此順序。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新的或現有封存結尾或作用中記錄的基底無效。       - <code> newBaseSequenceNumber </code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定的記錄檔並沒有任何延伸區。 必須建立一或多個延伸區，才能使用記錄順序。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將記錄檔記錄寫入<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。 這個方法無法被繼承。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example demonstrates how to use this method to append a log record to the sequence.  \n  \n [!code-cs[S_UELogRecordSequence#13](~/add/codesnippet/csharp/11cb4ef9-9d52-4994-983c-_1.cs)]\n [!code-vb[S_UELogRecordSequence#13](~/add/codesnippet/visualbasic/11cb4ef9-9d52-4994-983c-_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>對此順序無效。       -或-<code>data</code>大於記錄大小上限，因此無法附加。       -或-<code>reservations</code>不由此記錄順序所建立。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將附加的記錄檔記錄寫入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>。 這個方法無法被繼承。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>對此順序無效。       -或-<code>data</code>大於記錄大小上限，因此無法附加。       -或-<code>reservations</code>不由此記錄順序所建立。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將附加的記錄檔記錄寫入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>，使用先前在順序中保留的空間。 這個方法無法被繼承。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       附加的記錄將會取用先前所保留，使用所指定的保留區的空間`reservations`參數。 如果附加成功，便會取用的最小保留區域，其可保留資料，而且該保留區域將會從集合移除。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含應透過這個記錄的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>對此順序無效。       -或-<code>data</code>大於記錄大小上限，因此無法附加。       -或-<code>reservations</code>不由此記錄順序所建立。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將附加的記錄檔記錄寫入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>，使用先前在順序中保留的空間。 這個方法無法被繼承。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       附加的記錄將會取用先前所保留，使用所指定的保留區的空間`reservations`參數。 如果附加成功，便會取用的最小保留區域，其可保留資料，而且該保留區域將會從集合移除。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含應透過這個記錄的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.LogRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>對此順序無效。       -或-<code>data</code>大於記錄大小上限，因此無法附加。       -或-<code>reservations</code>不由此記錄順序所建立。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得在目前的第一個有效記錄的序號<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。"
  remarks: "有效的序號會大於或等於 BaseSequenceNumber，且小於<xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>       這個屬性的值可以藉由呼叫變更<xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>方法或<xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>方法。</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence.WriteRestartArea%2A>"
  example:
  - "This example shows how to use the BaseSequenceNumber member in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/p-system.io.log.logrecor_2_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_2_1.vb)]"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "對應中的有效記錄的最小序號<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。"
  overload: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始執行非同步的附加作業。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步的附加，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>或<code>previousRecord</code>對此順序無效。       -或-<code>data</code>大於記錄大小上限，因此無法附加。       -或-<code>reservations</code>不由此記錄順序所建立。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>或<code>previousRecord</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始執行非同步的附加作業。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步的附加，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>對此順序無效。       -或-<code>data</code>大於記錄大小上限，因此無法附加。       -或-<code>reservations</code>不由此記錄順序所建立。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始執行非同步的附加作業。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       附加的記錄將會取用先前所保留，使用所指定的保留區的空間`reservations`參數。 如果附加成功，便會取用的最小保留區域，其可保留資料，而且該保留區域將會從集合移除。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含應透過這個記錄的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步的附加，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>對此順序無效。       -或-<code>data</code>大於記錄大小上限，因此無法附加。       -或-<code>reservations</code>不由此記錄順序所建立。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始執行非同步的附加作業。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.LogRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.LogRecordSequence.EndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       附加的記錄將會取用先前所保留，使用所指定的保留區的空間`reservations`參數。 如果附加成功，便會取用的最小保留區域，其可保留資料，而且該保留區域將會從集合移除。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含應透過這個記錄的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步的附加，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>對此順序無效。       -或-<code>data</code>大於記錄大小上限，因此無法附加。       -或-<code>reservations</code>不由此記錄順序所建立。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始非同步的清除作業，使用先前在順序中保留的空間。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>目前的方法來傳回<xref:System.IO.Log.LogRecordSequence.EndFlush%2A>方法，以確保清除完成，並適當地釋放資源。</xref:System.IO.Log.LogRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> 如果在非同步清除期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.LogRecordSequence.EndFlush%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndFlush%2A>       呼叫這個方法可確保所有記錄已附加至<xref:System.IO.Log.LogRecordSequence>永久寫入。</xref:System.IO.Log.LogRecordSequence>       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 非同步清除要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致擲回例外狀況時<xref:System.IO.Log.LogRecordSequence.EndFlush%2A>方法呼叫。</xref:System.IO.Log.LogRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "必須寫入之最新記錄的序號。 如果這個<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>無效，則必須寫入所有的記錄。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，排清完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可從其他要求中辨別這個特定非同步清除要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步排清作業可能還在擱置中。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>無效，無法對此順序。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定的記錄檔並沒有任何延伸區。 必須建立一或多個延伸區，才能使用記錄順序。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始非同步的保留和附加作業。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       指定的保留區會加入至提供的保留區集合中的不可部分完成的作業與記錄附加作業。 如果附加失敗，則會不保留任何空間。       一般來說，這個方法可能會完成之前已寫入記錄。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>方法呼叫。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要建立保留項目中的保留項目集合。"
    - id: reservations
      type: System.Int64[]
      description: "要進行，以位元組為單位的保留區。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表這個非同步作業，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>userRecord</code>或<code>previousRecord</code>對此順序無效。       -或-<code>data</code>大於記錄大小上限，因此無法附加。       -或-<code>reservations</code>不由此記錄順序所建立。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始非同步的保留和附加作業。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       指定的保留區會加入至提供的保留區集合中的不可部分完成的作業與記錄附加作業。 如果附加失敗，則會不保留任何空間。       一般來說，這個方法可能會完成之前已寫入記錄。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>方法呼叫。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要建立保留項目中的保留項目集合。"
    - id: reservations
      type: System.Int64[]
      description: "要進行，以位元組為單位的保留區。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表這個非同步作業，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "附加記錄時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄，或是將此保留項目。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始執行非同步的重新啟動區域寫入作業，使用先前在順序中保留的空間。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>方法，以確定重新啟動區域寫入作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> 如果執行非同步的重新啟動區域寫入作業期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       當作業成功完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。       如果<xref:System.IO.Log.ReservationCollection>指定，則寫入重新啟動區域將會取用先前所保留，使用包含在集合中的保留區的空間。</xref:System.IO.Log.ReservationCollection> 如果此方法成功，便會取用的最小保留區，其可保留資料，而且該保留區將會從集合移除。       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>方法呼叫。</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "即將串連並附加成記錄的位元組陣列區段。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含適用於此重新啟動區域的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，重新啟動區域寫入完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步重新啟動區域寫入要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表非同步重新啟動區域寫入作業，可能還在擱置中。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>無效，無法對此順序。       -或者-指定的記錄列舉開始序號無效。       -或-<code>data</code>大於記錄大小上限，因此無法附加。       -或-<code>reservation</code>不由此記錄順序所建立。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個參數是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新的或現有封存結尾或作用中記錄的基底無效。       - <code> newBaseSeqNum </code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始執行非同步的重新啟動區域寫入作業，使用先前在順序中保留的空間。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>方法，以確定重新啟動區域寫入作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> 如果執行非同步的重新啟動區域寫入作業期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       當作業成功完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。       如果<xref:System.IO.Log.ReservationCollection>指定，則寫入重新啟動區域將會取用先前所保留，使用包含在集合中的保留區的空間。</xref:System.IO.Log.ReservationCollection> 如果此方法成功，便會取用的最小保留區，其可保留資料，而且該保留區將會從集合移除。       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>方法呼叫。</xref:System.IO.Log.LogRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含適用於此重新啟動區域的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，重新啟動區域寫入完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步重新啟動區域寫入要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表非同步重新啟動區域寫入作業，可能還在擱置中。</xref:System.IAsyncResult>"
  overload: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>無效，無法對此順序。       -或者-指定的記錄列舉開始序號無效。       -或-<code>data</code>大於記錄大小上限，因此無法附加。       -或-<code>reservationCollection</code>不由此記錄順序所建立。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個參數是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新的或現有封存結尾或作用中記錄的基底無效。       - <code> newBaseSeqNum </code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "建立新<xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>。 這個方法無法被繼承。"
  remarks: ''
  example:
  - "Reservations can be performed in two ways as shown in the following examples. You can adopt the practices in the samples for robust processing. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \n//Using the ReserveAndAppend Method  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n  \n// Using the Manual Approach  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nreservations.Add(lengthOfUndoRecord);  \ntry  \n{  \n   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  \n}  \ncatch (Exception)  \n{  \n   reservations.Remove(lengthOfUndoRecord);  \n   throw;  \n}  \n  \nrecordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  \n```"
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "新建立<xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>。"
  overload: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Dispose
  id: Dispose
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "釋放此元件所使用的資源。"
  remarks: ''
  example:
  - "This example shows how to use Dispose to release resource:  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/m-system.io.log.logrecor_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_1.vb)]  \n  \n [!code-cs[S_UELogRecordSequence#12](~/add/codesnippet/csharp/m-system.io.log.logrecor_2.cs)]\n [!code-vb[S_UELogRecordSequence#12](~/add/codesnippet/visualbasic/m-system.io.log.logrecor_2.vb)]"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.LogRecordSequence.Dispose*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "結束執行非同步的附加作業。 這個方法無法被繼承。"
  remarks: "這個方法會封鎖，直到 I/O 作業完成為止。 EndAppend 呼叫時，就會顯示在非同步寫入要求，例如磁碟失敗期間，在 I/O 要求期間發生的錯誤。       必須正好一次呼叫此方法，在每個<xref:System.IAsyncResult>傳回<xref:System.IO.Log.LogRecordSequence.BeginAppend%2A>方法。</xref:System.IO.Log.LogRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未處理的非同步 I/O 要求的參考。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.LogRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>不正確。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End &quot; name=&quot;End &quot; href=&quot;&quot;></xref>已經呼叫這項非同步作業。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "結束非同步的清除作業。 這個方法無法被繼承。"
  remarks: "這個方法會封鎖，直到 I/O 作業完成為止。 EndFlush 呼叫時，就會顯示在非同步清除要求，例如磁碟失敗期間，在 I/O 要求期間發生的錯誤。       必須正好一次呼叫此方法，在每個<xref:System.IAsyncResult>傳回<xref:System.IO.Log.LogRecordSequence.BeginFlush%2A>方法。</xref:System.IO.Log.LogRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未處理的非同步 I/O 要求的參考。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後一筆寫入之記錄序號。"
  overload: System.IO.Log.LogRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>不正確。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>已經呼叫這項非同步作業。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "結束執行非同步的保留和附加作業。 這個方法無法被繼承。"
  remarks: "這個方法會封鎖，直到 I/O 作業完成為止。 EndReserveAndAppend 呼叫時，就會顯示在非同步寫入要求，例如磁碟失敗期間，在 I/O 要求期間發生的錯誤。       必須正好一次呼叫此方法，在每個<xref:System.IAsyncResult>傳回<xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A>方法。</xref:System.IO.Log.LogRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未處理的非同步 I/O 要求的參考。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>不正確。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>已經呼叫這項非同步作業。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "結束執行非同步的重新啟動區域寫入作業。 這個方法無法被繼承。"
  remarks: "這個方法會封鎖，直到 I/O 作業完成為止。 EndWriteRestartArea 呼叫時，就會顯示在非同步寫入要求，例如磁碟失敗期間，在 I/O 要求期間發生的錯誤。       必須正好一次呼叫此方法，在每個<xref:System.IAsyncResult>傳回<xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A>方法。</xref:System.IO.Log.LogRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未處理的非同步 I/O 要求的參考。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "寫入之記錄序號。"
  overload: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>不正確。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新的或現有封存結尾或作用中記錄的基底無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>已經呼叫這項非同步作業。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "確定已寫入所有附加的記錄。 這個方法無法被繼承。"
  remarks: "呼叫這個方法可確保所有記錄已附加至<xref:System.IO.Log.LogRecordSequence>已永久寫入。</xref:System.IO.Log.LogRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後一筆寫入之記錄序號。"
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "清除資料時發生 I/O 錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "不支援這項作業。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間，以包含新的重新啟動區域。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定的記錄檔並沒有任何延伸區。 必須建立一或多個延伸區，才能使用記錄順序。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "可確保已永久寫入所有附加的記錄，且包含指定的序號的記錄。 這個方法無法被繼承。"
  remarks: "呼叫這個方法可以確保所有記錄最多內含指定的序號有已永久寫入。"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "必須寫入之最新記錄的序號。 如果這個<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>無效，則必須寫入所有的記錄。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後一筆寫入之記錄序號。"
  overload: System.IO.Log.LogRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>無效，無法對此順序。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "指定的記錄檔並沒有任何延伸區。 必須建立一或多個延伸區，才能使用記錄順序。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得序號大於最後一筆附加的記錄"
  remarks: "此屬性包含保證似乎較大序號的最後序號附加記錄。 有效的序號會大於或等於<xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A>且小於 LastSequenceNumber。</xref:System.IO.Log.LogRecordSequence.BaseSequenceNumber%2A> 其他所有序號都全都無效。"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "大於最後一筆附加的記錄序號。"
  overload: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.LogStore
  id: LogStore
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得<xref href=&quot;System.IO.Log.LogStore&quot;> </xref> ，其中包含這個記錄順序的資料。 這個方法無法被繼承。"
  remarks: ''
  example:
  - "This example shows how to use the LogStore member to add extents.  \n  \n [!code-cs[S_UELogRecordSequence#11](~/add/codesnippet/csharp/p-system.io.log.logrecor_1_1.cs)]\n [!code-vb[S_UELogRecordSequence#11](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_1_1.vb)]"
  syntax:
    content: public System.IO.Log.LogStore LogStore { get; }
    return:
      type: System.IO.Log.LogStore
      description: "<xref href=&quot;System.IO.Log.LogStore&quot;> </xref> ，其中包含這個記錄順序的資料。"
  overload: System.IO.Log.LogRecordSequence.LogStore*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得可以新增至這個記錄順序的記錄的大小上限。"
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "可以新增至這個記錄順序的記錄大小上限。"
  overload: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "序列中傳回之記錄的可列舉集合。 這個方法無法被繼承。"
  remarks: "這個方法會傳回序列中之記錄的可列舉集合。 列舉的記錄順序取決於值`logRecordEnum`參數。"
  example:
  - "This example shows how to use ReadLogRecords in a loop.  \n  \n [!code-cs[S_UELogRecordSequence#10](~/add/codesnippet/csharp/65162f37-dafe-4315-8e44-_1.cs)]\n [!code-vb[S_UELogRecordSequence#10](~/add/codesnippet/visualbasic/65162f37-dafe-4315-8e44-_1.vb)]"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "開始讀取的第一個記錄序號。"
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "有效<xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;></xref>值，指定應該讀取哪一筆記錄中的方式 （也就是，向前或向後） <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。"
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "記錄順序中的可列舉集合。"
  overload: System.IO.Log.LogRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>start</code>無效，無法對此順序。       -或-<code>logRecordEnum</code>無效。       -或者-集合中找不到指定的項目。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。       -或用來寫入記錄檔記錄正在用來讀取的緩衝區大小大於緩衝區大小。       -或者-記錄順序已損毀。       -或者-指定的記錄檔格式或版本無效。       -或者-記錄已寫入的記錄順序版本不相容。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "此作業無效，因為列舉尚未啟動。 呼叫<xref:System.Collections.IEnumerator.MoveNext*>必須設法。</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "傳回序列中的重新啟動區域的可列舉集合。 這個方法無法被繼承。"
  remarks: "重新啟動區域會列舉在反向序列數字的順序，也就是從最低序號最高的序號。 只重新啟動區域的最後一個序號之間序號和要列舉的基底序號。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "序列中的重新啟動區域的可列舉集合。"
  overload: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>start</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。       -或用來寫入記錄檔記錄正在用來讀取的緩衝區大小大於緩衝區大小。       -或者-記錄順序已損毀。       -或者-指定的記錄檔格式或版本無效。       -或者-記錄已寫入的記錄順序版本不相容。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "此作業無效，因為列舉尚未啟動。 呼叫<xref:System.Collections.IEnumerator.MoveNext*>必須設法。</xref:System.Collections.IEnumerator.MoveNext*>       -或列舉已經結束。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "自動建立單一保留區，並將記錄附加至順序。 這個方法無法被繼承。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       指定的保留區會加入至提供的保留區集合中的不可部分完成的作業與記錄附加作業。 如果附加失敗，則會不保留任何空間。       一般來說，這個方法可能會完成之前已寫入記錄。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example shows how to use this method to make reservations. Notice that this task can only be performed when using the CLFS-based <xref:System.IO.Log.LogRecordSequence> class.  \n  \n```  \nReservationCollection reservations = recordSequence.CreateReservationCollection();  \nlong[] lengthOfUndoRecords = new long[] { 1000 };  \nrecordSequence.ReserveAndAppend(recordData,  \n                                                     userSqn,  \n                                                     previousSqn,  \n                                                     RecordSequenceAppendOptions.None,  \n                                                     reservations,  \n                                                     lengthOfUndoRecords);  \nrecordSequence.Append(undoRecordData,    // If necessary …  \n                                    userSqn,  \n                                    previousSqn,  \n                                    RecordSequenceAppendOptions.ForceFlush,  \n                                    reservations);  \n```"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，其中包含要建立保留項目中的集合。"
    - id: reservations
      type: System.Int64[]
      description: "要進行，以位元組為單位的保留區。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>nextUndoRecord</code>或<code>previousRecord</code>對此順序無效。       -或-<code>data</code>大於記錄大小上限，因此無法附加。       -或-<code>reservations</code>不由此記錄順序所建立。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>nextUndoRecord</code>或<code>previousRecord</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "自動建立單一保留區，並將記錄附加至順序。 這個方法無法被繼承。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       指定的保留區會加入至提供的保留區集合中的不可部分完成的作業與記錄附加作業。 如果附加失敗，則會不保留任何空間。       一般來說，這個方法可能會完成之前已寫入記錄。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.LogRecordSequence.Flush%2A>方法。</xref:System.IO.Log.LogRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber userRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: userRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要建立保留項目中的保留項目集合。"
    - id: reservations
      type: System.Int64[]
      description: "要進行，以位元組為單位的保留區。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "附加記錄時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄，或是將此保留項目。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>userRecord</code>或<code>previousRecord</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得已保留的位元組總數。"
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "在這個記錄順序中所做的所有保留區的大小總計。"
  overload: System.IO.Log.LogRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得最接近記錄結尾之重新啟動區域的序號。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 常見的記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證確定至少一個有效區域永遠可供使用。 當需要復原時，CLFS 會讀取其重新啟動區域和所有資料從最後一個檢查點作業。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。       使用<xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>方法，您可以移除最近寫入的重新啟動區域。</xref:System.IO.Log.LogRecordSequence.SetLastRecord%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "最接近記錄結尾之重新啟動區域的序號。"
  overload: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得或設定值，指出是否將附加的記錄檔已滿時自動重試。"
  remarks: "如果這個屬性的值為`true`，和<xref:System.IO.Log.LogRecordSequence.Append%2A>呼叫失敗，因為在序列中沒有足夠的空間，記錄順序將會嘗試釋放空間，並重試附加。</xref:System.IO.Log.LogRecordSequence.Append%2A>"
  example:
  - "This example shows how to use the RetryAppend property.  \n  \n [!code-cs[S_UELogRecordSequence#3](~/add/codesnippet/csharp/p-system.io.log.logrecor_0_1.cs)]\n [!code-vb[S_UELogRecordSequence#3](~/add/codesnippet/visualbasic/p-system.io.log.logrecor_0_1.vb)]"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果附加的記錄檔已滿; 自動重試否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.Log.LogRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  id: SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "設定中的最後一筆記錄<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。"
  remarks: "指定的序號必須大於基底序號。       這個方法完成時，先前附加序號大於指定的序號的所有記錄都都無法存取。"
  syntax:
    content: public void SetLastRecord (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "中的最新的序號編號<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。       這應該是指目前記錄檔中的最新有效記錄。"
  overload: System.IO.Log.LogRecordSequence.SetLastRecord*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>無效，無法對此順序。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新的或現有封存結尾或作用中記錄的基底無效。       - <code> sequenceNumber </code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-已到達記錄檔的結尾。       -或者-指定的記錄檔格式或版本無效。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "標示需要移動順序的結尾。"
  remarks: "您可以引發事件時，記錄順序已用盡空間。 這個事件一經引發，序列 （也就是基底序號） 的結尾往前移動以釋放空間。       在任何時間，記錄順序決定其必須釋出空間，因為任何原因，可以引發事件。 例如，可能會決定 CLFS 原則引擎引發事件時，它會判斷，兩個記錄用戶端共用相同的記錄檔的結尾相距過遠。 釋出空間即可由寫入重新啟動區域，或是截斷記錄檔並使用<xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A>方法清除空間。</xref:System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber%2A> 在範例 > 一節中的程式碼範例示範第二種方法。       您也可以呼叫<xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>TailPinned 事件，以釋出空間以外的方法。</xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A> 重新啟動區域是類似於其他記錄處理系統中的檢查點。 呼叫這個方法表示應用程式會將視為完全完成，重新啟動區域之前的所有記錄，而且可供未來的記錄會附加。 與任何其他記錄相同，這個方法所寫入的記錄必須有函式記錄檔中的實際可用空間。"
  example:
  - "This example shows how to use the TailPinned event.  \n  \n```  \nrecordSequence.RetryAppend = true;  \nrecordSequence.TailPinned += new EventHandler<TailPinnedEventArgs>(HandleTailPinned);  \n  \nvoid HandleTailPinned(object sender, TailPinnedEventArgs tailPinnedEventArgs)  \n{  \n   // tailPinnedEventArgs.TargetSequenceNumber is the target   \n   // sequence number to free up space to.    \n   // However, this sequence number is not necessarily valid.  We have  \n   // to use this sequence number as a starting point for finding a  \n   // valid point within the log to advance toward. You need to  \n   // identify a record with a sequence number equal to, or greater  \n   // than TargetSequenceNumber; let's call this   \n   // realTargetSequenceNumber. Once found, move the base  \n  \n   recordSequence.AdvanceBaseSequenceNumber(realTargetSequenceNumber);  \n  \n}  \n```"
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將重新啟動區域寫入<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。 這個方法無法被繼承。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 常見的記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證確定至少一個有效區域永遠可供使用。 當需要復原時，CLFS 會讀取其重新啟動區域和所有資料從最後一個檢查點作業。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。       可以使用來讀取重新啟動區域<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       位元組陣列區段中的資料將串連至單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "即將串連並附加成記錄的陣列區段。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入重新啟動區域時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間，以包含新的重新啟動區域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將重新啟動區域寫入<xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。 這個方法無法被繼承。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 常見的記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證確定至少一個有效區域永遠可供使用。 當需要復原時，CLFS 會讀取其重新啟動區域和所有資料從最後一個檢查點作業。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。       可以使用來讀取重新啟動區域<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       位元組陣列區段中的資料將串連至單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入重新啟動區域時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間，以包含新的重新啟動區域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將重新啟動區域寫入<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>並更新基底序號。 這個方法無法被繼承。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 常見的記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證確定至少一個有效區域永遠可供使用。 當需要復原時，CLFS 會讀取其重新啟動區域和所有資料從最後一個檢查點作業。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。       可以使用來讀取重新啟動區域<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       當寫入重新啟動區域時，位元組陣列區段中的資料會串連成單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。       這個方法順利完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>方法呼叫。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入重新啟動區域時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間，以包含新的重新啟動區域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將重新啟動區域寫入<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>並更新基底序號。 這個方法無法被繼承。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 常見的記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證確定至少一個有效區域永遠可供使用。 當需要復原時，CLFS 會讀取其重新啟動區域和所有資料從最後一個檢查點作業。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。       可以使用來讀取重新啟動區域<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       當寫入重新啟動區域時，位元組陣列區段中的資料會串連成單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。       這個方法順利完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>方法呼叫。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入重新啟動區域時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間，以包含新的重新啟動區域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將重新啟動區域寫入<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>使用保留區，並更新基底序號。 這個方法無法被繼承。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 常見的記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證確定至少一個有效區域永遠可供使用。 當需要復原時，CLFS 會讀取其重新啟動區域和所有資料從最後一個檢查點作業。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。       可以使用來讀取重新啟動區域<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       當寫入重新啟動區域時，位元組陣列區段中的資料會串連成單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。       如果已指定保留區，寫入的重新啟動區域將會取用先前所保留，使用包含在集合中的保留區的空間。 如果此方法成功，便會取用的最小保留區，可以包含的資料，而且該保留區將會從集合移除。       這個方法順利完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>方法呼叫。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含適用於此重新啟動區域的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入重新啟動區域時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間，以包含新的重新啟動區域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將重新啟動區域寫入<xref href=&quot;System.IO.Log.LogRecordSequence&quot;></xref>使用保留區，並更新基底序號。 這個方法無法被繼承。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 常見的記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證確定至少一個有效區域永遠可供使用。 當需要復原時，CLFS 會讀取其重新啟動區域和所有資料從最後一個檢查點作業。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。       可以使用來讀取重新啟動區域<xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.LogRecordSequence.ReadRestartAreas%2A>       當寫入重新啟動區域時，位元組陣列區段中的資料會串連成單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。       如果已指定保留區，寫入的重新啟動區域將會取用先前所保留，使用包含在集合中的保留區的空間。 如果此方法成功，便會取用的最小保留區，可以包含的資料，而且該保留區將會從集合移除。       這個方法順利完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>方法呼叫。</xref:System.IO.Log.LogRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservationCollection);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含適用於此重新啟動區域的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.LogRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>無效，無法對此順序。       -或者-指定的記錄列舉開始序號無效。       -或-<code>data</code>大於記錄大小上限，因此無法附加。       -或-<code>reservationCollection</code>不由此記錄順序所建立。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個參數是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "新的或現有封存結尾或作用中記錄的基底無效。       - <code> newBaseSeqNum </code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。       -或者-無法執行要求，因為 I/O 裝置錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄順序遭作業系統拒絕。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.ReservationNotFoundException
  parent: System.IO.Log
  isExternal: false
  name: ReservationNotFoundException
  nameWithType: ReservationNotFoundException
  fullName: System.IO.Log.ReservationNotFoundException
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore)
- uid: System.IO.Log.LogStore
  parent: System.IO.Log
  isExternal: false
  name: LogStore
  nameWithType: LogStore
  fullName: System.IO.Log.LogStore
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.Log.LogRecordSequence.#ctor(System.IO.Log.LogStore,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(LogStore,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(LogStore,Int32,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32)
- uid: System.IO.Log.LogRecordSequence.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Int32,System.Security.AccessControl.FileSecurity)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  nameWithType: LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
  fullName: System.IO.Log.LogRecordSequence.LogRecordSequence(String,FileMode,FileAccess,FileShare,Int32,Int32,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.LogRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.LogRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: LogRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.LogRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.LogRecordSequence.Dispose
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose()
  nameWithType: LogRecordSequence.Dispose()
  fullName: System.IO.Log.LogRecordSequence.Dispose()
- uid: System.IO.Log.LogRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: LogRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: LogRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: LogRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.LogRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.LogRecordSequence.Flush
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: LogRecordSequence.Flush()
  fullName: System.IO.Log.LogRecordSequence.Flush()
- uid: System.IO.Log.LogRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: LogRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
  fullName: System.IO.Log.LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.LogRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.LogRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: LogRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.LogRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.LogRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.LogRecordSequence.ReservedBytes
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
  fullName: System.IO.Log.LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
  fullName: System.IO.Log.LogRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.LogRecordSequence.SetLastRecord(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord(SequenceNumber)
  nameWithType: LogRecordSequence.SetLastRecord(SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.SetLastRecord(SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.TailPinned
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: LogRecordSequence.TailPinned
  fullName: System.IO.Log.LogRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.LogRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.LogRecordSequence.#ctor*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogRecordSequence
  nameWithType: LogRecordSequence.LogRecordSequence
- uid: System.IO.Log.LogRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: LogRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.Append*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Append
  nameWithType: LogRecordSequence.Append
- uid: System.IO.Log.LogRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.LogRecordSequence.BeginAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: LogRecordSequence.BeginAppend
- uid: System.IO.Log.LogRecordSequence.BeginFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: LogRecordSequence.BeginFlush
- uid: System.IO.Log.LogRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: LogRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: LogRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: LogRecordSequence.CreateReservationCollection
- uid: System.IO.Log.LogRecordSequence.Dispose*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Dispose
  nameWithType: LogRecordSequence.Dispose
- uid: System.IO.Log.LogRecordSequence.EndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: LogRecordSequence.EndAppend
- uid: System.IO.Log.LogRecordSequence.EndFlush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: LogRecordSequence.EndFlush
- uid: System.IO.Log.LogRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: LogRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: LogRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.LogRecordSequence.Flush*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: Flush
  nameWithType: LogRecordSequence.Flush
- uid: System.IO.Log.LogRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogRecordSequence.LastSequenceNumber
- uid: System.IO.Log.LogRecordSequence.LogStore*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: LogStore
  nameWithType: LogRecordSequence.LogStore
- uid: System.IO.Log.LogRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: LogRecordSequence.MaximumRecordLength
- uid: System.IO.Log.LogRecordSequence.ReadLogRecords*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: LogRecordSequence.ReadLogRecords
- uid: System.IO.Log.LogRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: LogRecordSequence.ReadRestartAreas
- uid: System.IO.Log.LogRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: LogRecordSequence.ReserveAndAppend
- uid: System.IO.Log.LogRecordSequence.ReservedBytes*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: LogRecordSequence.ReservedBytes
- uid: System.IO.Log.LogRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: LogRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.LogRecordSequence.RetryAppend*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: LogRecordSequence.RetryAppend
- uid: System.IO.Log.LogRecordSequence.SetLastRecord*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: SetLastRecord
  nameWithType: LogRecordSequence.SetLastRecord
- uid: System.IO.Log.LogRecordSequence.WriteRestartArea*
  parent: System.IO.Log.LogRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: LogRecordSequence.WriteRestartArea
