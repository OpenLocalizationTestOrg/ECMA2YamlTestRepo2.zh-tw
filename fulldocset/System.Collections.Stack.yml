### YamlMime:ManagedReference
items:
- uid: System.Collections.Stack
  id: Stack
  children:
  - System.Collections.Stack.#ctor
  - System.Collections.Stack.#ctor(System.Collections.ICollection)
  - System.Collections.Stack.#ctor(System.Int32)
  - System.Collections.Stack.Clear
  - System.Collections.Stack.Clone
  - System.Collections.Stack.Contains(System.Object)
  - System.Collections.Stack.CopyTo(System.Array,System.Int32)
  - System.Collections.Stack.Count
  - System.Collections.Stack.GetEnumerator
  - System.Collections.Stack.IsSynchronized
  - System.Collections.Stack.Peek
  - System.Collections.Stack.Pop
  - System.Collections.Stack.Push(System.Object)
  - System.Collections.Stack.Synchronized(System.Collections.Stack)
  - System.Collections.Stack.SyncRoot
  - System.Collections.Stack.ToArray
  langs:
  - csharp
  name: Stack
  nameWithType: Stack
  fullName: System.Collections.Stack
  type: Class
  summary: "代表物件的簡單後進先出 (LIFO) 非泛型集合。"
  remarks: "這個集合的泛型版本，請參閱<xref:System.Collections.Generic.Stack%601?displayProperty=fullName>.</xref:System.Collections.Generic.Stack%601?displayProperty=fullName>       在堆疊的容量是堆疊可以保存的項目數目。 當項目加入至堆疊時，會自動增加容量視需要透過重新配置。       如果<xref:System.Collections.Stack.Count%2A>小於堆疊中的容量<xref:System.Collections.Stack.Push%2A>是一種 o （1） 運算。</xref:System.Collections.Stack.Push%2A> </xref:System.Collections.Stack.Count%2A> 如果需要以容納新項目中，增加的容量<xref:System.Collections.Stack.Push%2A>會變成 O (`n`) 作業，其中`n`為<xref:System.Collections.Stack.Count%2A>。</xref:System.Collections.Stack.Count%2A> </xref:System.Collections.Stack.Push%2A> <xref:System.Collections.Stack.Pop%2A>是一種 o （1） 運算。</xref:System.Collections.Stack.Pop%2A>       堆疊接受`null`有效的值，並允許重複的項目。"
  example:
  - "The following example shows how to create and add values to a Stack and how to display its values.  \n  \n [!code-cs[Classic Stack Example#1](~/add/codesnippet/csharp/t-system.collections.stack_1.cs)]\n [!code-vb[Classic Stack Example#1](~/add/codesnippet/visualbasic/t-system.collections.stack_1.vb)]\n [!code-cpp[Classic Stack Example#1](~/add/codesnippet/cpp/t-system.collections.stack_1.cpp)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Stack/StackDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Stack : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Stack.#ctor
  id: '#ctor'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack()
  nameWithType: Stack.Stack()
  fullName: System.Collections.Stack.Stack()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新執行個體<xref href=&quot;System.Collections.Stack&quot;></xref>類別為空白且具有預設初始容量。"
  remarks: "容量<xref:System.Collections.Stack>是項目數目，<xref:System.Collections.Stack>可以保存。</xref:System.Collections.Stack> </xref:System.Collections.Stack> 當項目加入至<xref:System.Collections.Stack>，就會自動增加容量的要求以重新配置內部的陣列。</xref:System.Collections.Stack>       如果可以評估集合的大小，指定初始容量，就不需要執行數個項目加入至<xref:System.Collections.Stack>。</xref:System.Collections.Stack>時調整大小作業       這個建構函式是 o （1） 運算。"
  syntax:
    content: public Stack ();
    parameters: []
  overload: System.Collections.Stack.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack(ICollection)
  nameWithType: Stack.Stack(ICollection)
  fullName: System.Collections.Stack.Stack(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新執行個體<xref href=&quot;System.Collections.Stack&quot;></xref>類別，其中包含從指定之集合複製項目，且具有相同的初始容量，以複製的項目數目。"
  remarks: "容量<xref:System.Collections.Stack>是項目數目，<xref:System.Collections.Stack>可以保存。</xref:System.Collections.Stack> </xref:System.Collections.Stack> 當項目加入至<xref:System.Collections.Stack>，就會自動增加容量的要求以重新配置內部的陣列。</xref:System.Collections.Stack>       如果可以評估集合的大小，指定初始容量，就不需要執行數個項目加入至<xref:System.Collections.Stack>。</xref:System.Collections.Stack>時調整大小作業       將元素複製到<xref:System.Collections.Stack>相同的順序讀取<xref:System.Collections.IEnumerator>的<xref:System.Collections.ICollection>。</xref:System.Collections.ICollection> </xref:System.Collections.IEnumerator> </xref:System.Collections.Stack>       這個建構函式為 O (`n`) 作業，其中`n`是中的項目數`col`。"
  syntax:
    content: public Stack (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>要複製的項目。</xref:System.Collections.ICollection>"
  overload: System.Collections.Stack.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Stack.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Stack(Int32)
  nameWithType: Stack.Stack(Int32)
  fullName: System.Collections.Stack.Stack(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新執行個體<xref href=&quot;System.Collections.Stack&quot;></xref>類別的空的而且指定的初始容量或預設的初始容量、 較長者為準。"
  remarks: "容量<xref:System.Collections.Stack>是項目數目，<xref:System.Collections.Stack>可以保存。</xref:System.Collections.Stack> </xref:System.Collections.Stack> 當項目加入至<xref:System.Collections.Stack>，就會自動增加容量的要求以重新配置內部的陣列。</xref:System.Collections.Stack>       如果可以評估集合的大小，指定初始容量，就不需要執行數個項目加入至<xref:System.Collections.Stack>。</xref:System.Collections.Stack>時調整大小作業       這個建構函式為 O (`n`) 作業，其中`n`是`initialCapacity`。"
  syntax:
    content: public Stack (int initialCapacity);
    parameters:
    - id: initialCapacity
      type: System.Int32
      description: "初始項目數， <xref href=&quot;System.Collections.Stack&quot;> </xref>可以包含。"
  overload: System.Collections.Stack.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>initialCapacity</code>小於零。"
  platform:
  - net462
- uid: System.Collections.Stack.Clear
  id: Clear
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Clear()
  nameWithType: Stack.Clear()
  fullName: System.Collections.Stack.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "移除所有的物件，從<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "<xref:System.Collections.Stack.Count%2A>已設為零，並從項目集合的其他物件的參考也會釋放。</xref:System.Collections.Stack.Count%2A>       這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Stack.Count%2A>。</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Stack>.  \n  \n [!code-cpp[Classic Stack.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.sta_5_1.cpp)]\n [!code-vb[Classic Stack.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_5_1.vb)]\n [!code-cs[Classic Stack.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.sta_5_1.cs)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Stack.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Clone
  id: Clone
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Clone()
  nameWithType: Stack.Clone()
  fullName: System.Collections.Stack.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "建立的淺層複本<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "集合的淺層複本只會複製元素的集合，不論它們是參考類型或實值類型，但是不會複製參考所參考的物件。 新的集合中的參考都指向相同原始集合中的參考所指向的物件。       相反地，項目複製集合的深層複本，並直接或間接參考之項目，所有項目。       這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Stack.Count%2A>。</xref:System.Collections.Stack.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "淺層複本<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  overload: System.Collections.Stack.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Stack.Contains(Object)
  fullName: System.Collections.Stack.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "判斷元素是否在<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "這個方法會判斷是否相等，藉由呼叫<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName>       這個方法會執行線性搜尋;因此，這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Stack.Count%2A>。</xref:System.Collections.Stack.Count%2A>       從.NET Framework 2.0 開始，這個方法會測試是否相等藉由傳遞`obj`引數<xref:System.Object.Equals%2A>集合中的個別物件的方法。</xref:System.Object.Equals%2A> 在舊版的.NET Framework 中，使用傳遞的個別項目集合中要進行這項判斷<xref:System.Object.Equals%2A>方法`obj`引數。</xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "要在中尋找的物件<xref href=&quot;System.Collections.Stack&quot;> </xref>。 這個值可以是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>, if <code>obj</code> is found in the <xref href=&quot;System.Collections.Stack&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Stack.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Stack.CopyTo(Array,Int32)
  fullName: System.Collections.Stack.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "複製<xref href=&quot;System.Collections.Stack&quot;></xref>至現有一維<xref:System.Array>、 指定的陣列索引處開始。</xref:System.Array>"
  remarks: "將元素複製到後進先出 (LIFO) 順序，類似且連續的<xref:System.Collections.Stack.Pop%2A>.</xref:System.Collections.Stack.Pop%2A>呼叫所傳回的項目順序中的陣列       這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Stack.Count%2A>。</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.  \n  \n [!code-cpp[Classic Stack.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sta_6_1.cpp)]\n [!code-vb[Classic Stack.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_6_1.vb)]\n [!code-cs[Classic Stack.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sta_6_1.cs)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "一維<xref:System.Array>也就是從複製之元素的目的地<xref href=&quot;System.Collections.Stack&quot;> </xref>。</xref:System.Array> <xref:System.Array>必須有以零為起始的索引。</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "中以零為起始的索引`array`由此開始複製。"
  overload: System.Collections.Stack.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小於零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>是多維的。       -在來源中的項目數<xref href=&quot;System.Collections.Stack&quot;></xref>大於可用空間<code>index</code>至目的地結尾<code>array</code>。"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "來源類型<xref href=&quot;System.Collections.Stack&quot;></xref>無法自動轉換成目的地類型<code> array </code>。"
  platform:
  - net462
- uid: System.Collections.Stack.Count
  id: Count
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Count
  nameWithType: Stack.Count
  fullName: System.Collections.Stack.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得所包含的元素數目<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "容量則是項目數目，<xref:System.Collections.Stack>可以儲存。</xref:System.Collections.Stack> 計數是實際<xref:System.Collections.Stack>.</xref:System.Collections.Stack>中的項目數目       容量永遠是大於或等於 Count。 如果計數超過容量加入項目時，容量會自動增加之前複製的舊項目並加入新項目後，重新配置內部的陣列。       擷取這個屬性的值是一種 o （1） 運算。"
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "中包含的元素數目<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  overload: System.Collections.Stack.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Stack
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Stack.GetEnumerator()
  fullName: System.Collections.Stack.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "傳回<xref:System.Collections.IEnumerator>如<xref href=&quot;System.Collections.Stack&quot;> </xref>。</xref:System.Collections.IEnumerator>"
  remarks: "[Visual Basic、 C#]      `foreach` C# 語言的陳述式 (`for each`在 Visual Basic 中) 會隱藏列舉值的複雜度。  因此，使用`foreach`建議，而不是直接管理 列舉值。       列舉程式可以用來讀取集合中的資料，但無法用於修改基礎集合。       一開始，列舉程式位在集合中的第一個項目之前。 <xref:System.Collections.IEnumerator.Reset%2A>也會列舉值帶回至這個位置。</xref:System.Collections.IEnumerator.Reset%2A>  此位置<xref:System.Collections.IEnumerator.Current%2A>是未定義。</xref:System.Collections.IEnumerator.Current%2A> 因此，您必須呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>前進的第一個元素之前讀取<xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A>值集合的列舉值</xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>會傳回相同的物件直到<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>稱為。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>設定<xref:System.Collections.IEnumerator.Current%2A>下一個項目。</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       如果<xref:System.Collections.IEnumerator.MoveNext%2A>超過集合的列舉值的結尾會位於集合中的最後一個元素之後和<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 列舉值位於這個位置上，後續呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>也會傳回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> 如果最後一個呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`，<xref:System.Collections.IEnumerator.Current%2A>是未定義。</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 若要設定<xref:System.Collections.IEnumerator.Current%2A>的第一個元素的集合，您可以呼叫<xref:System.Collections.IEnumerator.Reset%2A>後面加上<xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       只要集合維持不變，列舉程式就持續有效。 如果對集合進行變更，例如加入、 修改或刪除元素，列舉程式會永久失效，且其行為未定義。       列舉程式沒有集合的獨佔存取因此，列舉集合在本質上並非安全執行緒程序。  若要保證列舉過程的執行緒安全，您可以鎖定在整個列舉過程的集合。  若要讓集合以便進行讀取和寫入的多重執行緒能夠存取，您必須實作自己的同步處理。       這個方法是一種 o （1） 運算。"
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Stack&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Stack.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Stack
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
  fullName: System.Collections.Stack.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得值，指出是否存取<xref href=&quot;System.Collections.Stack&quot;></xref>是同步 （安全執行緒）。"
  remarks: "若要保證的執行緒安全<xref:System.Collections.Stack>，所有作業都必須都透過包裝函式所傳回<xref:System.Collections.Stack.Synchronized%2A>方法。</xref:System.Collections.Stack.Synchronized%2A> </xref:System.Collections.Stack>       透過集合進行列舉在本質上並不是安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。       下列程式碼範例示範如何鎖定集合使用<xref:System.Collections.Stack.SyncRoot%2A>在整個列舉過程。</xref:System.Collections.Stack.SyncRoot%2A>       [!code-cpp[傳統 Stack.IsSynchronized 範例&#2;](~/add/codesnippet/cpp/p-system.collections.sta_0_1.cpp)][!code-cs[傳統 Stack.IsSynchronized 範例&#2;](~/add/codesnippet/csharp/p-system.collections.sta_0_1.cs)][!code-vb[傳統 Stack.IsSynchronized 範例&#2;](~/add/codesnippet/visualbasic/p-system.collections.sta_0_1.vb) ]擷取這個屬性的值是一種 o （1） 運算。    "
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.sta_0_2.vb)]\n [!code-cpp[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.sta_0_2.cpp)]\n [!code-cs[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.sta_0_2.cs)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果存取<xref href=&quot;System.Collections.Stack&quot;></xref>是同步 （安全執行緒），否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Stack.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Peek
  id: Peek
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Peek()
  nameWithType: Stack.Peek()
  fullName: System.Collections.Stack.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "傳回的物件，在頂端<xref href=&quot;System.Collections.Stack&quot;></xref>而不移除它。"
  remarks: "這個方法是類似的<xref:System.Collections.Stack.Pop%2A>方法，但查看不會修改<xref:System.Collections.Stack>.</xref:System.Collections.Stack> </xref:System.Collections.Stack.Pop%2A>       `null`可推入至<xref:System.Collections.Stack>做為預留位置，視。</xref:System.Collections.Stack> 若要在區別 null 值和堆疊的結尾，請檢查<xref:System.Collections.Stack.Count%2A>屬性或 catch <xref:System.InvalidOperationException>，它就會擲回時<xref:System.Collections.Stack>是空的。</xref:System.Collections.Stack> </xref:System.InvalidOperationException> </xref:System.Collections.Stack.Count%2A>       這個方法是一種 o （1） 運算。"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_4_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_4_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_4_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "<xref:System.Object>頂端<xref href=&quot;System.Collections.Stack&quot;> </xref>。</xref:System.Object>"
  overload: System.Collections.Stack.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Stack&quot;> </xref>是空的。"
  platform:
  - net462
- uid: System.Collections.Stack.Pop
  id: Pop
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Pop()
  nameWithType: Stack.Pop()
  fullName: System.Collections.Stack.Pop()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "移除並傳回頂端的物件<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "這個方法是類似的<xref:System.Collections.Stack.Peek%2A>方法，但<xref:System.Collections.Stack.Peek%2A>不是會修改<xref:System.Collections.Stack>.</xref:System.Collections.Stack> </xref:System.Collections.Stack.Peek%2A> </xref:System.Collections.Stack.Peek%2A>       `null`可推入至<xref:System.Collections.Stack>做為預留位置，視。</xref:System.Collections.Stack> 若要在區別 null 值和堆疊的結尾，請檢查<xref:System.Collections.Stack.Count%2A>屬性或 catch <xref:System.InvalidOperationException>，它就會擲回時<xref:System.Collections.Stack>是空的。</xref:System.Collections.Stack> </xref:System.InvalidOperationException> </xref:System.Collections.Stack.Count%2A>       這個方法是一種 o （1） 運算。"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_2_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_2_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_2_1.cpp)]"
  syntax:
    content: public virtual object Pop ();
    parameters: []
    return:
      type: System.Object
      description: "<xref:System.Object>從頂端移除<xref href=&quot;System.Collections.Stack&quot;> </xref>。</xref:System.Object>"
  overload: System.Collections.Stack.Pop*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Stack&quot;> </xref>是空的。"
  platform:
  - net462
- uid: System.Collections.Stack.Push(System.Object)
  id: Push(System.Object)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Push(Object)
  nameWithType: Stack.Push(Object)
  fullName: System.Collections.Stack.Push(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "將物件插入頂端<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "如果<xref:System.Collections.Stack.Count%2A>已等於容量，容量<xref:System.Collections.Stack>增加的自動重新配置內部的陣列，並加入新項目之前現有的項目複製到新陣列。</xref:System.Collections.Stack> </xref:System.Collections.Stack.Count%2A>       `null`可推入至<xref:System.Collections.Stack>做為預留位置，視。</xref:System.Collections.Stack> 它會佔據堆疊中的位置，並會被視為任何物件。       如果<xref:System.Collections.Stack.Count%2A>小於比堆疊的容量，推入是 o （1） 運算。</xref:System.Collections.Stack.Count%2A> 如果需要增加，以容納新項目容量，推入就會變成 O (`n`) 作業，其中`n`為<xref:System.Collections.Stack.Count%2A>。</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Stack>, remove elements from the <xref:System.Collections.Stack>, or view the element at the top of the <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.Peek Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_1_1.vb)]\n [!code-cs[Classic Stack.Peek Example#1](~/add/codesnippet/csharp/m-system.collections.sta_1_1.cs)]\n [!code-cpp[Classic Stack.Peek Example#1](~/add/codesnippet/cpp/m-system.collections.sta_1_1.cpp)]"
  syntax:
    content: public virtual void Push (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "<xref:System.Object>要推送至<xref href=&quot;System.Collections.Stack&quot;> </xref>。</xref:System.Object> 這個值可以是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Stack.Push*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.Synchronized(System.Collections.Stack)
  id: Synchronized(System.Collections.Stack)
  parent: System.Collections.Stack
  langs:
  - csharp
  name: Synchronized(Stack)
  nameWithType: Stack.Synchronized(Stack)
  fullName: System.Collections.Stack.Synchronized(Stack)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "傳回同步 （安全執行緒） 包裝函式<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "若要保證的執行緒安全<xref:System.Collections.Stack>，所有作業必須透過這個包裝函式來都完成。</xref:System.Collections.Stack>       透過集合進行列舉在本質上並不是安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。       下列程式碼範例示範如何鎖定集合使用<xref:System.Collections.Stack.SyncRoot%2A>在整個列舉過程。</xref:System.Collections.Stack.SyncRoot%2A>       [!code-cpp[傳統 Stack.IsSynchronized 範例&#2;](~/add/codesnippet/cpp/m-system.collections.sta_3_1.cpp)][!code-cs[傳統 Stack.IsSynchronized 範例&#2;](~/add/codesnippet/csharp/m-system.collections.sta_3_1.cs)][!code-vb[傳統 Stack.IsSynchronized 範例&#2;](~/add/codesnippet/visualbasic/m-system.collections.sta_3_1.vb) ]這個方法是 o （1） 運算。    "
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Stack>, determine if a <xref:System.Collections.Stack> is synchronized, and use a synchronized <xref:System.Collections.Stack>.  \n  \n [!code-vb[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_3_2.vb)]\n [!code-cpp[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.sta_3_2.cpp)]\n [!code-cs[Classic Stack.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.sta_3_2.cs)]"
  syntax:
    content: public static System.Collections.Stack Synchronized (System.Collections.Stack stack);
    parameters:
    - id: stack
      type: System.Collections.Stack
      description: "<xref href=&quot;System.Collections.Stack&quot;> </xref>來同步處理。"
    return:
      type: System.Collections.Stack
      description: "已同步處理的包裝函式周圍<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  overload: System.Collections.Stack.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>stack</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Stack.SyncRoot
  id: SyncRoot
  parent: System.Collections.Stack
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Stack.SyncRoot
  fullName: System.Collections.Stack.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得物件，可用來同步處理存取具備<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  remarks: "若要建立的同步化的版本<xref:System.Collections.Stack>，使用<xref:System.Collections.Stack.Synchronized%2A>方法。</xref:System.Collections.Stack.Synchronized%2A> </xref:System.Collections.Stack> 不過，在衍生的類別可以提供自己的同步處理的版本<xref:System.Collections.Stack>使用 SyncRoot 屬性。</xref:System.Collections.Stack> 同步處理的程式碼必須在上執行作業的 SyncRoot <xref:System.Collections.Stack>，不是直接在<xref:System.Collections.Stack>.</xref:System.Collections.Stack> </xref:System.Collections.Stack> 這可確保衍生自其他物件的集合正常運作。 具體而言，保持正常的同步處理與其他可能同時修改的執行緒<xref:System.Collections.Stack>物件。</xref:System.Collections.Stack>       透過集合進行列舉在本質上並不是安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。       下列程式碼範例示範如何中鎖定集合，在整個列舉過程中使用 syncroot 同步。       [!code-cpp[傳統 Stack.IsSynchronized 範例&#2;](~/add/codesnippet/cpp/p-system.collections.sta_1_1.cpp)][!code-cs[傳統 Stack.IsSynchronized 範例&#2;](~/add/codesnippet/csharp/p-system.collections.sta_1_1.cs)][!code-vb[傳統 Stack.IsSynchronized 範例&#2;](~/add/codesnippet/visualbasic/p-system.collections.sta_1_1.vb) ]擷取這個屬性的值是一種 o （1） 運算。    "
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "<xref:System.Object>可用以同步存取<xref href=&quot;System.Collections.Stack&quot;> </xref>。</xref:System.Object>"
  overload: System.Collections.Stack.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Stack.ToArray
  id: ToArray
  parent: System.Collections.Stack
  langs:
  - csharp
  name: ToArray()
  nameWithType: Stack.ToArray()
  fullName: System.Collections.Stack.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "複製<xref href=&quot;System.Collections.Stack&quot;></xref>到新的陣列。"
  remarks: "將元素複製到後進先出 (LIFO) 順序，類似且連續的<xref:System.Collections.Stack.Pop%2A>.</xref:System.Collections.Stack.Pop%2A>呼叫所傳回的項目順序中的陣列       這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Stack.Count%2A>。</xref:System.Collections.Stack.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Stack> into a one-dimensional array.  \n  \n [!code-cpp[Classic Stack.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.sta_0_1.cpp)]\n [!code-vb[Classic Stack.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.sta_0_1.vb)]\n [!code-cs[Classic Stack.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.sta_0_1.cs)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "新陣列，包含的項目複本<xref href=&quot;System.Collections.Stack&quot;> </xref>。"
  overload: System.Collections.Stack.ToArray*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Collections.Stack.#ctor
  parent: System.Collections.Stack
  isExternal: false
  name: Stack()
  nameWithType: Stack.Stack()
  fullName: System.Collections.Stack.Stack()
- uid: System.Collections.Stack.#ctor(System.Collections.ICollection)
  parent: System.Collections.Stack
  isExternal: false
  name: Stack(ICollection)
  nameWithType: Stack.Stack(ICollection)
  fullName: System.Collections.Stack.Stack(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Stack.#ctor(System.Int32)
  parent: System.Collections.Stack
  isExternal: false
  name: Stack(Int32)
  nameWithType: Stack.Stack(Int32)
  fullName: System.Collections.Stack.Stack(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Stack.Clear
  parent: System.Collections.Stack
  isExternal: false
  name: Clear()
  nameWithType: Stack.Clear()
  fullName: System.Collections.Stack.Clear()
- uid: System.Collections.Stack.Clone
  parent: System.Collections.Stack
  isExternal: false
  name: Clone()
  nameWithType: Stack.Clone()
  fullName: System.Collections.Stack.Clone()
- uid: System.Collections.Stack.Contains(System.Object)
  parent: System.Collections.Stack
  isExternal: false
  name: Contains(Object)
  nameWithType: Stack.Contains(Object)
  fullName: System.Collections.Stack.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Stack.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Stack
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Stack.CopyTo(Array,Int32)
  fullName: System.Collections.Stack.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Stack.Count
  parent: System.Collections.Stack
  isExternal: false
  name: Count
  nameWithType: Stack.Count
  fullName: System.Collections.Stack.Count
- uid: System.Collections.Stack.GetEnumerator
  parent: System.Collections.Stack
  isExternal: false
  name: GetEnumerator()
  nameWithType: Stack.GetEnumerator()
  fullName: System.Collections.Stack.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Stack.IsSynchronized
  parent: System.Collections.Stack
  isExternal: false
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
  fullName: System.Collections.Stack.IsSynchronized
- uid: System.Collections.Stack.Peek
  parent: System.Collections.Stack
  isExternal: false
  name: Peek()
  nameWithType: Stack.Peek()
  fullName: System.Collections.Stack.Peek()
- uid: System.Collections.Stack.Pop
  parent: System.Collections.Stack
  isExternal: false
  name: Pop()
  nameWithType: Stack.Pop()
  fullName: System.Collections.Stack.Pop()
- uid: System.Collections.Stack.Push(System.Object)
  parent: System.Collections.Stack
  isExternal: false
  name: Push(Object)
  nameWithType: Stack.Push(Object)
  fullName: System.Collections.Stack.Push(Object)
- uid: System.Collections.Stack.Synchronized(System.Collections.Stack)
  parent: System.Collections.Stack
  isExternal: false
  name: Synchronized(Stack)
  nameWithType: Stack.Synchronized(Stack)
  fullName: System.Collections.Stack.Synchronized(Stack)
- uid: System.Collections.Stack
  parent: System.Collections
  isExternal: false
  name: Stack
  nameWithType: Stack
  fullName: System.Collections.Stack
- uid: System.Collections.Stack.SyncRoot
  parent: System.Collections.Stack
  isExternal: false
  name: SyncRoot
  nameWithType: Stack.SyncRoot
  fullName: System.Collections.Stack.SyncRoot
- uid: System.Collections.Stack.ToArray
  parent: System.Collections.Stack
  isExternal: false
  name: ToArray()
  nameWithType: Stack.ToArray()
  fullName: System.Collections.Stack.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Stack.#ctor*
  parent: System.Collections.Stack
  isExternal: false
  name: Stack
  nameWithType: Stack.Stack
- uid: System.Collections.Stack.Clear*
  parent: System.Collections.Stack
  isExternal: false
  name: Clear
  nameWithType: Stack.Clear
- uid: System.Collections.Stack.Clone*
  parent: System.Collections.Stack
  isExternal: false
  name: Clone
  nameWithType: Stack.Clone
- uid: System.Collections.Stack.Contains*
  parent: System.Collections.Stack
  isExternal: false
  name: Contains
  nameWithType: Stack.Contains
- uid: System.Collections.Stack.CopyTo*
  parent: System.Collections.Stack
  isExternal: false
  name: CopyTo
  nameWithType: Stack.CopyTo
- uid: System.Collections.Stack.Count*
  parent: System.Collections.Stack
  isExternal: false
  name: Count
  nameWithType: Stack.Count
- uid: System.Collections.Stack.GetEnumerator*
  parent: System.Collections.Stack
  isExternal: false
  name: GetEnumerator
  nameWithType: Stack.GetEnumerator
- uid: System.Collections.Stack.IsSynchronized*
  parent: System.Collections.Stack
  isExternal: false
  name: IsSynchronized
  nameWithType: Stack.IsSynchronized
- uid: System.Collections.Stack.Peek*
  parent: System.Collections.Stack
  isExternal: false
  name: Peek
  nameWithType: Stack.Peek
- uid: System.Collections.Stack.Pop*
  parent: System.Collections.Stack
  isExternal: false
  name: Pop
  nameWithType: Stack.Pop
- uid: System.Collections.Stack.Push*
  parent: System.Collections.Stack
  isExternal: false
  name: Push
  nameWithType: Stack.Push
- uid: System.Collections.Stack.Synchronized*
  parent: System.Collections.Stack
  isExternal: false
  name: Synchronized
  nameWithType: Stack.Synchronized
- uid: System.Collections.Stack.SyncRoot*
  parent: System.Collections.Stack
  isExternal: false
  name: SyncRoot
  nameWithType: Stack.SyncRoot
- uid: System.Collections.Stack.ToArray*
  parent: System.Collections.Stack
  isExternal: false
  name: ToArray
  nameWithType: Stack.ToArray
