### YamlMime:ManagedReference
items:
- uid: System.IO.Log.IRecordSequence
  id: IRecordSequence
  children:
  - System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.BaseSequenceNumber
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.IRecordSequence.CreateReservationCollection
  - System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.IRecordSequence.Flush
  - System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.LastSequenceNumber
  - System.IO.Log.IRecordSequence.MaximumRecordLength
  - System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.IRecordSequence.ReadRestartAreas
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.IRecordSequence.ReservedBytes
  - System.IO.Log.IRecordSequence.RestartSequenceNumber
  - System.IO.Log.IRecordSequence.RetryAppend
  - System.IO.Log.IRecordSequence.TailPinned
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: IRecordSequence
  nameWithType: IRecordSequence
  fullName: System.IO.Log.IRecordSequence
  type: Interface
  summary: "提供泛型介面來記錄的序列。"
  remarks: "IRecordSequence 介面會提供記錄導向資料流的抽象介面。 IRecordSequence 執行個體可用來讀取和寫入記錄檔記錄。       IRecordSequence 介面提供下列功能，-附加記錄檔會記錄使用<xref:System.IO.Log.IRecordSequence.Append%2A>方法。</xref:System.IO.Log.IRecordSequence.Append%2A>      -讀取附加的記錄使用<xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadLogRecords%2A>      -撰寫特殊的重新啟動記錄使用<xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>方法。</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>      讀取重新啟動記錄從最近寫入重新啟動記錄使用<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>      -將記錄清除至永久性存放區使用<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A>      -保留空間以便附加記錄。      -記錄檔的基底往前移可用記錄檔空間。      接收<xref:System.IO.Log.IRecordSequence.TailPinned>事件通知以移動記錄檔可用空間的基底。</xref:System.IO.Log.IRecordSequence.TailPinned>       記錄檔記錄會附加至 IRecordSequence 執行個體，並指定每一筆記錄的唯一序號。 序號會嚴格單純增加內指定的記錄順序。 記錄檔記錄組成 IRecordSequence 執行個體中所提供的不透明資料<xref:System.Collections.IList>給位元組 arraysegments 之。</xref:System.Collections.IList>       IRecordSequence 介面也會公開一些基本的屬性會提供記錄界限相關的資訊。      -<xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>屬性包含在記錄順序中的第一個有效記錄的序號。</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      -<xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>屬性包含保證似乎較大序號的最後序號附加記錄。</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>      -<xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>屬性包含最後一個寫入重新啟動區域的序號。</xref:System.IO.Log.IRecordSequence.RestartSequenceNumber%2A>      -<xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>屬性包含可以附加，或從順序讀取最大記錄大小。</xref:System.IO.Log.IRecordSequence.MaximumRecordLength%2A>      -<xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>屬性包含在這個記錄順序中所做的所有保留區的大小總計。</xref:System.IO.Log.IRecordSequence.ReservedBytes%2A>      -如果<xref:System.IO.Log.IRecordSequence.RetryAppend%2A>屬性設定為`true`，和<xref:System.IO.Log.IRecordSequence.Append%2A>作業失敗，因為在序列中沒有空間，記錄順序會嘗試釋放空間，然後重試附加作業。</xref:System.IO.Log.IRecordSequence.Append%2A> </xref:System.IO.Log.IRecordSequence.RetryAppend%2A>"
  syntax:
    content: 'public interface IRecordSequence : IDisposable'
  implements:
  - System.IDisposable
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "向前移的記錄檔的基底序號。"
  remarks: "當您使用<xref:System.IO.Log.LogRecordSequence>新基底序號執行個體，嘗試將序號往前移以釋放記錄中的空間，必須位於不同的記錄範圍的上一個延伸區標示為空白。</xref:System.IO.Log.LogRecordSequence> 不支援部分釋放延伸區。"
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新基底序號的記錄順序。"
  overload: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>不正確。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSequenceNumber</code>不在作用中記錄檔中。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "修改序列時發生 I/O 錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，將記錄檔記錄寫入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "附加記錄時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，將附加的記錄檔記錄寫入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "附加記錄時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，將附加的記錄檔記錄寫入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>，使用先前在順序中保留的空間。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       附加的記錄將會取用先前所保留，使用所指定的保留區的空間`reservations`參數。 如果附加成功，便會取用的最小保留區域，其可保留資料，而且該保留區域將會從集合移除。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含應透過這個記錄的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "附加記錄時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，將附加的記錄檔記錄寫入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>，使用先前在順序中保留的空間。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       附加的記錄將會取用先前所保留，使用所指定的保留區的空間`reservations`參數。 如果附加成功，便會取用的最小保留區域，其可保留資料，而且該保留區域將會從集合移除。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含應透過這個記錄的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.IRecordSequence.Append*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "附加記錄時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，則取得第一個有效記錄的序號在目前<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>。"
  remarks: "有效的序號會大於或等於 BaseSequenceNumber，且小於<xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.IRecordSequence.LastSequenceNumber%2A>       可以變更這個屬性的值，藉由呼叫<xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>或<xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A>方法。</xref:System.IO.Log.IRecordSequence.WriteRestartArea%2A> </xref:System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "對應中的有效記錄的最小序號<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>。"
  overload: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，開始執行非同步的附加作業。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步的附加，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "附加記錄時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，開始執行非同步的附加作業，使用先前在順序中保留的空間。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步的附加，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "附加記錄時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，開始執行非同步的附加作業使用先前在順序中保留的空間。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       附加的記錄將會取用先前所保留，使用所指定的保留區的空間`reservations`參數。 如果附加成功，便會取用的最小保留區域，其可保留資料，而且該保留區域將會從集合移除。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含應透過這個記錄的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步的附加，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "附加記錄時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，開始執行非同步的附加作業，使用先前在順序中保留的空間。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.IRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.IRecordSequence.EndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       附加的記錄將會取用先前所保留，使用所指定的保留區的空間`reservations`參數。 如果附加成功，便會取用的最小保留區域，其可保留資料，而且該保留區域將會從集合移除。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousUndoRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含應透過這個記錄的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步的附加，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "附加記錄時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，開始非同步的清除作業，使用先前在順序中保留的空間。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>目前的方法來傳回<xref:System.IO.Log.IRecordSequence.EndFlush%2A>方法，以確保清除完成，並適當地釋放資源。</xref:System.IO.Log.IRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> 如果在非同步清除期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.IRecordSequence.EndFlush%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndFlush%2A>       呼叫這個方法可確保所有記錄已附加至<xref:System.IO.Log.IRecordSequence>永久寫入。</xref:System.IO.Log.IRecordSequence>       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 非同步清除要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致擲回例外狀況時<xref:System.IO.Log.IRecordSequence.EndFlush%2A>方法呼叫。</xref:System.IO.Log.IRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "必須寫入之最新記錄的序號。 如果這個<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>無效，則必須寫入所有的記錄。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，排清完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可從其他要求中辨別這個特定非同步清除要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步排清作業可能還在擱置中。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "清除資料時發生 I/O 錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在覆寫時在衍生的類別中，開始非同步的保留和附加作業。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       指定的保留區會加入至提供的保留區集合中的不可部分完成的作業與記錄附加作業。 如果附加失敗，則會不保留任何空間。       一般來說，這個方法可能會完成之前已寫入記錄。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>方法呼叫。</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要建立保留項目中的保留項目集合。"
    - id: reservations
      type: System.Int64[]
      description: "要進行，以位元組為單位的保留區。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表這個非同步作業，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "附加記錄時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄，或是將此保留項目。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在覆寫時在衍生的類別中，開始非同步的保留和附加作業。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       指定的保留區會加入至提供的保留區集合中的不可部分完成的作業與記錄附加作業。 如果附加失敗，則會不保留任何空間。       一般來說，這個方法可能會完成之前已寫入記錄。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>方法呼叫。</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要建立保留項目中的保留項目集合。"
    - id: reservations
      type: System.Int64[]
      description: "要進行，以位元組為單位的保留區。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表這個非同步作業，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "附加記錄時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄，或是將此保留項目。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，開始執行非同步的重新啟動區域寫入作業，使用先前在順序中保留的空間。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>方法，以確定重新啟動區域寫入作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> 如果執行非同步的重新啟動區域寫入作業期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       當作業成功完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。       如果<xref:System.IO.Log.ReservationCollection>指定，則寫入重新啟動區域將會取用先前所保留，使用包含在集合中的保留區的空間。</xref:System.IO.Log.ReservationCollection> 如果此方法成功，便會取用的最小保留區，其可保留資料，而且該保留區將會從集合移除。       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>方法呼叫。</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含適用於此重新啟動區域的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，重新啟動區域寫入完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步重新啟動區域寫入要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表非同步重新啟動區域寫入作業，可能還在擱置中。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，開始執行非同步的重新啟動區域寫入作業，使用先前在順序中保留的空間。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>方法，以確定重新啟動區域寫入作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> 如果執行非同步的重新啟動區域寫入作業期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       當作業成功完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。       如果<xref:System.IO.Log.ReservationCollection>指定，則寫入重新啟動區域將會取用先前所保留，使用包含在集合中的保留區的空間。</xref:System.IO.Log.ReservationCollection> 如果此方法成功，便會取用的最小保留區，其可保留資料，而且該保留區將會從集合移除。       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>方法呼叫。</xref:System.IO.Log.IRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含適用於此重新啟動區域的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，重新啟動區域寫入完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步重新啟動區域寫入要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表非同步重新啟動區域寫入作業，可能還在擱置中。</xref:System.IAsyncResult>"
  overload: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入重新啟動區域時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "當在衍生類別中覆寫時，會建立新<xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>。"
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "新建立<xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>。"
  overload: System.IO.Log.IRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，結束執行非同步的附加作業。"
  remarks: "這個方法會封鎖，直到 I/O 作業完成為止。 EndAppend 呼叫時，就會顯示在非同步寫入要求，例如磁碟失敗期間，在 I/O 要求期間發生的錯誤。       必須正好一次呼叫此方法，在每個<xref:System.IAsyncResult>傳回<xref:System.IO.Log.IRecordSequence.BeginAppend%2A>方法。</xref:System.IO.Log.IRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未處理的非同步 I/O 要求的參考。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.IRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，結束非同步的清除作業。"
  remarks: "這個方法會封鎖，直到 I/O 作業完成為止。 EndFlush 呼叫時，就會顯示在非同步清除要求，例如磁碟失敗期間，在 I/O 要求期間發生的錯誤。       必須正好一次呼叫此方法，在每個<xref:System.IAsyncResult>傳回<xref:System.IO.Log.IRecordSequence.BeginFlush%2A>方法。</xref:System.IO.Log.IRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未處理的非同步 I/O 要求的參考。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後一筆寫入之記錄序號。"
  overload: System.IO.Log.IRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，結束執行非同步的保留和附加作業。"
  remarks: "這個方法會封鎖，直到 I/O 作業完成為止。 EndReserveAndAppend 呼叫時，就會顯示在非同步寫入要求，例如磁碟失敗期間，在 I/O 要求期間發生的錯誤。       必須正好一次呼叫此方法，在每個<xref:System.IAsyncResult>傳回<xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A>方法。</xref:System.IO.Log.IRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未處理的非同步 I/O 要求的參考。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，結束執行非同步的重新啟動區域寫入作業。"
  remarks: "這個方法會封鎖，直到 I/O 作業完成為止。 EndWriteRestartArea 呼叫時，就會顯示在非同步寫入要求，例如磁碟失敗期間，在 I/O 要求期間發生的錯誤。       必須正好一次呼叫此方法，在每個<xref:System.IAsyncResult>傳回<xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A>方法。</xref:System.IO.Log.IRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未處理的非同步 I/O 要求的參考。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "寫入之記錄序號。"
  overload: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，可確保已寫入所有附加的記錄。"
  remarks: "呼叫這個方法可確保所有記錄已附加至<xref:System.IO.Log.IRecordSequence>已永久寫入。</xref:System.IO.Log.IRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後一筆寫入之記錄序號。"
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "清除資料時發生 I/O 錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，可確保已永久寫入所有附加的記錄，且包含指定的序號的記錄。"
  remarks: "呼叫這個方法可以確保所有記錄最多內含指定的序號有已永久寫入。"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "必須寫入之最新記錄的序號。 如果這個<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>無效，則必須寫入所有的記錄。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後一筆寫入之記錄序號。"
  overload: System.IO.Log.IRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "清除資料時發生 I/O 錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "當在衍生類別中覆寫時，取得序號大於最後一筆附加的記錄。"
  remarks: "此屬性包含保證似乎較大序號的最後序號附加記錄。 有效的序號會大於或等於<xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>且小於 LastSequenceNumber。</xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>      > [!NOTE] > 時使用的<xref:System.IO.Log.LogRecordSequence>執行個體的<xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A>值可能會變成過期之前記錄清除至記錄檔。</xref:System.IO.Log.LogRecordSequence.LastSequenceNumber%2A> </xref:System.IO.Log.LogRecordSequence> 請參閱<xref:System.IO.Log.IRecordSequence.Flush%2A>，<xref:System.IO.Log.RecordAppendOptions>如需有關清除記錄...</xref:System.IO.Log.RecordAppendOptions> </xref:System.IO.Log.IRecordSequence.Flush%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "大於最後一筆附加的記錄序號。"
  overload: System.IO.Log.IRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "當在衍生類別中覆寫時，取得最大記錄可以附加或讀取此順序，以位元組為單位的大小。"
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "附加或讀取此順序，以位元組為單位的最大記錄大小。"
  overload: System.IO.Log.IRecordSequence.MaximumRecordLength*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "當在衍生類別中覆寫時，會傳回序列中之記錄的可列舉集合。"
  remarks: "當在衍生類別中覆寫時，會傳回序列中之記錄的可列舉集合。 列舉的記錄順序取決於值`logRecordEnum`參數。"
  example:
  - "This sample demonstrates the use of the ReadLogRecords method.  \n  \n```c#  \nusing System;  \n using System.IO;  \n using System.IO.Log;  \n  \n class ReadRecordsSample  \n {  \n     static SequenceNumber AppendRecord(IRecordSequence sequence,  \n                                        string message,  \n                                        SequenceNumber user,  \n                                        SequenceNumber previous)  \n     {  \n         MemoryStream data = new MemoryStream();  \n         BinaryWriter writer = new BinaryWriter(data);  \n         writer.Write(message);  \n  \n         ArraySegment<byte>[] segments;  \n         segments = new ArraySegment<byte>[1];  \n         segments[0] = new ArraySegment(data.GetBuffer(),  \n                                        0,  \n                                        Data.Length);  \n  \n         return sequence.Append(segments,  \n                                user,  \n                                previous,  \n                                WriteFlags.None);  \n     }  \n  \n     public static void Main(string[] args)  \n     {  \n         IRecordSequence sequence;  \n         sequence = new FileIRecordSequence(args[0]);  \n  \n         SequenceNumber a, b, c, d;  \n  \n         a = AppendRecord(sequence,  \n                          \"This is record A\",  \n                          SequenceNumber.Invalid,  \n                          SequenceNumber.Invalid);  \n         Console.WriteLine(\"Record A has sequence number System.IO.Log\", a);  \n  \n         b = AppendRecord(sequence,  \n                          \"This is record B\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record B has sequence number System.IO.Log\", b);  \n  \n         c = AppendRecord(sequence,  \n                          \"This is record C\",  \n                          a,  \n                          a);  \n         Console.WriteLine(\"Record C has sequence number System.IO.Log\", c);  \n  \n         d = AppendRecord(sequence,  \n                          \"This is record D\",  \n                          b,  \n                          c);  \n         Console.WriteLine(\"Record D has sequence number System.IO.Log\", d);  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(a, ReadDirection.Forward))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.User))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n  \n         foreach(LogRecord record in  \n                 sequence.ReadLogRecords(d, ReadDirection.Previous))  \n         {  \n             BinaryReader reader = new BinaryReader(record.Data);  \n             Console.WriteLine(\"System.IO.Log: T:System.IO.Log.IRecordSequence\",  \n                               record.SequenceNumber,  \n                               reader.ReadString());  \n         }  \n     }  \n       }  \n```"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "開始讀取的第一個記錄序號。"
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "有效<xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;></xref>值，指定應該讀取哪一筆記錄中的方式 （也就是，向前或向後） <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。"
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "記錄順序中的可列舉集合。"
  overload: System.IO.Log.IRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "讀取記錄時發生 I/O 錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "當在衍生類別中覆寫時，會傳回序列中的重新啟動區域的可列舉集合。"
  remarks: "重新啟動區域會列舉在反向序列數字的順序，也就是從最低序號最高的序號。 只重新啟動區域的最後一個序號之間序號和要列舉的基底序號。      > [!NOTE] > 如果記錄檔的範圍包含<xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A>變成損毀，這個方法可以擲回<xref:System.IO.IOException>並出現錯誤訊息 「 無法執行要求，因為發生意外的 I/O 例外狀況。</xref:System.IO.IOException> </xref:System.IO.Log.IRecordSequence.BaseSequenceNumber%2A> 傳回下列錯誤碼: &quot;80070026&quot; 」。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "序列中的重新啟動區域的可列舉集合。"
  overload: System.IO.Log.IRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "讀取記錄時發生 I/O 錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "當在衍生類別中覆寫時，自動建立單一保留區，並將記錄附加至順序。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       指定的保留區會加入至提供的保留區集合中的不可部分完成的作業與記錄附加作業。 如果附加失敗，則會不保留任何空間。       一般來說，這個方法可能會完成之前已寫入記錄。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，其中包含要建立保留項目中的集合。"
    - id: reservations
      type: System.Int64[]
      description: "要進行，以位元組為單位的保留區。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "附加記錄時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄，或是將此保留項目。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "當在衍生類別中覆寫時，自動建立單一保留區，並將記錄附加至順序。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       指定的保留區會加入至提供的保留區集合中的不可部分完成的作業與記錄附加作業。 如果附加失敗，則會不保留任何空間。       一般來說，這個方法可能會完成之前已寫入記錄。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.IRecordSequence.Flush%2A>方法。</xref:System.IO.Log.IRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要建立保留項目中的保留項目集合。"
    - id: reservations
      type: System.Int64[]
      description: "要進行，以位元組為單位的保留區。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.IRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "附加記錄時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間來容納新的記錄，或是將此保留項目。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "當在衍生類別中覆寫時，取得已保留的位元組總數。"
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "在這個記錄順序中所做的所有保留區的大小總計。"
  overload: System.IO.Log.IRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "當在衍生類別中覆寫時，取得最近寫入的重新啟動區域的序號。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 當需要復原時，您可以剖析重新啟動區域，從上一個檢查點作業擷取所有資料。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。"
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "重新啟動區域的最近寫入的序號。"
  overload: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得或設定值，指出是否將附加的記錄檔已滿時自動重試。"
  remarks: "如果這個屬性的值為`true`，和<xref:System.IO.Log.IRecordSequence.Append%2A>呼叫失敗，因為在序列中沒有足夠的空間，記錄順序將會嘗試釋放空間，並重試附加。</xref:System.IO.Log.IRecordSequence.Append%2A>"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果附加的記錄檔已滿; 自動重試否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.Log.IRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "發生於在記錄順序判斷必須向前移動結尾。"
  remarks: "您可以引發事件時，記錄順序已用盡空間。 這個事件一經引發，序列 （也就是基底序號） 的結尾往前移動以釋放空間。"
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，將重新啟動區域寫入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 常見的記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證確定至少一個有效區域永遠可供使用。 當需要復原時，CLFS 會讀取其重新啟動區域和所有資料從最後一個檢查點作業。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。       可以使用來讀取重新啟動區域<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       位元組陣列區段中的資料將串連至單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入重新啟動區域時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間，以包含新的重新啟動區域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，將重新啟動區域寫入<xref href=&quot;System.IO.Log.IRecordSequence&quot;> </xref>。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 當需要復原時，您可以剖析重新啟動區域，從上一個檢查點作業擷取所有資料。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。 可以使用來讀取重新啟動區域<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       位元組陣列區段中的資料將串連至單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入重新啟動區域時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間，以包含新的重新啟動區域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，將重新啟動區域寫入<xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>並更新基底序號"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 當需要復原時，您可以剖析重新啟動區域，從上一個檢查點作業擷取所有資料。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。 可以使用來讀取重新啟動區域<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       當寫入重新啟動區域時，位元組陣列區段中的資料會串連成單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。       這個方法順利完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入重新啟動區域時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間，以包含新的重新啟動區域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，將重新啟動區域寫入<xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>並更新基底序號。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 當需要復原時，您可以剖析重新啟動區域，從上一個檢查點作業擷取所有資料。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。 可以使用來讀取重新啟動區域<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       當寫入重新啟動區域時，位元組陣列區段中的資料會串連成單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。       這個方法順利完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入重新啟動區域時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間，以包含新的重新啟動區域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，將重新啟動區域寫入<xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>使用保留區，並更新基底序號"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 當需要復原時，您可以剖析重新啟動區域，從上一個檢查點作業擷取所有資料。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。 可以使用來讀取重新啟動區域<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       當寫入重新啟動區域時，位元組陣列區段中的資料會串連成單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。       如果已指定保留區，寫入的重新啟動區域將會取用先前所保留，使用包含在集合中的保留區的空間。 如果此方法成功，便會取用的最小保留區，可以包含的資料，而且該保留區將會從集合移除。       這個方法順利完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>方法呼叫。</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含適用於此重新啟動區域的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入重新啟動區域時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間，以包含新的重新啟動區域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在衍生類別中覆寫，將重新啟動區域寫入<xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>使用保留區，並更新基底序號。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 當需要復原時，您可以剖析重新啟動區域，從上一個檢查點作業擷取所有資料。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。 可以使用來讀取重新啟動區域<xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.IRecordSequence.ReadRestartAreas%2A>       當寫入重新啟動區域時，位元組陣列區段中的資料會串連成單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。       如果已指定保留區，寫入的重新啟動區域將會取用先前所保留，使用包含在集合中的保留區的空間。 如果此方法成功，便會取用的最小保留區，可以包含的資料，而且該保留區將會從集合移除。       這個方法順利完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>方法呼叫。</xref:System.IO.Log.IRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSequenceNumber, System.IO.Log.ReservationCollection reservation);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含適用於此重新啟動區域的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.IRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "寫入重新啟動區域時發生 I/O 錯誤。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序無法騰出足夠的可用空間，以包含新的重新啟動區域。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
references:
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.IRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.IRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: IRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.IRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.IRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: IRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: IRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: IRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.IRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.IRecordSequence.Flush
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: IRecordSequence.Flush()
  fullName: System.IO.Log.IRecordSequence.Flush()
- uid: System.IO.Log.IRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: IRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.IRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.IRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.IRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: IRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.IRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.IRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.IRecordSequence.ReservedBytes
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
  fullName: System.IO.Log.IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
  fullName: System.IO.Log.IRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.IRecordSequence.TailPinned
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: IRecordSequence.TailPinned
  fullName: System.IO.Log.IRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.IRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.IRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: IRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.Append*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Append
  nameWithType: IRecordSequence.Append
- uid: System.IO.Log.IRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: IRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.IRecordSequence.BeginAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: IRecordSequence.BeginAppend
- uid: System.IO.Log.IRecordSequence.BeginFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: IRecordSequence.BeginFlush
- uid: System.IO.Log.IRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: IRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.IRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: IRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.IRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: IRecordSequence.CreateReservationCollection
- uid: System.IO.Log.IRecordSequence.EndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: IRecordSequence.EndAppend
- uid: System.IO.Log.IRecordSequence.EndFlush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: IRecordSequence.EndFlush
- uid: System.IO.Log.IRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: IRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.IRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: IRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.IRecordSequence.Flush*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: Flush
  nameWithType: IRecordSequence.Flush
- uid: System.IO.Log.IRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: IRecordSequence.LastSequenceNumber
- uid: System.IO.Log.IRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: IRecordSequence.MaximumRecordLength
- uid: System.IO.Log.IRecordSequence.ReadLogRecords*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: IRecordSequence.ReadLogRecords
- uid: System.IO.Log.IRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: IRecordSequence.ReadRestartAreas
- uid: System.IO.Log.IRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: IRecordSequence.ReserveAndAppend
- uid: System.IO.Log.IRecordSequence.ReservedBytes*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: IRecordSequence.ReservedBytes
- uid: System.IO.Log.IRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: IRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.IRecordSequence.RetryAppend*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: IRecordSequence.RetryAppend
- uid: System.IO.Log.IRecordSequence.WriteRestartArea*
  parent: System.IO.Log.IRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: IRecordSequence.WriteRestartArea
