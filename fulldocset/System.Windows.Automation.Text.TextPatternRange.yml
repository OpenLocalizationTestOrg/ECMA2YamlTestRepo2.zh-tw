### YamlMime:ManagedReference
items:
- uid: System.Windows.Automation.Text.TextPatternRange
  id: TextPatternRange
  children:
  - System.Windows.Automation.Text.TextPatternRange.AddToSelection
  - System.Windows.Automation.Text.TextPatternRange.Clone
  - System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  - System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  - System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  - System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  - System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  - System.Windows.Automation.Text.TextPatternRange.GetChildren
  - System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  - System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  - System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  - System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  - System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  - System.Windows.Automation.Text.TextPatternRange.Select
  - System.Windows.Automation.Text.TextPatternRange.TextPattern
  langs:
  - csharp
  name: TextPatternRange
  nameWithType: TextPatternRange
  fullName: System.Windows.Automation.Text.TextPatternRange
  type: Class
  summary: "代表一段連續文字<xref href=&quot;System.Windows.Automation.TextPattern&quot;></xref>容器。"
  remarks: "插入點、 的子集或所有中的文字，可以代表 TextPatternRange<xref:System.Windows.Automation.TextPattern>容器。</xref:System.Windows.Automation.TextPattern>       TextPatternRange 將變成無效，發生下列其中之一︰ 中的文字<xref:System.Windows.Automation.TextPattern>容器變更一些使用者活動，因為或<xref:System.Windows.Automation.ValuePattern.SetValue%2A>方法<xref:System.Windows.Automation.ValuePattern>用來以程式設計方式變更的值中的文字<xref:System.Windows.Automation.TextPattern>容器。</xref:System.Windows.Automation.TextPattern> </xref:System.Windows.Automation.ValuePattern> </xref:System.Windows.Automation.ValuePattern.SetValue%2A> </xref:System.Windows.Automation.TextPattern>"
  syntax:
    content: public class TextPatternRange
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection
  id: AddToSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: AddToSelection()
  nameWithType: TextPatternRange.AddToSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.AddToSelection()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "加入至支援多個文字容器中反白顯示的文字集合，斷續選取。"
  remarks: "文字插入點移動至新的選取範圍的區域。       提供變質文字範圍移動插入點。"
  syntax:
    content: public void AddToSelection ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.AddToSelection*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "如果文字提供者不支援多次斷續選取 (比方說，<xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>的值必須<xref uid=&quot;langword_csharp_Multiple&quot; name=&quot;Multiple&quot; href=&quot;&quot;> </xref>)。</xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Clone
  id: Clone
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Clone()
  nameWithType: TextPatternRange.Clone()
  fullName: System.Windows.Automation.Text.TextPatternRange.Clone()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "擷取新<xref href=&quot;System.Windows.Automation.Text.TextPatternRange&quot;></xref>等於原始<xref href=&quot;System.Windows.Automation.Text.TextPatternRange&quot;></xref>且繼承其所有屬性。"
  remarks: "或者，建立新<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>從<xref:System.Windows.Automation.TextPattern>和移動兩個端點，與原始的文字範圍的結束點的對應。</xref:System.Windows.Automation.TextPattern> </xref:System.Windows.Automation.TextPattern.DocumentRange%2A>       新的範圍可以從原始獨立操作。"
  example:
  - "[!code-cs[UIATextPattern_snip#1060](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1060)]  \n  \n [!code-vb[UIATextPattern_snip#2060](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2060)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange Clone ();
    parameters: []
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "新的文字範圍。 Null 參考 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>中[!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)]) 絕對不會傳回。"
  overload: System.Windows.Automation.Text.TextPatternRange.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  id: Compare(System.Windows.Automation.Text.TextPatternRange)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Compare(TextPatternRange)
  nameWithType: TextPatternRange.Compare(TextPatternRange)
  fullName: System.Windows.Automation.Text.TextPatternRange.Compare(TextPatternRange)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "傳回<xref:System.Boolean>值，指出是否範圍 ( <xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref>端點<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;></xref>端點) 的文字範圍是與另一個文字範圍相同。</xref:System.Boolean>"
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1061](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1061)]  \n  \n [!code-vb[UIATextPattern_snip#2061](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2061)]"
  syntax:
    content: public bool Compare (System.Windows.Automation.Text.TextPatternRange range);
    parameters:
    - id: range
      type: System.Windows.Automation.Text.TextPatternRange
      description: "要比較的文字範圍。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果兩個文字範圍的跨幅相同的。否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Automation.Text.TextPatternRange.Compare*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "如果要比較的範圍不是來自相同文字提供者。"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  id: CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "傳回<xref:System.Int32>表示兩個文字範圍是否具有相同的端點。</xref:System.Int32>"
  remarks: "您可以藉由比較相同的文字範圍的開始與結束端點識別變質文字範圍時，或端點是以邏輯文字流程順序。"
  example:
  - "[!code-cs[UIATextPattern_snip#1062](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1062)]  \n  \n [!code-vb[UIATextPattern_snip#2062](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2062)]"
  syntax:
    content: public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref>或<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;></xref>呼叫端的端點。"
    - id: targetRange
      type: System.Windows.Automation.Text.TextPatternRange
      description: "比較目標範圍。"
    - id: targetEndpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;> </xref>或<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;></xref>端點的目標。"
    return:
      type: System.Int32
      description: "如果呼叫端的端點更早出現在文字中比目標端點，傳回負數的值。       如果呼叫端的端點是在與目標端點位於相同位置，則傳回零。       如果呼叫端的端點在文字中比目標端點更晚出現，則傳回正值。"
  overload: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "如果範圍是 null 參考 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>中[!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "如果範圍是從另一個容器。"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  id: ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: ExpandToEnclosingUnit(TextUnit)
  nameWithType: TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  fullName: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "將文字範圍擴展至指定<xref href=&quot;System.Windows.Automation.Text.TextUnit&quot;> </xref>。"
  remarks: "如果範圍中的指定單位的精確數量則保持不變。       為了讓 expandtoenclosingunit 進行方法，才能順利執行，一連串的動作是在幕後執行。      1.  文字範圍已正規化;也就是文字範圍已摺疊為變質範圍在<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>端點，讓<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>端點變成多餘。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> 這個步驟是必要情況下，文字範圍跨越`unit`界限; 例如，&quot;{The U} RL [http://www.microsoft.com](http://www.microsoft.com)內嵌在文字&quot;其中&quot;{&quot;和&quot;}&quot;是文字範圍端點。      2.  產生的範圍向後移<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>要求開頭`unit`界限。</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  將範圍移往前或往後在<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>所要求的數目`unit`界限。</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      4.  範圍到時會展開，從變質範圍狀態移動<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>依一個要求的端點`unit`界限。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![由 Move & expandtoenclosingunit 進行的範圍調整](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;由移動 & expandtoenclosingunit 進行的範圍調整&quot;)如何針對 move （） 和 expandtoenclosingunit （） 調整文字範圍的範例 > [!NOTE] > 這些步驟是必要的因為它是很常見的螢幕助讀員讀取完整單字、 句子或整個段落插入點或任何虛擬的游標位置。       Expandtoenclosingunit 進行尊重隱藏和顯示文字。 UI 自動化用戶端可以檢查<xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>文字方塊可見性。</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       Expandtoenclosingunit 進行會延後到下一個最大<xref:System.Windows.Automation.Text.TextUnit>如果給定<xref:System.Windows.Automation.Text.TextUnit>控制項不支援。</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       如下所示的順序，從最大、 最小單位。      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-cs[UIATextPattern_snip#1063](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1063)]  \n  \n [!code-vb[UIATextPattern_snip#2063](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2063)]"
  syntax:
    content: public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);
    parameters:
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "文字單元。"
  overload: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  id: FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: FindAttribute(AutomationTextAttribute,Object,Boolean)
  nameWithType: TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "傳回具有指定的屬性值的文字範圍子集。"
  remarks: "在隱藏與顯示的文字之間沒有差異。 使用者介面自動化用戶端可以使用<xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>檢查文字方塊可見性。</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>      > [!NOTE] > 使用<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>搜尋整份文件。</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>"
  example:
  - "[!code-cs[UIATextPattern_snip#1064](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1064)]  \n  \n [!code-vb[UIATextPattern_snip#2064](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2064)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange FindAttribute (System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward);
    parameters:
    - id: attribute
      type: System.Windows.Automation.AutomationTextAttribute
      description: "要搜尋的屬性。"
    - id: value
      type: System.Object
      description: "要搜尋的屬性值。 此值必須符合指定之屬性的型別。"
    - id: backward
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果應該傳回最後一個出現的文字範圍，而不是第一個;否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "文字範圍具有相符屬性和屬性值。否則為 null (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>中[!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])。"
  overload: System.Windows.Automation.Text.TextPatternRange.FindAttribute*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  id: FindText(System.String,System.Boolean,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: FindText(String,Boolean,Boolean)
  nameWithType: TextPatternRange.FindText(String,Boolean,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindText(String,Boolean,Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "傳回包含指定的文字的文字範圍子集。"
  remarks: "在隱藏與顯示的文字之間沒有差異。 使用者介面自動化用戶端可以使用<xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>檢查文字方塊可見性。</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>      > [!NOTE] > 使用<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>搜尋整份文件。</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>"
  example:
  - "[!code-cs[UIATextPattern_snip#1065](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1065)]  \n  \n [!code-vb[UIATextPattern_snip#2065](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2065)]"
  syntax:
    content: public System.Windows.Automation.Text.TextPatternRange FindText (string text, bool backward, bool ignoreCase);
    parameters:
    - id: text
      type: System.String
      description: "要搜尋的文字字串。"
    - id: backward
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果應該傳回最後一個出現的文字範圍，而不是第一個;否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: ignoreCase
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果應該忽略大小寫。否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Windows.Automation.Text.TextPatternRange
      description: "符合指定之文字; 文字範圍否則為 null (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>中[!INCLUDE[TLA#tla_visualbnet](~/add/includes/tlasharptla-visualbnet-md.md)])。"
  overload: System.Windows.Automation.Text.TextPatternRange.FindText*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  id: GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetAttributeValue(AutomationTextAttribute)
  nameWithType: TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "傳回整個文字範圍中指定之屬性的值。"
  remarks: "在隱藏與顯示的文字之間沒有差異。 使用者介面自動化用戶端可以使用<xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>檢查文字方塊可見性。</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>"
  example:
  - "[!code-cs[UIATextPattern_snip#1066](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1066)]  \n  \n [!code-vb[UIATextPattern_snip#2066](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2066)]"
  syntax:
    content: public object GetAttributeValue (System.Windows.Automation.AutomationTextAttribute attribute);
    parameters:
    - id: attribute
      type: System.Windows.Automation.AutomationTextAttribute
      description: "文字屬性。"
    return:
      type: System.Object
      description: "傳回指定之屬性的值。 例如，getattributevalue （textpattern.fontnameattribute） 會傳回代表字型名稱的字串，如果唯一的文字範圍，getattributevalue （textpattern.isitalicattribute) 會傳回布林值。       傳回<xref href=&quot;System.Windows.Automation.TextPattern.MixedAttributeValue&quot;></xref>如果文字範圍內的指定屬性的值而有所不同。       傳回<xref href=&quot;System.Windows.Automation.AutomationElement.NotSupported&quot;></xref>如果提供者或控制項不支援指定的屬性。"
  overload: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "如果指定的屬性不是有效的。"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  id: GetBoundingRectangles
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetBoundingRectangles()
  nameWithType: TextPatternRange.GetBoundingRectangles()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "擷取每一個完整或部分可見的文字範圍中的文字行構成的週框的集合。"
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1067](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1067)]  \n  \n [!code-vb[UIATextPattern_snip#2067](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2067)]"
  syntax:
    content: public System.Windows.Rect[] GetBoundingRectangles ();
    parameters: []
    return:
      type: System.Windows.Rect[]
      description: "文字的文字範圍中的每一個完整或部分行構成的週框陣列。       變質文字範圍的空陣列。       已將其放在完全螢幕之外、 螢幕座標的文字範圍的空陣列捲動到檢視，或被重疊的視窗遮蔽。"
  overload: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren
  id: GetChildren
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetChildren()
  nameWithType: TextPatternRange.GetChildren()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetChildren()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "擷取文字範圍內所有內嵌物件的集合。"
  remarks: ''
  example:
  - "[!code-vb[UIATextPattern_snip#StartTarget](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#starttarget)]\n [!code-cs[UIATextPattern_snip#StartTarget](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#starttarget)]  \n[!code-vb[UIATextPattern_snip#GetTextElement](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#gettextelement)]\n[!code-cs[UIATextPattern_snip#GetTextElement](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#gettextelement)]  \n[!code-vb[UIATextPattern_snip#GetEmbeddedObjects](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#getembeddedobjects)]\n[!code-cs[UIATextPattern_snip#GetEmbeddedObjects](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#getembeddedobjects)]"
  syntax:
    content: public System.Windows.Automation.AutomationElement[] GetChildren ();
    parameters: []
    return:
      type: System.Windows.Automation.AutomationElement[]
      description: "落在範圍內的所有子物件的集合。 子系與範圍重疊，但不完全圍住，則也會包含在集合中。       如果沒有子物件會傳回空集合。"
  overload: System.Windows.Automation.Text.TextPatternRange.GetChildren*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  id: GetEnclosingElement
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetEnclosingElement()
  nameWithType: TextPatternRange.GetEnclosingElement()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "傳回最內層<xref href=&quot;System.Windows.Automation.AutomationElement&quot;></xref>圍住文字範圍。"
  remarks: "封入<xref:System.Windows.Automation.AutomationElement>，通常提供文字範圍的文字提供者。</xref:System.Windows.Automation.AutomationElement> 不過，如果文字提供者支援子項目，例如表格或超連結，然後封入項目可能是文字提供者的子系。"
  example:
  - "[!code-cs[UIATextPattern_snip#1069](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1069)]  \n  \n [!code-vb[UIATextPattern_snip#2069](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2069)]"
  syntax:
    content: public System.Windows.Automation.AutomationElement GetEnclosingElement ();
    parameters: []
    return:
      type: System.Windows.Automation.AutomationElement
      description: "封入呼叫者最內層項目。"
  overload: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  id: GetText(System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: GetText(Int32)
  nameWithType: TextPatternRange.GetText(Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetText(Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "傳回文字範圍的純文字。"
  remarks: "GetText 尊重隱藏和顯示文字。 UI 自動化用戶端可以檢查<xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>文字方塊可見性。</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       如果`maxLength`大於的長度是呼叫端的文字範圍內，傳回的字串會是個文字範圍的純文字。       GetText 不會影響順序文字流向; 中的端點它一定會傳回邏輯文字流程順序中的文字範圍的開始和結束端點之間的文字。"
  example:
  - "[!code-cs[UIATextPattern_snip#1070](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1070)]  \n  \n [!code-vb[UIATextPattern_snip#2070](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2070)]"
  syntax:
    content: public string GetText (int maxLength);
    parameters:
    - id: maxLength
      type: System.Int32
      description: "要傳回之字串的長度上限。 使用`-1`如果需要無限制。"
    return:
      type: System.String
      description: "純文字的文字範圍內，可能以截斷方式在指定<code> maxLength </code>。"
  overload: System.Windows.Automation.Text.TextPatternRange.GetText*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "如果<code> maxLength </code>小於-1。"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  id: Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Move(TextUnit,Int32)
  nameWithType: TextPatternRange.Move(TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.Move(TextUnit,Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "將文字範圍的文字單元數移動。"
  remarks: "需周遊文字範圍的內容時，一系列的步驟會在幕後移動方法，才能成功執行的順序。      1.  文字範圍已正規化;也就是文字範圍已摺疊為變質範圍在<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>端點，可讓<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>端點變成多餘。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> 這個步驟是必要情況下，文字範圍跨越`unit`界限; 例如，&quot;{The U} RL [http://www.microsoft.com](http://www.microsoft.com)內嵌在文字&quot;其中&quot;{&quot;和&quot;}&quot;是文字範圍端點。      2.  產生的範圍向後移<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>要求開頭`unit`界限。</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  將範圍移往前或往後在<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>所要求的數目`unit`界限。</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      4.  範圍到時會展開，從變質範圍狀態移動<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>依一個要求的端點`unit`界限。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![由 Move & expandtoenclosingunit 進行的範圍調整](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;由移動 & expandtoenclosingunit 進行的範圍調整&quot;)如何針對 move （） 和 expandtoenclosingunit （） 的文字內容 （或內部文字） 的文字容器和內嵌的物件，例如超連結或表格儲存格，調整文字範圍的範例會公開為單一連續的文字資料流中的控制項檢閱和內容檢閱[!INCLUDE[TLA2#tla_uiautomation](~/add/includes/tla2sharptla-uiautomation-md.md)]樹狀; 物件界限會被忽略。 如果使用者介面自動化用戶端擷取的文字，以便敘述、 解譯或分析以某種方式，將文字範圍應檢查特殊案例，例如具有文字內容或其他內嵌物件的資料表。 這可藉由呼叫<xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>取得<xref:System.Windows.Automation.AutomationElement>的每個內嵌物件，然後再呼叫<xref:System.Windows.Automation.TextPattern.RangeFromChild%2A>取得文字範圍的每個項目; 這會以遞迴方式，直到擷取所有的文字內容為止。</xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> </xref:System.Windows.Automation.AutomationElement> </xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>       ![合併的內嵌物件的文字範圍。](~/add/media/uia-textpattern-embeddedobjecttextranges.png &quot;合併內嵌物件的文字範圍。&quot;)   具有內嵌的物件及其範圍的文字資料流範例跨越移動方面此時隱藏和顯示文字。 UI 自動化用戶端可以檢查<xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>文字方塊可見性。</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>       移動會延後到下一個最大<xref:System.Windows.Automation.Text.TextUnit>如果給定<xref:System.Windows.Automation.Text.TextUnit>控制項不支援。</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       如下所示的順序，從最大、 最小單位。      - <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>- <xref:System.Windows.Automation.Text.TextUnit>> [!NOTE] > 文字不會改變以任何方式如只是文字範圍擴展的不同部分文字。</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-vb[UIATextPattern_snip#StartTarget](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#starttarget)]\n [!code-cs[UIATextPattern_snip#StartTarget](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#starttarget)]  \n[!code-vb[UIATextPattern_snip#GetTextElement](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#gettextelement)]\n[!code-cs[UIATextPattern_snip#GetTextElement](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#gettextelement)]  \n[!code-vb[UIATextPattern_snip#MoveSelection](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#moveselection)]\n[!code-cs[UIATextPattern_snip#MoveSelection](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#moveselection)]"
  syntax:
    content: public int Move (System.Windows.Automation.Text.TextUnit unit, int count);
    parameters:
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "文字單元界限。"
    - id: count
      type: System.Int32
      description: "要移動的文字單元數。 正值會將移動的文字範圍向前，負值會將文字範圍向後，0 沒有作用。"
    return:
      type: System.Int32
      description: "實際移動的單位數。 這可能會小於要求的數目如果新的文字範圍端點大於或小於比<xref:System.Windows.Automation.TextPattern.DocumentRange*>端點。</xref:System.Windows.Automation.TextPattern.DocumentRange*>"
  overload: System.Windows.Automation.Text.TextPatternRange.Move*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  id: MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "將文字範圍的一個端點移至第二個文字範圍指定的端點。"
  remarks: "如果移動端點置於相同的文字範圍的另一個端點則導致變質範圍，以及確保端點的正確順序也，移動其他端點 (也就是<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>一定會小於或等於<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>)。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>"
  example:
  - "[!code-cs[UIATextPattern_snip#1072](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1072)]  \n  \n [!code-vb[UIATextPattern_snip#2072](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2072)]"
  syntax:
    content: public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "要移動的端點。"
    - id: targetRange
      type: System.Windows.Automation.Text.TextPatternRange
      description: "另一個範圍是從相同的文字提供者。"
    - id: targetEndpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "另一個範圍上的端點。"
  overload: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  id: MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  nameWithType: TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "一個文字範圍的端點指定的數目的移動<xref href=&quot;System.Windows.Automation.Text.TextUnit&quot;></xref>文件範圍內。"
  remarks: "需周遊文字範圍的內容時，一系列的步驟會在幕後順序<xref:System.Windows.Automation.Text.TextPatternRange.Move%2A>方法才能成功執行。</xref:System.Windows.Automation.Text.TextPatternRange.Move%2A>      1.  文字範圍已正規化;也就是文字範圍已摺疊為變質範圍在<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>端點，可讓<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>端點變成多餘。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> </xref:System.Windows.Automation.Text.TextPatternRangeEndpoint> 這個步驟是必要情況下，文字範圍跨越`unit`界限; 例如，&quot;{The U} RL [http://www.microsoft.com](http://www.microsoft.com)內嵌在文字&quot;其中&quot;{&quot;和&quot;}&quot;是文字範圍端點。      2.  產生的範圍向後移<xref:System.Windows.Automation.TextPattern.DocumentRange%2A>要求開頭`unit`界限。</xref:System.Windows.Automation.TextPattern.DocumentRange%2A>      3.  範圍到時會展開，從變質範圍狀態移動<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>依一個要求的端點`unit`界限。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>       ![由 Move & expandtoenclosingunit 進行的範圍調整](~/add/media/uia-textpattern-moveandexpand-examples.png &quot;由移動 & expandtoenclosingunit 進行的範圍調整&quot;)如何針對 move （） 和 expandtoenclosingunit （） 的文字內容 （或內部文字） 的文字容器和內嵌的物件，例如超連結或表格儲存格，調整文字範圍的範例會公開為單一連續的文字資料流中的控制項檢閱和內容檢閱[!INCLUDE[TLA2#tla_uiautomation](~/add/includes/tla2sharptla-uiautomation-md.md)]樹狀; 物件界限會被忽略。 如果使用者介面自動化用戶端擷取的文字，以便敘述、 解譯或分析以某種方式，將文字範圍應檢查特殊案例，例如具有文字內容或其他內嵌物件的資料表。 這可藉由呼叫<xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>取得<xref:System.Windows.Automation.AutomationElement>的每個內嵌物件，然後再呼叫<xref:System.Windows.Automation.TextPattern.RangeFromChild%2A>取得文字範圍的每個項目; 這會以遞迴方式，直到擷取所有的文字內容為止。</xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> </xref:System.Windows.Automation.AutomationElement> </xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A>       ![合併的內嵌物件的文字範圍。](~/add/media/uia-textpattern-embeddedobjecttextranges.png &quot;合併內嵌物件的文字範圍。&quot;)   範例中的文字資料流，具有內嵌的物件及其範圍 MoveEndpointByUnit 會延後到下一個最大<xref:System.Windows.Automation.Text.TextUnit>如果給定<xref:System.Windows.Automation.Text.TextUnit>控制項不支援。</xref:System.Windows.Automation.Text.TextUnit> </xref:System.Windows.Automation.Text.TextUnit>       如下所示的順序，從最大、 最小單位。      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit>      -   <xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit></xref:System.Windows.Automation.Text.TextUnit>"
  example:
  - "[!code-cs[UIATextPattern_snip#1073](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1073)]  \n  \n [!code-vb[UIATextPattern_snip#2073](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2073)]"
  syntax:
    content: public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);
    parameters:
    - id: endpoint
      type: System.Windows.Automation.Text.TextPatternRangeEndpoint
      description: "要移動的端點。"
    - id: unit
      type: System.Windows.Automation.Text.TextUnit
      description: "移動的文字單元。"
    - id: count
      type: System.Int32
      description: "要移動的單位數目。 正計數將端點向前移動。 負計數會向後移動。 計數為 0 沒有任何作用。"
    return:
      type: System.Int32
      description: "實際移動的單位數，這可以小於要求如果移動端點會碰到的開頭或結尾的文件。"
  overload: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  id: RemoveFromSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: RemoveFromSelection()
  nameWithType: TextPatternRange.RemoveFromSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "移除反白顯示的一段文字，對應至呼叫端文字範圍<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;></xref>和<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;></xref>端點，從現有的集合，反白的文字中的文字容器支援多次斷續選取。"
  remarks: "移除反白顯示的區域，將文字插入點。       提供變質文字範圍，將會移動插入點。"
  syntax:
    content: public void RemoveFromSelection ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "如果文字提供者不支援多次斷續選取 (比方說，<xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>的值必須<xref uid=&quot;langword_csharp_Multiple&quot; name=&quot;Multiple&quot; href=&quot;&quot;> </xref>)。</xref:System.Windows.Automation.TextPattern.SupportedTextSelection*>"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  id: ScrollIntoView(System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: ScrollIntoView(Boolean)
  nameWithType: TextPatternRange.ScrollIntoView(Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(Boolean)
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "導致文字控制項垂直捲動，直到看到檢視區中的文字範圍為止。"
  remarks: "ScrollIntoView 尊重隱藏和顯示文字。 UI 自動化用戶端可以檢查<xref:System.Windows.Automation.TextPattern.IsHiddenAttribute>文字方塊可見性。</xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> 如果隱藏的文字範圍，文字控制項將捲動隱藏的文字檢視區中有一個錨點。"
  example:
  - "[!code-cs[UIATextPattern_snip#1074](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1074)]  \n  \n [!code-vb[UIATextPattern_snip#2074](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2074)]"
  syntax:
    content: public void ScrollIntoView (bool alignToTop);
    parameters:
    - id: alignToTop
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果應該捲動文字控制項，讓文字範圍與檢視區; 頂端齊<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果應該與檢視區的底端齊。"
  overload: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "如果控制項不支援捲動。"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.Select
  id: Select
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: Select()
  nameWithType: TextPatternRange.Select()
  fullName: System.Windows.Automation.Text.TextPatternRange.Select()
  type: Method
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "對應至文字範圍的文字控制項中的文字會反白顯示<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;></xref>和<xref href=&quot;System.Windows.Automation.Text.TextPatternRangeEndpoint&quot;></xref>端點。"
  remarks: "如果提供變質文字範圍，文字插入點會移至<xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>個文字範圍端點。</xref:System.Windows.Automation.Text.TextPatternRangeEndpoint>"
  example:
  - "[!code-cs[UIATextPattern_snip#1075](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1075)]  \n  \n [!code-vb[UIATextPattern_snip#2075](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2075)]"
  syntax:
    content: public void Select ();
    parameters: []
  overload: System.Windows.Automation.Text.TextPatternRange.Select*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "文字控制項不支援文字選取範圍時，就會發生。"
  platform:
  - net462
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern
  id: TextPattern
  parent: System.Windows.Automation.Text.TextPatternRange
  langs:
  - csharp
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
  fullName: System.Windows.Automation.Text.TextPatternRange.TextPattern
  type: Property
  assemblies:
  - UIAutomationClient
  namespace: System.Windows.Automation.Text
  summary: "取得<xref href=&quot;System.Windows.Automation.TextPattern&quot;></xref>文字範圍關聯。"
  remarks: ''
  example:
  - "[!code-cs[UIATextPattern_snip#1076](~/add/codesnippet/csharp/UIATextPattern_snip/SearchWindow.cs#1076)]  \n  \n [!code-vb[UIATextPattern_snip#2076](~/add/codesnippet/visualbasic/UIATextPattern_snip/SearchWindow.vb#2076)]"
  syntax:
    content: public System.Windows.Automation.TextPattern TextPattern { get; }
    return:
      type: System.Windows.Automation.TextPattern
      description: "文字提供者。"
  overload: System.Windows.Automation.Text.TextPatternRange.TextPattern*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: AddToSelection()
  nameWithType: TextPatternRange.AddToSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.AddToSelection()
- uid: System.Windows.Automation.Text.TextPatternRange.Clone
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Clone()
  nameWithType: TextPatternRange.Clone()
  fullName: System.Windows.Automation.Text.TextPatternRange.Clone()
- uid: System.Windows.Automation.Text.TextPatternRange
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextPatternRange
  nameWithType: TextPatternRange
  fullName: System.Windows.Automation.Text.TextPatternRange
- uid: System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Compare(TextPatternRange)
  nameWithType: TextPatternRange.Compare(TextPatternRange)
  fullName: System.Windows.Automation.Text.TextPatternRange.Compare(TextPatternRange)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Automation.Text.TextPatternRangeEndpoint
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextPatternRangeEndpoint
  nameWithType: TextPatternRangeEndpoint
  fullName: System.Windows.Automation.Text.TextPatternRangeEndpoint
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ExpandToEnclosingUnit(TextUnit)
  nameWithType: TextPatternRange.ExpandToEnclosingUnit(TextUnit)
  fullName: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(TextUnit)
- uid: System.Windows.Automation.Text.TextUnit
  parent: System.Windows.Automation.Text
  isExternal: false
  name: TextUnit
  nameWithType: TextUnit
  fullName: System.Windows.Automation.Text.TextUnit
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindAttribute(AutomationTextAttribute,Object,Boolean)
  nameWithType: TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindAttribute(AutomationTextAttribute,Object,Boolean)
- uid: System.Windows.Automation.AutomationTextAttribute
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationTextAttribute
  nameWithType: AutomationTextAttribute
  fullName: System.Windows.Automation.AutomationTextAttribute
- uid: System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindText(String,Boolean,Boolean)
  nameWithType: TextPatternRange.FindText(String,Boolean,Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.FindText(String,Boolean,Boolean)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetAttributeValue(AutomationTextAttribute)
  nameWithType: TextPatternRange.GetAttributeValue(AutomationTextAttribute)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(AutomationTextAttribute)
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetBoundingRectangles()
  nameWithType: TextPatternRange.GetBoundingRectangles()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles()
- uid: System.Windows.Rect[]
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect[]
  spec.csharp:
  - uid: System.Windows.Rect
    name: Rect
    nameWithType: Rect
    fullName: Rect[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetChildren()
  nameWithType: TextPatternRange.GetChildren()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetChildren()
- uid: System.Windows.Automation.AutomationElement[]
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationElement
  nameWithType: AutomationElement
  fullName: System.Windows.Automation.AutomationElement[]
  spec.csharp:
  - uid: System.Windows.Automation.AutomationElement
    name: AutomationElement
    nameWithType: AutomationElement
    fullName: AutomationElement[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetEnclosingElement()
  nameWithType: TextPatternRange.GetEnclosingElement()
  fullName: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement()
- uid: System.Windows.Automation.AutomationElement
  parent: System.Windows.Automation
  isExternal: false
  name: AutomationElement
  nameWithType: AutomationElement
  fullName: System.Windows.Automation.AutomationElement
- uid: System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetText(Int32)
  nameWithType: TextPatternRange.GetText(Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.GetText(Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Move(TextUnit,Int32)
  nameWithType: TextPatternRange.Move(TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.Move(TextUnit,Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  nameWithType: TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(TextPatternRangeEndpoint,TextPatternRange,TextPatternRangeEndpoint)
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  nameWithType: TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
  fullName: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(TextPatternRangeEndpoint,TextUnit,Int32)
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: RemoveFromSelection()
  nameWithType: TextPatternRange.RemoveFromSelection()
  fullName: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection()
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ScrollIntoView(Boolean)
  nameWithType: TextPatternRange.ScrollIntoView(Boolean)
  fullName: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(Boolean)
- uid: System.Windows.Automation.Text.TextPatternRange.Select
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Select()
  nameWithType: TextPatternRange.Select()
  fullName: System.Windows.Automation.Text.TextPatternRange.Select()
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
  fullName: System.Windows.Automation.Text.TextPatternRange.TextPattern
- uid: System.Windows.Automation.TextPattern
  parent: System.Windows.Automation
  isExternal: false
  name: TextPattern
  nameWithType: TextPattern
  fullName: System.Windows.Automation.TextPattern
- uid: System.Windows.Automation.Text.TextPatternRange.AddToSelection*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: AddToSelection
  nameWithType: TextPatternRange.AddToSelection
- uid: System.Windows.Automation.Text.TextPatternRange.Clone*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Clone
  nameWithType: TextPatternRange.Clone
- uid: System.Windows.Automation.Text.TextPatternRange.Compare*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Compare
  nameWithType: TextPatternRange.Compare
- uid: System.Windows.Automation.Text.TextPatternRange.CompareEndpoints*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: CompareEndpoints
  nameWithType: TextPatternRange.CompareEndpoints
- uid: System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ExpandToEnclosingUnit
  nameWithType: TextPatternRange.ExpandToEnclosingUnit
- uid: System.Windows.Automation.Text.TextPatternRange.FindAttribute*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindAttribute
  nameWithType: TextPatternRange.FindAttribute
- uid: System.Windows.Automation.Text.TextPatternRange.FindText*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: FindText
  nameWithType: TextPatternRange.FindText
- uid: System.Windows.Automation.Text.TextPatternRange.GetAttributeValue*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetAttributeValue
  nameWithType: TextPatternRange.GetAttributeValue
- uid: System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetBoundingRectangles
  nameWithType: TextPatternRange.GetBoundingRectangles
- uid: System.Windows.Automation.Text.TextPatternRange.GetChildren*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetChildren
  nameWithType: TextPatternRange.GetChildren
- uid: System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetEnclosingElement
  nameWithType: TextPatternRange.GetEnclosingElement
- uid: System.Windows.Automation.Text.TextPatternRange.GetText*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: GetText
  nameWithType: TextPatternRange.GetText
- uid: System.Windows.Automation.Text.TextPatternRange.Move*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Move
  nameWithType: TextPatternRange.Move
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByRange
  nameWithType: TextPatternRange.MoveEndpointByRange
- uid: System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: MoveEndpointByUnit
  nameWithType: TextPatternRange.MoveEndpointByUnit
- uid: System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: RemoveFromSelection
  nameWithType: TextPatternRange.RemoveFromSelection
- uid: System.Windows.Automation.Text.TextPatternRange.ScrollIntoView*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: ScrollIntoView
  nameWithType: TextPatternRange.ScrollIntoView
- uid: System.Windows.Automation.Text.TextPatternRange.Select*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: Select
  nameWithType: TextPatternRange.Select
- uid: System.Windows.Automation.Text.TextPatternRange.TextPattern*
  parent: System.Windows.Automation.Text.TextPatternRange
  isExternal: false
  name: TextPattern
  nameWithType: TextPatternRange.TextPattern
