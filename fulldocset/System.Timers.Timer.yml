### YamlMime:ManagedReference
items:
- uid: System.Timers.Timer
  id: Timer
  children:
  - System.Timers.Timer.#ctor
  - System.Timers.Timer.#ctor(System.Double)
  - System.Timers.Timer.AutoReset
  - System.Timers.Timer.BeginInit
  - System.Timers.Timer.Close
  - System.Timers.Timer.Dispose(System.Boolean)
  - System.Timers.Timer.Elapsed
  - System.Timers.Timer.Enabled
  - System.Timers.Timer.EndInit
  - System.Timers.Timer.Interval
  - System.Timers.Timer.Site
  - System.Timers.Timer.Start
  - System.Timers.Timer.Stop
  - System.Timers.Timer.SynchronizingObject
  langs:
  - csharp
  name: Timer
  nameWithType: Timer
  fullName: System.Timers.Timer
  type: Class
  summary: "產生事件之後設定的間隔，產生週期性事件的選項。       若要瀏覽此類型的.NET Framework 原始程式碼，請參閱[參考來源](http://referencesource.microsoft.com/#System/services/timers/system/timers/Timer.cs#897683f27faba082)。"
  remarks: "> [!NOTE]> 這種類型的.NET Framework 原始程式碼，請參閱 <<c2> [ 參考來源](http://referencesource.microsoft.com/#System/services/timers/system/timers/Timer.cs#897683f27faba082)。 您可以瀏覽原始碼、 下載的參考，離線檢視，並逐步執行原始程式碼 （包含修補程式和更新），在偵錯;請參閱[指示](http://referencesource.microsoft.com/)。       Timer 元件是伺服器為基礎的計時器引發<xref:System.Timers.Timer.Elapsed>個的毫秒數之後，應用程式中的事件<xref:System.Timers.Timer.Interval%2A>屬性經過。</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> 您可以設定計時器物件，以引發此事件一次或重複使用<xref:System.Timers.Timer.AutoReset%2A>屬性。</xref:System.Timers.Timer.AutoReset%2A> 通常，計時器物件宣告類別層級，因此，只要需要它維持在範圍內。 然後您可以處理其<xref:System.Timers.Timer.Elapsed>事件以提供正常處理。</xref:System.Timers.Timer.Elapsed> 例如，假設您有重要的伺服器，必須保持在 24 小時一天、 一週 7 天。 您可以建立使用計時器物件，以定期檢查伺服器，並確認系統已啟動並執行服務。 如果系統沒有回應，服務可能嘗試重新啟動伺服器，或通知系統管理員。      > [!IMPORTANT] > 計時器類別是.NET Framework 中可用。 它不會包含在.NET 的標準程式庫，並不適用於其他平台，例如.NET Core 或通用 Windows 平台。 在這些平台，以及所有的.NET 平台的可攜性，您應該使用<xref:System.Threading.Timer?displayProperty=fullName>類別。</xref:System.Threading.Timer?displayProperty=fullName>       此類型會實作<xref:System.IDisposable>介面。</xref:System.IDisposable> 當您完成使用類型時，您應該會處置它直接或間接。 若要直接處置的類型，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。</xref:System.IDisposable.Dispose%2A> 若要為其配置間接，使用語言建構例如`using`（C# 中） 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱中的 「 使用物件的實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。</xref:System.IDisposable>       伺服器端 Timer 類別可供使用多執行緒環境中的背景工作執行緒。 伺服器計時器可以在執行緒之間移動處理所引發<xref:System.Timers.Timer.Elapsed>事件，導致更多的精確度，比在時間上引發事件的 Windows 計時器。</xref:System.Timers.Timer.Elapsed>       Timer 元件引發<xref:System.Timers.Timer.Elapsed>事件，根據的值 （以毫秒為單位） 的<xref:System.Timers.Timer.Interval%2A>屬性。</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> 您可以處理這個事件來執行您所需要的處理。 例如，假設您有連續張貼至資料庫的銷售訂單的線上銷售應用程式。 服務傳送的指示進行編譯的訂單，而非個別處理每筆訂單的批次作業。 您可以使用計時器啟動的批次處理序每隔 30 分鐘。      > [!IMPORTANT] > System.Timers.Timer 類別具有的系統時鐘為相同的解析度。 這表示<xref:System.Timers.Timer.Elapsed>事件就會引發，如果系統時鐘的解析度所定義的間隔<xref:System.Timers.Timer.Interval%2A>屬性小於系統時鐘的解析度。</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> 如需詳細資訊，請參閱<xref:System.Timers.Timer.Interval%2A>屬性。</xref:System.Timers.Timer.Interval%2A>       當<xref:System.Timers.Timer.AutoReset%2A>設`false`，計時器物件引發<xref:System.Timers.Timer.Elapsed>事件只能出現一次，第一個之後<xref:System.Timers.Timer.Interval%2A>經過。</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.AutoReset%2A> 保留提高<xref:System.Timers.Timer.Elapsed>事件會定期在所定義的間隔<xref:System.Timers.Timer.Interval%2A>，將<xref:System.Timers.Timer.AutoReset%2A>至`true`，這是預設值。</xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed>       Timer 元件會攔截，且會抑制所有事件處理常式擲回的例外狀況<xref:System.Timers.Timer.Elapsed>事件。</xref:System.Timers.Timer.Elapsed> 此行為是未來的.NET Framework 版本中可能會變更。 不過請注意，這是不一樣的事件處理常式以非同步方式執行，且包含`await`運算子 （C# 中） 或`Await`運算子 （在 Visual Basic)。 這些事件處理常式中擲回的例外狀況傳播回到呼叫的執行緒，如下列範例所示。 如需非同步方法中擲回的例外狀況的詳細資訊，請參閱[例外狀況處理](~/add/includes/ajax-current-ext-md.md)。       [!code-cs[System.Timers.Timer#3](~/add/codesnippet/csharp/t-system.timers.timer_1.cs)][!code-vb[System.Timers.Timer#3](~/add/codesnippet/visualbasic/t-system.timers.timer_1.vb) ]如果<xref:System.Timers.Timer.SynchronizingObject%2A>屬性是`null`、<xref:System.Timers.Timer.Elapsed>事件會在引發<xref:System.Threading.ThreadPool>執行緒。</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.SynchronizingObject%2A>   如果處理<xref:System.Timers.Timer.Elapsed>事件持續時間超過<xref:System.Timers.Timer.Interval%2A>，可能會再次引發事件，在另一台<xref:System.Threading.ThreadPool>執行緒。</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Elapsed> 在此情況下，事件處理常式應該是可重新進入。      > [!NOTE] > 的事件處理方法呼叫另一個執行緒的同時，可能會執行一個執行緒上<xref:System.Timers.Timer.Stop%2A>方法或設定<xref:System.Timers.Timer.Enabled%2A>屬性`false`。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> 這可能會導致<xref:System.Timers.Timer.Elapsed>之後停止計時器所引發的事件。</xref:System.Timers.Timer.Elapsed> 範例程式碼<xref:System.Timers.Timer.Stop%2A>方法顯示如何避免競爭情形。</xref:System.Timers.Timer.Stop%2A>       即使<xref:System.Timers.Timer.SynchronizingObject%2A>不`null`，<xref:System.Timers.Timer.Elapsed>之後就可能發生的事件<xref:System.Timers.Timer.Dispose%2A>或<xref:System.Timers.Timer.Stop%2A>呼叫方法之後或<xref:System.Timers.Timer.Enabled%2A>屬性已設定為`false`，因為要引發的訊號<xref:System.Timers.Timer.Elapsed>事件一律排入佇列以便在執行緒集區執行緒上執行。</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.SynchronizingObject%2A> 其中一種方式來解決這種競爭情形是設定的旗標的事件處理常式來<xref:System.Timers.Timer.Elapsed>忽略後續事件的事件。</xref:System.Timers.Timer.Elapsed>       如果您使用計時器類別與使用者介面項目，例如表單或控制項，而不會讓該使用者介面項目，在計時器指派表單或控制項，其中包含計時器<xref:System.Timers.Timer.SynchronizingObject%2A>屬性，以便將事件封送處理至使用者介面執行緒。</xref:System.Timers.Timer.SynchronizingObject%2A>       如需計時器的執行個體的預設屬性值的清單，請參閱<xref:System.Timers.Timer.%23ctor%2A>建構函式。</xref:System.Timers.Timer.%23ctor%2A>      > [!TIP] > 注意，.NET Framework 類別庫包含名為四個類別`Timer`，每個提供不同功能的: >>-計時器 （本主題）︰ 固定間隔引發事件。 類別僅供做為伺服器為基礎或服務元件，在多執行緒環境中。它沒有使用者介面，並在執行階段看不到。   >- <xref:System.Threading.Timer?displayProperty=fullName>︰ 在執行緒集區執行緒上定期執行的單一回呼方法。</xref:System.Threading.Timer?displayProperty=fullName> 計時器會具現化，且無法變更時，會定義回呼方法。 Timer 類別，例如此類別僅適用於做為伺服器為基礎或服務元件，在多執行緒環境中。它沒有使用者介面，並在執行階段看不到。   >- <xref:System.Windows.Forms.Timer?displayProperty=fullName>︰ 固定間隔引發事件的 Windows Form 元件。</xref:System.Windows.Forms.Timer?displayProperty=fullName> 元件沒有使用者介面，設計在單一執行緒的環境中使用。   >- <xref:System.Web.UI.Timer?displayProperty=fullName>︰ 以固定間隔執行非同步或同步網頁回傳的 ASP.NET 元件。</xref:System.Web.UI.Timer?displayProperty=fullName>"
  example:
  - "The following example instantiates a `System.Timers.Timer` object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cs[System.Timers.Timer#2](~/add/codesnippet/csharp/t-system.timers.timer_2.cs)]\n [!code-vb[System.Timers.Timer#2](~/add/codesnippet/visualbasic/t-system.timers.timer_2.vb)]"
  syntax:
    content: >-
      [System.ComponentModel.DefaultEvent("Elapsed")]

      [System.ComponentModel.DefaultProperty("Interval")]

      public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  implements:
  - System.ComponentModel.ISupportInitialize
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.ToString
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Timers.Timer.#ctor
  id: '#ctor'
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Timer()
  nameWithType: Timer.Timer()
  fullName: System.Timers.Timer.Timer()
  type: Constructor
  assemblies:
  - System
  namespace: System.Timers
  summary: "初始化的新執行個體<xref href=&quot;System.Timers.Timer&quot;></xref>類別，並將所有的屬性設定為其初始值。"
  remarks: "下表顯示<xref:System.Timers.Timer>.</xref:System.Timers.Timer>的執行個體的初始屬性值      |屬性 |初始值 |  |--------------|-------------------|  |<xref:System.Timers.Timer.AutoReset%2A>|`true`|  |<xref:System.Timers.Timer.Enabled%2A>|`false`|  |<xref:System.Timers.Timer.Interval%2A>|&100; 毫秒 |  |<xref:System.Timers.Timer.SynchronizingObject%2A>|Null 參考 (`Nothing`在 Visual Basic 中)。 |</xref:System.Timers.Timer.SynchronizingObject%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.AutoReset%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/m-system.timers.timer.sh_1_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/m-system.timers.timer.sh_1_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/m-system.timers.timer.sh_1_1.vb)]"
  syntax:
    content: public Timer ();
    parameters: []
  overload: System.Timers.Timer.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.#ctor(System.Double)
  id: '#ctor(System.Double)'
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Timer(Double)
  nameWithType: Timer.Timer(Double)
  fullName: System.Timers.Timer.Timer(Double)
  type: Constructor
  assemblies:
  - System
  namespace: System.Timers
  summary: "初始化的新執行個體<xref href=&quot;System.Timers.Timer&quot;></xref>類別，並設定<xref:System.Timers.Timer.Interval*>屬性，以指定的毫秒數。</xref:System.Timers.Timer.Interval*>"
  remarks: "這個建構函式設定<xref:System.Timers.Timer.Interval%2A>屬性，將新的計時器執行個體，但不會啟用計時器。</xref:System.Timers.Timer.Interval%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cs[System.Timers.Timer#3](~/add/codesnippet/csharp/m-system.timers.timer.sh_0_1.cs)]\n [!code-vb[System.Timers.Timer#3](~/add/codesnippet/visualbasic/m-system.timers.timer.sh_0_1.vb)]"
  syntax:
    content: public Timer (double interval);
    parameters:
    - id: interval
      type: System.Double
      description: "時間 （毫秒），事件之間。 值必須大於零且小於或等於&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;。"
  overload: System.Timers.Timer.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "值<code> interval </code>參數是小於或等於零，或大於&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;。"
  platform:
  - net462
- uid: System.Timers.Timer.AutoReset
  id: AutoReset
  parent: System.Timers.Timer
  langs:
  - csharp
  name: AutoReset
  nameWithType: Timer.AutoReset
  fullName: System.Timers.Timer.AutoReset
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "取得或設定布林值，指出是否<xref href=&quot;System.Timers.Timer&quot;></xref>應該引發<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件一次 (<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>) 或重複 (<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>)。"
  remarks: "如果<xref:System.Timers.Timer>時已啟用<xref:System.Timers.Timer.Start%2A>呼叫方法時，會重設間隔。</xref:System.Timers.Timer.Start%2A> </xref:System.Timers.Timer> 如果是 AutoReset `false`、<xref:System.Timers.Timer.Start%2A>必須呼叫方法，才能再次開始計數。</xref:System.Timers.Timer.Start%2A>       重設間隔會影響當<xref:System.Timers.Timer.Elapsed>就會引發事件。</xref:System.Timers.Timer.Elapsed> 例如，如果您設定為 5 秒的間隔，然後再設定<xref:System.Timers.Timer.Enabled%2A>屬性`true`，計數開始時間<xref:System.Timers.Timer.Enabled%2A>設定。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> 如果您 10 秒時此計數是 3 秒，重設間隔<xref:System.Timers.Timer.Elapsed>第一次 13 秒之後，就會引發事件<xref:System.Timers.Timer.Enabled%2A>屬性設定為`true`。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed>"
  example:
  - "The following example creates a <xref:System.Timers.Timer> whose <xref:System.Timers.Timer.Elapsed> event fires after 1.5 seconds. Its event handler then displays \"Hello World!\" on the console.  \n  \n [!code-vb[Classic Timer.Timer1 Example#1](~/add/codesnippet/visualbasic/p-system.timers.timer.au_1.vb)]\n [!code-cs[Classic Timer.Timer1 Example#1](~/add/codesnippet/csharp/p-system.timers.timer.au_1.cs)]\n [!code-cpp[Classic Timer.Timer1 Example#1](~/add/codesnippet/cpp/p-system.timers.timer.au_1.cpp)]"
  syntax:
    content: public bool AutoReset { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Timers.Timer&quot;></xref>應該引發<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件每次間隔耗盡。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果應該引發<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件一次，間隔耗盡後第一次。 預設值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Timers.Timer.AutoReset*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.BeginInit
  id: BeginInit
  parent: System.Timers.Timer
  langs:
  - csharp
  name: BeginInit()
  nameWithType: Timer.BeginInit()
  fullName: System.Timers.Timer.BeginInit()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "開始執行階段初始化<xref href=&quot;System.Timers.Timer&quot;></xref>表單或另一個元件所使用。"
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]設計環境會使用這個方法來開始初始化用於表單或另一個元件所使用的元件。 <xref:System.Timers.Timer.EndInit%2A>方法結束初始化。</xref:System.Timers.Timer.EndInit%2A> 使用 BeginInit 和<xref:System.Timers.Timer.EndInit%2A>方法可防止控制項完全初始化之前使用。</xref:System.Timers.Timer.EndInit%2A>"
  syntax:
    content: public void BeginInit ();
    parameters: []
  overload: System.Timers.Timer.BeginInit*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Close
  id: Close
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Close()
  nameWithType: Timer.Close()
  fullName: System.Timers.Timer.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "所使用的資源釋出<xref href=&quot;System.Timers.Timer&quot;> </xref>。"
  remarks: "Close 方法接著呼叫`Dispose`方法。"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Timers.Timer.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: Timer.Dispose(Boolean)
  fullName: System.Timers.Timer.Dispose(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "目前所使用的資源全部釋出<xref href=&quot;System.Timers.Timer&quot;> </xref>。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示釋放 managed 和 unmanaged 資源，<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示只釋放 unmanaged 的資源。"
  overload: System.Timers.Timer.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Elapsed
  id: Elapsed
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Elapsed
  nameWithType: Timer.Elapsed
  fullName: System.Timers.Timer.Elapsed
  type: Event
  assemblies:
  - System
  namespace: System.Timers
  summary: "發生於間隔耗盡時。"
  remarks: "如果引發 Elapsed 事件<xref:System.Timers.Timer.Enabled%2A>屬性是`true`所定義的時間間隔 （以毫秒為單位） 和<xref:System.Timers.Timer.Interval%2A>屬性超過。</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Enabled%2A> 如果<xref:System.Timers.Timer.AutoReset%2A>屬性是`true`，在所定義的間隔內重複引發此事件<xref:System.Timers.Timer.Interval%2A>屬性; 否則就會引發此事件一次，第一次<xref:System.Timers.Timer.Interval%2A>值超過。</xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.Interval%2A> </xref:System.Timers.Timer.AutoReset%2A>       如果<xref:System.Timers.Timer.Interval%2A>後會設定<xref:System.Timers.Timer>已啟動，計數重設。</xref:System.Timers.Timer> </xref:System.Timers.Timer.Interval%2A> 例如，如果您設定為 5 秒的間隔，然後再設定<xref:System.Timers.Timer.Enabled%2A>至`true`，計數開始時間<xref:System.Timers.Timer.Enabled%2A>設定。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> 第一次 13 秒後重設為 10 秒時計數為 3 秒的間隔，會引發 Elapsed 事件<xref:System.Timers.Timer.Enabled%2A>設`true`。</xref:System.Timers.Timer.Enabled%2A>       如果<xref:System.Timers.Timer.SynchronizingObject%2A>屬性是`null`，經過事件會在引發<xref:System.Threading.ThreadPool>執行緒。</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.SynchronizingObject%2A> 如果 Elapsed 事件的處理時間比<xref:System.Timers.Timer.Interval%2A>，可能會再次引發事件，在另一台<xref:System.Threading.ThreadPool>執行緒。</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Interval%2A> 在此情況下，事件處理常式應該是可重新進入。      > [!NOTE] > 的事件處理方法呼叫另一個執行緒的同時，可能會執行一個執行緒上<xref:System.Timers.Timer.Stop%2A>方法或設定<xref:System.Timers.Timer.Enabled%2A>屬性`false`。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> 這可能會導致 Elapsed 事件引發之後停止計時器。 範例程式碼<xref:System.Timers.Timer.Stop%2A>方法顯示如何避免競爭情形。</xref:System.Timers.Timer.Stop%2A>       即使<xref:System.Timers.Timer.SynchronizingObject%2A>不`null`之後, 就可能發生 Elapsed 事件<xref:System.Timers.Timer.Dispose%2A>或<xref:System.Timers.Timer.Stop%2A>呼叫方法之後或<xref:System.Timers.Timer.Enabled%2A>屬性已設定為`false`，因為引發 Elapsed 事件訊號一律排入佇列以便在執行緒集區執行緒上執行。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.SynchronizingObject%2A> 若要解決這種競爭情形的一個方式是將設定的旗標來忽略後續事件的 Elapsed 事件的事件處理常式。       <xref:System.Timers.Timer>元件會攔截，且會抑制所有 Elapsed 事件的事件處理常式擲回的例外狀況。</xref:System.Timers.Timer> 此行為是未來的.NET Framework 版本中可能會變更。"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its Elapsed event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/e-system.timers.timer.el_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/e-system.timers.timer.el_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/e-system.timers.timer.el_1.vb)]"
  syntax:
    content: public event System.Timers.ElapsedEventHandler Elapsed;
    return:
      type: System.Timers.ElapsedEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Enabled
  id: Enabled
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Enabled
  nameWithType: Timer.Enabled
  fullName: System.Timers.Timer.Enabled
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "取得或設定值，指出是否<xref href=&quot;System.Timers.Timer&quot;></xref>應該引發<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件。"
  remarks: "將 Enabled 設定為`true`等同於呼叫<xref:System.Timers.Timer.Start%2A>，而若要啟用設定`false`等同於呼叫<xref:System.Timers.Timer.Stop%2A>.</xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Start%2A>      > [!NOTE] > 來引發訊號<xref:System.Timers.Timer.Elapsed>事件一定在佇列執行<xref:System.Threading.ThreadPool>執行緒。</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> 這可能會導致<xref:System.Timers.Timer.Elapsed>之後的 Enabled 屬性設定為所引發的事件`false`。</xref:System.Timers.Timer.Elapsed> 程式碼範例<xref:System.Timers.Timer.Stop%2A>方法顯示其中一種方式解決這種競爭情形。</xref:System.Timers.Timer.Stop%2A>       如果已啟用設`true`和<xref:System.Timers.Timer.AutoReset%2A>設為`false`、<xref:System.Timers.Timer>引發<xref:System.Timers.Timer.Elapsed>經過事件一次，第一個時間間隔。</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A>       如果間隔的設定之後<xref:System.Timers.Timer>已啟動，計數重設。</xref:System.Timers.Timer> 例如，如果您將間隔設定為 5 秒，然後將 [啟用] 屬性設定為`true`，計數開始的時間設定已啟用。 如果您 10 秒時計數是 3 秒，重設間隔<xref:System.Timers.Timer.Elapsed>第一次之後啟用已設定為 13 秒內就會引發事件`true`。</xref:System.Timers.Timer.Elapsed>      > [!NOTE] > 視覺化的設計工具，例如在 Microsoft Visual Studio 中，設定為 Enabled 屬性`true`插入新的<xref:System.Timers.Timer>。</xref:System.Timers.Timer>時"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/p-system.timers.timer.en_1.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/p-system.timers.timer.en_1.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/p-system.timers.timer.en_1.vb)]"
  syntax:
    content: public bool Enabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Timers.Timer&quot;></xref>應該引發<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Timers.Timer.Enabled*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "無法設定這個屬性，因為計時器已被處置。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Timers.Timer.Interval*>屬性已設定的值大於&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;啟用計時器之前。</xref:System.Timers.Timer.Interval*>"
  platform:
  - net462
- uid: System.Timers.Timer.EndInit
  id: EndInit
  parent: System.Timers.Timer
  langs:
  - csharp
  name: EndInit()
  nameWithType: Timer.EndInit()
  fullName: System.Timers.Timer.EndInit()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "結束執行階段初始化<xref href=&quot;System.Timers.Timer&quot;></xref>表單或另一個元件所使用。"
  remarks: "[!INCLUDE[vsprvslong](~/add/includes/ajax-current-ext-md.md)]設計環境會使用這個方法來結束初始化用於表單或另一個元件所使用的元件。 <xref:System.Timers.Timer.BeginInit%2A>方法會啟動初始化。</xref:System.Timers.Timer.BeginInit%2A> 使用<xref:System.Timers.Timer.BeginInit%2A>和 EndInit 方法可防止控制項完全初始化之前使用。</xref:System.Timers.Timer.BeginInit%2A>"
  syntax:
    content: public void EndInit ();
    parameters: []
  overload: System.Timers.Timer.EndInit*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Interval
  id: Interval
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Interval
  nameWithType: Timer.Interval
  fullName: System.Timers.Timer.Interval
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "取得或設定的間隔，以毫秒為單位，引發<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件。"
  remarks: "您使用 [間隔] 屬性來判斷的頻率<xref:System.Timers.Timer.Elapsed>引發事件。</xref:System.Timers.Timer.Elapsed> 因為<xref:System.Timers.Timer>類別取決於系統時鐘，其具有的系統時鐘為相同的解析度。</xref:System.Timers.Timer> 這表示<xref:System.Timers.Timer.Elapsed>事件就會引發，如果 [間隔] 屬性小於系統時鐘的解析度，系統時鐘的解析度所定義的間隔。</xref:System.Timers.Timer.Elapsed> 下列範例會將 [間隔] 屬性設為 5 毫秒。 在上執行時[!INCLUDE[win7](~/add/includes/win7-md.md)]系統的系統時鐘已解析的大約 15 毫秒，事件引發，大約每隔 15 毫秒，而不是每隔 5 毫秒。       [!code-cs[System.Timers.Timer.Interval#1](~/add/codesnippet/csharp/p-system.timers.timer.in_1.cs)][!code-vb[System.Timers.Timer.Interval#1](~/add/codesnippet/visualbasic/p-system.timers.timer.in_1.vb) ]您可以使用下列程式碼來判斷目前系統上的系統時鐘的解析度︰ [!code-cs [System.Timers.Timer.Interval#2](~/add/codesnippet/csharp/p-system.timers.timer.in_2.cs)][!code-vb[System.Timers.Timer.Interval#2](~/add/codesnippet/visualbasic/p-system.timers.timer.in_2.vb) ]如果應用程式需要比所提供更高的解析度<xref:System.Timers.Timer>類別或系統時鐘，使用高解析度的多媒體計時器，請參閱 < [How to︰ 使用 High-Resolution 計時器](http://msdn.microsoft.com/library/aa964692.aspx)。</xref:System.Timers.Timer>           如果間隔的設定之後<xref:System.Timers.Timer>已啟動，計數重設。</xref:System.Timers.Timer> 例如，如果您設定為 5 秒的間隔，然後再設定<xref:System.Timers.Timer.Enabled%2A>屬性`true`，計數開始時間<xref:System.Timers.Timer.Enabled%2A>設定。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A> 如果您 10 秒時計數是 3 秒，重設間隔<xref:System.Timers.Timer.Elapsed>第一次 13 秒之後，就會引發事件<xref:System.Timers.Timer.Enabled%2A>設`true`。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed>       如果<xref:System.Timers.Timer.Enabled%2A>設`true`和<xref:System.Timers.Timer.AutoReset%2A>設`false`、<xref:System.Timers.Timer>引發<xref:System.Timers.Timer.Elapsed>事件一次，第一次間隔經過。</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Enabled%2A> <xref:System.Timers.Timer.Enabled%2A>然後將設定為`false`。</xref:System.Timers.Timer.Enabled%2A>      > [!NOTE] > 如果<xref:System.Timers.Timer.Enabled%2A>和<xref:System.Timers.Timer.AutoReset%2A>都設定為`false`，以及計時器先前已啟用，設定的間隔屬性原因<xref:System.Timers.Timer.Elapsed>一次，引發的事件，如同<xref:System.Timers.Timer.Enabled%2A>屬性已設定為`true`。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.AutoReset%2A> </xref:System.Timers.Timer.Enabled%2A> 若要設定的間隔，而不會引發事件，您可以暫時設定<xref:System.Timers.Timer.Enabled%2A>屬性`true`，所需的時間間隔，以設定 [間隔] 屬性，然後立即設定<xref:System.Timers.Timer.Enabled%2A>屬性設回`false`。</xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Enabled%2A>"
  example:
  - "The following example instantiates a <xref:System.Timers.Timer> object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2000 milliseconds), sets up an event handler for the event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised.  \n  \n [!code-cpp[System.Timers.Timer#1](~/add/codesnippet/cpp/p-system.timers.timer.in_3.cpp)]\n [!code-cs[System.Timers.Timer#1](~/add/codesnippet/csharp/p-system.timers.timer.in_3.cs)]\n [!code-vb[System.Timers.Timer#1](~/add/codesnippet/visualbasic/p-system.timers.timer.in_3.vb)]"
  syntax:
    content: public double Interval { get; set; }
    return:
      type: System.Double
      description: "時間，以毫秒為單位，介於<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>事件。 值必須大於零，且小於或等於&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;。 預設為 100 毫秒。"
  overload: System.Timers.Timer.Interval*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "時間間隔小於或等於零。       -或-間隔大於&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;，且目前已啟用計時器。 （目前未啟用計時器，如果沒有擲回例外狀況之前它會變成啟用。）"
  platform:
  - net462
- uid: System.Timers.Timer.Site
  id: Site
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Site
  nameWithType: Timer.Site
  fullName: System.Timers.Timer.Site
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "取得或設定繫結的站台<xref href=&quot;System.Timers.Timer&quot;></xref>到其在設計模式中的容器。"
  remarks: "站台繫結<xref:System.ComponentModel.Component>至<xref:System.ComponentModel.Container>和啟用它們之間的通訊，以及提供一種方式管理其元件容器。</xref:System.ComponentModel.Container> </xref:System.ComponentModel.Component>"
  syntax:
    content: public override System.ComponentModel.ISite Site { get; set; }
    return:
      type: System.ComponentModel.ISite
      description: "<xref href=&quot;System.ComponentModel.ISite&quot;> </xref>介面代表繫結的站台<xref href=&quot;System.Timers.Timer&quot;></xref>到其容器的物件。"
  overload: System.Timers.Timer.Site*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.Start
  id: Start
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Start()
  nameWithType: Timer.Start()
  fullName: System.Timers.Timer.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "開始引發<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>藉由設定事件<xref:System.Timers.Timer.Enabled*>至<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。</xref:System.Timers.Timer.Enabled*>"
  remarks: "如果在呼叫 Start 和<xref:System.Timers.Timer.AutoReset%2A>設`false`、<xref:System.Timers.Timer>引發<xref:System.Timers.Timer.Elapsed>經過事件一次，第一個時間間隔。</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A> 如果在呼叫 Start 和<xref:System.Timers.Timer.AutoReset%2A>是`true`、<xref:System.Timers.Timer>引發<xref:System.Timers.Timer.Elapsed>事件第一個時間間隔經過，而且在指定的時間間隔引發事件會繼續。</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer> </xref:System.Timers.Timer.AutoReset%2A>       您也可以藉由設定啟動計時<xref:System.Timers.Timer.Enabled%2A>至`true`。</xref:System.Timers.Timer.Enabled%2A>      > [!NOTE] > 如果<xref:System.Timers.Timer.AutoReset%2A>是`false`，必須呼叫 Start 方法，才能再次開始計數。</xref:System.Timers.Timer.AutoReset%2A>       當計時器被啟用的 Start 方法的呼叫沒有任何作用。"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Timers.Timer.Start*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<xref href=&quot;System.Timers.Timer&quot;> </xref>等於或大於此數目，而間隔建立&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt; + 1 或設為小於零的間隔。"
  platform:
  - net462
- uid: System.Timers.Timer.Stop
  id: Stop
  parent: System.Timers.Timer
  langs:
  - csharp
  name: Stop()
  nameWithType: Timer.Stop()
  fullName: System.Timers.Timer.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Timers
  summary: "停止引發<xref href=&quot;System.Timers.Timer.Elapsed&quot;></xref>藉由設定事件<xref:System.Timers.Timer.Enabled*>至<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Timers.Timer.Enabled*>"
  remarks: "您也可以藉由設定停止時間<xref:System.Timers.Timer.Enabled%2A>至`false`。</xref:System.Timers.Timer.Enabled%2A>      > [!NOTE] > 來引發訊號<xref:System.Timers.Timer.Elapsed>事件一定在佇列執行<xref:System.Threading.ThreadPool>執行緒，因此事件處理方法可能會在一個執行緒上同時執行另一個執行緒上執行停止方法的呼叫。</xref:System.Threading.ThreadPool> </xref:System.Timers.Timer.Elapsed> 這可能會導致<xref:System.Timers.Timer.Elapsed>呼叫停止方法之後所引發事件。</xref:System.Timers.Timer.Elapsed> 下一節的程式碼範例會示範一種方法解決這種競爭情形。"
  example:
  - "The following example instantiates a `System.Timers.Timer` object that fires its <xref:System.Timers.Timer.Elapsed?displayProperty=fullName> event every two seconds (2,000 milliseconds), sets up an event handler for the  event, and starts the timer. The event handler displays the value of the <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=fullName> property each time it is raised. When the user presses the Enter key, the application calls the  Stop method before terminating the application.  \n  \n [!code-cs[System.Timers.Timer#2](~/add/codesnippet/csharp/m-system.timers.timer.stop_1.cs)]\n [!code-vb[System.Timers.Timer#2](~/add/codesnippet/visualbasic/m-system.timers.timer.stop_1.vb)]  \n  \n The following code example shows one way to prevent the thread that calls the Stop method from continuing until a currently executing <xref:System.Timers.Timer.Elapsed> event ends, and also to prevent two <xref:System.Timers.Timer.Elapsed> events from executing the event handler at the same time (often referred to as reentrancy).  \n  \n The example executes 100 test runs. Each time the test is run, the timer is started with an interval of 150 milliseconds. The event handler uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to simulate a task that randomly varies in length from 50 to 200 milliseconds. The test method also starts a control thread that waits for a second and then stops the timer. If an event is being handled when the control thread stops the timer, the control thread must wait until the event is finished before proceeding.  \n  \n The <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName> method overload is used to avoid reentrancy and to prevent the control thread from continuing until an executing event ends. The event handler uses the <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> method to set a control variable to 1, but only if the value is currently zero. This is an atomic operation. If the return value is zero, the control variable has been set to 1 and the event handler proceeds. If the return value is non-zero, the event is simply discarded to avoid reentrancy. (If it were necessary to execute every event, the <xref:System.Threading.Monitor> class would be a better way to synchronize the events.) When the event handler ends, it sets the control variable back to zero. The example records the total number of events that executed, that were discarded because of reentrancy, and that occurred after the Stop method was called.  \n  \n The control thread uses the <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> method to set the control variable to -1 (minus one), but only if the value is currently zero. If the atomic operation returns non-zero, an event is currently executing. The control thread waits and tries again. The example records the number of times the control thread had to wait for an event to finish.  \n  \n [!code-cs[Timer.Stop#1](~/add/codesnippet/csharp/m-system.timers.timer.stop_2.cs)]\n [!code-vb[Timer.Stop#1](~/add/codesnippet/visualbasic/m-system.timers.timer.stop_2.vb)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Timers.Timer.Stop*
  exceptions: []
  platform:
  - net462
- uid: System.Timers.Timer.SynchronizingObject
  id: SynchronizingObject
  parent: System.Timers.Timer
  langs:
  - csharp
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
  fullName: System.Timers.Timer.SynchronizingObject
  type: Property
  assemblies:
  - System
  namespace: System.Timers
  summary: "取得或設定用來封送處理當間隔已經耗盡時所發出的事件處理常式呼叫的物件。"
  remarks: "SynchronizingObject 時`null`，處理的方法<xref:System.Timers.Timer.Elapsed>系統執行緒集區執行緒上呼叫事件。</xref:System.Timers.Timer.Elapsed> 如需有關系統執行緒集區的詳細資訊，請參閱<xref:System.Threading.ThreadPool>.</xref:System.Threading.ThreadPool>       當<xref:System.Timers.Timer.Elapsed>事件由 visual 的 Windows Form 元件，例如按鈕，存取元件透過系統執行緒集區可能結果的例外狀況，或只是可能會無法運作。</xref:System.Timers.Timer.Elapsed> SynchronizingObject 設為 Windows Form 的元件，這會導致處理的方法來避免這種效果<xref:System.Timers.Timer.Elapsed>事件建立元件的相同執行緒上呼叫。</xref:System.Timers.Timer.Elapsed>      > [!NOTE] > 即使 SynchronizingObject 屬性不是`null`，<xref:System.Timers.Timer.Elapsed>之後就可能發生的事件<xref:System.Timers.Timer.Dispose%2A>或<xref:System.Timers.Timer.Stop%2A>呼叫方法之後或<xref:System.Timers.Timer.Enabled%2A>屬性已設定為`false`，因為要引發的訊號<xref:System.Timers.Timer.Elapsed>事件一律排入佇列以便在執行緒集區執行緒上執行。</xref:System.Timers.Timer.Elapsed> </xref:System.Timers.Timer.Enabled%2A> </xref:System.Timers.Timer.Stop%2A> </xref:System.Timers.Timer.Dispose%2A> </xref:System.Timers.Timer.Elapsed> 其中一種方式來解決這種競爭情形是設定的旗標的事件處理常式來<xref:System.Timers.Timer.Elapsed>忽略後續事件的事件。</xref:System.Timers.Timer.Elapsed>       如果<xref:System.Timers.Timer>會在 Windows Form 設計工具中，以使用 Visual Studio 內，SynchronizingObject 會自動設定為包含<xref:System.Timers.Timer>.</xref:System.Timers.Timer>控制項</xref:System.Timers.Timer> 例如，如果您將<xref:System.Timers.Timer>的設計工具上`Form1`(繼承自<xref:System.Windows.Forms.Form>)，SynchronizingObject 屬性<xref:System.Timers.Timer>設為執行個體`Form1`。</xref:System.Timers.Timer> </xref:System.Windows.Forms.Form> </xref:System.Timers.Timer>"
  example:
  - "The following example is a Windows Forms app that serves as a very simple text file editor. When the text in the text box has not been saved, the app asks the user at one-minute intervals whether he or she wants to save the contents of the text box.  To do this, the <xref:System.Timers.Timer.Interval%2A> property is set to one minute (60,000 milliseconds), and the SynchronizingObject property is set to the <xref:System.Windows.Forms.Form> object.  \n  \n [!code-cs[System.Timers.Timer.SynchronizingObject#1](~/add/codesnippet/csharp/SynchronizingObjectCS1/Form1.cs#1)]\n [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/add/codesnippet/visualbasic/SynchronizingObjectVB1/Form1.vb#1)]  \n  \n The example requires that you add the following controls to the form:  \n  \n-   A <xref:System.Windows.Forms.TextBox> control named `TextBox1` (its default name).  \n  \n-   A <xref:System.Windows.Forms.Button> control named `Button1` (its default name).  \n  \n-   A <xref:System.Windows.Forms.SaveFileDialog> control named `SaveSaveFileDialog1` (its default name) ."
  syntax:
    content: public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }
    return:
      type: System.ComponentModel.ISynchronizeInvoke
      description: "<xref href=&quot;System.ComponentModel.ISynchronizeInvoke&quot;> </xref>表示用來封送處理當間隔已經耗盡時所發出的事件處理常式呼叫的物件。 預設值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Timers.Timer.SynchronizingObject*
  exceptions: []
  platform:
  - net462
references:
- uid: System.ComponentModel.Component
  isExternal: false
  name: System.ComponentModel.Component
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Timers.Timer.#ctor
  parent: System.Timers.Timer
  isExternal: false
  name: Timer()
  nameWithType: Timer.Timer()
  fullName: System.Timers.Timer.Timer()
- uid: System.Timers.Timer.#ctor(System.Double)
  parent: System.Timers.Timer
  isExternal: false
  name: Timer(Double)
  nameWithType: Timer.Timer(Double)
  fullName: System.Timers.Timer.Timer(Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Timers.Timer.AutoReset
  parent: System.Timers.Timer
  isExternal: false
  name: AutoReset
  nameWithType: Timer.AutoReset
  fullName: System.Timers.Timer.AutoReset
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Timers.Timer.BeginInit
  parent: System.Timers.Timer
  isExternal: false
  name: BeginInit()
  nameWithType: Timer.BeginInit()
  fullName: System.Timers.Timer.BeginInit()
- uid: System.Timers.Timer.Close
  parent: System.Timers.Timer
  isExternal: false
  name: Close()
  nameWithType: Timer.Close()
  fullName: System.Timers.Timer.Close()
- uid: System.Timers.Timer.Dispose(System.Boolean)
  parent: System.Timers.Timer
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: Timer.Dispose(Boolean)
  fullName: System.Timers.Timer.Dispose(Boolean)
- uid: System.Timers.Timer.Elapsed
  parent: System.Timers.Timer
  isExternal: false
  name: Elapsed
  nameWithType: Timer.Elapsed
  fullName: System.Timers.Timer.Elapsed
- uid: System.Timers.ElapsedEventHandler
  parent: System.Timers
  isExternal: false
  name: ElapsedEventHandler
  nameWithType: ElapsedEventHandler
  fullName: System.Timers.ElapsedEventHandler
- uid: System.Timers.Timer.Enabled
  parent: System.Timers.Timer
  isExternal: false
  name: Enabled
  nameWithType: Timer.Enabled
  fullName: System.Timers.Timer.Enabled
- uid: System.Timers.Timer.EndInit
  parent: System.Timers.Timer
  isExternal: false
  name: EndInit()
  nameWithType: Timer.EndInit()
  fullName: System.Timers.Timer.EndInit()
- uid: System.Timers.Timer.Interval
  parent: System.Timers.Timer
  isExternal: false
  name: Interval
  nameWithType: Timer.Interval
  fullName: System.Timers.Timer.Interval
- uid: System.Timers.Timer.Site
  parent: System.Timers.Timer
  isExternal: false
  name: Site
  nameWithType: Timer.Site
  fullName: System.Timers.Timer.Site
- uid: System.ComponentModel.ISite
  parent: System.ComponentModel
  isExternal: false
  name: ISite
  nameWithType: ISite
  fullName: System.ComponentModel.ISite
- uid: System.Timers.Timer.Start
  parent: System.Timers.Timer
  isExternal: false
  name: Start()
  nameWithType: Timer.Start()
  fullName: System.Timers.Timer.Start()
- uid: System.Timers.Timer.Stop
  parent: System.Timers.Timer
  isExternal: false
  name: Stop()
  nameWithType: Timer.Stop()
  fullName: System.Timers.Timer.Stop()
- uid: System.Timers.Timer.SynchronizingObject
  parent: System.Timers.Timer
  isExternal: false
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
  fullName: System.Timers.Timer.SynchronizingObject
- uid: System.ComponentModel.ISynchronizeInvoke
  parent: System.ComponentModel
  isExternal: false
  name: ISynchronizeInvoke
  nameWithType: ISynchronizeInvoke
  fullName: System.ComponentModel.ISynchronizeInvoke
- uid: System.Timers.Timer.#ctor*
  parent: System.Timers.Timer
  isExternal: false
  name: Timer
  nameWithType: Timer.Timer
- uid: System.Timers.Timer.AutoReset*
  parent: System.Timers.Timer
  isExternal: false
  name: AutoReset
  nameWithType: Timer.AutoReset
- uid: System.Timers.Timer.BeginInit*
  parent: System.Timers.Timer
  isExternal: false
  name: BeginInit
  nameWithType: Timer.BeginInit
- uid: System.Timers.Timer.Close*
  parent: System.Timers.Timer
  isExternal: false
  name: Close
  nameWithType: Timer.Close
- uid: System.Timers.Timer.Dispose*
  parent: System.Timers.Timer
  isExternal: false
  name: Dispose
  nameWithType: Timer.Dispose
- uid: System.Timers.Timer.Enabled*
  parent: System.Timers.Timer
  isExternal: false
  name: Enabled
  nameWithType: Timer.Enabled
- uid: System.Timers.Timer.EndInit*
  parent: System.Timers.Timer
  isExternal: false
  name: EndInit
  nameWithType: Timer.EndInit
- uid: System.Timers.Timer.Interval*
  parent: System.Timers.Timer
  isExternal: false
  name: Interval
  nameWithType: Timer.Interval
- uid: System.Timers.Timer.Site*
  parent: System.Timers.Timer
  isExternal: false
  name: Site
  nameWithType: Timer.Site
- uid: System.Timers.Timer.Start*
  parent: System.Timers.Timer
  isExternal: false
  name: Start
  nameWithType: Timer.Start
- uid: System.Timers.Timer.Stop*
  parent: System.Timers.Timer
  isExternal: false
  name: Stop
  nameWithType: Timer.Stop
- uid: System.Timers.Timer.SynchronizingObject*
  parent: System.Timers.Timer
  isExternal: false
  name: SynchronizingObject
  nameWithType: Timer.SynchronizingObject
