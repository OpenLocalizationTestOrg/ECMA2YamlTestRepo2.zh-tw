### YamlMime:ManagedReference
items:
- uid: System.Web.HttpContext
  id: HttpContext
  children:
  - System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)
  - System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)
  - System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})
  - System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)
  - System.Web.HttpContext.AddError(System.Exception)
  - System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})
  - System.Web.HttpContext.AllErrors
  - System.Web.HttpContext.AllowAsyncDuringSyncStages
  - System.Web.HttpContext.Application
  - System.Web.HttpContext.ApplicationInstance
  - System.Web.HttpContext.AsyncPreloadMode
  - System.Web.HttpContext.Cache
  - System.Web.HttpContext.ClearError
  - System.Web.HttpContext.Current
  - System.Web.HttpContext.CurrentHandler
  - System.Web.HttpContext.CurrentNotification
  - System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)
  - System.Web.HttpContext.Error
  - System.Web.HttpContext.GetAppConfig(System.String)
  - System.Web.HttpContext.GetConfig(System.String)
  - System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)
  - System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  - System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)
  - System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  - System.Web.HttpContext.GetSection(System.String)
  - System.Web.HttpContext.Handler
  - System.Web.HttpContext.IsCustomErrorEnabled
  - System.Web.HttpContext.IsDebuggingEnabled
  - System.Web.HttpContext.IsPostNotification
  - System.Web.HttpContext.IsWebSocketRequest
  - System.Web.HttpContext.IsWebSocketRequestUpgrading
  - System.Web.HttpContext.Items
  - System.Web.HttpContext.PageInstrumentation
  - System.Web.HttpContext.PreviousHandler
  - System.Web.HttpContext.Profile
  - System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)
  - System.Web.HttpContext.Request
  - System.Web.HttpContext.Response
  - System.Web.HttpContext.RewritePath(System.String)
  - System.Web.HttpContext.RewritePath(System.String,System.Boolean)
  - System.Web.HttpContext.RewritePath(System.String,System.String,System.String)
  - System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)
  - System.Web.HttpContext.Server
  - System.Web.HttpContext.Session
  - System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)
  - System.Web.HttpContext.SkipAuthorization
  - System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)
  - System.Web.HttpContext.ThreadAbortOnTimeout
  - System.Web.HttpContext.Timestamp
  - System.Web.HttpContext.Trace
  - System.Web.HttpContext.User
  - System.Web.HttpContext.WebSocketNegotiatedProtocol
  - System.Web.HttpContext.WebSocketRequestedProtocols
  langs:
  - csharp
  name: HttpContext
  nameWithType: HttpContext
  fullName: System.Web.HttpContext
  type: Class
  summary: "封裝所有關於個別 HTTP 要求的 HTTP 特定資訊。"
  remarks: "繼承的類別<xref:System.Web.IHttpModule>和<xref:System.Web.IHttpHandler>介面可供目前的 HTTP 要求的 HttpContext 物件的參考。</xref:System.Web.IHttpHandler> </xref:System.Web.IHttpModule> 此物件提供存取內建<xref:System.Web.HttpContext.Request%2A>， <xref:System.Web.HttpContext.Response%2A>，和<xref:System.Web.HttpContext.Server%2A>要求屬性。</xref:System.Web.HttpContext.Server%2A> </xref:System.Web.HttpContext.Response%2A> </xref:System.Web.HttpContext.Request%2A>"
  example:
  - "A Visual Studio Web site project with source code is available to accompany this topic: [Download](http://go.microsoft.com/fwlink/?LinkId=192422).  \n  \n The following example demonstrates how to access and display properties of the HttpContext object. The context of the current HTTP request is accessed by using the <xref:System.Web.UI.Page.Context%2A> property of the <xref:System.Web.UI.Page> object.  \n  \n [!code-vb[System.Web.HttpContext#1](~/add/codesnippet/visualbasic/t-system.web.httpcontext_1.aspx)]\n [!code-cs[System.Web.HttpContext#1](~/add/codesnippet/csharp/t-system.web.httpcontext_1.aspx)]"
  syntax:
    content: 'public sealed class HttpContext : IServiceProvider'
  inheritance:
  - System.Object
  implements:
  - System.IServiceProvider
  inheritedMembers: []
  platform:
  - net462
- uid: System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)
  id: '#ctor(System.Web.HttpWorkerRequest)'
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: HttpContext(HttpWorkerRequest)
  nameWithType: HttpContext.HttpContext(HttpWorkerRequest)
  fullName: System.Web.HttpContext.HttpContext(HttpWorkerRequest)
  type: Constructor
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "初始化的新執行個體<xref href=&quot;System.Web.HttpContext&quot;></xref>會使用指定的背景工作要求物件的類別。"
  syntax:
    content: public HttpContext (System.Web.HttpWorkerRequest wr);
    parameters:
    - id: wr
      type: System.Web.HttpWorkerRequest
      description: "<xref href=&quot;System.Web.HttpWorkerRequest&quot;> </xref>目前 HTTP 要求的物件。"
  overload: System.Web.HttpContext.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)
  id: '#ctor(System.Web.HttpRequest,System.Web.HttpResponse)'
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: HttpContext(HttpRequest,HttpResponse)
  nameWithType: HttpContext.HttpContext(HttpRequest,HttpResponse)
  fullName: System.Web.HttpContext.HttpContext(HttpRequest,HttpResponse)
  type: Constructor
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "初始化的新執行個體<xref href=&quot;System.Web.HttpContext&quot;></xref>使用指定的要求和回應物件的類別。"
  syntax:
    content: public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);
    parameters:
    - id: request
      type: System.Web.HttpRequest
      description: "<xref href=&quot;System.Web.HttpRequest&quot;> </xref>目前 HTTP 要求的物件。"
    - id: response
      type: System.Web.HttpResponse
      description: "<xref href=&quot;System.Web.HttpResponse&quot;> </xref>目前 HTTP 要求的物件。"
  overload: System.Web.HttpContext.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})
  id: AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>)
  nameWithType: HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>)
  fullName: System.Web.HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "接受<xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;></xref>要求使用指定的使用者函式。"
  remarks: "呼叫這個方法相當於呼叫<xref:System.Web.HttpContext.AcceptWebSocketRequest%2A>方法多載，並傳遞`null`如`options`參數。</xref:System.Web.HttpContext.AcceptWebSocketRequest%2A>"
  syntax:
    content: public void AcceptWebSocketRequest (Func<System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task> userFunc);
    parameters:
    - id: userFunc
      type: System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task}
      description: "使用者函式。"
  overload: System.Web.HttpContext.AcceptWebSocketRequest*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>userFunc</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "要求並非<xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;></xref>要求。"
  platform:
  - net462
- uid: System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)
  id: AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>,AspNetWebSocketOptions)
  nameWithType: HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>,AspNetWebSocketOptions)
  fullName: System.Web.HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>,AspNetWebSocketOptions)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "接受<xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;></xref>要求使用指定的使用者函式和選項物件。"
  syntax:
    content: public void AcceptWebSocketRequest (Func<System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task> userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);
    parameters:
    - id: userFunc
      type: System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task}
      description: "使用者函式。"
    - id: options
      type: System.Web.WebSockets.AspNetWebSocketOptions
      description: "選項物件。"
  overload: System.Web.HttpContext.AcceptWebSocketRequest*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>userFunc</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "要求並非<xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;></xref>要求。"
  platform:
  - net462
- uid: System.Web.HttpContext.AddError(System.Exception)
  id: AddError(System.Exception)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: AddError(Exception)
  nameWithType: HttpContext.AddError(Exception)
  fullName: System.Web.HttpContext.AddError(Exception)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "例外狀況加入目前 HTTP 要求的例外狀況集合。"
  syntax:
    content: public void AddError (Exception errorInfo);
    parameters:
    - id: errorInfo
      type: System.Exception
      description: "<xref:System.Exception>要加入例外狀況集合。</xref:System.Exception>"
  overload: System.Web.HttpContext.AddError*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})
  id: AddOnRequestCompleted(System.Action{System.Web.HttpContext})
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: AddOnRequestCompleted(Action<HttpContext>)
  nameWithType: HttpContext.AddOnRequestCompleted(Action<HttpContext>)
  fullName: System.Web.HttpContext.AddOnRequestCompleted(Action<HttpContext>)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "引發虛擬事件結束的 HTTP 要求的一部分時所發生的事件。"
  remarks: "此事件之前發生<xref:System.Web.WebSockets.AspNetWebSocket>連接一開始都會。</xref:System.Web.WebSockets.AspNetWebSocket>"
  syntax:
    content: public System.Web.ISubscriptionToken AddOnRequestCompleted (Action<System.Web.HttpContext> callback);
    parameters:
    - id: callback
      type: System.Action{System.Web.HttpContext}
      description: "HTTP 內容物件。"
    return:
      type: System.Web.ISubscriptionToken
      description: "訂閱語彙基元。"
  overload: System.Web.HttpContext.AddOnRequestCompleted*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>callback</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Web.HttpContext.AllErrors
  id: AllErrors
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: AllErrors
  nameWithType: HttpContext.AllErrors
  fullName: System.Web.HttpContext.AllErrors
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得處理 HTTP 要求時累積的錯誤陣列。"
  syntax:
    content: public Exception[] AllErrors { get; }
    return:
      type: System.Exception[]
      description: "陣列<xref:System.Exception>目前 HTTP 要求的物件。</xref:System.Exception>"
  overload: System.Web.HttpContext.AllErrors*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.AllowAsyncDuringSyncStages
  id: AllowAsyncDuringSyncStages
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: AllowAsyncDuringSyncStages
  nameWithType: HttpContext.AllowAsyncDuringSyncStages
  fullName: System.Web.HttpContext.AllowAsyncDuringSyncStages
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得或設定值，指出 ASP.NET 要求處理未預期的組件期間，是否允許非同步作業。"
  remarks: "如果這個旗標未設為`true`，ASP.NET 將會擲回例外狀況，當它偵測到濫用非同步 API 的應用程式。 如果您嘗試呼叫非同步方法時，部分的要求處理管線，未預期的非同步作業，或如果沒有仍未完成的非同步工作時，非同步模組或處理常式發出訊號完成，這可能會發生。 此行為可作為安全網，可讓您知道在初期是否您正在撰寫非同步程式碼不符合預期模式和可能有負面影響。"
  syntax:
    content: public bool AllowAsyncDuringSyncStages { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>如果 ASP.NET 會擲回例外狀況時不應該; 一次使用了非同步 API否則， <xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.HttpContext.AllowAsyncDuringSyncStages*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Application
  id: Application
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Application
  nameWithType: HttpContext.Application
  fullName: System.Web.HttpContext.Application
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得<xref href=&quot;System.Web.HttpApplicationState&quot;></xref>目前 HTTP 要求的物件。"
  syntax:
    content: public System.Web.HttpApplicationState Application { get; }
    return:
      type: System.Web.HttpApplicationState
      description: "<xref href=&quot;System.Web.HttpApplicationState&quot;> </xref>目前 HTTP 要求。       若要取得<xref href=&quot;System.Web.HttpApplication&quot;></xref>目前 HTTP 要求的物件，請使用<xref:System.Web.HttpContext.ApplicationInstance*>.</xref:System.Web.HttpContext.ApplicationInstance*> (ASP.NET 會使用<xref uid=&quot;langword_csharp_ApplicationInstance&quot; name=&quot;ApplicationInstance&quot; href=&quot;&quot;></xref>而不是<xref uid=&quot;langword_csharp_Application&quot; name=&quot;Application&quot; href=&quot;&quot;></xref>做為屬性名稱來參考目前<xref href=&quot;System.Web.HttpApplication&quot;></xref>執行個體，以避免 ASP.NET 與傳統 ASP 混淆。 在傳統 ASP 中， <xref uid=&quot;langword_csharp_Application&quot; name=&quot;Application&quot; href=&quot;&quot;> </xref>參考全域應用程式狀態字典。)"
  overload: System.Web.HttpContext.Application*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.ApplicationInstance
  id: ApplicationInstance
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: ApplicationInstance
  nameWithType: HttpContext.ApplicationInstance
  fullName: System.Web.HttpContext.ApplicationInstance
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得或設定<xref href=&quot;System.Web.HttpApplication&quot;></xref>目前 HTTP 要求的物件。"
  syntax:
    content: public System.Web.HttpApplication ApplicationInstance { get; set; }
    return:
      type: System.Web.HttpApplication
      description: "<xref href=&quot;System.Web.HttpApplication&quot;> </xref>目前 HTTP 要求。       ASP.NET 會使用<xref uid=&quot;langword_csharp_ApplicationInstance&quot; name=&quot;ApplicationInstance&quot; href=&quot;&quot;></xref>而不是<xref uid=&quot;langword_csharp_Application&quot; name=&quot;Application&quot; href=&quot;&quot;></xref>做為屬性名稱來參考目前<xref href=&quot;System.Web.HttpApplication&quot;></xref>執行個體，以避免 ASP.NET 與傳統 ASP 混淆。 在傳統 ASP 中， <xref uid=&quot;langword_csharp_Application&quot; name=&quot;Application&quot; href=&quot;&quot;> </xref>參考全域應用程式狀態字典。"
  overload: System.Web.HttpContext.ApplicationInstance*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "IIS 7.0 執行 Web 應用程式中整合模式中，並嘗試從非 null 值則變更屬性值<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.Web.HttpContext.AsyncPreloadMode
  id: AsyncPreloadMode
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: AsyncPreloadMode
  nameWithType: HttpContext.AsyncPreloadMode
  fullName: System.Web.HttpContext.AsyncPreloadMode
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得或設定物件，其中包含有關非同步預先載入模式之旗標。"
  remarks: "第一次存取這個屬性時，包含非同步預先載入模式的旗標的物件載入從<xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A>組態檔中設定。</xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A>       雖然可以透過程式設計方式設定這個屬性，變更屬性值只會有影響之前設定屬性如果`ExecuteRequestHandler`ASP.NET 要求管線中的步驟。"
  syntax:
    content: public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }
    return:
      type: System.Web.Configuration.AsyncPreloadModeFlags
      description: "包含有關非同步預先載入模式之旗標的物件。"
  overload: System.Web.HttpContext.AsyncPreloadMode*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Cache
  id: Cache
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Cache
  nameWithType: HttpContext.Cache
  fullName: System.Web.HttpContext.Cache
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得<xref href=&quot;System.Web.Caching.Cache&quot;></xref>物件目前的應用程式定義域。"
  remarks: "一個執行個體的<xref:System.Web.Caching.Cache>類別每個應用程式網域。</xref:System.Web.Caching.Cache> 如此一來，<xref:System.Web.Caching.Cache>快取屬性所傳回的物件是<xref:System.Web.Caching.Cache>應用程式定義域中的所有要求的物件。</xref:System.Web.Caching.Cache> </xref:System.Web.Caching.Cache>"
  syntax:
    content: public System.Web.Caching.Cache Cache { get; }
    return:
      type: System.Web.Caching.Cache
      description: "<xref href=&quot;System.Web.Caching.Cache&quot;> </xref>目前的應用程式定義域。"
  overload: System.Web.HttpContext.Cache*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.ClearError
  id: ClearError
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: ClearError()
  nameWithType: HttpContext.ClearError()
  fullName: System.Web.HttpContext.ClearError()
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "清除目前 HTTP 要求的所有錯誤。"
  syntax:
    content: public void ClearError ();
    parameters: []
  overload: System.Web.HttpContext.ClearError*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Current
  id: Current
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Current
  nameWithType: HttpContext.Current
  fullName: System.Web.HttpContext.Current
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得或設定<xref href=&quot;System.Web.HttpContext&quot;></xref>目前 HTTP 要求的物件。"
  remarks: "這個屬性是類別的靜態屬性<xref:System.Web.HttpContext>類別。</xref:System.Web.HttpContext> 屬性存放區<xref:System.Web.HttpContext>套用至目前要求的執行個體。</xref:System.Web.HttpContext> 這個執行個體的屬性是<xref:System.Web.HttpContext>類別</xref:System.Web.HttpContext>的非靜態屬性       您也可以使用<xref:System.Web.UI.Page.Context%2A?displayProperty=fullName>屬性來存取<xref:System.Web.HttpContext>目前 HTTP 要求的物件。</xref:System.Web.HttpContext> </xref:System.Web.UI.Page.Context%2A?displayProperty=fullName>"
  example:
  - "The following code example uses the Current property to access the <xref:System.Web.HttpContext.AddError%2A?displayProperty=fullName> and <xref:System.Web.HttpContext.ClearError%2A?displayProperty=fullName> methods and the <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=fullName> property. The example creates three custom exceptions using the <xref:System.Web.HttpContext.AddError%2A> method and uses the <xref:System.Web.HttpContext.AllErrors%2A> property to load these exceptions to an array. It then writes the array to the containing page and uses the <xref:System.Web.HttpContext.ClearError%2A> method to clear all the errors from the <xref:System.Web.UI.Page.Context%2A> property.  \n  \n```c#  \nprotected void Page_Load(object sender, EventArgs e)  \n{  \n    HttpContext context = HttpContext.Current;  \n    Response.Write(\"<p>HttpContext.Current Example:</p>\");  \n  \n    // Add three custom exceptions.  \n    context.AddError(new Exception(\"New Exception #1\"));  \n    context.AddError(new Exception(\"New Exception #2\"));  \n    context.AddError(new Exception(\"New Exception #3\"));  \n  \n    // Capture all the new Exceptions in an array.  \n    Exception[] errs = context.AllErrors;  \n  \n    foreach (Exception ex in errs)  \n    {  \n        Response.Write(\"<p>\" + Server.HtmlEncode(ex.ToString()) + \"</p>\");  \n    }  \n  \n    // Clear the exceptions so ASP.NET won't handle them.  \n    context.ClearError();  \n}  \n```  \n  \n```vb  \nProtected Sub Page_Load(sender As Object, e As EventArgs)  \nDim context As HttpContext = HttpContext.Current  \nResponse.Write(\"<p>HttpContext.Current Example:</p>\")  \n  \n' Add three custom exceptions.  \ncontext.AddError(New Exception(\"New Exception #1\"))  \ncontext.AddError(New Exception(\"New Exception #2\"))  \ncontext.AddError(New Exception(\"New Exception #3\"))  \n  \n' Capture all the new Exceptions in an array.  \nDim errs As Exception() = context.AllErrors  \n  \nFor Each ex As Exception In errs  \nResponse.Write(\"<p>\" & Server.HtmlEncode(ex.ToString()) & \"</p>\")  \nNext  \n  \n' Clear the exceptions so ASP.NET won't handle them.  \ncontext.ClearError()  \nEnd Sub  \n  \n```"
  syntax:
    content: public static System.Web.HttpContext Current { get; set; }
    return:
      type: System.Web.HttpContext
      description: "<xref href=&quot;System.Web.HttpContext&quot;> </xref>目前 HTTP 要求的執行個體。"
  overload: System.Web.HttpContext.Current*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.CurrentHandler
  id: CurrentHandler
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: CurrentHandler
  nameWithType: HttpContext.CurrentHandler
  fullName: System.Web.HttpContext.CurrentHandler
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得<xref href=&quot;System.Web.IHttpHandler&quot;></xref>物件，代表目前正在執行的處理常式。"
  remarks: "CurrentHandler 屬性所參考之目前正在執行處理常式可能不同於所參考的處理常式<xref:System.Web.HttpContext.Handler%2A>屬性。</xref:System.Web.HttpContext.Handler%2A> 這可能是另一個處理常式使用要求時<xref:System.Web.HttpServerUtility.Execute%2A>方法或<xref:System.Web.HttpServerUtility.Transfer%2A>方法。</xref:System.Web.HttpServerUtility.Transfer%2A> </xref:System.Web.HttpServerUtility.Execute%2A> 當目前正在執行的處理常式完成處理時，會還原先前決定的處理常式。"
  syntax:
    content: public System.Web.IHttpHandler CurrentHandler { get; }
    return:
      type: System.Web.IHttpHandler
      description: "<xref href=&quot;System.Web.IHttpHandler&quot;> </xref> ，代表目前正在執行的處理常式。"
  overload: System.Web.HttpContext.CurrentHandler*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.CurrentNotification
  id: CurrentNotification
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: CurrentNotification
  nameWithType: HttpContext.CurrentNotification
  fullName: System.Web.HttpContext.CurrentNotification
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得<xref href=&quot;System.Web.RequestNotification&quot;></xref>值，指出目前<xref href=&quot;System.Web.HttpApplication&quot;></xref>正在處理的事件。"
  remarks: "CurrentNotification 屬性需要的整合式的管線模式中[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]且至少為.NET Framework 3.0 版。 屬性可用時，傳回<xref:System.Web.RequestNotification>值。</xref:System.Web.RequestNotification> CurrentNotification 屬性的值會指出在哪些事件<xref:System.Web.HttpApplication>執行個體目前正在處理要求。</xref:System.Web.HttpApplication>       CurrentNotification 屬性不是要設定。 相反地，它由所設定[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]ASP.NET 管線中的要求處理期間。 將 CurrentNotification 屬性，將會造成編譯錯誤。       .NET Framework 3.5 版中引進 CurrentNotification。  如需詳細資訊，請參閱[版本和相依性](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example demonstrates how to use the CurrentNotification property to determine what event of the <xref:System.Web.HttpApplication> object that is handling the current request is being processed. In the example, the event handler handles several events of the <xref:System.Web.HttpApplication> object, and the CurrentNotification property determines what code is invoked for each event being handled.  \n  \n [!code-cs[System.Web.HttpResponse.IsPostNotification#1](~/add/codesnippet/csharp/p-system.web.httpcontext_0_1.cs)]\n [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/add/codesnippet/visualbasic/p-system.web.httpcontext_0_1.vb)]"
  syntax:
    content: public System.Web.RequestNotification CurrentNotification { get; }
    return:
      type: System.Web.RequestNotification
      description: "其中一個<xref href=&quot;System.Web.RequestNotification&quot;></xref>值。"
  overload: System.Web.HttpContext.CurrentNotification*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "此作業需要整合式的管線模式中[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]且至少為.NET Framework 3.0 版。"
  platform:
  - net462
- uid: System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)
  id: DisposeOnPipelineCompleted(System.IDisposable)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: DisposeOnPipelineCompleted(IDisposable)
  nameWithType: HttpContext.DisposeOnPipelineCompleted(IDisposable)
  fullName: System.Web.HttpContext.DisposeOnPipelineCompleted(IDisposable)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "讓物件的<xref:System.IDisposable.Dispose*>時要呼叫的方法<xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;></xref>這項要求的連接部分完成。</xref:System.IDisposable.Dispose*>"
  remarks: "<xref:System.IDisposable.Dispose%2A>目標物件的方法呼叫之後這兩個 HTTP 要求一部分而<xref:System.Web.WebSockets.AspNetWebSocket>連線已經結束。</xref:System.Web.WebSockets.AspNetWebSocket> </xref:System.IDisposable.Dispose%2A> <xref:System.Web.HttpContext>物件不能進行檢查。</xref:System.Web.HttpContext>"
  syntax:
    content: public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);
    parameters:
    - id: target
      type: System.IDisposable
      description: "物件的<xref:System.IDisposable.Dispose*>方法時，必須呼叫<xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;></xref>要求的連接部分完成。</xref:System.IDisposable.Dispose*>"
    return:
      type: System.Web.ISubscriptionToken
      description: "訂閱語彙基元。"
  overload: System.Web.HttpContext.DisposeOnPipelineCompleted*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Error
  id: Error
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Error
  nameWithType: HttpContext.Error
  fullName: System.Web.HttpContext.Error
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得 HTTP 期間未累積的第一個錯誤 （如果有的話） 要求處理。"
  syntax:
    content: public Exception Error { get; }
    return:
      type: System.Exception
      description: "第一個<xref:System.Exception>目前 HTTP 要求/回應處理，否則<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果 HTTP 要求處理期間未不累積任何錯誤。</xref:System.Exception> 預設值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.HttpContext.Error*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.GetAppConfig(System.String)
  id: GetAppConfig(System.String)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: GetAppConfig(String)
  nameWithType: HttpContext.GetAppConfig(String)
  fullName: System.Web.HttpContext.GetAppConfig(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "傳回要求目前的應用程式的組態資訊。"
  remarks: "GetAppConfig 方法已被取代。 使用<xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A>方法<xref:System.Web.Configuration.WebConfigurationManager>類別，以取得目前應用程式的組態資訊。</xref:System.Web.Configuration.WebConfigurationManager> </xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A>"
  syntax:
    content: public static object GetAppConfig (string name);
    parameters:
    - id: name
      type: System.String
      description: "要求資訊的應用程式組態標記。"
    return:
      type: System.Object
      description: "包含組態資訊的物件。 （轉型成適當的組態類型再使用傳回的組態 > 一節）。"
  overload: System.Web.HttpContext.GetAppConfig*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.GetConfig(System.String)
  id: GetConfig(System.String)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: GetConfig(String)
  nameWithType: HttpContext.GetConfig(String)
  fullName: System.Web.HttpContext.GetConfig(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "傳回要求目前 HTTP 要求的組態資訊。"
  remarks: "GetConfig 方法已被取代。 使用<xref:System.Web.HttpContext.GetSection%2A>方法來取得目前 HTTP 要求的組態資訊。</xref:System.Web.HttpContext.GetSection%2A>"
  syntax:
    content: public object GetConfig (string name);
    parameters:
    - id: name
      type: System.String
      description: "要求資訊的組態標記。"
    return:
      type: System.Object
      description: "指定<xref href=&quot;System.Configuration.ConfigurationSection&quot;> </xref>， <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>如果區段不存在，或存取區段，則不在執行階段為內部物件。 （轉型成適當的組態類型再使用傳回的物件）。"
  overload: System.Web.HttpContext.GetConfig*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)
  id: GetGlobalResourceObject(System.String,System.String)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: GetGlobalResourceObject(String,String)
  nameWithType: HttpContext.GetGlobalResourceObject(String,String)
  fullName: System.Web.HttpContext.GetGlobalResourceObject(String,String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得應用程式層級資源物件是根據指定<> *> 和<> *> 屬性。"
  remarks: "GetGlobalResourceObject 方法會傳回使用中指定的文化特性的全域資源<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>屬性。</xref:System.Globalization.CultureInfo.CurrentUICulture%2A>      > [!NOTE] > 的某些編輯環境，例如[!INCLUDE[vwprvw](~/add/includes/vwprvw-md.md)]，編輯器可能會擲回設計階段<xref:System.Resources.MissingManifestResourceException>例外狀況，如果您在全域資源金鑰名稱中使用句號 （.）。</xref:System.Resources.MissingManifestResourceException> 不過，這不會影響您要編輯或儲存檔案，而且您可以忽略此錯誤。"
  syntax:
    content: public static object GetGlobalResourceObject (string classKey, string resourceKey);
    parameters:
    - id: classKey
      type: System.String
      description: "字串，代表<xref:System.Web.Compilation.ResourceExpressionFields.ClassKey*>要求之資源物件的屬性。</xref:System.Web.Compilation.ResourceExpressionFields.ClassKey*>"
    - id: resourceKey
      type: System.String
      description: "字串，代表<xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>要求之資源物件的屬性。</xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>"
    return:
      type: System.Object
      description: "<xref:System.Object>，代表所要求的應用程式層級資源物件; 否則為 null，如果找不到資源物件，或資源物件已找到但其沒有要求的屬性。</xref:System.Object>"
  overload: System.Web.HttpContext.GetGlobalResourceObject*
  exceptions:
  - type: System.Resources.MissingManifestResourceException
    commentId: T:System.Resources.MissingManifestResourceException
    description: "A resource object with the specified <code>classKey</code> parameter was not found.  \n  \n \\- or -  \n  \n The main assembly does not contain the resources for the neutral culture, and these resources are required because the appropriate satellite assembly is missing."
  platform:
  - net462
- uid: System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  id: GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: GetGlobalResourceObject(String,String,CultureInfo)
  nameWithType: HttpContext.GetGlobalResourceObject(String,String,CultureInfo)
  fullName: System.Web.HttpContext.GetGlobalResourceObject(String,String,CultureInfo)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得應用程式層級資源物件是根據指定<> *> 和<> *> 內容，然後在<xref:System.Globalization.CultureInfo>物件。</xref:System.Globalization.CultureInfo>"
  remarks: "<xref:System.Globalization.CultureInfo>物件代表的資源已當地語系化的文化特性。</xref:System.Globalization.CultureInfo> 如果未針對這個文化特性當地語系化的資源，則查詢會遵循找出適當的資源後援程序。 如需詳細資訊，請參閱[封裝和部署資源](~/add/includes/ajax-current-ext-md.md)。      > [!NOTE] > 中某些編輯環境中，Visual Web Developer 中，例如編輯器 中可能會擲回設計階段<xref:System.Resources.MissingManifestResourceException>例外狀況，如果您在全域資源金鑰名稱中使用句號 （.）。</xref:System.Resources.MissingManifestResourceException> 不過，這不會影響您要編輯或儲存檔案，而且您可以忽略此錯誤。"
  syntax:
    content: public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);
    parameters:
    - id: classKey
      type: System.String
      description: "字串，代表<xref:System.Web.Compilation.ResourceExpressionFields.ClassKey*>要求之資源物件的屬性。</xref:System.Web.Compilation.ResourceExpressionFields.ClassKey*>"
    - id: resourceKey
      type: System.String
      description: "字串，代表<xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>要求之資源物件的屬性。</xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "字串，代表<xref:System.Globalization.CultureInfo>要求之資源的物件。</xref:System.Globalization.CultureInfo>"
    return:
      type: System.Object
      description: "<xref:System.Object>，代表所要求的應用程式層級資源物件，會針對指定的文化特性當地語系化，否則<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果找不到資源物件，或如果找到的資源物件，但它並沒有要求的屬性。</xref:System.Object>"
  overload: System.Web.HttpContext.GetGlobalResourceObject*
  exceptions:
  - type: System.Resources.MissingManifestResourceException
    commentId: T:System.Resources.MissingManifestResourceException
    description: "A resource object for which the specified <code>classKey</code> parameter was not found.  \n  \n \\- or -  \n  \n The main assembly does not contain the resources for the neutral culture, and these resources are required because the appropriate satellite assembly is missing."
  platform:
  - net462
- uid: System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)
  id: GetLocalResourceObject(System.String,System.String)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: GetLocalResourceObject(String,String)
  nameWithType: HttpContext.GetLocalResourceObject(String,String)
  fullName: System.Web.HttpContext.GetLocalResourceObject(String,String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得頁面層級資源物件是根據指定<> *> 和<> *> 屬性。"
  remarks: "GetLocalResourceObject 方法會傳回本機資源使用中指定的文化特性<xref:System.Globalization.CultureInfo.CurrentUICulture%2A>屬性。</xref:System.Globalization.CultureInfo.CurrentUICulture%2A>"
  syntax:
    content: public static object GetLocalResourceObject (string virtualPath, string resourceKey);
    parameters:
    - id: virtualPath
      type: System.String
      description: "<xref:System.Web.Compilation.ExpressionBuilderContext.VirtualPath*>本機資源物件的屬性。</xref:System.Web.Compilation.ExpressionBuilderContext.VirtualPath*>"
    - id: resourceKey
      type: System.String
      description: "字串，代表<xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>所要求之資源物件的屬性</xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>"
    return:
      type: System.Object
      description: "<xref:System.Object>，代表所要求的頁面層級資源物件; 否則<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果找到相符的資源物件而非<code> resourceKey </code>參數。</xref:System.Object>"
  overload: System.Web.HttpContext.GetLocalResourceObject*
  exceptions:
  - type: System.Resources.MissingManifestResourceException
    commentId: T:System.Resources.MissingManifestResourceException
    description: "找不到資源物件指定<code> virtualPath </code>參數。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定<code> virtualPath </code>參數不是目前的應用程式根目錄中。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "找不到頁面的資源類別。"
  platform:
  - net462
- uid: System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  id: GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: GetLocalResourceObject(String,String,CultureInfo)
  nameWithType: HttpContext.GetLocalResourceObject(String,String,CultureInfo)
  fullName: System.Web.HttpContext.GetLocalResourceObject(String,String,CultureInfo)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得頁面層級資源物件是根據指定<> *> 和<> *> 內容，然後在<xref:System.Globalization.CultureInfo>物件。</xref:System.Globalization.CultureInfo>"
  remarks: "如果未針對這個文化特性當地語系化的資源，則查詢會遵循找出適當的資源後援程序。 如需詳細資訊，請參閱[封裝和部署資源](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);
    parameters:
    - id: virtualPath
      type: System.String
      description: "<xref:System.Web.Compilation.ExpressionBuilderContext.VirtualPath*>本機資源物件的屬性。</xref:System.Web.Compilation.ExpressionBuilderContext.VirtualPath*>"
    - id: resourceKey
      type: System.String
      description: "字串，代表<xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>要求之資源物件的屬性。</xref:System.Web.Compilation.ResourceExpressionFields.ResourceKey*>"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "字串，代表<xref:System.Globalization.CultureInfo>要求之資源物件的物件。</xref:System.Globalization.CultureInfo>"
    return:
      type: System.Object
      description: "<xref:System.Object>，代表所要求的本機資源物件，針對指定的文化特性當地語系化; 否則為<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果找到相符的資源物件而非<code> resourceKey </code>參數。</xref:System.Object>"
  overload: System.Web.HttpContext.GetLocalResourceObject*
  exceptions:
  - type: System.Resources.MissingManifestResourceException
    commentId: T:System.Resources.MissingManifestResourceException
    description: "找不到資源物件指定<code> virtualPath </code>參數。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "指定<code> virtualPath </code>參數不是目前的應用程式根目錄中。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "找不到頁面的資源類別。"
  platform:
  - net462
- uid: System.Web.HttpContext.GetSection(System.String)
  id: GetSection(System.String)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: GetSection(String)
  nameWithType: HttpContext.GetSection(String)
  fullName: System.Web.HttpContext.GetSection(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得目前應用程式的預設組態的指定的組態區段。"
  syntax:
    content: public object GetSection (string sectionName);
    parameters:
    - id: sectionName
      type: System.String
      description: "組態區段路徑 （XPath 格式） 和組態項目名稱。"
    return:
      type: System.Object
      description: "指定<xref href=&quot;System.Configuration.ConfigurationSection&quot;> </xref>， <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>如果區段不存在，或存取區段，則不在執行階段為內部物件。"
  overload: System.Web.HttpContext.GetSection*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Handler
  id: Handler
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Handler
  nameWithType: HttpContext.Handler
  fullName: System.Web.HttpContext.Handler
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得或設定<xref href=&quot;System.Web.IHttpHandler&quot;></xref>負責處理 HTTP 要求的物件。"
  remarks: "處理常式屬性包含處理常式來處理 HTTP 要求的參考。 使用項目，或使用使用者程式碼中定義的自訂處理常式，則可以指定的處理常式。 如需有關處理常式的詳細資訊，請參閱[HTTP 處理常式和 HTTP 模組概觀](~/add/includes/ajax-current-ext-md.md)。       即使目前的頁面已變更伺服器端方法，例如，處理常式屬性的參考會維持相同<xref:System.Web.HttpServerUtility.Execute%2A>方法或<xref:System.Web.HttpServerUtility.Transfer%2A>方法。</xref:System.Web.HttpServerUtility.Transfer%2A> </xref:System.Web.HttpServerUtility.Execute%2A>"
  syntax:
    content: public System.Web.IHttpHandler Handler { get; set; }
    return:
      type: System.Web.IHttpHandler
      description: "<xref href=&quot;System.Web.IHttpHandler&quot;> </xref>負責處理 HTTP 要求。"
  overload: System.Web.HttpContext.Handler*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.IsCustomErrorEnabled
  id: IsCustomErrorEnabled
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: IsCustomErrorEnabled
  nameWithType: HttpContext.IsCustomErrorEnabled
  fullName: System.Web.HttpContext.IsCustomErrorEnabled
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得值，指出是否對目前 HTTP 要求啟用自訂錯誤。"
  syntax:
    content: public bool IsCustomErrorEnabled { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果啟用自訂錯誤。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.HttpContext.IsCustomErrorEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.IsDebuggingEnabled
  id: IsDebuggingEnabled
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: IsDebuggingEnabled
  nameWithType: HttpContext.IsDebuggingEnabled
  fullName: System.Web.HttpContext.IsDebuggingEnabled
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得值，指出目前的 HTTP 要求是否處於偵錯模式。"
  syntax:
    content: public bool IsDebuggingEnabled { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果要求處於偵錯模式，否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.HttpContext.IsDebuggingEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.IsPostNotification
  id: IsPostNotification
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: IsPostNotification
  nameWithType: HttpContext.IsPostNotification
  fullName: System.Web.HttpContext.IsPostNotification
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得值，是目前正在處理的點在 ASP.NET 之後管線<xref href=&quot;System.Web.HttpApplication&quot;></xref>事件是否處理完成。"
  remarks: "使用整合式模式中才支援 IsPostNotification 屬性[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]且至少.NET Framework 3.0。 屬性可用時，會傳回布林值，指出是否將事件列<xref:System.Web.HttpApplication>物件已完成處理。</xref:System.Web.HttpApplication>       IsPostNotification 屬性不是要設定。 相反地，它由[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]ASP.NET 執行階段，每個通知。 將 IsPostNotification 屬性，將會造成編譯錯誤。       在案例中，<xref:System.Web.HttpApplication>物件由一個事件處理常式處理，您可以使用 IsPostNotification 中的屬性與<xref:System.Web.RequestNotification>列舉型別精確地判斷供應用程式生命週期中目前的要求使用現有的設定</xref:System.Web.RequestNotification>組合</xref:System.Web.HttpApplication>的多個事件       .NET Framework 3.5 版中引進 IsPostNotification。  如需詳細資訊，請參閱[版本和相依性](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example demonstrates how to use the IsPostNotification property to determine when an event of the <xref:System.Web.HttpApplication> object has finished processing all the associated event handlers. The custom event handler in this example handles several events of the <xref:System.Web.HttpApplication> object, and the IsPostNotification property is used to determine what code is invoked after a specific event is handled.  \n  \n [!code-cs[System.Web.HttpResponse.IsPostNotification#1](~/add/codesnippet/csharp/p-system.web.httpcontext_2_1.cs)]\n [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/add/codesnippet/visualbasic/p-system.web.httpcontext_2_1.vb)]"
  syntax:
    content: public bool IsPostNotification { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果啟用自訂錯誤。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.HttpContext.IsPostNotification*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "此作業需要的整合式的管線模式中[!INCLUDE[iisver](~/add/includes/ajax-current-ext-md.md)]且至少.NET Framework 3.0。"
  platform:
  - net462
- uid: System.Web.HttpContext.IsWebSocketRequest
  id: IsWebSocketRequest
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: IsWebSocketRequest
  nameWithType: HttpContext.IsWebSocketRequest
  fullName: System.Web.HttpContext.IsWebSocketRequest
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得值，指出要求是否<xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;></xref>要求。"
  remarks: "這個方法會傳回`true`如果要求包含初始<xref:System.Web.WebSockets.AspNetWebSocket>交握和`WebSocket`的 IIS 模組是使用中。</xref:System.Web.WebSockets.AspNetWebSocket>"
  syntax:
    content: public bool IsWebSocketRequest { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果要求是<xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;></xref>要求; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.HttpContext.IsWebSocketRequest*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.IsWebSocketRequestUpgrading
  id: IsWebSocketRequestUpgrading
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: IsWebSocketRequestUpgrading
  nameWithType: HttpContext.IsWebSocketRequestUpgrading
  fullName: System.Web.HttpContext.IsWebSocketRequestUpgrading
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得值，指出連接是否正從 HTTP 連接升級<xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;></xref>連線。"
  syntax:
    content: public bool IsWebSocketRequestUpgrading { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果連接正在升級。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.HttpContext.IsWebSocketRequestUpgrading*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Items
  id: Items
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Items
  nameWithType: HttpContext.Items
  fullName: System.Web.HttpContext.Items
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得索引鍵/值集合，可用來組織及共用資料之間<xref href=&quot;System.Web.IHttpModule&quot;></xref>介面和<xref href=&quot;System.Web.IHttpHandler&quot;></xref>在 HTTP 要求的介面。"
  syntax:
    content: public System.Collections.IDictionary Items { get; }
    return:
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>索引鍵/值集合，根據指定的索引鍵提供存取集合中個別值。</xref:System.Collections.IDictionary>"
  overload: System.Web.HttpContext.Items*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.PageInstrumentation
  id: PageInstrumentation
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: PageInstrumentation
  nameWithType: HttpContext.PageInstrumentation
  fullName: System.Web.HttpContext.PageInstrumentation
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得此要求的頁面檢測服務執行個體的參考。"
  syntax:
    content: public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }
    return:
      type: System.Web.Instrumentation.PageInstrumentationService
      description: "此要求的頁面檢測服務執行個體。"
  overload: System.Web.HttpContext.PageInstrumentation*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.PreviousHandler
  id: PreviousHandler
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: PreviousHandler
  nameWithType: HttpContext.PreviousHandler
  fullName: System.Web.HttpContext.PreviousHandler
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得<xref href=&quot;System.Web.IHttpHandler&quot;></xref>父處理常式的物件。"
  remarks: "PreviousHandler 屬性會對應到最後一個處理常式執行目前要求之前。"
  syntax:
    content: public System.Web.IHttpHandler PreviousHandler { get; }
    return:
      type: System.Web.IHttpHandler
      description: "<xref href=&quot;System.Web.IHttpHandler&quot;> </xref>執行個體，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果找不到任何先前的處理常式。"
  overload: System.Web.HttpContext.PreviousHandler*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Profile
  id: Profile
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Profile
  nameWithType: HttpContext.Profile
  fullName: System.Web.HttpContext.Profile
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得<xref href=&quot;System.Web.Profile.ProfileBase&quot;></xref>物件目前的使用者設定檔。"
  remarks: "設定檔屬性用於永續性儲存體的使用類型安全的應用程式開發介面的結構化資料。 當存取設定檔屬性，但沒有值存在，則會傳回空的執行個體。`null`就不會傳回。"
  syntax:
    content: public System.Web.Profile.ProfileBase Profile { get; }
    return:
      type: System.Web.Profile.ProfileBase
      description: "A <xref href=&quot;System.Web.Profile.ProfileBase&quot;> </xref>如果應用程式組態檔包含的定義檔的屬性; 否則<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.HttpContext.Profile*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)
  id: RemapHandler(System.Web.IHttpHandler)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: RemapHandler(IHttpHandler)
  nameWithType: HttpContext.RemapHandler(IHttpHandler)
  fullName: System.Web.HttpContext.RemapHandler(IHttpHandler)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "可讓您指定要求的處理常式。"
  remarks: "如果您設定`handler`至`null`的預設處理常式用來處理要求。 您可以設定`handler`非同步處理常式或同步處理常式。 此處理常式必須實作<xref:System.Web.IHttpHandler>介面。</xref:System.Web.IHttpHandler>"
  syntax:
    content: public void RemapHandler (System.Web.IHttpHandler handler);
    parameters:
    - id: handler
      type: System.Web.IHttpHandler
      description: "應該處理此要求的物件。"
  overload: System.Web.HttpContext.RemapHandler*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "RemapHandler 方法之後才呼叫<xref href=&quot;System.Web.HttpApplication.MapRequestHandler&quot;></xref>發生事件。"
  platform:
  - net462
- uid: System.Web.HttpContext.Request
  id: Request
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Request
  nameWithType: HttpContext.Request
  fullName: System.Web.HttpContext.Request
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得<xref href=&quot;System.Web.HttpRequest&quot;></xref>目前 HTTP 要求的物件。"
  remarks: "要求屬性提供以程式設計方式存取的屬性和方法的<xref:System.Web.HttpRequest>類別。</xref:System.Web.HttpRequest> 因為 ASP.NET 網頁包含預設參考<xref:System.Web>命名空間 (其中包含<xref:System.Web.HttpContext>類別)，您可以參考的成員<xref:System.Web.HttpRequest>在.aspx 頁面上，而不需要使用完整的類別參考至<xref:System.Web.HttpContext>。</xref:System.Web.HttpContext> </xref:System.Web.HttpRequest> </xref:System.Web.HttpContext> </xref:System.Web> 例如，您可以使用`Request.Browser`來取得用戶端瀏覽器的功能。 不過，如果您想要使用的成員<xref:System.Web.HttpRequest>從 ASP.NET 程式碼後置模組，您必須將參考併入到<xref:System.Web>命名空間模組以及目前作用中的要求/回應內容以及中的類別的完整的參考<xref:System.Web>您想要使用的。</xref:System.Web> </xref:System.Web> </xref:System.Web.HttpRequest> 例如，程式碼後置頁面在您必須指定完整格式的名稱`HttpContext.Current.Request.Browser`。      > [!NOTE] > ASP.NET 將會擲回例外狀況，如果您嘗試使用這個屬性時<xref:System.Web.HttpRequest>物件不能。</xref:System.Web.HttpRequest> 例如，這會在 Application_Start 方法的 Global.asax 檔案中，或從 Application_Start 方法呼叫的方法，則為 true。 在該時間有尚未建立任何 HTTP 要求。"
  syntax:
    content: public System.Web.HttpRequest Request { get; }
    return:
      type: System.Web.HttpRequest
      description: "<xref href=&quot;System.Web.HttpRequest&quot;> </xref>目前 HTTP 要求。"
  overload: System.Web.HttpContext.Request*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "Web 應用程式在 IIS 7 下執行，以整合模式。"
  platform:
  - net462
- uid: System.Web.HttpContext.Response
  id: Response
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Response
  nameWithType: HttpContext.Response
  fullName: System.Web.HttpContext.Response
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得<xref href=&quot;System.Web.HttpResponse&quot;></xref>目前 HTTP 回應物件。"
  remarks: "此回應屬性會提供以程式設計方式存取的屬性和方法的<xref:System.Web.HttpResponse>類別。</xref:System.Web.HttpResponse> 因為 ASP.NET 網頁包含預設參考<xref:System.Web>命名空間 (其中包含<xref:System.Web.HttpContext>類別)，您可以參考的成員<xref:System.Web.HttpContext>在.aspx 頁面上，而不需要使用完整的類別參考至<xref:System.Web.HttpContext>。</xref:System.Web.HttpContext> </xref:System.Web.HttpContext> </xref:System.Web.HttpContext> </xref:System.Web> 例如，您可以使用`Response.Write(&quot;some output&quot;)`將輸出寫入 HTTP 輸出資料流。 不過，如果您想要使用的成員<xref:System.Web.HttpResponse>從 ASP.NET 程式碼後置模組，您必須將參考併入到<xref:System.Web>模組和目前作用中的要求/回應內容的完整的參考中的類別中的命名空間<xref:System.Web>您想要使用的。</xref:System.Web> </xref:System.Web> </xref:System.Web.HttpResponse> 例如，程式碼後置頁面在您必須指定完整格式的名稱`HttpContext.Current.Response.Write(&quot;some output&quot;)`。"
  syntax:
    content: public System.Web.HttpResponse Response { get; }
    return:
      type: System.Web.HttpResponse
      description: "<xref href=&quot;System.Web.HttpResponse&quot;> </xref>目前 HTTP 回應。"
  overload: System.Web.HttpContext.Response*
  exceptions:
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "Web 應用程式在 IIS 7 下執行，以整合模式。"
  platform:
  - net462
- uid: System.Web.HttpContext.RewritePath(System.String)
  id: RewritePath(System.String)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: RewritePath(String)
  nameWithType: HttpContext.RewritePath(String)
  fullName: System.Web.HttpContext.RewritePath(String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "重寫 URL，使用指定的路徑。"
  remarks: "RewritePath 方法資源的要求重新導向至與要求的 URL 會以不同的路徑。 如果您必須重設虛擬路徑，以便正確地解析來自用戶端的伺服器資源的要求，請使用會採用此方法的多載`rebaseClientPath`參數並將參數設定為`false`。       URL 重寫時，您想要重新建構您的 Web 應用程式中的頁面，而且您想要確定，已設為書籤的舊 Url 的人員仍然可以使用它們之後移動頁面。 URL 重寫，可讓您明確地將要求轉送到新的網頁位置。       如果您想要啟用網站的 Url，更加易懂易記，而且已最佳化，用於搜尋引擎，更健全的替代方法是使用 ASP.NET 路由。 如需詳細資訊，請參閱[ASP.NET 路由](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example shows how to use the RewritePath method to enable a Web site to respond to URLs that do not reflect the file structure in the Web site. The first block of code is an ASP.NET Web page that is named RewritePath.aspx. It requires a query string. If the name of your site is WebSite1, the URL `http://localhost/WebSite1/RewritePath.aspx?page=1` displays \"Page 1\" in the browser. The block of code that follows the Web page is the `Application_BeginRequest` event handler in the Global.asax file. This code intercepts requests for URLs such as `http://localhost/WebSite1/page1` and converts them to the form that is required for RewritePath.aspx before they are processed. Therefore, the URL `http://localhost/WebSite1/page1` invokes RewritePath.aspx with the query-string parameter that displays \"Page 1\" in the browser. If a URL such as `http://localhost/WebSite1/page1` is received, an overload of RewritePath is invoked that enables you to provide a value for the <xref:System.Web.HttpRequest.PathInfo%2A> property as well as a query string parameter.  \n  \n [!code-cs[HttpContext_RewritePath#2](~/add/codesnippet/csharp/m-system.web.httpcontext_1.aspx)]\n [!code-vb[HttpContext_RewritePath#2](~/add/codesnippet/visualbasic/m-system.web.httpcontext_1.aspx)]  \n  \n [!code-vb[HttpContext_RewritePath#1](~/add/codesnippet/visualbasic/m-system.web.httpcontext_2.asax)]\n [!code-cs[HttpContext_RewritePath#1](~/add/codesnippet/csharp/m-system.web.httpcontext_2.asax)]"
  syntax:
    content: public void RewritePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "內部重寫路徑。"
  overload: System.Web.HttpContext.RewritePath*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "<code> path </code>參數不是目前的應用程式根目錄中。"
  platform:
  - net462
- uid: System.Web.HttpContext.RewritePath(System.String,System.Boolean)
  id: RewritePath(System.String,System.Boolean)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: RewritePath(String,Boolean)
  nameWithType: HttpContext.RewritePath(String,Boolean)
  fullName: System.Web.HttpContext.RewritePath(String,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "重寫 URL，使用指定的路徑和布林值，指定是否修改伺服器資源的虛擬路徑。"
  remarks: "RewritePath 方法由呼叫<xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=fullName>方法`rebaseClientPath`參數設定為`true`。</xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=fullName> 若要確保不會修改用來建構資源路徑的虛擬路徑，將`rebaseClientPath`參數`false`。 常見的案例，您可能想設定`rebaseClientPath`至`false`時，您需要重寫 URL，而且您會使用佈景主題，並將 URL 重新導向至位於不同的資料夾所要求的資源的資源。       URL 重寫時，您想要重新建構您的 Web 應用程式中的頁面，而且您想要確定，已設為書籤的舊 Url 的人員仍然可以使用它們之後移動頁面。 URL 重寫，可讓您明確地將要求轉送到新的網頁位置。       如果您想要啟用網站的 Url，更加易懂易記，而且已最佳化，用於搜尋引擎，更健全的替代方法是使用 ASP.NET 路由。 如需詳細資訊，請參閱[ASP.NET 路由](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - For a code example, see the <xref:System.Web.HttpContext.RewritePath%28System.String%29> method overload.
  syntax:
    content: public void RewritePath (string path, bool rebaseClientPath);
    parameters:
    - id: path
      type: System.String
      description: "內部重寫路徑。"
    - id: rebaseClientPath
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要重設虛擬路徑;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>来保持虛擬路徑不變。"
  overload: System.Web.HttpContext.RewritePath*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "<code> path </code>參數不是目前的應用程式根目錄中。"
  platform:
  - net462
- uid: System.Web.HttpContext.RewritePath(System.String,System.String,System.String)
  id: RewritePath(System.String,System.String,System.String)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: RewritePath(String,String,String)
  nameWithType: HttpContext.RewritePath(String,String,String)
  fullName: System.Web.HttpContext.RewritePath(String,String,String)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "重寫 URL，使用指定的路徑、 路徑資訊和查詢字串資訊。"
  remarks: "RewritePath 方法將要求重新導向之資源的另一個資源而不需要變更 URL。       `filePath`參數不包括`pathInfo`參數內容。 針對 URL http://www.microsoft.com/virdir/page.html/tail，`filePath`參數是 http://www.microsoft.com/virdir/page.html，而`pathInfo`參數為結尾。       URL 重寫時，您想要重新建構您的 Web 應用程式中的頁面，而且您想要確定，已設為書籤的舊 Url 的人員仍然可以使用它們之後移動頁面。 URL 重寫，可讓您明確地將要求轉送到新的網頁位置。       如果您想要啟用網站的 Url，更加易懂易記，而且已最佳化，用於搜尋引擎，更健全的替代方法是使用 ASP.NET 路由。 如需詳細資訊，請參閱[ASP.NET 路由](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - For a code example, including an example of this method overload, see the <xref:System.Web.HttpContext.RewritePath%28System.String%29> method overload.
  syntax:
    content: public void RewritePath (string filePath, string pathInfo, string queryString);
    parameters:
    - id: filePath
      type: System.String
      description: "內部重寫路徑。"
    - id: pathInfo
      type: System.String
      description: "資源的額外路徑資訊。 如需詳細資訊，請參閱<xref:System.Web.HttpRequest.PathInfo*>.</xref:System.Web.HttpRequest.PathInfo*>"
    - id: queryString
      type: System.String
      description: "要求查詢字串。"
  overload: System.Web.HttpContext.RewritePath*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code> path </code>參數不是目前的應用程式根目錄中。"
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "<code> filePath </code>參數不是目前的應用程式根目錄中。"
  platform:
  - net462
- uid: System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)
  id: RewritePath(System.String,System.String,System.String,System.Boolean)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: RewritePath(String,String,String,Boolean)
  nameWithType: HttpContext.RewritePath(String,String,String,Boolean)
  fullName: System.Web.HttpContext.RewritePath(String,String,String,Boolean)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "重寫 URL，使用指定的虛擬路徑、 路徑資訊、 查詢字串資訊和布林值，指定用戶端檔案路徑是否設為重寫路徑。"
  remarks: "`filePath`參數不包含的內容`pathInfo`參數。 針對 URL http://www.microsoft.com/virdir/page.html/tail，`filePath`參數是 http://www.microsoft.com/virdir/page.html，而`pathInfo`參數為結尾。       若要確保不會修改用來建構資源路徑的虛擬路徑，將`setClientFilePath`參數`false`。 常見的案例，您可能想設定`setClientFilePath`至`false`時，您需要重寫 URL，而且您會使用佈景主題，並將 URL 重新導向至位於不同的資料夾所要求的資源的資源。       URL 重寫時，您想要重新建構您的 Web 應用程式中的頁面，而且您想要確定，已設為書籤的舊 Url 的人員仍然可以使用它們之後移動頁面。 URL 重寫，可讓您明確地將要求轉送到新的網頁位置。       如果您想要啟用網站的 Url，更加易懂易記，而且已最佳化，用於搜尋引擎，更健全的替代方法是使用 ASP.NET 路由。 如需詳細資訊，請參閱[ASP.NET 路由](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - For a code example, see the <xref:System.Web.HttpContext.RewritePath%28System.String%29> method overload.
  syntax:
    content: public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);
    parameters:
    - id: filePath
      type: System.String
      description: "服務要求之資源的虛擬路徑。"
    - id: pathInfo
      type: System.String
      description: "用於 URL 重新導向的額外路徑資訊。 如需詳細資訊，請參閱<xref:System.Web.HttpRequest.PathInfo*>.</xref:System.Web.HttpRequest.PathInfo*>"
    - id: queryString
      type: System.String
      description: "用於 URL 重新導向要求查詢字串。"
    - id: setClientFilePath
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要設定的值用戶端資源所使用的檔案路徑`filePath`參數，否則為<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.HttpContext.RewritePath*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code> path </code>參數不是目前的應用程式根目錄中。"
  - type: System.Web.HttpException
    commentId: T:System.Web.HttpException
    description: "<code> filePath </code>參數不是目前的應用程式根目錄中。"
  platform:
  - net462
- uid: System.Web.HttpContext.Server
  id: Server
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Server
  nameWithType: HttpContext.Server
  fullName: System.Web.HttpContext.Server
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得<xref href=&quot;System.Web.HttpServerUtility&quot;></xref>物件，提供用於處理 Web 要求的方法。"
  remarks: "此伺服器屬性會提供以程式設計方式存取的屬性和方法的<xref:System.Web.HttpServerUtility>類別。</xref:System.Web.HttpServerUtility> 因為 ASP.NET 網頁包含預設參考<xref:System.Web>命名空間 (其中包含<xref:System.Web.HttpContext>類別)，您可以參考的成員<xref:System.Web.HttpContext>在.aspx 頁面上，而不需要使用完整的類別參考至<xref:System.Web.HttpContext>。</xref:System.Web.HttpContext> </xref:System.Web.HttpContext> </xref:System.Web.HttpContext> </xref:System.Web> 例如，您可以使用`Server.CreateObject(&quot;MyCOMComponent&quot;)`在伺服器上建立 COM 物件的執行個體。 不過，如果您想要使用的成員<xref:System.Web.HttpServerUtility>從 ASP.NET 程式碼後置模組，您必須將參考併入到<xref:System.Web>命名空間模組以及目前作用中的要求/回應內容以及中的類別的完整的參考<xref:System.Web>您想要使用的。</xref:System.Web> </xref:System.Web> </xref:System.Web.HttpServerUtility> 例如，程式碼後置頁面在您必須指定完整格式的名稱`HttpContext.Current.Server.CreateObject(&quot;MyCOMComponent&quot;)`。"
  syntax:
    content: public System.Web.HttpServerUtility Server { get; }
    return:
      type: System.Web.HttpServerUtility
      description: "<xref href=&quot;System.Web.HttpServerUtility&quot;> </xref>目前 HTTP 要求。"
  overload: System.Web.HttpContext.Server*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Session
  id: Session
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Session
  nameWithType: HttpContext.Session
  fullName: System.Web.HttpContext.Session
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得<xref href=&quot;System.Web.SessionState.HttpSessionState&quot;></xref>目前 HTTP 要求的物件。"
  remarks: "此工作階段屬性會提供以程式設計方式存取的屬性和方法的<xref:System.Web.SessionState.HttpSessionState>類別。</xref:System.Web.SessionState.HttpSessionState>       若要使用工作階段狀態，您必須啟用它。 如需如何啟用工作階段狀態資訊，請參閱**設定工作階段狀態**中[ASP.NET 工作階段狀態概觀](~/add/includes/ajax-current-ext-md.md)。       如需如何將值儲存在工作階段狀態資訊，請參閱[How to︰ 將值儲存在工作階段狀態](~/add/includes/ajax-current-ext-md.md)。 如需如何從工作階段狀態中讀取的值資訊，請參閱[How to︰ 從工作階段狀態的讀取值](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following examples show how to save values in session state and how to read values from session state.  \n  \n These examples require:  \n  \n-   An ASP.NET application that has session state enabled.  \n  \n-   A Web Forms page class that has access to the <xref:System.Web.UI.Page.Session%2A?displayProperty=fullName> property, or any class that has access to the <xref:System.Web.HttpContext.Current%2A?displayProperty=fullName> property.  \n  \n```c#  \nstring firstName = \"Jeff\";  \nstring lastName = \"Smith\";  \nstring city = \"Seattle\";  \n  \n// Save to session state in a Web Forms page class.  \nSession[\"FirstName\"] = firstName;  \nSession[\"LastName\"] = lastName;  \nSession[\"City\"] = city;  \n  \n// Read from session state in a Web Forms page class.  \nfirstName = (string)(Session[\"FirstName\"]);  \nlastName = (string)(Session[\"LastName\"]);  \ncity = (string)(Session[\"City\"]);  \n  \n// Outside of Web Forms page class, use HttpContext.Current.  \nHttpContext context = HttpContext.Current;  \ncontext.Session[\"FirstName\"] = firstName;  \nfirstName = (string)(context.Session[\"FirstName\"]);  \n  \n```  \n  \n```vb#  \nDim firstName As String = \"Jeff\"  \nDim lastName As String = \"Smith\"  \nDim city As String = \"Seattle\"  \n  \n' Save to session state in a Web Forms page class.  \nSession(\"FirstName\") = firstName  \nSession(\"LastName\") = lastName  \nSession(\"City\") = city  \n  \n' Read from session state in a Web Forms page class.  \nfirstName = DirectCast(Session(\"FirstName\"), String)  \nlastName = DirectCast(Session(\"LastName\"), String)  \ncity = DirectCast(Session(\"City\"), String)  \n  \n' Outside of Web Forms page class, use HttpContext.Current.  \nDim context As HttpContext = HttpContext.Current  \ncontext.Session(\"FirstName\") = firstName  \nfirstName = DirectCast(context.Session(\"FirstName\"), String)  \n  \n```"
  syntax:
    content: public System.Web.SessionState.HttpSessionState Session { get; }
    return:
      type: System.Web.SessionState.HttpSessionState
      description: "<xref href=&quot;System.Web.SessionState.HttpSessionState&quot;> </xref>目前 HTTP 要求的物件。"
  overload: System.Web.HttpContext.Session*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)
  id: SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: SetSessionStateBehavior(SessionStateBehavior)
  nameWithType: HttpContext.SetSessionStateBehavior(SessionStateBehavior)
  fullName: System.Web.HttpContext.SetSessionStateBehavior(SessionStateBehavior)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "設定，才能支援 HTTP 要求的工作階段狀態行為的型別。"
  remarks: "在 ASP.NET 預設實作中，HTTP 要求處理常式會指出它是否需要工作階段狀態，藉由實作<xref:System.Web.SessionState.IRequiresSessionState>介面或<xref:System.Web.SessionState.IReadOnlySessionState>介面。</xref:System.Web.SessionState.IReadOnlySessionState> </xref:System.Web.SessionState.IRequiresSessionState> SetSessionStateBehavior 方法和<xref:System.Web.SessionState.SessionStateBehavior>列舉型別可讓您提供有關處理要求所需的工作階段狀態支援之類型的其他詳細資訊。</xref:System.Web.SessionState.SessionStateBehavior> 如需詳細資訊，請參閱<xref:System.Web.SessionState.SessionStateBehavior>列舉型別。</xref:System.Web.SessionState.SessionStateBehavior>       SetSessionStateBehavior 方法必須先呼叫才能<xref:System.Web.HttpApplication.AcquireRequestState>管線事件。</xref:System.Web.HttpApplication.AcquireRequestState> 發生於期間或之後此事件的呼叫會導致<xref:System.InvalidOperationException>例外狀況。</xref:System.InvalidOperationException>"
  syntax:
    content: public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);
    parameters:
    - id: sessionStateBehavior
      type: System.Web.SessionState.SessionStateBehavior
      description: "需要一個列舉值，指定工作階段狀態行為的類型。"
  overload: System.Web.HttpContext.SetSessionStateBehavior*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "呼叫此方法之後<xref href=&quot;System.Web.HttpApplication.AcquireRequestState&quot;></xref>引發事件。"
  platform:
  - net462
- uid: System.Web.HttpContext.SkipAuthorization
  id: SkipAuthorization
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: SkipAuthorization
  nameWithType: HttpContext.SkipAuthorization
  fullName: System.Web.HttpContext.SkipAuthorization
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得或設定值，指定是否<xref href=&quot;System.Web.Security.UrlAuthorizationModule&quot;></xref>物件應該略過目前要求的授權檢查。"
  remarks: "SkipAuthorization 屬性被供進階使用需要重新導向至網頁，可讓匿名連線的驗證模組。 表單驗證模組和 Passport 驗證模組同時設定 SkipAuthorization 時將重新導向至設定的登入頁面。 設定 SkipAuthorization 需要`ControlPrincipal`旗標設定。 如需有關資訊`ControlPrincipal`旗標，請參閱<xref:System.Security.Permissions.SecurityPermissionFlag>.</xref:System.Security.Permissions.SecurityPermissionFlag>"
  syntax:
    content: public bool SkipAuthorization { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Web.Security.UrlAuthorizationModule&quot;></xref>應該略過授權檢查，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.HttpContext.SkipAuthorization*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)
  id: System#IServiceProvider#GetService(System.Type)
  isEii: true
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: System.IServiceProvider.GetService(Type)
  nameWithType: HttpContext.System.IServiceProvider.GetService(Type)
  fullName: System.Web.HttpContext.System.IServiceProvider.GetService(Type)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "傳回目前服務類型的物件。"
  remarks: "此方法適合用來存取基礎<xref:System.Web.HttpWorkerRequest>物件。</xref:System.Web.HttpWorkerRequest>"
  syntax:
    content: object IServiceProvider.GetService (Type service);
    parameters:
    - id: service
      type: System.Type
      description: "一種<xref href=&quot;System.Web.HttpContext&quot;></xref>服務設定服務提供者。"
    return:
      type: System.Object
      description: "A <xref href=&quot;System.Web.HttpContext&quot;> </xref>，否則<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果找不到任何服務。"
  overload: System.Web.HttpContext.System#IServiceProvider#GetService*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.ThreadAbortOnTimeout
  id: ThreadAbortOnTimeout
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: ThreadAbortOnTimeout
  nameWithType: HttpContext.ThreadAbortOnTimeout
  fullName: System.Web.HttpContext.ThreadAbortOnTimeout
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得或設定值，指定 ASP.NET 執行階段是否應呼叫&lt;xref:System.Threading.Thread.Abort%2A?displayProperty=fullName&gt;要求逾時服務此要求的執行緒上。"
  remarks: "處理常式和使用的模組中<xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=fullName>屬性來實作合作式取消作業，您可能想要停用<xref:System.Threading.Thread.Abort%2A?displayProperty=fullName>ASP.NET 預設會執行要求逾時的行為。</xref:System.Threading.Thread.Abort%2A?displayProperty=fullName> </xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=fullName> 此屬性設定為`false`可以協助您確保取消作業和清除的常式將會執行不含 ASP.NET 所中斷。       如果您將此屬性設定為`false`，ASP.NET 不會自動顯示 「 要求已逾時 」 錯誤頁面發生逾時。 應用程式會負責設定適當的回應內容。"
  syntax:
    content: public bool ThreadAbortOnTimeout { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果&lt;xref:System.Threading.Thread.Abort%2A?displayProperty=fullName&gt; ; 否則，在執行緒逾時，將會呼叫<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.HttpContext.ThreadAbortOnTimeout*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Timestamp
  id: Timestamp
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Timestamp
  nameWithType: HttpContext.Timestamp
  fullName: System.Web.HttpContext.Timestamp
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得目前 HTTP 要求的初始時間戳記。"
  remarks: "時間戳記屬性所傳回的時間戳記是伺服器的當地時間和設定的具現化期間<xref:System.Web.HttpContext>物件。</xref:System.Web.HttpContext> 本地時間是 UTC 時間，加上的 UTC 位移。"
  syntax:
    content: public DateTime Timestamp { get; }
    return:
      type: System.DateTime
      description: "目前 HTTP 要求的時間戳記。"
  overload: System.Web.HttpContext.Timestamp*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.Trace
  id: Trace
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: Trace
  nameWithType: HttpContext.Trace
  fullName: System.Web.HttpContext.Trace
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得<xref href=&quot;System.Web.TraceContext&quot;></xref>目前 HTTP 回應物件。"
  syntax:
    content: public System.Web.TraceContext Trace { get; }
    return:
      type: System.Web.TraceContext
      description: "<xref href=&quot;System.Web.TraceContext&quot;> </xref>目前 HTTP 回應。"
  overload: System.Web.HttpContext.Trace*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.User
  id: User
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: User
  nameWithType: HttpContext.User
  fullName: System.Web.HttpContext.User
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得或設定目前 HTTP 要求的安全性資訊。"
  remarks: "使用者屬性提供以程式設計方式存取的屬性和方法的<xref:System.Security.Principal.IPrincipal>介面。</xref:System.Security.Principal.IPrincipal>       因為 ASP.NET 網頁包含預設參考<xref:System.Web>命名空間 (其中包含<xref:System.Web.HttpContext>類別)，您可以參考的成員<xref:System.Web.HttpContext>在.aspx 頁面上，而不需要使用完整的類別參考至<xref:System.Web.HttpContext>。</xref:System.Web.HttpContext> </xref:System.Web.HttpContext> </xref:System.Web.HttpContext> </xref:System.Web> 例如，您可以使用`User.Identity.Name`取得的使用者名稱代表其目前的處理序正在執行。 不過，如果您想要使用的成員<xref:System.Security.Principal.IPrincipal>從 ASP.NET 程式碼後置模組，您必須將參考併入到<xref:System.Web>命名空間模組以及目前作用中的要求/回應內容以及中的類別的完整的參考<xref:System.Web>您想要使用的。</xref:System.Web> </xref:System.Web> </xref:System.Security.Principal.IPrincipal> 例如，程式碼後置頁面在您必須指定完整格式的名稱`HttpContext.Current.User.Identity.Name`。"
  example:
  - "The following example shows how to access properties of the current user through the User property. Those properties are used to set the title of the Web page.  \n  \n If the application uses Windows authentication, the user name includes the domain. For example, the page title would be “Home page for DOMAIN\\username”.  \n  \n [!code-cs[System.Web.HttpContext.User#1](~/add/codesnippet/csharp/p-system.web.httpcontext_1_1.cs)]\n [!code-vb[System.Web.HttpContext.User#1](~/add/codesnippet/visualbasic/p-system.web.httpcontext_1_1.vb)]"
  syntax:
    content: public System.Security.Principal.IPrincipal User { get; set; }
    return:
      type: System.Security.Principal.IPrincipal
      description: "目前 HTTP 要求的安全性資訊。"
  overload: System.Web.HttpContext.User*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.WebSocketNegotiatedProtocol
  id: WebSocketNegotiatedProtocol
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: WebSocketNegotiatedProtocol
  nameWithType: HttpContext.WebSocketNegotiatedProtocol
  fullName: System.Web.HttpContext.WebSocketNegotiatedProtocol
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得已從伺服器傳送給用戶端的交涉通訊協定<xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;></xref>連線。"
  syntax:
    content: public string WebSocketNegotiatedProtocol { get; }
    return:
      type: System.String
      description: "交涉的通訊協定。"
  overload: System.Web.HttpContext.WebSocketNegotiatedProtocol*
  exceptions: []
  platform:
  - net462
- uid: System.Web.HttpContext.WebSocketRequestedProtocols
  id: WebSocketRequestedProtocols
  parent: System.Web.HttpContext
  langs:
  - csharp
  name: WebSocketRequestedProtocols
  nameWithType: HttpContext.WebSocketRequestedProtocols
  fullName: System.Web.HttpContext.WebSocketRequestedProtocols
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web
  summary: "取得用戶端要求的通訊協定的已排序的清單。"
  syntax:
    content: public System.Collections.Generic.IList<string> WebSocketRequestedProtocols { get; }
    return:
      type: System.Collections.Generic.IList{System.String}
      description: "要求的通訊協定，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果這不是<xref href=&quot;System.Web.WebSockets.AspNetWebSocket&quot;></xref>要求或沒有清單，則存在。"
  overload: System.Web.HttpContext.WebSocketRequestedProtocols*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.Resources.MissingManifestResourceException
  isExternal: true
  name: System.Resources.MissingManifestResourceException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Web.HttpException
  parent: System.Web
  isExternal: false
  name: HttpException
  nameWithType: HttpException
  fullName: System.Web.HttpException
- uid: System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)
  parent: System.Web.HttpContext
  isExternal: false
  name: HttpContext(HttpWorkerRequest)
  nameWithType: HttpContext.HttpContext(HttpWorkerRequest)
  fullName: System.Web.HttpContext.HttpContext(HttpWorkerRequest)
- uid: System.Web.HttpWorkerRequest
  parent: System.Web
  isExternal: false
  name: HttpWorkerRequest
  nameWithType: HttpWorkerRequest
  fullName: System.Web.HttpWorkerRequest
- uid: System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)
  parent: System.Web.HttpContext
  isExternal: false
  name: HttpContext(HttpRequest,HttpResponse)
  nameWithType: HttpContext.HttpContext(HttpRequest,HttpResponse)
  fullName: System.Web.HttpContext.HttpContext(HttpRequest,HttpResponse)
- uid: System.Web.HttpRequest
  parent: System.Web
  isExternal: false
  name: HttpRequest
  nameWithType: HttpRequest
  fullName: System.Web.HttpRequest
- uid: System.Web.HttpResponse
  parent: System.Web
  isExternal: false
  name: HttpResponse
  nameWithType: HttpResponse
  fullName: System.Web.HttpResponse
- uid: System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})
  parent: System.Web.HttpContext
  isExternal: false
  name: AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>)
  nameWithType: HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>)
  fullName: System.Web.HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>)
- uid: System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task}
  parent: System
  isExternal: true
  name: Func<AspNetWebSocketContext,Task>
  nameWithType: Func<AspNetWebSocketContext,Task>
  fullName: System.Func<System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task>
  spec.csharp:
  - uid: System.Func`2
    name: Func
    nameWithType: Func
    fullName: Func<System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Web.WebSockets.AspNetWebSocketContext
    name: AspNetWebSocketContext
    nameWithType: AspNetWebSocketContext
    fullName: AspNetWebSocketContext
  - name: ','
    nameWithType: ','
    fullName: ','
  - uid: System.Threading.Tasks.Task
    name: Task
    nameWithType: Task
    fullName: Task
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)
  parent: System.Web.HttpContext
  isExternal: false
  name: AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>,AspNetWebSocketOptions)
  nameWithType: HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>,AspNetWebSocketOptions)
  fullName: System.Web.HttpContext.AcceptWebSocketRequest(Func<AspNetWebSocketContext,Task>,AspNetWebSocketOptions)
- uid: System.Web.WebSockets.AspNetWebSocketOptions
  parent: System.Web.WebSockets
  isExternal: false
  name: AspNetWebSocketOptions
  nameWithType: AspNetWebSocketOptions
  fullName: System.Web.WebSockets.AspNetWebSocketOptions
- uid: System.Web.HttpContext.AddError(System.Exception)
  parent: System.Web.HttpContext
  isExternal: false
  name: AddError(Exception)
  nameWithType: HttpContext.AddError(Exception)
  fullName: System.Web.HttpContext.AddError(Exception)
- uid: System.Exception
  parent: System
  isExternal: true
  name: Exception
  nameWithType: Exception
  fullName: System.Exception
- uid: System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})
  parent: System.Web.HttpContext
  isExternal: false
  name: AddOnRequestCompleted(Action<HttpContext>)
  nameWithType: HttpContext.AddOnRequestCompleted(Action<HttpContext>)
  fullName: System.Web.HttpContext.AddOnRequestCompleted(Action<HttpContext>)
- uid: System.Web.ISubscriptionToken
  parent: System.Web
  isExternal: false
  name: ISubscriptionToken
  nameWithType: ISubscriptionToken
  fullName: System.Web.ISubscriptionToken
- uid: System.Action{System.Web.HttpContext}
  parent: System
  isExternal: true
  name: Action<HttpContext>
  nameWithType: Action<HttpContext>
  fullName: System.Action<System.Web.HttpContext>
  spec.csharp:
  - uid: System.Action`1
    name: Action
    nameWithType: Action
    fullName: Action<System.Web.HttpContext>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Web.HttpContext
    name: HttpContext
    nameWithType: HttpContext
    fullName: HttpContext
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Web.HttpContext.AllErrors
  parent: System.Web.HttpContext
  isExternal: false
  name: AllErrors
  nameWithType: HttpContext.AllErrors
  fullName: System.Web.HttpContext.AllErrors
- uid: System.Exception[]
  parent: System
  isExternal: true
  name: Exception
  nameWithType: Exception
  fullName: System.Exception[]
  spec.csharp:
  - uid: System.Exception
    name: Exception
    nameWithType: Exception
    fullName: Exception[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Web.HttpContext.AllowAsyncDuringSyncStages
  parent: System.Web.HttpContext
  isExternal: false
  name: AllowAsyncDuringSyncStages
  nameWithType: HttpContext.AllowAsyncDuringSyncStages
  fullName: System.Web.HttpContext.AllowAsyncDuringSyncStages
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Web.HttpContext.Application
  parent: System.Web.HttpContext
  isExternal: false
  name: Application
  nameWithType: HttpContext.Application
  fullName: System.Web.HttpContext.Application
- uid: System.Web.HttpApplicationState
  parent: System.Web
  isExternal: false
  name: HttpApplicationState
  nameWithType: HttpApplicationState
  fullName: System.Web.HttpApplicationState
- uid: System.Web.HttpContext.ApplicationInstance
  parent: System.Web.HttpContext
  isExternal: false
  name: ApplicationInstance
  nameWithType: HttpContext.ApplicationInstance
  fullName: System.Web.HttpContext.ApplicationInstance
- uid: System.Web.HttpApplication
  parent: System.Web
  isExternal: false
  name: HttpApplication
  nameWithType: HttpApplication
  fullName: System.Web.HttpApplication
- uid: System.Web.HttpContext.AsyncPreloadMode
  parent: System.Web.HttpContext
  isExternal: false
  name: AsyncPreloadMode
  nameWithType: HttpContext.AsyncPreloadMode
  fullName: System.Web.HttpContext.AsyncPreloadMode
- uid: System.Web.Configuration.AsyncPreloadModeFlags
  parent: System.Web.Configuration
  isExternal: false
  name: AsyncPreloadModeFlags
  nameWithType: AsyncPreloadModeFlags
  fullName: System.Web.Configuration.AsyncPreloadModeFlags
- uid: System.Web.HttpContext.Cache
  parent: System.Web.HttpContext
  isExternal: false
  name: Cache
  nameWithType: HttpContext.Cache
  fullName: System.Web.HttpContext.Cache
- uid: System.Web.Caching.Cache
  parent: System.Web.Caching
  isExternal: false
  name: Cache
  nameWithType: Cache
  fullName: System.Web.Caching.Cache
- uid: System.Web.HttpContext.ClearError
  parent: System.Web.HttpContext
  isExternal: false
  name: ClearError()
  nameWithType: HttpContext.ClearError()
  fullName: System.Web.HttpContext.ClearError()
- uid: System.Web.HttpContext.Current
  parent: System.Web.HttpContext
  isExternal: false
  name: Current
  nameWithType: HttpContext.Current
  fullName: System.Web.HttpContext.Current
- uid: System.Web.HttpContext
  parent: System.Web
  isExternal: false
  name: HttpContext
  nameWithType: HttpContext
  fullName: System.Web.HttpContext
- uid: System.Web.HttpContext.CurrentHandler
  parent: System.Web.HttpContext
  isExternal: false
  name: CurrentHandler
  nameWithType: HttpContext.CurrentHandler
  fullName: System.Web.HttpContext.CurrentHandler
- uid: System.Web.IHttpHandler
  parent: System.Web
  isExternal: false
  name: IHttpHandler
  nameWithType: IHttpHandler
  fullName: System.Web.IHttpHandler
- uid: System.Web.HttpContext.CurrentNotification
  parent: System.Web.HttpContext
  isExternal: false
  name: CurrentNotification
  nameWithType: HttpContext.CurrentNotification
  fullName: System.Web.HttpContext.CurrentNotification
- uid: System.Web.RequestNotification
  parent: System.Web
  isExternal: false
  name: RequestNotification
  nameWithType: RequestNotification
  fullName: System.Web.RequestNotification
- uid: System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)
  parent: System.Web.HttpContext
  isExternal: false
  name: DisposeOnPipelineCompleted(IDisposable)
  nameWithType: HttpContext.DisposeOnPipelineCompleted(IDisposable)
  fullName: System.Web.HttpContext.DisposeOnPipelineCompleted(IDisposable)
- uid: System.IDisposable
  parent: System
  isExternal: true
  name: IDisposable
  nameWithType: IDisposable
  fullName: System.IDisposable
- uid: System.Web.HttpContext.Error
  parent: System.Web.HttpContext
  isExternal: false
  name: Error
  nameWithType: HttpContext.Error
  fullName: System.Web.HttpContext.Error
- uid: System.Web.HttpContext.GetAppConfig(System.String)
  parent: System.Web.HttpContext
  isExternal: false
  name: GetAppConfig(String)
  nameWithType: HttpContext.GetAppConfig(String)
  fullName: System.Web.HttpContext.GetAppConfig(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Web.HttpContext.GetConfig(System.String)
  parent: System.Web.HttpContext
  isExternal: false
  name: GetConfig(String)
  nameWithType: HttpContext.GetConfig(String)
  fullName: System.Web.HttpContext.GetConfig(String)
- uid: System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)
  parent: System.Web.HttpContext
  isExternal: false
  name: GetGlobalResourceObject(String,String)
  nameWithType: HttpContext.GetGlobalResourceObject(String,String)
  fullName: System.Web.HttpContext.GetGlobalResourceObject(String,String)
- uid: System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  parent: System.Web.HttpContext
  isExternal: false
  name: GetGlobalResourceObject(String,String,CultureInfo)
  nameWithType: HttpContext.GetGlobalResourceObject(String,String,CultureInfo)
  fullName: System.Web.HttpContext.GetGlobalResourceObject(String,String,CultureInfo)
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)
  parent: System.Web.HttpContext
  isExternal: false
  name: GetLocalResourceObject(String,String)
  nameWithType: HttpContext.GetLocalResourceObject(String,String)
  fullName: System.Web.HttpContext.GetLocalResourceObject(String,String)
- uid: System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)
  parent: System.Web.HttpContext
  isExternal: false
  name: GetLocalResourceObject(String,String,CultureInfo)
  nameWithType: HttpContext.GetLocalResourceObject(String,String,CultureInfo)
  fullName: System.Web.HttpContext.GetLocalResourceObject(String,String,CultureInfo)
- uid: System.Web.HttpContext.GetSection(System.String)
  parent: System.Web.HttpContext
  isExternal: false
  name: GetSection(String)
  nameWithType: HttpContext.GetSection(String)
  fullName: System.Web.HttpContext.GetSection(String)
- uid: System.Web.HttpContext.Handler
  parent: System.Web.HttpContext
  isExternal: false
  name: Handler
  nameWithType: HttpContext.Handler
  fullName: System.Web.HttpContext.Handler
- uid: System.Web.HttpContext.IsCustomErrorEnabled
  parent: System.Web.HttpContext
  isExternal: false
  name: IsCustomErrorEnabled
  nameWithType: HttpContext.IsCustomErrorEnabled
  fullName: System.Web.HttpContext.IsCustomErrorEnabled
- uid: System.Web.HttpContext.IsDebuggingEnabled
  parent: System.Web.HttpContext
  isExternal: false
  name: IsDebuggingEnabled
  nameWithType: HttpContext.IsDebuggingEnabled
  fullName: System.Web.HttpContext.IsDebuggingEnabled
- uid: System.Web.HttpContext.IsPostNotification
  parent: System.Web.HttpContext
  isExternal: false
  name: IsPostNotification
  nameWithType: HttpContext.IsPostNotification
  fullName: System.Web.HttpContext.IsPostNotification
- uid: System.Web.HttpContext.IsWebSocketRequest
  parent: System.Web.HttpContext
  isExternal: false
  name: IsWebSocketRequest
  nameWithType: HttpContext.IsWebSocketRequest
  fullName: System.Web.HttpContext.IsWebSocketRequest
- uid: System.Web.HttpContext.IsWebSocketRequestUpgrading
  parent: System.Web.HttpContext
  isExternal: false
  name: IsWebSocketRequestUpgrading
  nameWithType: HttpContext.IsWebSocketRequestUpgrading
  fullName: System.Web.HttpContext.IsWebSocketRequestUpgrading
- uid: System.Web.HttpContext.Items
  parent: System.Web.HttpContext
  isExternal: false
  name: Items
  nameWithType: HttpContext.Items
  fullName: System.Web.HttpContext.Items
- uid: System.Collections.IDictionary
  parent: System.Collections
  isExternal: true
  name: IDictionary
  nameWithType: IDictionary
  fullName: System.Collections.IDictionary
- uid: System.Web.HttpContext.PageInstrumentation
  parent: System.Web.HttpContext
  isExternal: false
  name: PageInstrumentation
  nameWithType: HttpContext.PageInstrumentation
  fullName: System.Web.HttpContext.PageInstrumentation
- uid: System.Web.Instrumentation.PageInstrumentationService
  parent: System.Web.Instrumentation
  isExternal: false
  name: PageInstrumentationService
  nameWithType: PageInstrumentationService
  fullName: System.Web.Instrumentation.PageInstrumentationService
- uid: System.Web.HttpContext.PreviousHandler
  parent: System.Web.HttpContext
  isExternal: false
  name: PreviousHandler
  nameWithType: HttpContext.PreviousHandler
  fullName: System.Web.HttpContext.PreviousHandler
- uid: System.Web.HttpContext.Profile
  parent: System.Web.HttpContext
  isExternal: false
  name: Profile
  nameWithType: HttpContext.Profile
  fullName: System.Web.HttpContext.Profile
- uid: System.Web.Profile.ProfileBase
  parent: System.Web.Profile
  isExternal: false
  name: ProfileBase
  nameWithType: ProfileBase
  fullName: System.Web.Profile.ProfileBase
- uid: System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)
  parent: System.Web.HttpContext
  isExternal: false
  name: RemapHandler(IHttpHandler)
  nameWithType: HttpContext.RemapHandler(IHttpHandler)
  fullName: System.Web.HttpContext.RemapHandler(IHttpHandler)
- uid: System.Web.HttpContext.Request
  parent: System.Web.HttpContext
  isExternal: false
  name: Request
  nameWithType: HttpContext.Request
  fullName: System.Web.HttpContext.Request
- uid: System.Web.HttpContext.Response
  parent: System.Web.HttpContext
  isExternal: false
  name: Response
  nameWithType: HttpContext.Response
  fullName: System.Web.HttpContext.Response
- uid: System.Web.HttpContext.RewritePath(System.String)
  parent: System.Web.HttpContext
  isExternal: false
  name: RewritePath(String)
  nameWithType: HttpContext.RewritePath(String)
  fullName: System.Web.HttpContext.RewritePath(String)
- uid: System.Web.HttpContext.RewritePath(System.String,System.Boolean)
  parent: System.Web.HttpContext
  isExternal: false
  name: RewritePath(String,Boolean)
  nameWithType: HttpContext.RewritePath(String,Boolean)
  fullName: System.Web.HttpContext.RewritePath(String,Boolean)
- uid: System.Web.HttpContext.RewritePath(System.String,System.String,System.String)
  parent: System.Web.HttpContext
  isExternal: false
  name: RewritePath(String,String,String)
  nameWithType: HttpContext.RewritePath(String,String,String)
  fullName: System.Web.HttpContext.RewritePath(String,String,String)
- uid: System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)
  parent: System.Web.HttpContext
  isExternal: false
  name: RewritePath(String,String,String,Boolean)
  nameWithType: HttpContext.RewritePath(String,String,String,Boolean)
  fullName: System.Web.HttpContext.RewritePath(String,String,String,Boolean)
- uid: System.Web.HttpContext.Server
  parent: System.Web.HttpContext
  isExternal: false
  name: Server
  nameWithType: HttpContext.Server
  fullName: System.Web.HttpContext.Server
- uid: System.Web.HttpServerUtility
  parent: System.Web
  isExternal: false
  name: HttpServerUtility
  nameWithType: HttpServerUtility
  fullName: System.Web.HttpServerUtility
- uid: System.Web.HttpContext.Session
  parent: System.Web.HttpContext
  isExternal: false
  name: Session
  nameWithType: HttpContext.Session
  fullName: System.Web.HttpContext.Session
- uid: System.Web.SessionState.HttpSessionState
  parent: System.Web.SessionState
  isExternal: false
  name: HttpSessionState
  nameWithType: HttpSessionState
  fullName: System.Web.SessionState.HttpSessionState
- uid: System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)
  parent: System.Web.HttpContext
  isExternal: false
  name: SetSessionStateBehavior(SessionStateBehavior)
  nameWithType: HttpContext.SetSessionStateBehavior(SessionStateBehavior)
  fullName: System.Web.HttpContext.SetSessionStateBehavior(SessionStateBehavior)
- uid: System.Web.SessionState.SessionStateBehavior
  parent: System.Web.SessionState
  isExternal: false
  name: SessionStateBehavior
  nameWithType: SessionStateBehavior
  fullName: System.Web.SessionState.SessionStateBehavior
- uid: System.Web.HttpContext.SkipAuthorization
  parent: System.Web.HttpContext
  isExternal: false
  name: SkipAuthorization
  nameWithType: HttpContext.SkipAuthorization
  fullName: System.Web.HttpContext.SkipAuthorization
- uid: System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)
  parent: System.Web.HttpContext
  isExternal: false
  name: System.IServiceProvider.GetService(Type)
  nameWithType: HttpContext.System.IServiceProvider.GetService(Type)
  fullName: System.Web.HttpContext.System.IServiceProvider.GetService(Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Web.HttpContext.ThreadAbortOnTimeout
  parent: System.Web.HttpContext
  isExternal: false
  name: ThreadAbortOnTimeout
  nameWithType: HttpContext.ThreadAbortOnTimeout
  fullName: System.Web.HttpContext.ThreadAbortOnTimeout
- uid: System.Web.HttpContext.Timestamp
  parent: System.Web.HttpContext
  isExternal: false
  name: Timestamp
  nameWithType: HttpContext.Timestamp
  fullName: System.Web.HttpContext.Timestamp
- uid: System.DateTime
  parent: System
  isExternal: true
  name: DateTime
  nameWithType: DateTime
  fullName: System.DateTime
- uid: System.Web.HttpContext.Trace
  parent: System.Web.HttpContext
  isExternal: false
  name: Trace
  nameWithType: HttpContext.Trace
  fullName: System.Web.HttpContext.Trace
- uid: System.Web.TraceContext
  parent: System.Web
  isExternal: false
  name: TraceContext
  nameWithType: TraceContext
  fullName: System.Web.TraceContext
- uid: System.Web.HttpContext.User
  parent: System.Web.HttpContext
  isExternal: false
  name: User
  nameWithType: HttpContext.User
  fullName: System.Web.HttpContext.User
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.Web.HttpContext.WebSocketNegotiatedProtocol
  parent: System.Web.HttpContext
  isExternal: false
  name: WebSocketNegotiatedProtocol
  nameWithType: HttpContext.WebSocketNegotiatedProtocol
  fullName: System.Web.HttpContext.WebSocketNegotiatedProtocol
- uid: System.Web.HttpContext.WebSocketRequestedProtocols
  parent: System.Web.HttpContext
  isExternal: false
  name: WebSocketRequestedProtocols
  nameWithType: HttpContext.WebSocketRequestedProtocols
  fullName: System.Web.HttpContext.WebSocketRequestedProtocols
- uid: System.Collections.Generic.IList{System.String}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<String>
  nameWithType: IList<String>
  fullName: System.Collections.Generic.IList<System.String>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.String>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Web.HttpContext.#ctor*
  parent: System.Web.HttpContext
  isExternal: false
  name: HttpContext
  nameWithType: HttpContext.HttpContext
- uid: System.Web.HttpContext.AcceptWebSocketRequest*
  parent: System.Web.HttpContext
  isExternal: false
  name: AcceptWebSocketRequest
  nameWithType: HttpContext.AcceptWebSocketRequest
- uid: System.Web.HttpContext.AddError*
  parent: System.Web.HttpContext
  isExternal: false
  name: AddError
  nameWithType: HttpContext.AddError
- uid: System.Web.HttpContext.AddOnRequestCompleted*
  parent: System.Web.HttpContext
  isExternal: false
  name: AddOnRequestCompleted
  nameWithType: HttpContext.AddOnRequestCompleted
- uid: System.Web.HttpContext.AllErrors*
  parent: System.Web.HttpContext
  isExternal: false
  name: AllErrors
  nameWithType: HttpContext.AllErrors
- uid: System.Web.HttpContext.AllowAsyncDuringSyncStages*
  parent: System.Web.HttpContext
  isExternal: false
  name: AllowAsyncDuringSyncStages
  nameWithType: HttpContext.AllowAsyncDuringSyncStages
- uid: System.Web.HttpContext.Application*
  parent: System.Web.HttpContext
  isExternal: false
  name: Application
  nameWithType: HttpContext.Application
- uid: System.Web.HttpContext.ApplicationInstance*
  parent: System.Web.HttpContext
  isExternal: false
  name: ApplicationInstance
  nameWithType: HttpContext.ApplicationInstance
- uid: System.Web.HttpContext.AsyncPreloadMode*
  parent: System.Web.HttpContext
  isExternal: false
  name: AsyncPreloadMode
  nameWithType: HttpContext.AsyncPreloadMode
- uid: System.Web.HttpContext.Cache*
  parent: System.Web.HttpContext
  isExternal: false
  name: Cache
  nameWithType: HttpContext.Cache
- uid: System.Web.HttpContext.ClearError*
  parent: System.Web.HttpContext
  isExternal: false
  name: ClearError
  nameWithType: HttpContext.ClearError
- uid: System.Web.HttpContext.Current*
  parent: System.Web.HttpContext
  isExternal: false
  name: Current
  nameWithType: HttpContext.Current
- uid: System.Web.HttpContext.CurrentHandler*
  parent: System.Web.HttpContext
  isExternal: false
  name: CurrentHandler
  nameWithType: HttpContext.CurrentHandler
- uid: System.Web.HttpContext.CurrentNotification*
  parent: System.Web.HttpContext
  isExternal: false
  name: CurrentNotification
  nameWithType: HttpContext.CurrentNotification
- uid: System.Web.HttpContext.DisposeOnPipelineCompleted*
  parent: System.Web.HttpContext
  isExternal: false
  name: DisposeOnPipelineCompleted
  nameWithType: HttpContext.DisposeOnPipelineCompleted
- uid: System.Web.HttpContext.Error*
  parent: System.Web.HttpContext
  isExternal: false
  name: Error
  nameWithType: HttpContext.Error
- uid: System.Web.HttpContext.GetAppConfig*
  parent: System.Web.HttpContext
  isExternal: false
  name: GetAppConfig
  nameWithType: HttpContext.GetAppConfig
- uid: System.Web.HttpContext.GetConfig*
  parent: System.Web.HttpContext
  isExternal: false
  name: GetConfig
  nameWithType: HttpContext.GetConfig
- uid: System.Web.HttpContext.GetGlobalResourceObject*
  parent: System.Web.HttpContext
  isExternal: false
  name: GetGlobalResourceObject
  nameWithType: HttpContext.GetGlobalResourceObject
- uid: System.Web.HttpContext.GetLocalResourceObject*
  parent: System.Web.HttpContext
  isExternal: false
  name: GetLocalResourceObject
  nameWithType: HttpContext.GetLocalResourceObject
- uid: System.Web.HttpContext.GetSection*
  parent: System.Web.HttpContext
  isExternal: false
  name: GetSection
  nameWithType: HttpContext.GetSection
- uid: System.Web.HttpContext.Handler*
  parent: System.Web.HttpContext
  isExternal: false
  name: Handler
  nameWithType: HttpContext.Handler
- uid: System.Web.HttpContext.IsCustomErrorEnabled*
  parent: System.Web.HttpContext
  isExternal: false
  name: IsCustomErrorEnabled
  nameWithType: HttpContext.IsCustomErrorEnabled
- uid: System.Web.HttpContext.IsDebuggingEnabled*
  parent: System.Web.HttpContext
  isExternal: false
  name: IsDebuggingEnabled
  nameWithType: HttpContext.IsDebuggingEnabled
- uid: System.Web.HttpContext.IsPostNotification*
  parent: System.Web.HttpContext
  isExternal: false
  name: IsPostNotification
  nameWithType: HttpContext.IsPostNotification
- uid: System.Web.HttpContext.IsWebSocketRequest*
  parent: System.Web.HttpContext
  isExternal: false
  name: IsWebSocketRequest
  nameWithType: HttpContext.IsWebSocketRequest
- uid: System.Web.HttpContext.IsWebSocketRequestUpgrading*
  parent: System.Web.HttpContext
  isExternal: false
  name: IsWebSocketRequestUpgrading
  nameWithType: HttpContext.IsWebSocketRequestUpgrading
- uid: System.Web.HttpContext.Items*
  parent: System.Web.HttpContext
  isExternal: false
  name: Items
  nameWithType: HttpContext.Items
- uid: System.Web.HttpContext.PageInstrumentation*
  parent: System.Web.HttpContext
  isExternal: false
  name: PageInstrumentation
  nameWithType: HttpContext.PageInstrumentation
- uid: System.Web.HttpContext.PreviousHandler*
  parent: System.Web.HttpContext
  isExternal: false
  name: PreviousHandler
  nameWithType: HttpContext.PreviousHandler
- uid: System.Web.HttpContext.Profile*
  parent: System.Web.HttpContext
  isExternal: false
  name: Profile
  nameWithType: HttpContext.Profile
- uid: System.Web.HttpContext.RemapHandler*
  parent: System.Web.HttpContext
  isExternal: false
  name: RemapHandler
  nameWithType: HttpContext.RemapHandler
- uid: System.Web.HttpContext.Request*
  parent: System.Web.HttpContext
  isExternal: false
  name: Request
  nameWithType: HttpContext.Request
- uid: System.Web.HttpContext.Response*
  parent: System.Web.HttpContext
  isExternal: false
  name: Response
  nameWithType: HttpContext.Response
- uid: System.Web.HttpContext.RewritePath*
  parent: System.Web.HttpContext
  isExternal: false
  name: RewritePath
  nameWithType: HttpContext.RewritePath
- uid: System.Web.HttpContext.Server*
  parent: System.Web.HttpContext
  isExternal: false
  name: Server
  nameWithType: HttpContext.Server
- uid: System.Web.HttpContext.Session*
  parent: System.Web.HttpContext
  isExternal: false
  name: Session
  nameWithType: HttpContext.Session
- uid: System.Web.HttpContext.SetSessionStateBehavior*
  parent: System.Web.HttpContext
  isExternal: false
  name: SetSessionStateBehavior
  nameWithType: HttpContext.SetSessionStateBehavior
- uid: System.Web.HttpContext.SkipAuthorization*
  parent: System.Web.HttpContext
  isExternal: false
  name: SkipAuthorization
  nameWithType: HttpContext.SkipAuthorization
- uid: System.Web.HttpContext.System#IServiceProvider#GetService*
  parent: System.Web.HttpContext
  isExternal: false
  name: System.IServiceProvider.GetService
  nameWithType: HttpContext.System.IServiceProvider.GetService
- uid: System.Web.HttpContext.ThreadAbortOnTimeout*
  parent: System.Web.HttpContext
  isExternal: false
  name: ThreadAbortOnTimeout
  nameWithType: HttpContext.ThreadAbortOnTimeout
- uid: System.Web.HttpContext.Timestamp*
  parent: System.Web.HttpContext
  isExternal: false
  name: Timestamp
  nameWithType: HttpContext.Timestamp
- uid: System.Web.HttpContext.Trace*
  parent: System.Web.HttpContext
  isExternal: false
  name: Trace
  nameWithType: HttpContext.Trace
- uid: System.Web.HttpContext.User*
  parent: System.Web.HttpContext
  isExternal: false
  name: User
  nameWithType: HttpContext.User
- uid: System.Web.HttpContext.WebSocketNegotiatedProtocol*
  parent: System.Web.HttpContext
  isExternal: false
  name: WebSocketNegotiatedProtocol
  nameWithType: HttpContext.WebSocketNegotiatedProtocol
- uid: System.Web.HttpContext.WebSocketRequestedProtocols*
  parent: System.Web.HttpContext
  isExternal: false
  name: WebSocketRequestedProtocols
  nameWithType: HttpContext.WebSocketRequestedProtocols
