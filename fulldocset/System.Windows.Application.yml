### YamlMime:ManagedReference
items:
- uid: System.Windows.Application
  id: Application
  children:
  - System.Windows.Application.#ctor
  - System.Windows.Application.Activated
  - System.Windows.Application.Current
  - System.Windows.Application.Deactivated
  - System.Windows.Application.DispatcherUnhandledException
  - System.Windows.Application.Exit
  - System.Windows.Application.FindResource(System.Object)
  - System.Windows.Application.FragmentNavigation
  - System.Windows.Application.GetContentStream(System.Uri)
  - System.Windows.Application.GetCookie(System.Uri)
  - System.Windows.Application.GetRemoteStream(System.Uri)
  - System.Windows.Application.GetResourceStream(System.Uri)
  - System.Windows.Application.LoadCompleted
  - System.Windows.Application.LoadComponent(System.Uri)
  - System.Windows.Application.LoadComponent(System.Object,System.Uri)
  - System.Windows.Application.MainWindow
  - System.Windows.Application.Navigated
  - System.Windows.Application.Navigating
  - System.Windows.Application.NavigationFailed
  - System.Windows.Application.NavigationProgress
  - System.Windows.Application.NavigationStopped
  - System.Windows.Application.OnActivated(System.EventArgs)
  - System.Windows.Application.OnDeactivated(System.EventArgs)
  - System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  - System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  - System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  - System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  - System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  - System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  - System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  - System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  - System.Windows.Application.Properties
  - System.Windows.Application.ResourceAssembly
  - System.Windows.Application.Resources
  - System.Windows.Application.Run
  - System.Windows.Application.Run(System.Windows.Window)
  - System.Windows.Application.SessionEnding
  - System.Windows.Application.SetCookie(System.Uri,System.String)
  - System.Windows.Application.Shutdown
  - System.Windows.Application.Shutdown(System.Int32)
  - System.Windows.Application.ShutdownMode
  - System.Windows.Application.Startup
  - System.Windows.Application.StartupUri
  - System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  - System.Windows.Application.TryFindResource(System.Object)
  - System.Windows.Application.Windows
  langs:
  - csharp
  name: Application
  nameWithType: Application
  fullName: System.Windows.Application
  type: Class
  summary: "封裝[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]應用程式。"
  remarks: "應用程式是封裝的類別[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]應用程式專屬功能，包括下列:-**應用程式存留期**: <xref:System.Windows.Application.Activated> <xref:System.Windows.Application.Current%2A> <xref:System.Windows.Application.Deactivated> <xref:System.Windows.Application.DispatcherUnhandledException> <xref:System.Windows.Application.Exit> <xref:System.Windows.Application.Run%2A> <xref:System.Windows.Application.SessionEnding> <xref:System.Windows.Application.Shutdown%2A> <xref:System.Windows.Application.ShutdownMode%2A>、 <xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.Application.SessionEnding> </xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application.Exit> </xref:System.Windows.Application.DispatcherUnhandledException> </xref:System.Windows.Application.Deactivated> </xref:System.Windows.Application.Current%2A> </xref:System.Windows.Application.Activated>      -**應用程式範圍 視窗、 屬性和資源管理**: <xref:System.Windows.Application.FindResource%2A> <xref:System.Windows.Application.GetContentStream%2A> <xref:System.Windows.Application.GetResourceStream%2A> <xref:System.Windows.Application.LoadComponent%2A> <xref:System.Windows.Application.MainWindow%2A> <xref:System.Windows.Application.Properties%2A> <xref:System.Windows.Application.Resources%2A> <xref:System.Windows.Application.StartupUri%2A>、 <xref:System.Windows.Application.Windows%2A>.</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Application.StartupUri%2A> </xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application.Properties%2A> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.LoadComponent%2A> </xref:System.Windows.Application.GetResourceStream%2A> </xref:System.Windows.Application.GetContentStream%2A> </xref:System.Windows.Application.FindResource%2A>      -**命令列參數並結束程式碼處理**: <xref:System.Windows.Application.Startup?displayProperty=fullName> <xref:System.Windows.Application.Exit?displayProperty=fullName>、 <xref:System.Windows.Application.Shutdown%2A?displayProperty=fullName>.</xref:System.Windows.Application.Shutdown%2A?displayProperty=fullName> </xref:System.Windows.Application.Exit?displayProperty=fullName> </xref:System.Windows.Application.Startup?displayProperty=fullName>      -   **Navigation**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.</xref:System.Windows.Application.GetCookie%2A></xref:System.Windows.Application.SetCookie%2A></xref:System.Windows.Application.NavigationFailed></xref:System.Windows.Application.NavigationStopped></xref:System.Windows.Application.NavigationProgress></xref:System.Windows.Application.Navigating></xref:System.Windows.Application.Navigated></xref:System.Windows.Application.LoadCompleted></xref:System.Windows.Application.FragmentNavigation>       應用程式實作單一子句模式，以提供其視窗、 屬性和資源範圍服務的共用存取權。 因此，建立應用程式類別只有一個執行個體，每<xref:System.AppDomain>.</xref:System.AppDomain>       您可以實作使用標記、 標記和程式碼後置或程式碼的應用程式。 如果應用程式以實作標記，標記檔案標記或標記和程式碼後置，必須設定為是否[!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)]`ApplicationDefinition`項目。      > [!NOTE] > 的獨立應用程式不需要的應用程式物件，它也可以實作自訂`static`進入點方法 (`Main`)，而不建立應用程式的執行個體開啟的視窗。 不過，[!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]需要應用程式物件。"
  example:
  - "The following example shows how a standard application is defined using only markup:  \n  \n [!code-xml[ApplicationSnippets#ApplicationMARKUP](~/add/codesnippet/xaml/ApplicationSnippets.CSharp/AppMarkup.xaml#applicationmarkup)]  \n  \n The following example shows how a standard application is defined using only code:  \n  \n [!code-cs[ApplicationSnippets#ApplicationCODE](~/add/codesnippet/csharp/ApplicationSnippets.CSharp/AppCode.cs#applicationcode)]\n [!code-vb[ApplicationSnippets#ApplicationCODE](~/add/codesnippet/visualbasic/applicationsnippets/appcode.vb#applicationcode)]  \n  \n The following example shows how a standard application is defined using a combination of markup and code-behind.  \n  \n [!code-xml[ApplicationSnippets#ApplicationXAML](~/add/codesnippet/xaml/ApplicationSnippets.CSharp/App.xaml#applicationxaml)]  \n  \n [!code-cs[ApplicationSnippets#ApplicationCODEBEHIND](~/add/codesnippet/csharp/ApplicationSnippets.CSharp/App.xaml.cs#applicationcodebehind)]\n [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/add/codesnippet/visualbasic/applicationsnippets/application.xaml.vb#applicationcodebehind)]"
  syntax:
    content: 'public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient'
  inheritance:
  - System.Object
  - System.Windows.Threading.DispatcherObject
  implements:
  - System.Windows.Markup.IQueryAmbient
  inheritedMembers:
  - System.Windows.Threading.DispatcherObject.CheckAccess
  - System.Windows.Threading.DispatcherObject.Dispatcher
  - System.Windows.Threading.DispatcherObject.VerifyAccess
  platform:
  - net462
- uid: System.Windows.Application.#ctor
  id: '#ctor'
  parent: System.Windows.Application
  langs:
  - csharp
  name: Application()
  nameWithType: Application.Application()
  fullName: System.Windows.Application.Application()
  type: Constructor
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.Application&quot;></xref>類別。"
  remarks: "只有一個執行個體<xref:System.Windows.Application>類別可由每個<xref:System.AppDomain>，以確保單一資料集的應用程式範圍 視窗、 屬性和資源的共用的存取。</xref:System.AppDomain> </xref:System.Windows.Application> 因此，預設的建構函式<xref:System.Windows.Application>類別會偵測是否已初始化的執行個體中的第一個執行個體<xref:System.AppDomain>; 如果不是，<xref:System.InvalidOperationException>就會擲回。</xref:System.InvalidOperationException> </xref:System.AppDomain> </xref:System.Windows.Application>       <xref:System.Windows.Application>物件目前<xref:System.AppDomain>公開靜態<xref:System.Windows.Application.Current%2A>屬性。</xref:System.Windows.Application.Current%2A> </xref:System.AppDomain> </xref:System.Windows.Application>"
  syntax:
    content: public Application ();
    parameters: []
  overload: System.Windows.Application.#ctor*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "多個執行個體<xref href=&quot;System.Windows.Application&quot;></xref>類別建立每個<xref href=&quot;System.AppDomain&quot;> </xref>。"
  platform:
  - net462
- uid: System.Windows.Application.Activated
  id: Activated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Activated
  nameWithType: Application.Activated
  fullName: System.Windows.Application.Activated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "發生於應用程式變成前景應用程式。"
  remarks: "A[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]啟動應用程式具有一個或多個開啟的視窗 （變成前景應用程式） 當其中一個 windows 啟動時第一次啟動應用程式，因為或其中一個視窗在何時啟用非作用中應用程式時︰ 特別是，啟用，就會發生時:-應用程式開啟其第一個視窗。      -使用者切換至應用程式使用 ALT + TAB，或使用 工作管理員。      -使用者按一下其中一個應用程式視窗的工作列按鈕。       需要偵測當他們所啟動的應用程式可以處理已啟動事件。       第一次啟動應用程式之後，它可能會停用並重新啟動幾次在其存留期間。 如果應用程式的狀態或行為取決於其啟動狀態，它可以處理啟動和<xref:System.Windows.Application.Deactivated>事件，以判斷哪一個啟用狀態的英吋</xref:System.Windows.Application.Deactivated>       一旦應用程式變成作用中，啟動系統不會引發一次直到應用程式停用時，不論是在應用程式使用中時，會啟動多少 windows 應用程式中。       啟動不會引發[!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]。"
  example:
  - "The following example shows how to detect when a standalone application activates and deactivates.  \n  \n [!code-xml[ApplicationActivationSnippets#DetectActivationStateXAML](~/add/codesnippet/xaml/ApplicationActivationSnippets.CSharp/App.xaml#detectactivationstatexaml)]  \n  \n [!code-cs[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/csharp/ApplicationActivationSnippets.CSharp/App.xaml.cs#detectactivationstatecodebehind)]\n [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/visualbasic/applicationactivationsnippets/application.xaml.vb#detectactivationstatecodebehind)]"
  syntax:
    content: public event EventHandler Activated;
    return:
      type: System.EventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Current
  id: Current
  parent: System.Windows.Application
  langs:
  - csharp
  name: Current
  nameWithType: Application.Current
  fullName: System.Windows.Application.Current
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得<xref href=&quot;System.Windows.Application&quot;></xref>物件目前<xref href=&quot;System.AppDomain&quot;> </xref>。"
  remarks: "<xref:System.Windows.Application>為每個-<xref:System.AppDomain>單一型別，它會實作靜態的目前屬性，以提供共用的存取<xref:System.Windows.Application><xref:System.AppDomain>.</xref:System.AppDomain>在目前的執行個體</xref:System.Windows.Application></xref:System.AppDomain></xref:System.Windows.Application> 此設計會保證受該狀態<xref:System.Windows.Application>包括共用的資源和狀態，而且可從單一的共用位置。</xref:System.Windows.Application>       這個屬性是安全執行緒，可從任何執行緒。"
  syntax:
    content: public static System.Windows.Application Current { get; }
    return:
      type: System.Windows.Application
      description: "<xref href=&quot;System.Windows.Application&quot;> </xref>物件目前<xref href=&quot;System.AppDomain&quot;> </xref>。"
  overload: System.Windows.Application.Current*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Deactivated
  id: Deactivated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Deactivated
  nameWithType: Application.Deactivated
  fullName: System.Windows.Application.Deactivated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "發生於應用程式停止前景應用程式。"
  remarks: "A[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]具有一或多個開啟的 windows 應用程式，就會停用 （停止前景應用程式） 時使用者會執行下列:-使用 ALT + TAB，或使用 工作管理員會切換成另一個應用程式。      -按一下另一個應用程式視窗的工作列按鈕。       需要偵測停用的應用程式可以處理停用事件。       第一次啟動應用程式之後，它可能會停用並重新啟動幾次在其存留期間。 如果應用程式的狀態或行為取決於其啟動狀態，它可以處理這兩種停用和<xref:System.Windows.Application.Activated>事件，以判斷其狀態是英吋</xref:System.Windows.Application.Activated>       停用不會引發[!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]。"
  example:
  - "The following example shows how to detect when a standalone application deactivates and activates.  \n  \n [!code-xml[ApplicationActivationSnippets#DetectActivationStateXAML](~/add/codesnippet/xaml/ApplicationActivationSnippets.CSharp/App.xaml#detectactivationstatexaml)]  \n  \n [!code-cs[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/csharp/ApplicationActivationSnippets.CSharp/App.xaml.cs#detectactivationstatecodebehind)]\n [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/add/codesnippet/visualbasic/applicationactivationsnippets/application.xaml.vb#detectactivationstatecodebehind)]"
  syntax:
    content: public event EventHandler Deactivated;
    return:
      type: System.EventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.DispatcherUnhandledException
  id: DispatcherUnhandledException
  parent: System.Windows.Application
  langs:
  - csharp
  name: DispatcherUnhandledException
  nameWithType: Application.DispatcherUnhandledException
  fullName: System.Windows.Application.DispatcherUnhandledException
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "發生於應用程式所擲回但未處理例外狀況。"
  remarks: "根據預設，[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]攔截未處理例外狀況、 通知使用者 （從中它們可以回報該例外狀況） 對話方塊中，從例外狀況，並自動關閉應用程式。       不過，如果應用程式需要執行自訂處理的例外狀況處理從一個集中位置，您應該處理 DispatcherUnhandledException。       引發 DispatcherUnhandledException<xref:System.Windows.Application>的每個主要 UI 執行緒上執行的程式碼未處理的例外狀況。</xref:System.Windows.Application>       如果未處理例外狀況上背景[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]執行緒 (使用它自己的執行緒<xref:System.Windows.Threading.Dispatcher>) 或背景工作執行緒 (沒有執行緒<xref:System.Windows.Threading.Dispatcher>)，例外狀況不會轉送至 main[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]執行緒。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Threading.Dispatcher> 因此，不會引發 DispatcherUnhandledException。 在這些情況下，您必須撰寫程式碼來執行下列動作︰ 1。  處理背景執行緒上的例外狀況。      2.  分派這些例外狀況的主要[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]執行緒。      3.  會重新擲回它們在主要[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]執行緒，而不處理它們允許 DispatcherUnhandledException 引發。       如需詳細資訊，請參閱[執行緒模型](~/add/includes/ajax-current-ext-md.md)概觀。       DispatcherUnhandledException 事件處理常式會傳遞<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>引數，其中包含有關例外狀況，內容資訊包括:-例外狀況 (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>)。</xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A> </xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs>      -<xref:System.Windows.Threading.Dispatcher>從起源自 (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>)。</xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A> </xref:System.Windows.Threading.Dispatcher>       您可以使用這項資訊來判斷例外狀況是否為可復原。 可復原的例外狀況可能是<xref:System.IO.FileNotFoundException>，例如，時間可能會無法復原的例外狀況<xref:System.StackOverflowException>，例如。</xref:System.StackOverflowException> </xref:System.IO.FileNotFoundException>       當您處理 DispatcherUnhandledException，發生未處理例外狀況，而且您不想[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]繼續處理它，您需要設定<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>屬性`true`。</xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A>       不同於其他事件， <xref:System.Windows.Application>DispatcherUnhandledException 會引發，並沒有比對受保護虛擬實作 (OnDispatcherUnhandledException)。</xref:System.Windows.Application> 因此，類別衍生自<xref:System.Windows.Application>一律必須向處理未處理例外狀況的 DispatcherUnhandledException 註冊事件處理常式。</xref:System.Windows.Application>"
  example:
  - "The following example shows how to process unhandled exceptions by handling the DispatcherUnhandledException event.  \n  \n [!code-cs[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/add/codesnippet/csharp/ApplicationDispatcherUnhandledExceptionSnippets.CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]\n [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/add/codesnippet/visualbasic/applicationdispatcherunhandledexceptionsnippets/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  \n[!code-cs[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/add/codesnippet/csharp/ApplicationDispatcherUnhandledExceptionSnippets.CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]\n[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/add/codesnippet/visualbasic/applicationdispatcherunhandledexceptionsnippets/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]"
  syntax:
    content: public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;
    return:
      type: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Exit
  id: Exit
  parent: System.Windows.Application
  langs:
  - csharp
  name: Exit
  nameWithType: Application.Exit
  fullName: System.Windows.Application.Exit
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "應用程式關閉，而且不能取消之前發生。"
  remarks: "應用程式可以關機的原因如下:-<xref:System.Windows.Application.Shutdown%2A>方法<xref:System.Windows.Application>物件就會呼叫，以明確或決定<xref:System.Windows.Application.ShutdownMode%2A>屬性。</xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application> </xref:System.Windows.Application.Shutdown%2A>      -使用者會透過登出或關機，結束工作階段。       您可以偵測應用程式關閉時處理結束事件，並執行任何所需的額外處理。       您也可以處理來檢查或變更應用程式結束代碼，當您不需要呼叫結束<xref:System.Windows.Application.Shutdown%2A>明確。</xref:System.Windows.Application.Shutdown%2A> 結束代碼從公開<xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>屬性<xref:System.Windows.ExitEventArgs>傳遞給結束事件處理常式的引數。</xref:System.Windows.ExitEventArgs> </xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> 當應用程式停止執行時，結束代碼會傳遞給作業系統，供後續處理。       如果您的應用程式處理<xref:System.Windows.Application.SessionEnding>事件和後續取消結束，它就不會引發和應用程式繼續執行的像素來關機模式。</xref:System.Windows.Application.SessionEnding>       可設定結束碼[!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]，但是會忽略這個值。       如[!INCLUDE[TLA2#tla_xbap#plural](~/add/includes/tla2sharptla-xbapsharpplural-md.md)]，在下列情況中將會引發結束:-[!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)]巡覽離開的。      -在[!INCLUDE[TLA2#tla_ie7](~/add/includes/tla2sharptla-ie7-md.md)]，當 [] 索引標籤裝載[!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)]已關閉。      -當瀏覽器關閉時。       在所有情況下，值<xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>屬性會被忽略。</xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A>"
  example:
  - "The following example demonstrates how to:  \n  \n-   Handle the Exit event.  \n  \n-   Inspect and update the <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> property of the <xref:System.Windows.ExitEventArgs>.  \n  \n-   Write an entry to an application log in isolated storage.  \n  \n-   Persist the application state to isolated storage.  \n  \n [!code-xml[ApplicationExitSnippets#HandleExitXAML](~/add/codesnippet/xaml/ApplicationExitSnippets.CSharp/App.xaml#handleexitxaml)]  \n  \n [!code-cs[ApplicationExitSnippets#HandleExitCODEBEHIND](~/add/codesnippet/csharp/ApplicationExitSnippets.CSharp/App.xaml.cs#handleexitcodebehind)]\n [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/add/codesnippet/visualbasic/applicationexitsnippets/application.xaml.vb#handleexitcodebehind)]"
  syntax:
    content: public event System.Windows.ExitEventHandler Exit;
    return:
      type: System.Windows.ExitEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.FindResource(System.Object)
  id: FindResource(System.Object)
  parent: System.Windows.Application
  langs:
  - csharp
  name: FindResource(Object)
  nameWithType: Application.FindResource(Object)
  fullName: System.Windows.Application.FindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "搜尋[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]資源，例如<xref href=&quot;System.Windows.Style&quot;></xref>或<xref href=&quot;System.Windows.Media.Brush&quot;> </xref>、 具有指定之索引鍵，則擲回的例外狀況，如果找不到要求的資源 (請參閱[XAML 資源](~/add/includes/ajax-current-ext-md.md))。"
  remarks: "FindResource 會先查看應用程式範圍的資源，為指定的資源。 應用程式範圍的資源由管理<xref:System.Windows.Application>，而且會公開從<xref:System.Windows.Application.Resources%2A>屬性。</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application> 如果應用程式範圍的資源集中找不到指定的資源，FindResource 再接下來會搜尋系統資源。 系統資源是由使用者定義的 shell 資源，並且包含色彩、 字型及殼層組態。 這些由公開<xref:System.Windows.SystemColors>， <xref:System.Windows.SystemFonts>，和<xref:System.Windows.SystemParameters>類型，分別靜態屬性。</xref:System.Windows.SystemParameters> </xref:System.Windows.SystemFonts> </xref:System.Windows.SystemColors> 若要使用 FindResource 取得它們，這些型別也會公開資源的索引鍵屬性是設計成可傳遞至 FindResource;例如， <xref:System.Windows.SystemParameters.IconWidthKey%2A>.</xref:System.Windows.SystemParameters.IconWidthKey%2A>       FindResource 傳回的物件，因為您必須先轉換適當的型別傳回的值，如果找到資源。      > [!IMPORTANT] > 如果找不到機碼中呼叫這個方法，會擲回例外狀況。 如果您不想處理的例外狀況所導致的呼叫 FindResource，<xref:System.Windows.Application.TryFindResource%2A>改為呼叫;<xref:System.Windows.Application.TryFindResource%2A>傳回`null`時找不到要求的資源，並不會擲回例外狀況參考。</xref:System.Windows.Application.TryFindResource%2A> </xref:System.Windows.Application.TryFindResource%2A>       這個方法是安全執行緒，可以從任何執行緒呼叫。"
  example:
  - "The following example shows how to use FindResource to find a resource, and to handle <xref:System.Windows.ResourceReferenceKeyNotFoundException> if the resource is not found.  \n  \n [!code-cs[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/add/codesnippet/csharp/ApplicationFindResourceSnippets/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]\n [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/add/codesnippet/visualbasic/applicationfindresourcesnippets/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]"
  syntax:
    content: public object FindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "要尋找之資源的名稱。"
    return:
      type: System.Object
      description: "要求的資源物件。 如果找不到要求的資源， <xref href=&quot;System.Windows.ResourceReferenceKeyNotFoundException&quot;> </xref>就會擲回。"
  overload: System.Windows.Application.FindResource*
  exceptions:
  - type: System.Windows.ResourceReferenceKeyNotFoundException
    commentId: T:System.Windows.ResourceReferenceKeyNotFoundException
    description: "找不到資源。"
  platform:
  - net462
- uid: System.Windows.Application.FragmentNavigation
  id: FragmentNavigation
  parent: System.Windows.Application
  langs:
  - csharp
  name: FragmentNavigation
  nameWithType: Application.FragmentNavigation
  fullName: System.Windows.Application.FragmentNavigation
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "發生於應用程式中的巡覽開始導覽至內容片段中，如果想要的片段是在目前內容中，或來源之後立即進行巡覽[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]要的片段不同的內容是否已載入內容。"
  remarks: "導覽是其中一個<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       請參閱<xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;
    return:
      type: System.Windows.Navigation.FragmentNavigationEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.GetContentStream(System.Uri)
  id: GetContentStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetContentStream(Uri)
  nameWithType: Application.GetContentStream(Uri)
  fullName: System.Windows.Application.GetContentStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "傳回位於指定的內容資料檔案的資源資料流<xref:System.Uri>(請參閱[WPF 應用程式資源、 內容和資料檔案](~/add/includes/ajax-current-ext-md.md))。</xref:System.Uri>"
  remarks: "這個方法不具備執行緒安全。"
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);
    parameters:
    - id: uriContent
      type: System.Uri
      description: "將相對<xref:System.Uri>對應至鬆散的資源。</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "A <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> ，其中包含的內容資料檔，位於指定<xref:System.Uri>.</xref:System.Uri> 如果找不到鬆散的資源，則會傳回 null。"
  overload: System.Windows.Application.GetContentStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref:System.Uri>傳遞至 GetContentStream 為 null。</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Uri>也就是傳遞至 GetContentStream 是絕對<xref:System.Uri>.</xref:System.Uri> </xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.GetCookie(System.Uri)
  id: GetCookie(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetCookie(Uri)
  nameWithType: Application.GetCookie(Uri)
  fullName: System.Windows.Application.GetCookie(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "擷取的 cookie <xref:System.Uri>.</xref:System.Uri>所指定的位置"
  remarks: "GetCookie 擷取指定<xref:System.Uri>。</xref:System.Uri> cookie 如果無法擷取 cookie，<xref:System.ComponentModel.Win32Exception>就會擲回。</xref:System.ComponentModel.Win32Exception> 您需要撰寫程式碼將 cookie 字串剖析成名稱/值組的清單。       如概觀中的 cookie [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]，請參閱[巡覽概觀](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public static string GetCookie (Uri uri);
    parameters:
    - id: uri
      type: System.Uri
      description: "<xref:System.Uri>可指定為其建立 cookie 的位置。</xref:System.Uri>"
    return:
      type: System.String
      description: "A<xref:System.String>值，如果存在 cookie，否則<xref href=&quot;System.ComponentModel.Win32Exception&quot;></xref>就會擲回。</xref:System.String>"
  overload: System.Windows.Application.GetCookie*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "A[!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)]產生錯誤時<xref uid=&quot;langword_csharp_InternetGetCookie&quot; name=&quot;InternetGetCookie&quot; href=&quot;&quot;></xref>函式 （由 GetCookie 呼叫） 嘗試擷取指定的 cookie 時，發生問題時。"
  platform:
  - net462
- uid: System.Windows.Application.GetRemoteStream(System.Uri)
  id: GetRemoteStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetRemoteStream(Uri)
  nameWithType: Application.GetRemoteStream(Uri)
  fullName: System.Windows.Application.GetRemoteStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "傳回位於指定的站台的來源資料檔的資源資料流<xref:System.Uri>(請參閱[WPF 應用程式資源、 內容和資料檔案](~/add/includes/ajax-current-ext-md.md))。</xref:System.Uri>"
  remarks: "這個方法不具備執行緒安全。"
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);
    parameters:
    - id: uriRemote
      type: System.Uri
      description: "<xref:System.Uri>對應至鬆散的來源站台資源。</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "A <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> ，其中包含指定<xref:System.Uri>.</xref:System.Uri>位於站台的原始資料檔案的資源資料流 如果找不到鬆散的資源， <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>傳回。"
  overload: System.Windows.Application.GetRemoteStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref:System.Uri>傳遞至 GetRemoteStream 為 null。</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Uri>傳遞至 GetRemoteStream 不相關，而不是位於絕對值`pack://siteoforigin:,,,/`表單。</xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.GetResourceStream(System.Uri)
  id: GetResourceStream(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: GetResourceStream(Uri)
  nameWithType: Application.GetResourceStream(Uri)
  fullName: System.Windows.Application.GetResourceStream(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "傳回位於指定之資源的資料檔的資源資料流<xref:System.Uri>(請參閱[WPF 應用程式資源、 內容和資料檔案](~/add/includes/ajax-current-ext-md.md))。</xref:System.Uri>"
  remarks: "這個方法不具備執行緒安全。"
  syntax:
    content: public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);
    parameters:
    - id: uriResource
      type: System.Uri
      description: "<xref:System.Uri>可對應到內嵌資源。</xref:System.Uri>"
    return:
      type: System.Windows.Resources.StreamResourceInfo
      description: "A <xref href=&quot;System.Windows.Resources.StreamResourceInfo&quot;> </xref> ，其中包含位於指定<xref:System.Uri>.</xref:System.Uri>的資源資料檔案的資源資料流"
  overload: System.Windows.Application.GetResourceStream*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref:System.Uri>傳遞至 GetResourceStream 為 null。</xref:System.Uri>"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<xref:System.Uri>傳遞至 GetResourceStream 不相關，而不是位於絕對值`pack://application:,,,/`表單。</xref:System.Uri>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<xref:System.Uri>傳遞至找不到 GetResourceStream。</xref:System.Uri>"
  platform:
  - net462
- uid: System.Windows.Application.LoadCompleted
  id: LoadCompleted
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadCompleted
  nameWithType: Application.LoadCompleted
  fullName: System.Windows.Application.LoadCompleted
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "發生於應用程式中的巡覽所巡覽的內容已載入，剖析，並開始呈現。"
  remarks: "導覽是其中一個<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       請參閱<xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=fullName>      > [!NOTE] > 這類接聽事件上巡覽內容<xref:System.Windows.FrameworkElement.Loaded>事件<xref:System.Windows.Controls.Page>存取巡覽內容的屬性之前。</xref:System.Windows.Controls.Page> </xref:System.Windows.FrameworkElement.Loaded>"
  syntax:
    content: public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;
    return:
      type: System.Windows.Navigation.LoadCompletedEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.LoadComponent(System.Uri)
  id: LoadComponent(System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadComponent(Uri)
  nameWithType: Application.LoadComponent(Uri)
  fullName: System.Windows.Application.LoadComponent(Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "載入[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]位在指定的檔案[!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)]，並將它轉換為物件的根項目所指定的執行個體[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]檔案。"
  remarks: "您必須明確轉換成相同類型的根項目為傳回值[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]檔案。       [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]檔案可以是應用程式程式碼檔案 (設定為[!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)]頁面項目) 或應用程式資料檔案 (資源檔中，內容檔案或站台的來源檔案，請參閱 < [WPF 應用程式資源、 內容和資料檔案](~/add/includes/ajax-current-ext-md.md))。      > [!NOTE] > 這個方法不是安全執行緒。"
  syntax:
    content: public static object LoadComponent (Uri resourceLocator);
    parameters:
    - id: resourceLocator
      type: System.Uri
      description: "A<xref:System.Uri>對應至相對之[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]檔案。</xref:System.Uri>"
    return:
      type: System.Object
      description: "指定載入之 XAML 檔案的根項目執行個體。"
  overload: System.Windows.Application.LoadComponent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceLocator</code>為 null。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>resourceLocator</code> is an absolute [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)]."
  - type: System.Exception
    commentId: T:System.Exception
    description: "檔案不是[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]檔案。"
  platform:
  - net462
- uid: System.Windows.Application.LoadComponent(System.Object,System.Uri)
  id: LoadComponent(System.Object,System.Uri)
  parent: System.Windows.Application
  langs:
  - csharp
  name: LoadComponent(Object,Uri)
  nameWithType: Application.LoadComponent(Object,Uri)
  fullName: System.Windows.Application.LoadComponent(Object,Uri)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "載入[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]位在指定的檔案[!INCLUDE[TLA#tla_uri](~/add/includes/tlasharptla-uri-md.md)]並將它轉換為物件的根項目所指定的執行個體[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]檔案。"
  remarks: "[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]檔案可以是應用程式程式碼檔案 (設定為[!INCLUDE[TLA#tla_msbuild](~/add/includes/tlasharptla-msbuild-md.md)]頁面項目) 或應用程式資料檔案 (資源檔中，內容檔案或站台的來源檔案，請參閱 < [WPF 應用程式資源、 內容和資料檔案](~/add/includes/ajax-current-ext-md.md))。      > [!NOTE] > 這個方法不是安全執行緒。"
  syntax:
    content: public static void LoadComponent (object component, Uri resourceLocator);
    parameters:
    - id: component
      type: System.Object
      description: "相同的根項目類型的物件[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]檔案。"
    - id: resourceLocator
      type: System.Uri
      description: "A<xref:System.Uri>對應至相對之[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]檔案。</xref:System.Uri>"
  overload: System.Windows.Application.LoadComponent*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>resourceLocator</code>為 null。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <code>resourceLocator</code> is an absolute [!INCLUDE[TLA2#tla_uri](~/add/includes/tla2sharptla-uri-md.md)]."
  - type: System.Exception
    commentId: T:System.Exception
    description: "<code>component</code>不符合的根元素的類型[!INCLUDE[TLA2#tla_xaml](~/add/includes/tla2sharptla-xaml-md.md)]檔案。"
  platform:
  - net462
- uid: System.Windows.Application.MainWindow
  id: MainWindow
  parent: System.Windows.Application
  langs:
  - csharp
  name: MainWindow
  nameWithType: Application.MainWindow
  fullName: System.Windows.Application.MainWindow
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定應用程式的主視窗。"
  remarks: "第一個<xref:System.Windows.Window>要在<xref:System.AppDomain>.</xref:System.AppDomain>具現化物件</xref:System.Windows.Window>的參考，會自動設定 MainWindow       您可以藉由設定 MainWindow 指派另一個指定不同的主視窗<xref:System.Windows.Application.Windows%2A>MainWindow 屬性的物件。</xref:System.Windows.Application.Windows%2A>       如果<xref:System.Windows.Application.ShutdownMode%2A>屬性<xref:System.Windows.Application>物件設定為<xref:System.Windows.ShutdownMode>，關閉主視窗會關閉應用程式。</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application> </xref:System.Windows.Application.ShutdownMode%2A>       您可從 MainWindow 屬性設為[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]，如果應用程式的主視窗不是設定所產生的視窗<xref:System.Windows.Application.StartupUri%2A>屬性[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]。</xref:System.Windows.Application.StartupUri%2A> 兩個限制[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]方法是:-您可以指定[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]-只<xref:System.Windows.Window>或[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]-只<xref:System.Windows.Navigation.NavigationWindow>做為主要的視窗。</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Window>      -您必須設定<xref:System.Windows.UIElement.Visibility%2A>您所指定視窗的屬性，否則它將不會顯示。</xref:System.Windows.UIElement.Visibility%2A>       第一個參考<xref:System.Windows.Window>要具現化物件也會加入做為第一個項目<xref:System.Windows.Application.Windows%2A>集合。</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Window> 如果 MainWindow 後續設定至不同的參考<xref:System.Windows.Window>，將會變更主視窗的參考之項目的位置，在順序中的項目時<xref:System.Windows.Application.Windows%2A>維持不變。</xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Window> 因此，一律使用 MainWindow 參考到主視窗而不是<xref:System.Windows.Application.Windows%2A>.</xref:System.Windows.Application.Windows%2A>中的第一個項目      > [!NOTE] > 主視窗是否<xref:System.Windows.Navigation.NavigationWindow>，您需要特定的存取權<xref:System.Windows.Navigation.NavigationWindow>的成員，您必須為<xref:System.Windows.Navigation.NavigationWindow>。</xref:System.Windows.Navigation.NavigationWindow> MainWindow 值轉型</xref:System.Windows.Navigation.NavigationWindow>和</xref:System.Windows.Navigation.NavigationWindow>   >> 這個屬性就只能從建立的執行緒<xref:System.Windows.Application>物件。</xref:System.Windows.Application>"
  example:
  - "The following example shows how to find the main application window.  \n  \n [!code-cs[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/add/codesnippet/csharp/ApplicationMainWindowSnippets.CSharp/App.xaml.cs#getapplicationmainwindowcode)]\n [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/add/codesnippet/visualbasic/applicationmainwindowsnippets/application.xaml.vb#getapplicationmainwindowcode)]  \n  \n The following example shows how to set MainWindow using [!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)].  \n  \n [!code-xml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/add/codesnippet/xaml/ApplicationMainWindowSnippets.XAML/App.xaml#setapplicationmainwindowxaml)]  \n  \n The following example shows how to instantiate the MainWindow in code during application startup.  \n  \n [!code-cs[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/add/codesnippet/csharp/HOWTOWindowManagementSnippets/App.xaml.cs#firstwindowusingcodecodebehind)]\n [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/add/codesnippet/visualbasic/howtowindowmanagementsnippets/application.xaml.vb#firstwindowusingcodecodebehind)]"
  syntax:
    content: public System.Windows.Window MainWindow { get; set; }
    return:
      type: System.Windows.Window
      description: "A <xref href=&quot;System.Windows.Window&quot;> </xref>已指定為主要的應用程式視窗。"
  overload: System.Windows.Application.MainWindow*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "從裝載於瀏覽器，例如應用程式會設定 MainWindow [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]。"
  platform:
  - net462
- uid: System.Windows.Application.Navigated
  id: Navigated
  parent: System.Windows.Application
  langs:
  - csharp
  name: Navigated
  nameWithType: Application.Navigated
  fullName: System.Windows.Application.Navigated
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "發生於找到正在巡覽至應用程式中的巡覽器的內容，但它可能尚未完成載入。"
  remarks: "導覽是其中一個<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       請參閱<xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigatedEventHandler Navigated;
    return:
      type: System.Windows.Navigation.NavigatedEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Navigating
  id: Navigating
  parent: System.Windows.Application
  langs:
  - csharp
  name: Navigating
  nameWithType: Application.Navigating
  fullName: System.Windows.Application.Navigating
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "當應用程式中的巡覽要求新的瀏覽時，就會發生。"
  remarks: "導覽是其中一個<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       請參閱<xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;
    return:
      type: System.Windows.Navigation.NavigatingCancelEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationFailed
  id: NavigationFailed
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationFailed
  nameWithType: Application.NavigationFailed
  fullName: System.Windows.Application.NavigationFailed
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "發生於應用程式中的導覽巡覽至所要求的內容時發生錯誤。"
  remarks: "導覽是其中一個<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       請參閱<xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;
    return:
      type: System.Windows.Navigation.NavigationFailedEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationProgress
  id: NavigationProgress
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationProgress
  nameWithType: Application.NavigationProgress
  fullName: System.Windows.Application.NavigationProgress
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "是受管理的應用程式提供導覽進度資訊中的導覽器 在下載期間定期發生。"
  remarks: "導覽是其中一個<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       請參閱<xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;
    return:
      type: System.Windows.Navigation.NavigationProgressEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.NavigationStopped
  id: NavigationStopped
  parent: System.Windows.Application
  langs:
  - csharp
  name: NavigationStopped
  nameWithType: Application.NavigationStopped
  fullName: System.Windows.Application.NavigationStopped
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "發生時<xref uid=&quot;langword_csharp_StopLoading&quot; name=&quot;StopLoading&quot; href=&quot;&quot;></xref>呼叫的應用程式中的巡覽方法，或新的瀏覽要求時的巡覽器目前的瀏覽正在進行時。"
  remarks: "導覽是其中一個<xref:System.Windows.Navigation.NavigationWindow>或<xref:System.Windows.Controls.Frame>.</xref:System.Windows.Controls.Frame> </xref:System.Windows.Navigation.NavigationWindow>       請參閱<xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=fullName>.</xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=fullName>"
  syntax:
    content: public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;
    return:
      type: System.Windows.Navigation.NavigationStoppedEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnActivated(System.EventArgs)
  id: OnActivated(System.EventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnActivated(EventArgs)
  nameWithType: Application.OnActivated(EventArgs)
  fullName: System.Windows.Application.OnActivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.Application.Activated&quot;></xref>事件。"
  remarks: "OnActivated 引發<xref:System.Windows.Application.Activated>事件。</xref:System.Windows.Application.Activated>       從衍生的型別<xref:System.Windows.Application>可能會覆寫 OnActivated。</xref:System.Windows.Application> 覆寫的方法必須呼叫 OnActivated 基底類別中如果<xref:System.Windows.Application.Activated>需要引發。</xref:System.Windows.Application.Activated>"
  syntax:
    content: protected virtual void OnActivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>包含事件資料。</xref:System.EventArgs>"
  overload: System.Windows.Application.OnActivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnDeactivated(System.EventArgs)
  id: OnDeactivated(System.EventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnDeactivated(EventArgs)
  nameWithType: Application.OnDeactivated(EventArgs)
  fullName: System.Windows.Application.OnDeactivated(EventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.Application.Deactivated&quot;></xref>事件。"
  remarks: "OnDeactivated 引發<xref:System.Windows.Application.Deactivated>事件。</xref:System.Windows.Application.Deactivated>       從衍生的型別<xref:System.Windows.Application>可能會覆寫 OnDeactivated。</xref:System.Windows.Application> 覆寫的方法必須呼叫 OnDeactivated 基底類別中如果<xref:System.Windows.Application.Deactivated>需要引發。</xref:System.Windows.Application.Deactivated>"
  syntax:
    content: protected virtual void OnDeactivated (EventArgs e);
    parameters:
    - id: e
      type: System.EventArgs
      description: "<xref:System.EventArgs>包含事件資料。</xref:System.EventArgs>"
  overload: System.Windows.Application.OnDeactivated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  id: OnExit(System.Windows.ExitEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnExit(ExitEventArgs)
  nameWithType: Application.OnExit(ExitEventArgs)
  fullName: System.Windows.Application.OnExit(ExitEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.Application.Exit&quot;></xref>事件。"
  remarks: "OnExit 引發<xref:System.Windows.Application.Exit>事件。</xref:System.Windows.Application.Exit>       從衍生的型別<xref:System.Windows.Application>可能會覆寫 OnExit 方法。</xref:System.Windows.Application> 覆寫的方法必須呼叫 OnExit 基底類別中如果<xref:System.Windows.Application.Exit>需要引發。</xref:System.Windows.Application.Exit>"
  syntax:
    content: protected virtual void OnExit (System.Windows.ExitEventArgs e);
    parameters:
    - id: e
      type: System.Windows.ExitEventArgs
      description: "<xref href=&quot;System.Windows.ExitEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Windows.Application.OnExit*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  id: OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnFragmentNavigation(FragmentNavigationEventArgs)
  nameWithType: Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  fullName: System.Windows.Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.Application.FragmentNavigation&quot;></xref>事件。"
  remarks: "OnFragmentNavigation 引發<xref:System.Windows.Application.FragmentNavigation>事件。</xref:System.Windows.Application.FragmentNavigation>       從衍生的型別<xref:System.Windows.Application>可能會覆寫 OnFragmentNavigation。</xref:System.Windows.Application> 覆寫的方法必須呼叫 OnFragmentNavigation 基底類別中如果<xref:System.Windows.Application.FragmentNavigation>需要引發。</xref:System.Windows.Application.FragmentNavigation>"
  syntax:
    content: protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.FragmentNavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.FragmentNavigationEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Windows.Application.OnFragmentNavigation*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  id: OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnLoadCompleted(NavigationEventArgs)
  nameWithType: Application.OnLoadCompleted(NavigationEventArgs)
  fullName: System.Windows.Application.OnLoadCompleted(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.Application.LoadCompleted&quot;></xref>事件。"
  remarks: "OnLoadCompleted 引發<xref:System.Windows.Application.LoadCompleted>事件。</xref:System.Windows.Application.LoadCompleted>       從衍生的型別<xref:System.Windows.Application>可能會覆寫 OnLoadCompleted。</xref:System.Windows.Application> 覆寫的方法必須呼叫 OnLoadCompleted 基底類別中如果<xref:System.Windows.Application.LoadCompleted>需要引發。</xref:System.Windows.Application.LoadCompleted>"
  syntax:
    content: protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Windows.Application.OnLoadCompleted*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  id: OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigated(NavigationEventArgs)
  nameWithType: Application.OnNavigated(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigated(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.Application.Navigated&quot;></xref>事件。"
  remarks: "OnNavigated 引發<xref:System.Windows.Application.Navigated>事件。</xref:System.Windows.Application.Navigated>       從衍生的型別<xref:System.Windows.Application>可能會覆寫 OnNavigated。</xref:System.Windows.Application> 覆寫的方法必須呼叫 OnNavigated 基底類別中如果<xref:System.Windows.Application.Navigated>需要引發。</xref:System.Windows.Application.Navigated>"
  syntax:
    content: protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Windows.Application.OnNavigated*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  id: OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigating(NavigatingCancelEventArgs)
  nameWithType: Application.OnNavigating(NavigatingCancelEventArgs)
  fullName: System.Windows.Application.OnNavigating(NavigatingCancelEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.Application.Navigating&quot;></xref>事件。"
  remarks: "OnNavigating 引發<xref:System.Windows.Application.Navigating>事件。</xref:System.Windows.Application.Navigating>       從衍生的型別<xref:System.Windows.Application>可能會覆寫 OnNavigating。</xref:System.Windows.Application> 覆寫的方法必須呼叫 OnNavigating 基底類別中如果<xref:System.Windows.Application.Navigating>需要引發。</xref:System.Windows.Application.Navigating>"
  syntax:
    content: protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigatingCancelEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigatingCancelEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Windows.Application.OnNavigating*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  id: OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationFailed(NavigationFailedEventArgs)
  nameWithType: Application.OnNavigationFailed(NavigationFailedEventArgs)
  fullName: System.Windows.Application.OnNavigationFailed(NavigationFailedEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.Application.NavigationFailed&quot;></xref>事件。"
  remarks: "OnNavigationFailed 引發<xref:System.Windows.Application.NavigationFailed>事件。</xref:System.Windows.Application.NavigationFailed>       從衍生的型別<xref:System.Windows.Application>可能會覆寫 OnNavigationFailed。</xref:System.Windows.Application> 覆寫的方法必須呼叫 OnNavigationFailed 基底類別中如果<xref:System.Windows.Application.NavigationFailed>需要引發。</xref:System.Windows.Application.NavigationFailed>"
  example:
  - "<xref:System.Windows.Application.OnFragmentNavigation%2A>  \n  \n <xref:System.Windows.Application.OnLoadCompleted%2A>  \n  \n <xref:System.Windows.Application.OnNavigating%2A>  \n  \n <xref:System.Windows.Application.OnNavigated%2A>  \n  \n <xref:System.Windows.Application.OnNavigationProgress%2A>  \n  \n <xref:System.Windows.Application.OnNavigationStopped%2A>"
  syntax:
    content: protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationFailedEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationFailedEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Windows.Application.OnNavigationFailed*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  id: OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationProgress(NavigationProgressEventArgs)
  nameWithType: Application.OnNavigationProgress(NavigationProgressEventArgs)
  fullName: System.Windows.Application.OnNavigationProgress(NavigationProgressEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.Application.NavigationProgress&quot;></xref>事件。"
  remarks: "OnNavigationProgress 引發<xref:System.Windows.Application.NavigationProgress>事件。</xref:System.Windows.Application.NavigationProgress>       從衍生的型別<xref:System.Windows.Application>可能會覆寫 OnNavigationProgress。</xref:System.Windows.Application> 覆寫的方法必須明確地呼叫 OnNavigationProgress 基底類別中如果<xref:System.Windows.Application.NavigationProgress>需要引發。</xref:System.Windows.Application.NavigationProgress>"
  syntax:
    content: protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationProgressEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationProgressEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Windows.Application.OnNavigationProgress*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  id: OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnNavigationStopped(NavigationEventArgs)
  nameWithType: Application.OnNavigationStopped(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigationStopped(NavigationEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.Application.NavigationStopped&quot;></xref>事件。"
  remarks: "OnNavigationStopped 引發<xref:System.Windows.Application.NavigationStopped>事件。</xref:System.Windows.Application.NavigationStopped>       從衍生的型別<xref:System.Windows.Application>可能會覆寫 OnNavigationStopped。</xref:System.Windows.Application> 覆寫的方法必須呼叫 OnNavigationStopped 基底類別中如果<xref:System.Windows.Application.NavigationStopped>需要引發。</xref:System.Windows.Application.NavigationStopped>"
  syntax:
    content: protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);
    parameters:
    - id: e
      type: System.Windows.Navigation.NavigationEventArgs
      description: "A <xref href=&quot;System.Windows.Navigation.NavigationEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Windows.Application.OnNavigationStopped*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  id: OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnSessionEnding(SessionEndingCancelEventArgs)
  nameWithType: Application.OnSessionEnding(SessionEndingCancelEventArgs)
  fullName: System.Windows.Application.OnSessionEnding(SessionEndingCancelEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.Application.SessionEnding&quot;></xref>事件。"
  remarks: "OnSessionEnding 引發<xref:System.Windows.Application.SessionEnding>事件。</xref:System.Windows.Application.SessionEnding>       從衍生的型別<xref:System.Windows.Application>可能會覆寫 OnSessionEnding。</xref:System.Windows.Application> 覆寫的方法必須呼叫 OnSessionEnding 基底類別中如果<xref:System.Windows.Application.SessionEnding>需要引發。</xref:System.Windows.Application.SessionEnding>"
  syntax:
    content: protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);
    parameters:
    - id: e
      type: System.Windows.SessionEndingCancelEventArgs
      description: "A <xref href=&quot;System.Windows.SessionEndingCancelEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Windows.Application.OnSessionEnding*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  id: OnStartup(System.Windows.StartupEventArgs)
  parent: System.Windows.Application
  langs:
  - csharp
  name: OnStartup(StartupEventArgs)
  nameWithType: Application.OnStartup(StartupEventArgs)
  fullName: System.Windows.Application.OnStartup(StartupEventArgs)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "引發<xref href=&quot;System.Windows.Application.Startup&quot;></xref>事件。"
  remarks: "OnStartup 引發<xref:System.Windows.Application.Startup>事件。</xref:System.Windows.Application.Startup>       從衍生的型別<xref:System.Windows.Application>可能會覆寫 OnStartup。</xref:System.Windows.Application> 覆寫的方法必須呼叫 OnStartup 基底類別中如果<xref:System.Windows.Application.Startup>必須引發的事件。</xref:System.Windows.Application.Startup>"
  syntax:
    content: protected virtual void OnStartup (System.Windows.StartupEventArgs e);
    parameters:
    - id: e
      type: System.Windows.StartupEventArgs
      description: "A <xref href=&quot;System.Windows.StartupEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Windows.Application.OnStartup*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Properties
  id: Properties
  parent: System.Windows.Application
  langs:
  - csharp
  name: Properties
  nameWithType: Application.Properties
  fullName: System.Windows.Application.Properties
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得應用程式範圍的屬性集合。"
  remarks: "<xref:System.Windows.Application>會公開透過屬性可用來儲存應用程式範圍的屬性字典。</xref:System.Windows.Application> 這可讓您共用中的所有程式碼之間的狀態<xref:System.AppDomain>以執行緒安全的方式，而不必自行撰寫程式的狀態碼。</xref:System.AppDomain>       儲存在屬性內容必須轉換成傳回適當的型別。       TheProperties 屬性具備執行緒安全，且可從任何執行緒。"
  example:
  - "The following example shows how create and use an application-scope property using Properties.  \n  \n [!code-xml[ApplicationPropertiesSnippets#HandleStartupXAML](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/App.xaml#handlestartupxaml)]  \n  \n [!code-cs[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/csharp/ApplicationPropertiesSnippets.CSharp/App.xaml.cs#handlestartupcodebehind)]\n [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/visualbasic/applicationpropertiessnippets/application.xaml.vb#handlestartupcodebehind)]  \n  \n [!code-xml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  \n[!code-xml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/add/codesnippet/xaml/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  \n  \n [!code-cs[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/add/codesnippet/csharp/ApplicationPropertiesSnippets.CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]\n [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/add/codesnippet/visualbasic/applicationpropertiessnippets/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]"
  syntax:
    content: public System.Collections.IDictionary Properties { get; }
    return:
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>，其中包含應用程式領域屬性。</xref:System.Collections.IDictionary>"
  overload: System.Windows.Application.Properties*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.ResourceAssembly
  id: ResourceAssembly
  parent: System.Windows.Application
  langs:
  - csharp
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
  fullName: System.Windows.Application.ResourceAssembly
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定<xref:System.Reflection.Assembly>提供組件[!INCLUDE[TLA#tla_uri#plural](~/add/includes/tlasharptla-urisharpplural-md.md)]中的資源[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]應用程式。</xref:System.Reflection.Assembly>"
  remarks: "根據預設，[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]相對於項目組件，從傳回的值由執行階段在解決資源<xref:System.Reflection.Assembly.GetEntryAssembly%2A>方法。</xref:System.Reflection.Assembly.GetEntryAssembly%2A>       項目組件是所傳回的組件<xref:System.Reflection.Assembly.GetEntryAssembly%2A>和以下:-預設應用程式定義域中執行的組件。</xref:System.Reflection.Assembly.GetEntryAssembly%2A>      的藉由呼叫<xref:System.AppDomain.ExecuteAssembly%2A>.</xref:System.AppDomain.ExecuteAssembly%2A>要執行第一個組件       在下列情況中，不過，[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]組件無法取得項目組件的參考:-unmanaged （機器碼） 的應用程式主機[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]組件。      -受管理的應用程式主機[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]所載入的新應用程式定義域以外使用方法<xref:System.AppDomain.ExecuteAssembly%2A>.</xref:System.AppDomain.ExecuteAssembly%2A>的組件       在上述兩種情況，<xref:System.Reflection.Assembly.GetEntryAssembly%2A>傳回`null`，而[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]無法解析組件的資源。</xref:System.Reflection.Assembly.GetEntryAssembly%2A> 在這些情況下，ResourceAssembly 可以設定，只有一次，應該用來解析資源的組件的參考。       ResourceAssembly 只能設定一次，所以不太可能，資源組件會在之後變更[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]已載入組件。      > [!NOTE] > ResourceAssembly 時不能設定[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]組件可以探索項目組件 — 也就是，當<xref:System.Reflection.Assembly.GetEntryAssembly%2A>傳回組件的參考而非`null`。</xref:System.Reflection.Assembly.GetEntryAssembly%2A>       這個屬性是安全執行緒，可從任何執行緒。       .NET Framework 3.5 版中引進 ResourceAssembly。  如需詳細資訊，請參閱[版本和相依性](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public static System.Reflection.Assembly ResourceAssembly { get; set; }
    return:
      type: System.Reflection.Assembly
      description: "參考<xref:System.Reflection.Assembly>提供組件[!INCLUDE[TLA#tla_uri#plural](~/add/includes/tlasharptla-urisharpplural-md.md)]中的資源[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]應用程式。</xref:System.Reflection.Assembly>"
  overload: System.Windows.Application.ResourceAssembly*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "A[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]應用程式有項目組件，或已經設定 ResourceAssembly。"
  platform:
  - net462
- uid: System.Windows.Application.Resources
  id: Resources
  parent: System.Windows.Application
  langs:
  - csharp
  name: Resources
  nameWithType: Application.Resources
  fullName: System.Windows.Application.Resources
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定應用程式範圍的資源，例如樣式和筆刷的集合。"
  remarks: "資源屬性可以用來在 windows 和應用程式的項目之間共用資源。 此外，資源屬性包含在資源查閱路徑、 周遊順序如下︰ 1。  項目 2。  Windows 3。  4 的資源。  系統因此[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]元素可以繫結至應用程式範圍的資源。 此外，如果變更資源，資源系統可確保該元素繫結至這些資源的屬性會自動更新以反映變更。       應用程式範圍的資源會提供簡單的方式，以支援跨應用程式一致的主題。 您可以輕鬆地建立佈景主題[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]使用`Application.Resources`標記。 不過，如果您的應用程式支援多個主題，其中可能包含大量的佈景主題的項目，可能是您更輕鬆地管理這些使用其中一種<xref:System.Windows.ResourceDictionary>為每個主題的執行個體。</xref:System.Windows.ResourceDictionary> 如此一來，新的佈景主題可以套用至適當的<xref:System.Windows.ResourceDictionary>。</xref:System.Windows.ResourceDictionary>設定資源屬性       有兩個要使用的資源時的考量。 首先，字典*金鑰*不是物件，因此您必須使用完全相同物件執行個體時設定和取得屬性值 （請注意使用字串時，索引鍵是區分大小寫）。 其次，字典*值*不是物件，因此您必須取得的屬性值時，就將值轉換成所需的類型。       資源是安全執行緒，可從任何執行緒。"
  example:
  - "This example illustrates how to use [!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)] together with application-scope resources to create a consistent visual appearance.  \n  \n [!code-xml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/App.xaml#resourcespropertyxaml)]  \n  \n [!code-xml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/MainWindow.xaml#windowbackgroundpropertyxaml1)]  \n[!code-xml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/add/codesnippet/xaml/ApplicationResourcesSnippets.XAML/MainWindow.xaml#windowbackgroundpropertyxaml2)]  \n  \n The following example shows how to set an application resource in code and XAML.  \n  \n [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/add/codesnippet/visualbasic/howtoapplicationmodelsnippets/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]\n [!code-cs[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/add/codesnippet/csharp/HOWTOApplicationModelSnippets/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]  \n  \n [!code-xml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/add/codesnippet/xaml/HOWTOApplicationModelSnippets/App.xaml#setapplicationscoperesourcexaml)]  \n  \n The following example shows how to get an application resource in code.  \n  \n [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/add/codesnippet/visualbasic/howtoapplicationmodelsnippets/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]\n [!code-cs[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/add/codesnippet/csharp/HOWTOApplicationModelSnippets/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]"
  syntax:
    content: public System.Windows.ResourceDictionary Resources { get; set; }
    return:
      type: System.Windows.ResourceDictionary
      description: "A <xref href=&quot;System.Windows.ResourceDictionary&quot;> </xref>物件，其中包含零或多個應用程式範圍的資源。"
  overload: System.Windows.Application.Resources*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Run
  id: Run
  parent: System.Windows.Application
  langs:
  - csharp
  name: Run()
  nameWithType: Application.Run()
  fullName: System.Windows.Application.Run()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "啟動[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]應用程式。"
  remarks: "<xref:System.Windows.Application.Run%2A>呼叫以啟動[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]應用程式。</xref:System.Windows.Application.Run%2A> 如果您定義您<xref:System.Windows.Application>使用標記或標記和程式碼後置<xref:System.Windows.Application.Run%2A>會隱含地呼叫。</xref:System.Windows.Application.Run%2A> </xref:System.Windows.Application> 不過，如果您定義<xref:System.Windows.Application>使用程式碼中，您需要明確地呼叫<xref:System.Windows.Application.Run%2A>.</xref:System.Windows.Application.Run%2A></xref:System.Windows.Application>您       當<xref:System.Windows.Application.Run%2A>呼叫時，<xref:System.Windows.Application>附加新<xref:System.Windows.Threading.Dispatcher>執行個體[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]執行緒。</xref:System.Windows.Threading.Dispatcher> </xref:System.Windows.Application> </xref:System.Windows.Application.Run%2A> 下一步<xref:System.Windows.Threading.Dispatcher>物件的<xref:System.Windows.Threading.Dispatcher.Run%2A>呼叫方法，以便啟動以處理 windows 訊息的訊息幫浦。</xref:System.Windows.Threading.Dispatcher.Run%2A> </xref:System.Windows.Threading.Dispatcher> 最後，<xref:System.Windows.Threading.Dispatcher>物件會呼叫<xref:System.Windows.Application>物件的<xref:System.Windows.Application.OnStartup%2A>方法，以引發<xref:System.Windows.Application.Startup>事件。</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.OnStartup%2A> </xref:System.Windows.Application> </xref:System.Windows.Threading.Dispatcher> 因此，您所處理的時間建立應用程式執行模型<xref:System.Windows.Application.Startup>，此時應用程式會被視為在執行。</xref:System.Windows.Application.Startup>       應用程式停止時執行<xref:System.Windows.Application.Shutdown%2A>稱為; 的值<xref:System.Windows.Application.ShutdownMode%2A>屬性會決定當<xref:System.Windows.Application.Shutdown%2A>呼叫時，與是否自動，或者您需要明確地呼叫它。</xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.Application.ShutdownMode%2A> </xref:System.Windows.Application.Shutdown%2A>       <xref:System.Windows.Application.Run%2A>可以只從建立的執行緒呼叫<xref:System.Windows.Application>物件。</xref:System.Windows.Application></xref:System.Windows.Application.Run%2A> 此外，<xref:System.Windows.Application.Run%2A>無法從呼叫[!INCLUDE[TLA2#tla_xbap](~/add/includes/ajax-current-ext-md.md)]。</xref:System.Windows.Application.Run%2A>"
  example:
  - "The following example shows an application that uses a custom <xref:System.Windows.Application> and must therefore explicitly call <xref:System.Windows.Application.Run%2A>.  \n  \n [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/add/codesnippet/visualbasic/applicationrunsnippets/app.vb#customentrypointandruncode)]\n [!code-cs[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/add/codesnippet/csharp/ApplicationRunSnippets.CSharp/App.cs#customentrypointandruncode)]"
  syntax:
    content: public int Run ();
    parameters: []
    return:
      type: System.Int32
      description: "<xref:System.Int32>應用程式的應用程式關閉時，作業系統傳回的結束代碼。</xref:System.Int32> 根據預設，結束代碼值為 0。"
  overload: System.Windows.Application.Run*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "從瀏覽器裝載應用程式呼叫執行 (例如， [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)])。"
  platform:
  - net462
- uid: System.Windows.Application.Run(System.Windows.Window)
  id: Run(System.Windows.Window)
  parent: System.Windows.Application
  langs:
  - csharp
  name: Run(Window)
  nameWithType: Application.Run(Window)
  fullName: System.Windows.Application.Run(Window)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "啟動[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]應用程式，並開啟指定的視窗。"
  remarks: "這個多載擴充<xref:System.Windows.Application.Run%2A>方法來執行的應用程式啟動後開啟指定的視窗。</xref:System.Windows.Application.Run%2A>       如果您的程式碼定義<xref:System.Windows.Application>，會開啟視窗，它會開始執行時，您明確地呼叫執行。</xref:System.Windows.Application>       如果您建立您<xref:System.Windows.Application>使用標記或標記和程式碼後置，您就可以自動開啟視窗期間使用的下列技術:-以宣告方式，是藉由設定<xref:System.Windows.Application.StartupUri%2A>.</xref:System.Windows.Application.StartupUri%2A> </xref:System.Windows.Application>      -以程式設計的方式，是藉由處理<xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup>"
  example:
  - "The following example shows an application with a manually-created static entry point method that instantiates <xref:System.Windows.Application>, before calling <xref:System.Windows.Application.Run%2A>.  \n  \n [!code-cs[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/add/codesnippet/csharp/ApplicationRunOL1Snippets.CSharp/App.cs#customentrypointandrunol1code)]\n [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/add/codesnippet/visualbasic/applicationrunol1snippets/app.vb#customentrypointandrunol1code)]"
  syntax:
    content: public int Run (System.Windows.Window window);
    parameters:
    - id: window
      type: System.Windows.Window
      description: "A <xref href=&quot;System.Windows.Window&quot;> </xref> ，會自動開啟應用程式啟動時執行。"
    return:
      type: System.Int32
      description: "<xref:System.Int32>應用程式的應用程式關閉時，作業系統傳回的結束代碼。</xref:System.Int32> 根據預設，結束代碼值為 0。"
  overload: System.Windows.Application.Run*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref:System.Windows.Application.Run*>從瀏覽器裝載應用程式呼叫 (例如， [!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)])。</xref:System.Windows.Application.Run*>"
  platform:
  - net462
- uid: System.Windows.Application.SessionEnding
  id: SessionEnding
  parent: System.Windows.Application
  langs:
  - csharp
  name: SessionEnding
  nameWithType: Application.SessionEnding
  fullName: System.Windows.Application.SessionEnding
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "當使用者結束時，就會發生[!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)]透過登出或關閉作業系統的工作階段。"
  remarks: "根據預設，應用程式關閉時[!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)]使用者登出或關閉時，就會發生的工作階段結束。 當發生這種情況時，[!INCLUDE[TLA2#tla_mswin](~/add/includes/tla2sharptla-mswin-md.md)]會要求每個開啟的應用程式關閉。 不過，它可能會，應用程式可能無法馬上發生此情況時關閉。 例如，應用程式可能處於不一致的狀態，或進行長時間執行的作業資料。 在這些情況下，它可能會想要防止結束，工作階段，並可能比較想要允許使用者決定要讓結束工作階段的選項。       您可以偵測藉由處理 SessionEnding 事件的工作階段結束時。 如果應用程式需要阻礙工作階段結束，<xref:System.Windows.SessionEndingCancelEventArgs>傳遞至事件處理常式的引數會公開<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>，您將設定為`true`(預設值是`false`)。</xref:System.ComponentModel.CancelEventArgs.Cancel%2A> </xref:System.Windows.SessionEndingCancelEventArgs>       如果 SessionEnding 未經處理，或處理而被取消，<xref:System.Windows.Application.Shutdown%2A>稱為和<xref:System.Windows.Application.Exit>就會引發事件。</xref:System.Windows.Application.Exit> </xref:System.Windows.Application.Shutdown%2A>       若要取得工作階段結束的原因的詳細資訊，請檢查應用程式可以<xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>，這是其中一個<xref:System.Windows.ReasonSessionEnding>值 (<xref:System.Windows.ReasonSessionEnding>和<xref:System.Windows.ReasonSessionEnding>)。</xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.ReasonSessionEnding> </xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>       SessionEnding 不是主控台應用程式所引發。       只能在建立的執行緒上引發 SessionEnding<xref:System.Windows.Application>物件。</xref:System.Windows.Application>       不會引發 SessionEnding [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)]。"
  example:
  - "The following example demonstrates how to handle the SessionEnding event and allow the user to cancel it.  \n  \n [!code-xml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/add/codesnippet/xaml/ApplicationSessionEndingSnippets.CSharp/App.xaml#handlingsessionendingxaml)]  \n  \n [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/add/codesnippet/visualbasic/applicationsessionendingsnippets/application.xaml.vb#handlingsessionendingcodebehind)]\n [!code-cs[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/add/codesnippet/csharp/ApplicationSessionEndingSnippets.CSharp/App.xaml.cs#handlingsessionendingcodebehind)]"
  syntax:
    content: public event System.Windows.SessionEndingCancelEventHandler SessionEnding;
    return:
      type: System.Windows.SessionEndingCancelEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.SetCookie(System.Uri,System.String)
  id: SetCookie(System.Uri,System.String)
  parent: System.Windows.Application
  langs:
  - csharp
  name: SetCookie(Uri,String)
  nameWithType: Application.SetCookie(Uri,String)
  fullName: System.Windows.Application.SetCookie(Uri,String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "建立 cookie 的<xref:System.Uri>.</xref:System.Uri>所指定的位置"
  remarks: "Cookie 是任意的資料片段都儲存在應用程式工作階段 (工作階段 cookie)，或在應用程式工作階段 (持續性 cookies) 之間的用戶端電腦上應用程式。 您可以藉由呼叫 SetCookie 建立這兩種類型的 cookie。       Cookie 資料通常會採用格式的名稱/值組的格式如下︰`Name=Value`連同傳遞 SetCookie，這種格式的字串<xref:System.Uri>設定 cookie 的位置 （一般而言，應用程式定義域）。</xref:System.Uri>       Cookie 是工作階段 cookie 或永續性 cookie，取決於您傳遞給 SetCookie 的 cookie 字串是否包含到期日。 工作階段 cookie 字串沒有包括到期日。 永續性 cookie 字串存在，而且必須以下列格式︰`NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`永續性 cookie 儲存在目前[!INCLUDE[TLA#tla_mswin](~/add/includes/tlasharptla-mswin-md.md)]安裝的 Temporary Internet Files 資料夾，直至到期，在此情況下會刪除它們為止。 您可以從您的應用程式刪除永續性 cookie，藉由其到期日設定在過去的日期/時間值。       如概觀中的 cookie [!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]，請參閱[巡覽概觀](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public static void SetCookie (Uri uri, string value);
    parameters:
    - id: uri
      type: System.Uri
      description: "<xref:System.Uri>可指定應建立 cookie 的位置。</xref:System.Uri>"
    - id: value
      type: System.String
      description: "<xref:System.String>包含 cookie 資料。</xref:System.String>"
  overload: System.Windows.Application.SetCookie*
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "A[!INCLUDE[TLA#tla_win32](~/add/includes/tlasharptla-win32-md.md)]產生錯誤時<xref uid=&quot;langword_csharp_InternetSetCookie&quot; name=&quot;InternetSetCookie&quot; href=&quot;&quot;></xref>函式 （由 SetCookie 呼叫） 嘗試建立指定的 cookie 時，發生問題時。"
  platform:
  - net462
- uid: System.Windows.Application.Shutdown
  id: Shutdown
  parent: System.Windows.Application
  langs:
  - csharp
  name: Shutdown()
  nameWithType: Application.Shutdown()
  fullName: System.Windows.Application.Shutdown()
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "關閉應用程式。"
  remarks: "當呼叫關閉時，應用程式會停止執行。 您可以處理<xref:System.Windows.Application.Exit>事件來偵測應用程式時即將停止執行，若要執行任何適當的處理。</xref:System.Windows.Application.Exit>       關機會隱含地呼叫[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]在下列情況:-當<xref:System.Windows.Application.ShutdownMode%2A>設定為<xref:System.Windows.ShutdownMode>.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      -當<xref:System.Windows.Application.ShutdownMode%2A>設定為<xref:System.Windows.ShutdownMode>.</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      -當使用者結束工作階段和<xref:System.Windows.Application.SessionEnding>事件已處理時，或處理，而取消。</xref:System.Windows.Application.SessionEnding>       明確呼叫關閉會導致應用程式關閉，不論<xref:System.Windows.Application.ShutdownMode%2A>設定。</xref:System.Windows.Application.ShutdownMode%2A> 不過，如果<xref:System.Windows.Application.ShutdownMode%2A>設<xref:System.Windows.ShutdownMode>，您必須呼叫 Shutdown 以關閉應用程式。</xref:System.Windows.ShutdownMode> </xref:System.Windows.Application.ShutdownMode%2A>      > [!IMPORTANT] > 呼叫時的關機，不論是否會關閉應用程式<xref:System.Windows.Window.Closing>取消事件的任何開啟的視窗。</xref:System.Windows.Window.Closing>       可以呼叫這個方法，只能從建立的執行緒<xref:System.Windows.Application>物件。</xref:System.Windows.Application>"
  syntax:
    content: public void Shutdown ();
    parameters: []
  overload: System.Windows.Application.Shutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Shutdown(System.Int32)
  id: Shutdown(System.Int32)
  parent: System.Windows.Application
  langs:
  - csharp
  name: Shutdown(Int32)
  nameWithType: Application.Shutdown(Int32)
  fullName: System.Windows.Application.Shutdown(Int32)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "關閉指定的結束代碼傳回至作業系統的應用程式。"
  remarks: "您可以處理<xref:System.Windows.Application.Exit>事件設定的結束代碼。</xref:System.Windows.Application.Exit> 不過，如果您明確地呼叫<xref:System.Windows.Application.Shutdown%2A>，而且您處理<xref:System.Windows.Application.Exit>僅若要設定的結束代碼，您可以改為呼叫關機。</xref:System.Windows.Application.Exit> </xref:System.Windows.Application.Shutdown%2A>       可以呼叫這個方法，只能從建立的執行緒<xref:System.Windows.Application>物件。</xref:System.Windows.Application>"
  syntax:
    content: public void Shutdown (int exitCode);
    parameters:
    - id: exitCode
      type: System.Int32
      description: "整數的結束代碼的應用程式。 預設的結束代碼為 0。"
  overload: System.Windows.Application.Shutdown*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.ShutdownMode
  id: ShutdownMode
  parent: System.Windows.Application
  langs:
  - csharp
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
  fullName: System.Windows.Application.ShutdownMode
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定導致的狀況<xref:System.Windows.Application.Shutdown*>要呼叫的方法。</xref:System.Windows.Application.Shutdown*>"
  remarks: "應用程式停止執行時，才<xref:System.Windows.Application.Shutdown%2A>呼叫應用程式的方法。</xref:System.Windows.Application.Shutdown%2A> 隱含或明確地 ShutdownMode 屬性的值所指定，就會發生關機。       如果您將設定 ShutdownMode <xref:System.Windows.ShutdownMode>，[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]隱含地呼叫<xref:System.Windows.Application.Shutdown%2A>應用程式中的上一個視窗關閉時，即使未設定任何目前的具現化的視窗做為主要視窗 (請參閱<xref:System.Windows.Application.MainWindow%2A>)。</xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode>       ShutdownMode<xref:System.Windows.ShutdownMode>導致[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]隱含呼叫<xref:System.Windows.Application.Shutdown%2A>時<xref:System.Windows.Application.MainWindow%2A>隨即關閉，即使目前開啟其他視窗。</xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode>       某些應用程式的存留期間可能不相依於當主視窗或最後一個視窗已關閉，或可能完全不能相依於 windows。 這些案例，您需要將 ShutdownMode 屬性設定為<xref:System.Windows.ShutdownMode>，這需要明確<xref:System.Windows.Application.Shutdown%2A>停止應用程式的方法呼叫。</xref:System.Windows.Application.Shutdown%2A> </xref:System.Windows.ShutdownMode> 否則，應用程式會繼續在背景執行。       可以以宣告方式設定 ShutdownMode，從[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]或以程式設計方式從程式碼。       這個屬性就只能從建立的執行緒<xref:System.Windows.Application>物件。</xref:System.Windows.Application>"
  example:
  - "The following example shows how to configure ShutdownMode to specify that an application must be closed explicitly.  \n  \n [!code-xml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/add/codesnippet/xaml/ApplicationShutdownModeSnippets.XAML/App.xaml#setshutdownmodexaml)]"
  syntax:
    content: public System.Windows.ShutdownMode ShutdownMode { get; set; }
    return:
      type: System.Windows.ShutdownMode
      description: "A <xref href=&quot;System.Windows.ShutdownMode&quot;> </xref>列舉值。 預設值是<xref href=&quot;System.Windows.ShutdownMode&quot;> </xref>。"
  overload: System.Windows.Application.ShutdownMode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Startup
  id: Startup
  parent: System.Windows.Application
  langs:
  - csharp
  name: Startup
  nameWithType: Application.Startup
  fullName: System.Windows.Application.Startup
  type: Event
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "發生時<xref:System.Windows.Application.Run*>方法<xref href=&quot;System.Windows.Application&quot;></xref>物件稱為。</xref:System.Windows.Application.Run*>"
  remarks: "一般[!INCLUDE[TLA#tla_wpf](~/add/includes/tlasharptla-wpf-md.md)]應用程式可能會在啟動時，包括執行各種不同的初始設定工作:-處理命令列參數。      -開啟主視窗。      初始化應用程式範圍的資源。      初始化應用程式範圍的屬性。       您可以以宣告方式指定的主視窗和使用的應用程式範圍資源[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)](<xref:System.Windows.Application.StartupUri%2A>和<xref:System.Windows.Application.Resources%2A>分別)。</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application.StartupUri%2A> 有時候，不過，資源或主視窗的應用程式只能判斷以程式設計方式在執行階段。 此外，應用程式範圍的屬性和命令列參數僅能以程式設計的方式。 以程式設計方式初始化可執行的處理啟動事件，包括下列:-取得並處理命令列參數，都是從<xref:System.Windows.StartupEventArgs.Args%2A>屬性<xref:System.Windows.StartupEventArgs>傳遞至啟動的事件處理常式的類別。</xref:System.Windows.StartupEventArgs> </xref:System.Windows.StartupEventArgs.Args%2A>      -初始化應用程式範圍的資源使用<xref:System.Windows.Application.Resources%2A>屬性。</xref:System.Windows.Application.Resources%2A>      -應用程式範圍的屬性初始化是使用<xref:System.Windows.Application.Properties%2A>屬性。</xref:System.Windows.Application.Properties%2A>      -具現化，並會顯示一個 （或以上） 的視窗。      > [!NOTE] > 命令列參數也可以取得藉由呼叫靜態<xref:System.Environment.GetCommandLineArgs%2A>方法<xref:System.Environment>物件。</xref:System.Environment> </xref:System.Environment.GetCommandLineArgs%2A> 不過，<xref:System.Environment.GetCommandLineArgs%2A>需要完全信任才能執行。</xref:System.Environment.GetCommandLineArgs%2A>       如果您設定<xref:System.Windows.Application.StartupUri%2A>使用[!INCLUDE[TLA2#tla_titlexaml](~/add/includes/tla2sharptla-titlexaml-md.md)]，就無法使用從主要視窗建立<xref:System.Windows.Application.MainWindow%2A>屬性或<xref:System.Windows.Application.Windows%2A>屬性<xref:System.Windows.Application>Startup 事件處理後，直到物件。</xref:System.Windows.Application> </xref:System.Windows.Application.Windows%2A> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.StartupUri%2A> 如果您在啟動期間需要存取主要視窗中，您需要手動從啟動的事件處理常式中建立新的視窗物件。      > [!NOTE] > 如果應用程式使用<xref:System.Net.AuthenticationManager.CredentialPolicy%2A>若要指定認證原則，您需要設定<xref:System.Net.AuthenticationManager.CredentialPolicy%2A>啟動引發，否則後[!INCLUDE[TLA2#tla_wpf](~/add/includes/ajax-current-ext-md.md)]將其設為預設的內部原則直接啟動事件引發之後。</xref:System.Net.AuthenticationManager.CredentialPolicy%2A> </xref:System.Net.AuthenticationManager.CredentialPolicy%2A>       傳遞至啟動的事件處理常式的命令列引數不是相同[!INCLUDE[TLA#tla_url](~/add/includes/tlasharptla-url-md.md)]查詢字串參數傳遞給[!INCLUDE[TLA#tla_xbap](~/add/includes/tlasharptla-xbap-md.md)]。"
  example:
  - "The following example shows how to acquire and process command-line options from a standalone application. If the **/StartMinimized** command-line parameter was provided, the application opens the main window in a minimized state.  \n  \n [!code-xml[ApplicationStartupSnippets#HandleStartupXAML](~/add/codesnippet/xaml/ApplicationStartupSnippets.CSharp/App.xaml#handlestartupxaml)]  \n  \n [!code-cs[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/csharp/ApplicationStartupSnippets.CSharp/App.xaml.cs#handlestartupcodebehind)]\n [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/add/codesnippet/visualbasic/applicationstartupsnippets/application.xaml.vb#handlestartupcodebehind)]  \n  \n [!INCLUDE[TLA#tla_xbap#plural](~/add/includes/ajax-current-ext-md.md)] cannot retrieve and process command-line arguments because they are launched with [!INCLUDE[TLA#tla_clickonce](~/add/includes/tlasharptla-clickonce-md.md)] deployment (see [Deploying a WPF Application (WPF)](~/add/includes/ajax-current-ext-md.md)). However, they can retrieve and process query string parameters from the URLs that are used to launch them."
  syntax:
    content: public event System.Windows.StartupEventHandler Startup;
    return:
      type: System.Windows.StartupEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.StartupUri
  id: StartupUri
  parent: System.Windows.Application
  langs:
  - csharp
  name: StartupUri
  nameWithType: Application.StartupUri
  fullName: System.Windows.Application.StartupUri
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得或設定[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]，會自動顯示應用程式啟動時。"
  remarks: "您可以使用將 StartupUri 自動載入[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]應用程式啟動時的資源。       下表顯示的型別[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]可以載入的資源，都會開啟的視窗類型，這些資源可設定為將 StartupUri 的應用程式的類型。      |型別 |視窗 |應用程式類型 |  |----------|------------|----------------------|  |<xref:System.Windows.Window>|<xref:System.Windows.Window>|僅限獨立 |  |<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|僅限獨立 |  |<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|獨立/瀏覽器裝載 |  |<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|獨立/瀏覽器裝載 |  |<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|獨立/瀏覽器裝載 |  |<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|獨立/瀏覽器裝載 |      一般而言，您設定將 StartupUri 屬性以宣告方式在[!INCLUDE[TLA#tla_titlexaml](~/add/includes/ajax-current-ext-md.md)]。</xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.PageFunction%601> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Documents.FlowDocument> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Controls.UserControl> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Controls.Page> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Navigation.NavigationWindow> </xref:System.Windows.Window> </xref:System.Windows.Window> 不過，您可以設定將 StartupUri 程式設計角度而言，這類在<xref:System.Windows.Application.Startup>事件處理常式，也就是適用於只可載入必要的應用程式如果[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]在執行階段的資源。</xref:System.Windows.Application.Startup> 例如，應用程式可能會等到執行階段来載入其資源，則名稱[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]資源會儲存在組態檔。       您是否設定將 StartupUri 以宣告方式或以程式設計的方式，對應[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]資源未載入直到之後<xref:System.Windows.Application.Startup>處理事件。</xref:System.Windows.Application.Startup> 因此，您不需要存取結果視窗中與其中的<xref:System.Windows.Application.Windows%2A>屬性或<xref:System.Windows.Application.MainWindow%2A>屬性時處理<xref:System.Windows.Application.Startup>.</xref:System.Windows.Application.Startup> </xref:System.Windows.Application.MainWindow%2A> </xref:System.Windows.Application.Windows%2A>"
  syntax:
    content: public Uri StartupUri { get; set; }
    return:
      type: System.Uri
      description: "A<xref:System.Uri>參考[!INCLUDE[TLA2#tla_ui](~/add/includes/ajax-current-ext-md.md)]，會自動開啟應用程式啟動時。</xref:System.Uri>"
  overload: System.Windows.Application.StartupUri*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "設定將 StartupUri 的值是 null。"
  platform:
  - net462
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  id: System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  isEii: true
  parent: System.Windows.Application
  langs:
  - csharp
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "指定的環境屬性是否可以使用目前範圍中的查詢。"
  remarks: "這個成員是明確介面成員實作。 它可用時，才<xref:System.Windows.Application>執行個體轉換成<xref:System.Windows.Markup.IQueryAmbient>介面。</xref:System.Windows.Markup.IQueryAmbient> </xref:System.Windows.Application>"
  syntax:
    content: bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);
    parameters:
    - id: propertyName
      type: System.String
      description: "要求的環境屬性的名稱。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>要求的環境屬性是否可用。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.TryFindResource(System.Object)
  id: TryFindResource(System.Object)
  parent: System.Windows.Application
  langs:
  - csharp
  name: TryFindResource(Object)
  nameWithType: Application.TryFindResource(Object)
  fullName: System.Windows.Application.TryFindResource(Object)
  type: Method
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "搜尋指定的資源。"
  remarks: "TryFindResource 會先查看應用程式範圍的資源，為指定的資源。 應用程式範圍的資源由管理<xref:System.Windows.Application>，而且會公開從<xref:System.Windows.Application.Resources%2A>屬性。</xref:System.Windows.Application.Resources%2A> </xref:System.Windows.Application> 如果應用程式範圍的資源集中找不到指定的資源，TryFindResource 再接下來會搜尋系統資源。 系統資源是由使用者定義的 shell 資源，並且包含色彩、 字型及殼層組態。 這些由公開<xref:System.Windows.SystemColors>， <xref:System.Windows.SystemFonts>，和<xref:System.Windows.SystemParameters>類型，分別靜態屬性。</xref:System.Windows.SystemParameters> </xref:System.Windows.SystemFonts> </xref:System.Windows.SystemColors> 若要使用 TryFindResource 取得它們，這些型別也會公開資源的索引鍵屬性是設計成可傳遞至 TryFindResource;例如， <xref:System.Windows.SystemParameters.IconWidthKey%2A>.</xref:System.Windows.SystemParameters.IconWidthKey%2A>       TryFindResource 傳回的物件，因為您必須先轉換適當的型別傳回的值，如果找到資源。       這個方法是安全執行緒，可以從任何執行緒呼叫。"
  example:
  - "The following example shows how to use TryFindResource to acquire a resource.  \n  \n [!code-xml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/add/codesnippet/xaml/ApplicationTryFindResourceSnippets/App.xaml#applicationcalltryfindresourcexaml)]  \n  \n [!code-cs[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/add/codesnippet/csharp/ApplicationTryFindResourceSnippets/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]\n [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/add/codesnippet/visualbasic/applicationtryfindresourcesnippets/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  \n[!code-cs[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/add/codesnippet/csharp/ApplicationTryFindResourceSnippets/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]\n[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/add/codesnippet/visualbasic/applicationtryfindresourcesnippets/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]"
  syntax:
    content: public object TryFindResource (object resourceKey);
    parameters:
    - id: resourceKey
      type: System.Object
      description: "要尋找之資源的名稱。"
    return:
      type: System.Object
      description: "要求的資源物件。 如果找不到要求的資源，則會傳回 null 參考。"
  overload: System.Windows.Application.TryFindResource*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Application.Windows
  id: Windows
  parent: System.Windows.Application
  langs:
  - csharp
  name: Windows
  nameWithType: Application.Windows
  fullName: System.Windows.Application.Windows
  type: Property
  assemblies:
  - PresentationFramework
  namespace: System.Windows
  summary: "取得具現化的 windows 應用程式中。"
  remarks: "A<xref:System.Windows.Window>上具現化一個視窗時，windows 會自動加入參考[!INCLUDE[TLA#tla_ui](~/add/includes/tlasharptla-ui-md.md)]執行緒，則為所建立的背景工作執行緒不會加入 windows。</xref:System.Windows.Window> A<xref:System.Windows.Window>之後，會自動移除參考其<xref:System.Windows.Window.Closing>已處理事件，以及之前其<xref:System.Windows.Window.Closed>就會引發事件。</xref:System.Windows.Window.Closed> </xref:System.Windows.Window.Closing> </xref:System.Windows.Window>       根據預設，加入 Windows 屬性的第一個項目會成為<xref:System.Windows.Application.MainWindow%2A>.</xref:System.Windows.Application.MainWindow%2A>       這個屬性就只能從建立的執行緒<xref:System.Windows.Application>物件。</xref:System.Windows.Application>"
  example:
  - "The following example demonstrates how to enumerate the Windows property to build a top-level Windows menu, which is common to [!INCLUDE[TLA#tla_mdi](~/add/includes/tlasharptla-mdi-md.md)] applications like [!INCLUDE[TLA#tla_xl](~/add/includes/tlasharptla-xl-md.md)], or multiple-instance Single Document Interface (SDI) applications like [!INCLUDE[TLA#tla_word](~/add/includes/tlasharptla-word-md.md)].  \n  \n [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/add/codesnippet/visualbasic/applicationwindowssnippets/windowmenuitem.vb#windowmenuitemcode)]\n [!code-cs[ApplicationWindowsSnippets#WindowMenuItemCODE](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/WindowMenuItem.cs#windowmenuitemcode)]  \n  \n [!code-xml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/add/codesnippet/xaml/ApplicationWindowsSnippets.CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  \n  \n [!code-cs[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]\n [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/add/codesnippet/visualbasic/applicationwindowssnippets/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  \n[!code-cs[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/add/codesnippet/csharp/ApplicationWindowsSnippets.CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]\n[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/add/codesnippet/visualbasic/applicationwindowssnippets/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]"
  syntax:
    content: public System.Windows.WindowCollection Windows { get; }
    return:
      type: System.Windows.WindowCollection
      description: "A <xref href=&quot;System.Windows.WindowCollection&quot;> </xref> ，其中包含所有在目前的視窗物件的參考<xref href=&quot;System.AppDomain&quot;> </xref>。"
  overload: System.Windows.Application.Windows*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Windows.Threading.DispatcherObject
  isExternal: false
  name: System.Windows.Threading.DispatcherObject
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.ResourceReferenceKeyNotFoundException
  parent: System.Windows
  isExternal: false
  name: ResourceReferenceKeyNotFoundException
  nameWithType: ResourceReferenceKeyNotFoundException
  fullName: System.Windows.ResourceReferenceKeyNotFoundException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ComponentModel.Win32Exception
  parent: System.ComponentModel
  isExternal: false
  name: Win32Exception
  nameWithType: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.Windows.Application.#ctor
  parent: System.Windows.Application
  isExternal: false
  name: Application()
  nameWithType: Application.Application()
  fullName: System.Windows.Application.Application()
- uid: System.Windows.Application.Activated
  parent: System.Windows.Application
  isExternal: false
  name: Activated
  nameWithType: Application.Activated
  fullName: System.Windows.Application.Activated
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.Windows.Application.Current
  parent: System.Windows.Application
  isExternal: false
  name: Current
  nameWithType: Application.Current
  fullName: System.Windows.Application.Current
- uid: System.Windows.Application
  parent: System.Windows
  isExternal: false
  name: Application
  nameWithType: Application
  fullName: System.Windows.Application
- uid: System.Windows.Application.Deactivated
  parent: System.Windows.Application
  isExternal: false
  name: Deactivated
  nameWithType: Application.Deactivated
  fullName: System.Windows.Application.Deactivated
- uid: System.Windows.Application.DispatcherUnhandledException
  parent: System.Windows.Application
  isExternal: false
  name: DispatcherUnhandledException
  nameWithType: Application.DispatcherUnhandledException
  fullName: System.Windows.Application.DispatcherUnhandledException
- uid: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
  parent: System.Windows.Threading
  isExternal: false
  name: DispatcherUnhandledExceptionEventHandler
  nameWithType: DispatcherUnhandledExceptionEventHandler
  fullName: System.Windows.Threading.DispatcherUnhandledExceptionEventHandler
- uid: System.Windows.Application.Exit
  parent: System.Windows.Application
  isExternal: false
  name: Exit
  nameWithType: Application.Exit
  fullName: System.Windows.Application.Exit
- uid: System.Windows.ExitEventHandler
  parent: System.Windows
  isExternal: false
  name: ExitEventHandler
  nameWithType: ExitEventHandler
  fullName: System.Windows.ExitEventHandler
- uid: System.Windows.Application.FindResource(System.Object)
  parent: System.Windows.Application
  isExternal: false
  name: FindResource(Object)
  nameWithType: Application.FindResource(Object)
  fullName: System.Windows.Application.FindResource(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.Application.FragmentNavigation
  parent: System.Windows.Application
  isExternal: false
  name: FragmentNavigation
  nameWithType: Application.FragmentNavigation
  fullName: System.Windows.Application.FragmentNavigation
- uid: System.Windows.Navigation.FragmentNavigationEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: FragmentNavigationEventHandler
  nameWithType: FragmentNavigationEventHandler
  fullName: System.Windows.Navigation.FragmentNavigationEventHandler
- uid: System.Windows.Application.GetContentStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetContentStream(Uri)
  nameWithType: Application.GetContentStream(Uri)
  fullName: System.Windows.Application.GetContentStream(Uri)
- uid: System.Windows.Resources.StreamResourceInfo
  parent: System.Windows.Resources
  isExternal: false
  name: StreamResourceInfo
  nameWithType: StreamResourceInfo
  fullName: System.Windows.Resources.StreamResourceInfo
- uid: System.Uri
  parent: System
  isExternal: true
  name: Uri
  nameWithType: Uri
  fullName: System.Uri
- uid: System.Windows.Application.GetCookie(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetCookie(Uri)
  nameWithType: Application.GetCookie(Uri)
  fullName: System.Windows.Application.GetCookie(Uri)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Application.GetRemoteStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetRemoteStream(Uri)
  nameWithType: Application.GetRemoteStream(Uri)
  fullName: System.Windows.Application.GetRemoteStream(Uri)
- uid: System.Windows.Application.GetResourceStream(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: GetResourceStream(Uri)
  nameWithType: Application.GetResourceStream(Uri)
  fullName: System.Windows.Application.GetResourceStream(Uri)
- uid: System.Windows.Application.LoadCompleted
  parent: System.Windows.Application
  isExternal: false
  name: LoadCompleted
  nameWithType: Application.LoadCompleted
  fullName: System.Windows.Application.LoadCompleted
- uid: System.Windows.Navigation.LoadCompletedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: LoadCompletedEventHandler
  nameWithType: LoadCompletedEventHandler
  fullName: System.Windows.Navigation.LoadCompletedEventHandler
- uid: System.Windows.Application.LoadComponent(System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent(Uri)
  nameWithType: Application.LoadComponent(Uri)
  fullName: System.Windows.Application.LoadComponent(Uri)
- uid: System.Windows.Application.LoadComponent(System.Object,System.Uri)
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent(Object,Uri)
  nameWithType: Application.LoadComponent(Object,Uri)
  fullName: System.Windows.Application.LoadComponent(Object,Uri)
- uid: System.Windows.Application.MainWindow
  parent: System.Windows.Application
  isExternal: false
  name: MainWindow
  nameWithType: Application.MainWindow
  fullName: System.Windows.Application.MainWindow
- uid: System.Windows.Window
  parent: System.Windows
  isExternal: false
  name: Window
  nameWithType: Window
  fullName: System.Windows.Window
- uid: System.Windows.Application.Navigated
  parent: System.Windows.Application
  isExternal: false
  name: Navigated
  nameWithType: Application.Navigated
  fullName: System.Windows.Application.Navigated
- uid: System.Windows.Navigation.NavigatedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatedEventHandler
  nameWithType: NavigatedEventHandler
  fullName: System.Windows.Navigation.NavigatedEventHandler
- uid: System.Windows.Application.Navigating
  parent: System.Windows.Application
  isExternal: false
  name: Navigating
  nameWithType: Application.Navigating
  fullName: System.Windows.Application.Navigating
- uid: System.Windows.Navigation.NavigatingCancelEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatingCancelEventHandler
  nameWithType: NavigatingCancelEventHandler
  fullName: System.Windows.Navigation.NavigatingCancelEventHandler
- uid: System.Windows.Application.NavigationFailed
  parent: System.Windows.Application
  isExternal: false
  name: NavigationFailed
  nameWithType: Application.NavigationFailed
  fullName: System.Windows.Application.NavigationFailed
- uid: System.Windows.Navigation.NavigationFailedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationFailedEventHandler
  nameWithType: NavigationFailedEventHandler
  fullName: System.Windows.Navigation.NavigationFailedEventHandler
- uid: System.Windows.Application.NavigationProgress
  parent: System.Windows.Application
  isExternal: false
  name: NavigationProgress
  nameWithType: Application.NavigationProgress
  fullName: System.Windows.Application.NavigationProgress
- uid: System.Windows.Navigation.NavigationProgressEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationProgressEventHandler
  nameWithType: NavigationProgressEventHandler
  fullName: System.Windows.Navigation.NavigationProgressEventHandler
- uid: System.Windows.Application.NavigationStopped
  parent: System.Windows.Application
  isExternal: false
  name: NavigationStopped
  nameWithType: Application.NavigationStopped
  fullName: System.Windows.Application.NavigationStopped
- uid: System.Windows.Navigation.NavigationStoppedEventHandler
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationStoppedEventHandler
  nameWithType: NavigationStoppedEventHandler
  fullName: System.Windows.Navigation.NavigationStoppedEventHandler
- uid: System.Windows.Application.OnActivated(System.EventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnActivated(EventArgs)
  nameWithType: Application.OnActivated(EventArgs)
  fullName: System.Windows.Application.OnActivated(EventArgs)
- uid: System.EventArgs
  parent: System
  isExternal: true
  name: EventArgs
  nameWithType: EventArgs
  fullName: System.EventArgs
- uid: System.Windows.Application.OnDeactivated(System.EventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnDeactivated(EventArgs)
  nameWithType: Application.OnDeactivated(EventArgs)
  fullName: System.Windows.Application.OnDeactivated(EventArgs)
- uid: System.Windows.Application.OnExit(System.Windows.ExitEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnExit(ExitEventArgs)
  nameWithType: Application.OnExit(ExitEventArgs)
  fullName: System.Windows.Application.OnExit(ExitEventArgs)
- uid: System.Windows.ExitEventArgs
  parent: System.Windows
  isExternal: false
  name: ExitEventArgs
  nameWithType: ExitEventArgs
  fullName: System.Windows.ExitEventArgs
- uid: System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnFragmentNavigation(FragmentNavigationEventArgs)
  nameWithType: Application.OnFragmentNavigation(FragmentNavigationEventArgs)
  fullName: System.Windows.Application.OnFragmentNavigation(FragmentNavigationEventArgs)
- uid: System.Windows.Navigation.FragmentNavigationEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: FragmentNavigationEventArgs
  nameWithType: FragmentNavigationEventArgs
  fullName: System.Windows.Navigation.FragmentNavigationEventArgs
- uid: System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnLoadCompleted(NavigationEventArgs)
  nameWithType: Application.OnLoadCompleted(NavigationEventArgs)
  fullName: System.Windows.Application.OnLoadCompleted(NavigationEventArgs)
- uid: System.Windows.Navigation.NavigationEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationEventArgs
  nameWithType: NavigationEventArgs
  fullName: System.Windows.Navigation.NavigationEventArgs
- uid: System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigated(NavigationEventArgs)
  nameWithType: Application.OnNavigated(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigated(NavigationEventArgs)
- uid: System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigating(NavigatingCancelEventArgs)
  nameWithType: Application.OnNavigating(NavigatingCancelEventArgs)
  fullName: System.Windows.Application.OnNavigating(NavigatingCancelEventArgs)
- uid: System.Windows.Navigation.NavigatingCancelEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigatingCancelEventArgs
  nameWithType: NavigatingCancelEventArgs
  fullName: System.Windows.Navigation.NavigatingCancelEventArgs
- uid: System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationFailed(NavigationFailedEventArgs)
  nameWithType: Application.OnNavigationFailed(NavigationFailedEventArgs)
  fullName: System.Windows.Application.OnNavigationFailed(NavigationFailedEventArgs)
- uid: System.Windows.Navigation.NavigationFailedEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationFailedEventArgs
  nameWithType: NavigationFailedEventArgs
  fullName: System.Windows.Navigation.NavigationFailedEventArgs
- uid: System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationProgress(NavigationProgressEventArgs)
  nameWithType: Application.OnNavigationProgress(NavigationProgressEventArgs)
  fullName: System.Windows.Application.OnNavigationProgress(NavigationProgressEventArgs)
- uid: System.Windows.Navigation.NavigationProgressEventArgs
  parent: System.Windows.Navigation
  isExternal: false
  name: NavigationProgressEventArgs
  nameWithType: NavigationProgressEventArgs
  fullName: System.Windows.Navigation.NavigationProgressEventArgs
- uid: System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationStopped(NavigationEventArgs)
  nameWithType: Application.OnNavigationStopped(NavigationEventArgs)
  fullName: System.Windows.Application.OnNavigationStopped(NavigationEventArgs)
- uid: System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnSessionEnding(SessionEndingCancelEventArgs)
  nameWithType: Application.OnSessionEnding(SessionEndingCancelEventArgs)
  fullName: System.Windows.Application.OnSessionEnding(SessionEndingCancelEventArgs)
- uid: System.Windows.SessionEndingCancelEventArgs
  parent: System.Windows
  isExternal: false
  name: SessionEndingCancelEventArgs
  nameWithType: SessionEndingCancelEventArgs
  fullName: System.Windows.SessionEndingCancelEventArgs
- uid: System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)
  parent: System.Windows.Application
  isExternal: false
  name: OnStartup(StartupEventArgs)
  nameWithType: Application.OnStartup(StartupEventArgs)
  fullName: System.Windows.Application.OnStartup(StartupEventArgs)
- uid: System.Windows.StartupEventArgs
  parent: System.Windows
  isExternal: false
  name: StartupEventArgs
  nameWithType: StartupEventArgs
  fullName: System.Windows.StartupEventArgs
- uid: System.Windows.Application.Properties
  parent: System.Windows.Application
  isExternal: false
  name: Properties
  nameWithType: Application.Properties
  fullName: System.Windows.Application.Properties
- uid: System.Collections.IDictionary
  parent: System.Collections
  isExternal: true
  name: IDictionary
  nameWithType: IDictionary
  fullName: System.Collections.IDictionary
- uid: System.Windows.Application.ResourceAssembly
  parent: System.Windows.Application
  isExternal: false
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
  fullName: System.Windows.Application.ResourceAssembly
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.Windows.Application.Resources
  parent: System.Windows.Application
  isExternal: false
  name: Resources
  nameWithType: Application.Resources
  fullName: System.Windows.Application.Resources
- uid: System.Windows.ResourceDictionary
  parent: System.Windows
  isExternal: false
  name: ResourceDictionary
  nameWithType: ResourceDictionary
  fullName: System.Windows.ResourceDictionary
- uid: System.Windows.Application.Run
  parent: System.Windows.Application
  isExternal: false
  name: Run()
  nameWithType: Application.Run()
  fullName: System.Windows.Application.Run()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Application.Run(System.Windows.Window)
  parent: System.Windows.Application
  isExternal: false
  name: Run(Window)
  nameWithType: Application.Run(Window)
  fullName: System.Windows.Application.Run(Window)
- uid: System.Windows.Application.SessionEnding
  parent: System.Windows.Application
  isExternal: false
  name: SessionEnding
  nameWithType: Application.SessionEnding
  fullName: System.Windows.Application.SessionEnding
- uid: System.Windows.SessionEndingCancelEventHandler
  parent: System.Windows
  isExternal: false
  name: SessionEndingCancelEventHandler
  nameWithType: SessionEndingCancelEventHandler
  fullName: System.Windows.SessionEndingCancelEventHandler
- uid: System.Windows.Application.SetCookie(System.Uri,System.String)
  parent: System.Windows.Application
  isExternal: false
  name: SetCookie(Uri,String)
  nameWithType: Application.SetCookie(Uri,String)
  fullName: System.Windows.Application.SetCookie(Uri,String)
- uid: System.Windows.Application.Shutdown
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown()
  nameWithType: Application.Shutdown()
  fullName: System.Windows.Application.Shutdown()
- uid: System.Windows.Application.Shutdown(System.Int32)
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown(Int32)
  nameWithType: Application.Shutdown(Int32)
  fullName: System.Windows.Application.Shutdown(Int32)
- uid: System.Windows.Application.ShutdownMode
  parent: System.Windows.Application
  isExternal: false
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
  fullName: System.Windows.Application.ShutdownMode
- uid: System.Windows.ShutdownMode
  parent: System.Windows
  isExternal: false
  name: ShutdownMode
  nameWithType: ShutdownMode
  fullName: System.Windows.ShutdownMode
- uid: System.Windows.Application.Startup
  parent: System.Windows.Application
  isExternal: false
  name: Startup
  nameWithType: Application.Startup
  fullName: System.Windows.Application.Startup
- uid: System.Windows.StartupEventHandler
  parent: System.Windows
  isExternal: false
  name: StartupEventHandler
  nameWithType: StartupEventHandler
  fullName: System.Windows.StartupEventHandler
- uid: System.Windows.Application.StartupUri
  parent: System.Windows.Application
  isExternal: false
  name: StartupUri
  nameWithType: Application.StartupUri
  fullName: System.Windows.Application.StartupUri
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)
  parent: System.Windows.Application
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
  fullName: System.Windows.Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(String)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Application.TryFindResource(System.Object)
  parent: System.Windows.Application
  isExternal: false
  name: TryFindResource(Object)
  nameWithType: Application.TryFindResource(Object)
  fullName: System.Windows.Application.TryFindResource(Object)
- uid: System.Windows.Application.Windows
  parent: System.Windows.Application
  isExternal: false
  name: Windows
  nameWithType: Application.Windows
  fullName: System.Windows.Application.Windows
- uid: System.Windows.WindowCollection
  parent: System.Windows
  isExternal: false
  name: WindowCollection
  nameWithType: WindowCollection
  fullName: System.Windows.WindowCollection
- uid: System.Windows.Application.#ctor*
  parent: System.Windows.Application
  isExternal: false
  name: Application
  nameWithType: Application.Application
- uid: System.Windows.Application.Current*
  parent: System.Windows.Application
  isExternal: false
  name: Current
  nameWithType: Application.Current
- uid: System.Windows.Application.FindResource*
  parent: System.Windows.Application
  isExternal: false
  name: FindResource
  nameWithType: Application.FindResource
- uid: System.Windows.Application.GetContentStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetContentStream
  nameWithType: Application.GetContentStream
- uid: System.Windows.Application.GetCookie*
  parent: System.Windows.Application
  isExternal: false
  name: GetCookie
  nameWithType: Application.GetCookie
- uid: System.Windows.Application.GetRemoteStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetRemoteStream
  nameWithType: Application.GetRemoteStream
- uid: System.Windows.Application.GetResourceStream*
  parent: System.Windows.Application
  isExternal: false
  name: GetResourceStream
  nameWithType: Application.GetResourceStream
- uid: System.Windows.Application.LoadComponent*
  parent: System.Windows.Application
  isExternal: false
  name: LoadComponent
  nameWithType: Application.LoadComponent
- uid: System.Windows.Application.MainWindow*
  parent: System.Windows.Application
  isExternal: false
  name: MainWindow
  nameWithType: Application.MainWindow
- uid: System.Windows.Application.OnActivated*
  parent: System.Windows.Application
  isExternal: false
  name: OnActivated
  nameWithType: Application.OnActivated
- uid: System.Windows.Application.OnDeactivated*
  parent: System.Windows.Application
  isExternal: false
  name: OnDeactivated
  nameWithType: Application.OnDeactivated
- uid: System.Windows.Application.OnExit*
  parent: System.Windows.Application
  isExternal: false
  name: OnExit
  nameWithType: Application.OnExit
- uid: System.Windows.Application.OnFragmentNavigation*
  parent: System.Windows.Application
  isExternal: false
  name: OnFragmentNavigation
  nameWithType: Application.OnFragmentNavigation
- uid: System.Windows.Application.OnLoadCompleted*
  parent: System.Windows.Application
  isExternal: false
  name: OnLoadCompleted
  nameWithType: Application.OnLoadCompleted
- uid: System.Windows.Application.OnNavigated*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigated
  nameWithType: Application.OnNavigated
- uid: System.Windows.Application.OnNavigating*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigating
  nameWithType: Application.OnNavigating
- uid: System.Windows.Application.OnNavigationFailed*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationFailed
  nameWithType: Application.OnNavigationFailed
- uid: System.Windows.Application.OnNavigationProgress*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationProgress
  nameWithType: Application.OnNavigationProgress
- uid: System.Windows.Application.OnNavigationStopped*
  parent: System.Windows.Application
  isExternal: false
  name: OnNavigationStopped
  nameWithType: Application.OnNavigationStopped
- uid: System.Windows.Application.OnSessionEnding*
  parent: System.Windows.Application
  isExternal: false
  name: OnSessionEnding
  nameWithType: Application.OnSessionEnding
- uid: System.Windows.Application.OnStartup*
  parent: System.Windows.Application
  isExternal: false
  name: OnStartup
  nameWithType: Application.OnStartup
- uid: System.Windows.Application.Properties*
  parent: System.Windows.Application
  isExternal: false
  name: Properties
  nameWithType: Application.Properties
- uid: System.Windows.Application.ResourceAssembly*
  parent: System.Windows.Application
  isExternal: false
  name: ResourceAssembly
  nameWithType: Application.ResourceAssembly
- uid: System.Windows.Application.Resources*
  parent: System.Windows.Application
  isExternal: false
  name: Resources
  nameWithType: Application.Resources
- uid: System.Windows.Application.Run*
  parent: System.Windows.Application
  isExternal: false
  name: Run
  nameWithType: Application.Run
- uid: System.Windows.Application.SetCookie*
  parent: System.Windows.Application
  isExternal: false
  name: SetCookie
  nameWithType: Application.SetCookie
- uid: System.Windows.Application.Shutdown*
  parent: System.Windows.Application
  isExternal: false
  name: Shutdown
  nameWithType: Application.Shutdown
- uid: System.Windows.Application.ShutdownMode*
  parent: System.Windows.Application
  isExternal: false
  name: ShutdownMode
  nameWithType: Application.ShutdownMode
- uid: System.Windows.Application.StartupUri*
  parent: System.Windows.Application
  isExternal: false
  name: StartupUri
  nameWithType: Application.StartupUri
- uid: System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable*
  parent: System.Windows.Application
  isExternal: false
  name: System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
  nameWithType: Application.System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable
- uid: System.Windows.Application.TryFindResource*
  parent: System.Windows.Application
  isExternal: false
  name: TryFindResource
  nameWithType: Application.TryFindResource
- uid: System.Windows.Application.Windows*
  parent: System.Windows.Application
  isExternal: false
  name: Windows
  nameWithType: Application.Windows
