### YamlMime:ManagedReference
items:
- uid: System.Collections.Hashtable
  id: Hashtable
  children:
  - System.Collections.Hashtable.#ctor
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  - System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  - System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  - System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  - System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  - System.Collections.Hashtable.Add(System.Object,System.Object)
  - System.Collections.Hashtable.Clear
  - System.Collections.Hashtable.Clone
  - System.Collections.Hashtable.comparer
  - System.Collections.Hashtable.Contains(System.Object)
  - System.Collections.Hashtable.ContainsKey(System.Object)
  - System.Collections.Hashtable.ContainsValue(System.Object)
  - System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  - System.Collections.Hashtable.Count
  - System.Collections.Hashtable.EqualityComparer
  - System.Collections.Hashtable.GetEnumerator
  - System.Collections.Hashtable.GetHash(System.Object)
  - System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.Collections.Hashtable.hcp
  - System.Collections.Hashtable.IsFixedSize
  - System.Collections.Hashtable.IsReadOnly
  - System.Collections.Hashtable.IsSynchronized
  - System.Collections.Hashtable.Item(System.Object)
  - System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  - System.Collections.Hashtable.Keys
  - System.Collections.Hashtable.OnDeserialization(System.Object)
  - System.Collections.Hashtable.Remove(System.Object)
  - System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  - System.Collections.Hashtable.SyncRoot
  - System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  - System.Collections.Hashtable.Values
  langs:
  - csharp
  name: Hashtable
  nameWithType: Hashtable
  fullName: System.Collections.Hashtable
  type: Class
  summary: "表示集合的索引鍵/值組會組織為基礎的索引鍵的雜湊碼。       若要瀏覽此類型的.NET Framework 原始程式碼，請參閱[參考來源](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd)。"
  remarks: "> [!NOTE]> 這種類型的.NET Framework 原始程式碼，請參閱 <<c2> [ 參考來源](http://referencesource.microsoft.com/#mscorlib/system/collections/hashtable.cs#10fefb6e0ae510dd)。 您可以瀏覽原始碼、 下載的參考，離線檢視，並逐步執行原始程式碼 （包含修補程式和更新），在偵錯;請參閱[指示](http://referencesource.microsoft.com/)。       每個項目是儲存在索引鍵/值組<xref:System.Collections.DictionaryEntry>物件。</xref:System.Collections.DictionaryEntry> 金鑰不能`null`，但是值可以是。       做為索引鍵的雜湊表，才能覆寫物件<xref:System.Object.GetHashCode%2A?displayProperty=fullName>方法 (或<xref:System.Collections.IHashCodeProvider>介面) 和<xref:System.Object.Equals%2A?displayProperty=fullName>方法 (或<xref:System.Collections.IComparer>介面)。</xref:System.Collections.IComparer> </xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Collections.IHashCodeProvider> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> 方法和介面的實作必須處理區分大小寫相同的方式;否則雜湊表可能不正確地運作。 例如，在建立雜湊表，您必須使用<xref:System.Collections.CaseInsensitiveHashCodeProvider>類別 (或任何不區分大小寫<xref:System.Collections.IHashCodeProvider>實作) 與<xref:System.Collections.CaseInsensitiveComparer>類別 (或任何不區分大小寫<xref:System.Collections.IComparer>實作)。</xref:System.Collections.IComparer> </xref:System.Collections.CaseInsensitiveComparer> </xref:System.Collections.IHashCodeProvider> </xref:System.Collections.CaseInsensitiveHashCodeProvider>       此外，這些方法必須產生相同的結果時索引鍵的雜湊表中存在具有相同參數呼叫時。 替代方式是使用的雜湊表建構函式<xref:System.Collections.IEqualityComparer>參數。</xref:System.Collections.IEqualityComparer> 如果索引鍵相等與否是只需參考相等的繼承實作<xref:System.Object.GetHashCode%2A?displayProperty=fullName>和<xref:System.Object.Equals%2A?displayProperty=fullName>即已足夠。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName>       索引鍵物件必須是不變的只要它們作為雜湊表中的索引鍵。       項目加入至雜湊表，項目會放入桶，依據索引鍵的雜湊碼。 後續的查閱索引鍵使用索引鍵的雜湊的碼搜尋中只有一個特定的貯體，因而大幅降低尋找的項目所需的索引鍵比較的數量。       雜湊表的負載因數會決定雜湊桶項的最大比例。 較小的負載因數會導致更快的平均查閱次數，代價是會增加的記憶體耗用量。 預設的負載因數 1.0 通常會提供速度及大小最佳平衡。 建立雜湊表時，也可以指定不同的負載因數。       當項目加入至雜湊表，其中的 Hashtable 的實際負載因數會增加。 當實際的負載因數會到達指定的負載因數時，雜湊表中的貯體數目會自動增加到大於兩次目前的雜湊表值區數目最小質數。       雜湊表中的每個索引鍵物件必須提供它自己的雜湊函數，可以藉由呼叫<xref:System.Collections.Hashtable.GetHash%2A>.</xref:System.Collections.Hashtable.GetHash%2A>存取 不過，任何物件實作<xref:System.Collections.IHashCodeProvider>可以傳遞雜湊表的建構函式，而且該雜湊函式用於資料表中的所有物件。</xref:System.Collections.IHashCodeProvider>       雜湊表的容量是雜湊表可以保存的項目數目。 當項目加入至雜湊表，就會自動增加容量視需要透過重新配置。       對於非常大的雜湊表物件，您可以藉由設定增加到 64 位元系統上的 2 億元素的最大容量`enabled`屬性的組態項目`true`在執行階段環境中。       `foreach` C# 語言的陳述式 (`For Each`在 Visual Basic 中) 傳回集合中的項目類型的物件。 因為雜湊表的每個項目是索引鍵/值組，項目型別不是索引鍵的類型或值的類型。 相反地，項目型別是<xref:System.Collections.DictionaryEntry>.</xref:System.Collections.DictionaryEntry> 例如︰ [!code-cpp [System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/cpp/t-system.collections.has_1.cpp)][!code-cs[System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/csharp/t-system.collections.has_1.cs)][!code-vb[System.Collections.Hashtable_ClassExample#01](~/add/codesnippet/visualbasic/t-system.collections.has_1.vb) ] `foreach`陳述式是包裝函式，只允許讀取，不寫入至集合的列舉值。           序列化和還原序列化列舉值的雜湊表可能會導致變成重新排列項目，因為不可能繼續列舉型別，而不需呼叫<xref:System.Collections.IEnumerator.Reset%2A>方法。</xref:System.Collections.IEnumerator.Reset%2A>      > [!NOTE] > 因為索引鍵可以被繼承，變更其行為，其絕對唯一性無法保證使用比較<xref:System.Type.Equals%2A>方法。</xref:System.Type.Equals%2A>"
  example:
  - "The following example shows how to create, initialize and perform various functions to a Hashtable and how to print out its keys and values.  \n  \n [!code-cpp[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/cpp/t-system.collections.has_2.cpp)]\n [!code-cs[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/csharp/t-system.collections.has_2.cs)]\n [!code-vb[System.Collections.Hashtable_ClassExample#00](~/add/codesnippet/visualbasic/t-system.collections.has_2.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Hashtable/HashtableDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Hashtable : ICloneable, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
  inheritance:
  - System.Object
  implements:
  - System.Collections.IDictionary
  - System.ICloneable
  - System.Runtime.Serialization.IDeserializationCallback
  - System.Runtime.Serialization.ISerializable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor
  id: '#ctor'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable()
  nameWithType: Hashtable.Hashtable()
  fullName: System.Collections.Hashtable.Hashtable()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化新的空白執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>類別使用預設的初始容量，載入因數、 雜湊碼提供者和比較子。"
  remarks: "雜湊表的容量用來計算最佳的雜湊根據負載因數的資料表值區數目。 自動增加容量視需要而定。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       雜湊碼提供者在該雜湊程式碼中的索引鍵<xref:System.Collections.Hashtable>物件。</xref:System.Collections.Hashtable> 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       這個建構函式是 o （1） 運算。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/m-system.collections.has_4_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/m-system.collections.has_4_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/m-system.collections.has_4_1.vb)]"
  syntax:
    content: public Hashtable ();
    parameters: []
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  id: '#ctor(System.Collections.IDictionary)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary)
  nameWithType: Hashtable.Hashtable(IDictionary)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>指定字典中的項目複製到新的類別<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。 新<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件具有相等的項目數複製，初始容量，並使用預設載入因數、 雜湊碼提供者和比較子。"
  remarks: "初始容量設定為來源字典中的項目數。 容量會自動視需要增加的負載因數為基礎。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       雜湊碼提供者在該雜湊程式碼中的索引鍵<xref:System.Collections.Hashtable>物件。</xref:System.Collections.Hashtable> 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       新的項目<xref:System.Collections.Hashtable>都會依照相同的順序，以列舉值逐一<xref:System.Collections.IDictionary>物件。</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       這個建構函式為 O (`n`) 作業，其中`n`是中的項目數`d`參數。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/m-system.collections.has_1_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/m-system.collections.has_1_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/m-system.collections.has_1_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>要複製到新物件<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。</xref:System.Collections.IDictionary>"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化新的空白執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>類別使用預設的初始容量，並載入因數，以及指定<xref:System.Collections.IEqualityComparer>物件。</xref:System.Collections.IEqualityComparer>"
  remarks: "雜湊表的容量用來計算最佳的雜湊根據負載因數的資料表值區數目。 自動增加容量視需要而定。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       <xref:System.Collections.IEqualityComparer>物件包含雜湊碼提供者和比較子。</xref:System.Collections.IEqualityComparer> 如果<xref:System.Collections.IEqualityComparer>用於<xref:System.Collections.Hashtable>建構函式、 物件做為索引鍵中<xref:System.Collections.Hashtable>物件不需要覆寫<xref:System.Object.GetHashCode%2A?displayProperty=fullName>和<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       雜湊碼提供者在該<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的索引鍵的雜湊程式碼 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       <xref:System.Collections.IEqualityComparer>可案例，例如執行不區分大小寫字串的查閱。</xref:System.Collections.IEqualityComparer>       這個建構函式是 o （1） 運算。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/m-system.collections.has_5_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/m-system.collections.has_5_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/m-system.collections.has_5_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>物件，定義要使用的雜湊碼提供者和比較子<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。</xref:System.Collections.IEqualityComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>使用預設雜湊碼提供者和預設比較子。 預設雜湊碼提供者是每個索引鍵實作&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;和預設比較子是每個索引鍵實作&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32)
  nameWithType: Hashtable.Hashtable(Int32)
  fullName: System.Collections.Hashtable.Hashtable(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化新的空白執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>類別使用指定的初始容量，並預設載入因數、 雜湊碼提供者和比較子。"
  remarks: "指定的初始容量，就不需要執行數個調整大小作業時新增元素至<xref:System.Collections.Hashtable>物件。</xref:System.Collections.Hashtable> 容量會自動視需要增加的負載因數為基礎。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       雜湊碼提供者在該<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的索引鍵的雜湊程式碼 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       這個建構函式為 O (`n`) 作業，其中`n`是`capacity`。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/m-system.collections.has_2_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/m-system.collections.has_2_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/m-system.collections.has_2_1.vb)]"
  syntax:
    content: public Hashtable (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "大約項目數， <xref href=&quot;System.Collections.Hashtable&quot;> </xref>一開始可包含物件。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小於零。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>指定字典中的項目複製到新的類別<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。 新<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件預設初始容量等於複製，項目數目，並使用預設載入因數和指定<xref:System.Collections.IEqualityComparer>物件。</xref:System.Collections.IEqualityComparer>"
  remarks: "初始容量設定為來源字典中的項目數。 容量會自動視需要增加的負載因數為基礎。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       <xref:System.Collections.IEqualityComparer>物件包含雜湊碼提供者和比較子。</xref:System.Collections.IEqualityComparer> 如果<xref:System.Collections.IEqualityComparer>用於<xref:System.Collections.Hashtable>建構函式、 物件做為索引鍵中<xref:System.Collections.Hashtable>物件不需要覆寫<xref:System.Object.GetHashCode%2A?displayProperty=fullName>和<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       雜湊碼提供者在該<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的索引鍵的雜湊程式碼 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       <xref:System.Collections.IEqualityComparer>可案例，例如執行不區分大小寫字串的查閱。</xref:System.Collections.IEqualityComparer>       新的項目<xref:System.Collections.Hashtable>都會依照相同的順序，以列舉值逐一<xref:System.Collections.IDictionary>物件。</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       這個建構函式為 O (`n`) 作業，其中`n`是中的項目數`d`參數。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/81cd87de-02b7-42cc-8fdd-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/81cd87de-02b7-42cc-8fdd-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/81cd87de-02b7-42cc-8fdd-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>要複製到新物件<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。</xref:System.Collections.IDictionary>"
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>物件，定義要使用的雜湊碼提供者和比較子<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IEqualityComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>使用預設雜湊碼提供者和預設比較子。 預設雜湊碼提供者是每個索引鍵實作&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;和預設比較子是每個索引鍵實作&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  id: '#ctor(System.Collections.IDictionary,System.Single)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single)
  nameWithType: Hashtable.Hashtable(IDictionary,Single)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>指定字典中的項目複製到新的類別<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。 新<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件具有相等的項目數複製，初始容量，並使用指定的負載因數，以及預設雜湊碼提供者和比較子。"
  remarks: "初始容量設定為來源字典中的項目數。 容量會自動視需要增加的負載因數為基礎。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。 1.0 的負載因數是速度及大小最佳平衡。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       雜湊碼提供者在該雜湊程式碼中的索引鍵<xref:System.Collections.Hashtable>物件。</xref:System.Collections.Hashtable> 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       新的項目<xref:System.Collections.Hashtable>都會依照相同的順序，以列舉值逐一<xref:System.Collections.IDictionary>物件。</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       這個建構函式為 O (`n`) 作業，其中`n`是中的項目數`d`參數。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/fb1cfbc8-7454-4619-a6e7-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/fb1cfbc8-7454-4619-a6e7-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/fb1cfbc8-7454-4619-a6e7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>要複製到新物件<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "從 0.1 到 1.0 之間，提供最佳效能的預設值會乘以範圍之數字。 結果是雜湊桶項的最大比例。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>小於 0.1。       -或-<code>loadFactor</code>大於 1.0。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化新的空白執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>類別使用預設的初始容量，並載入因數，以及指定的雜湊碼提供者和比較子。"
  remarks: "雜湊表的容量用來計算最佳的雜湊根據負載因數的資料表值區數目。 自動增加容量視需要而定。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       雜湊碼提供者在該雜湊程式碼中的索引鍵<xref:System.Collections.Hashtable>物件。</xref:System.Collections.Hashtable> 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       自訂的雜湊碼提供者和自訂比較子以啟用案例，例如執行不區分大小寫字串的查閱。       這個建構函式是 o （1） 運算。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctor#1](~/add/codesnippet/cpp/1ff65986-0234-4702-94b7-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctor#1](~/add/codesnippet/csharp/1ff65986-0234-4702-94b7-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctor#1](~/add/codesnippet/visualbasic/1ff65986-0234-4702-94b7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref>物件，提供雜湊碼的所有索引鍵中<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>使用預設雜湊碼提供者，這是每個索引鍵實作&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;。"
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>物件用來判斷兩個索引鍵是否相等。</xref:System.Collections.IComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>表示使用預設比較子，這是每個索引鍵實作&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  id: '#ctor(System.Int32,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化新的空白執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>類別使用指定的初始容量和<xref:System.Collections.IEqualityComparer>，與預設負載因數。</xref:System.Collections.IEqualityComparer>"
  remarks: "指定的初始容量，就不需要執行數個調整大小作業時新增元素至<xref:System.Collections.Hashtable>物件。</xref:System.Collections.Hashtable> 容量會自動視需要增加的負載因數為基礎。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       <xref:System.Collections.IEqualityComparer>物件包含雜湊碼提供者和比較子。</xref:System.Collections.IEqualityComparer> 如果<xref:System.Collections.IEqualityComparer>用於<xref:System.Collections.Hashtable>建構函式、 物件做為索引鍵中<xref:System.Collections.Hashtable>不需要覆寫<xref:System.Object.GetHashCode%2A?displayProperty=fullName>和<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       雜湊碼提供者在該<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的索引鍵的雜湊程式碼 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       <xref:System.Collections.IEqualityComparer>可案例，例如執行不區分大小寫字串的查閱。</xref:System.Collections.IEqualityComparer>       這個建構函式為 O (`n`) 作業，其中`n`是`capacity`參數。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/5067e9ac-cd98-4da8-9418-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/5067e9ac-cd98-4da8-9418-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/5067e9ac-cd98-4da8-9418-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "大約項目數， <xref href=&quot;System.Collections.Hashtable&quot;> </xref>一開始可包含物件。"
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>物件，定義要使用的雜湊碼提供者和比較子<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IEqualityComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>使用預設雜湊碼提供者和預設比較子。 預設雜湊碼提供者是每個索引鍵實作&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;和預設比較子是每個索引鍵實作&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小於零。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single)
  nameWithType: Hashtable.Hashtable(Int32,Single)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化新的空白執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>類別使用指定的初始容量，並載入因數的預設雜湊碼提供者和比較子。"
  remarks: "指定的初始容量，就不需要執行數個調整大小作業時新增元素至<xref:System.Collections.Hashtable>物件。</xref:System.Collections.Hashtable> 容量會自動視需要增加的負載因數為基礎。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。 1.0 的負載因數是速度及大小最佳平衡。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       雜湊碼提供者在該<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的索引鍵的雜湊程式碼 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       這個建構函式為 O (`n`) 作業，其中`n`是`capacity`參數。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/m-system.collections.has_8_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/m-system.collections.has_8_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/m-system.collections.has_8_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "大約項目數， <xref href=&quot;System.Collections.Hashtable&quot;> </xref>一開始可包含物件。"
    - id: loadFactor
      type: System.Single
      description: "從 0.1 到 1.0 之間，提供最佳效能的預設值會乘以範圍之數字。 結果是雜湊桶項的最大比例。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小於零。       -或-<code>loadFactor</code>小於 0.1。       -或-<code>loadFactor</code>大於 1.0。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>capacity</code>造成溢位。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: '#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.Hashtable(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.Hashtable(SerializationInfo,StreamingContext)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化新的空白執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>序列化使用指定的類別<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;></xref>和<xref:System.Runtime.Serialization.StreamingContext>物件。</xref:System.Runtime.Serialization.StreamingContext>"
  remarks: "雜湊表的容量用來計算最佳的雜湊根據負載因數的資料表值區數目。 自動增加容量視需要而定。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       雜湊碼提供者在該雜湊程式碼中的索引鍵<xref:System.Collections.Hashtable>物件。</xref:System.Collections.Hashtable> 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       這個建構函式為 O (`n`) 作業，其中`n`為<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>       因為序列化和還原序列化的列舉值<xref:System.Collections.Hashtable>可能會導致變成重新排列項目，就不可能繼續列舉型別，而不需呼叫<xref:System.Collections.IEnumerator.Reset%2A>方法。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  syntax:
    content: protected Hashtable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>物件，其中包含要序列化所需的資訊<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A<xref:System.Runtime.Serialization.StreamingContext>物件，其中包含來源和目的地相關聯之序列化資料流<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>info</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>指定字典中的項目複製到新的類別<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。 新<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件具有相等的項目數複製，初始容量，並使用預設的負載因數，以及指定的雜湊碼提供者和比較子。 這個 API 已過時。 如需替代方法，請參閱&lt;xref:System.Collections.Hashtable.%23ctor%2A&gt;。"
  remarks: "初始容量設定為來源字典中的項目數。 容量會自動視需要增加的負載因數為基礎。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       雜湊碼提供者在該雜湊程式碼中的索引鍵<xref:System.Collections.Hashtable>物件。</xref:System.Collections.Hashtable> 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       自訂的雜湊碼提供者和自訂比較子以啟用案例，例如執行不區分大小寫字串的查閱。       新的項目<xref:System.Collections.Hashtable>都會依照相同的順序，以列舉值逐一<xref:System.Collections.IDictionary>物件。</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       這個建構函式為 O (`n`) 作業，其中`n`是中的項目數`d`參數。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/cpp/9a30e378-7c34-4854-b12f-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/csharp/9a30e378-7c34-4854-b12f-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorDictionary#1](~/add/codesnippet/visualbasic/9a30e378-7c34-4854-b12f-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>要複製到新物件<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。</xref:System.Collections.IDictionary>"
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref>物件，提供雜湊碼的所有索引鍵中<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>使用預設雜湊碼提供者，這是每個索引鍵實作&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;。"
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>物件用來判斷兩個索引鍵是否相等。</xref:System.Collections.IComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>表示使用預設比較子，這是每個索引鍵實作&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  id: '#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>指定字典中的項目複製到新的類別<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。 新<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件具有相等的項目數複製，初始容量，並且會利用指定的負載因數和<xref:System.Collections.IEqualityComparer>物件。</xref:System.Collections.IEqualityComparer>"
  remarks: "初始容量設定為來源字典中的項目數。 容量會自動視需要增加的負載因數為基礎。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。 1.0 的負載因數是速度及大小最佳平衡。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       <xref:System.Collections.IEqualityComparer>物件包含雜湊碼提供者和比較子。</xref:System.Collections.IEqualityComparer> 如果<xref:System.Collections.IEqualityComparer>用於<xref:System.Collections.Hashtable>建構函式、 物件做為索引鍵中<xref:System.Collections.Hashtable>物件不需要覆寫<xref:System.Object.GetHashCode%2A?displayProperty=fullName>和<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       雜湊碼提供者在該<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的索引鍵的雜湊程式碼 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       <xref:System.Collections.IEqualityComparer>可案例，例如執行不區分大小寫字串的查閱。</xref:System.Collections.IEqualityComparer>       新的項目<xref:System.Collections.Hashtable>都會依照相同的順序，以列舉值逐一<xref:System.Collections.IDictionary>物件。</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       這個建構函式為 O (`n`) 作業，其中`n`是中的項目數`d`參數。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/a92f83be-9de4-470a-8cbb-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/a92f83be-9de4-470a-8cbb-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/a92f83be-9de4-470a-8cbb-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>要複製到新物件<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "從 0.1 到 1.0 之間，提供最佳效能的預設值會乘以範圍之數字。 結果是雜湊桶項的最大比例。"
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>物件，定義要使用的雜湊碼提供者和比較子<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IEqualityComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>使用預設雜湊碼提供者和預設比較子。 預設雜湊碼提供者是每個索引鍵實作&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;和預設比較子是每個索引鍵實作&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>小於 0.1。       -或-<code>loadFactor</code>大於 1.0。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化新的空白執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>類別使用指定的初始容量、 雜湊碼提供者、 比較子，以及預設載入因數。"
  remarks: "指定的初始容量，就不需要執行數個調整大小作業時新增元素至<xref:System.Collections.Hashtable>物件。</xref:System.Collections.Hashtable> 容量會自動視需要增加的負載因數為基礎。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       雜湊碼提供者在該<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的索引鍵的雜湊程式碼 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       自訂的雜湊碼提供者和自訂比較子以啟用案例，例如執行不區分大小寫字串的查閱。       這個建構函式為 O (`n`) 作業，其中`n`是`capacity`參數。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/cpp/2154dba0-3cc6-41f7-aa9b-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/csharp/2154dba0-3cc6-41f7-aa9b-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorInt#1](~/add/codesnippet/visualbasic/2154dba0-3cc6-41f7-aa9b-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "大約項目數， <xref href=&quot;System.Collections.Hashtable&quot;> </xref>一開始可包含物件。"
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref>物件，提供雜湊碼的所有索引鍵中<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>使用預設雜湊碼提供者，這是每個索引鍵實作&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;。"
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>物件用來判斷兩個索引鍵是否相等。</xref:System.Collections.IComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>表示使用預設比較子，這是每個索引鍵實作&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小於零。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  id: '#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化新的空白執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>類別使用指定的初始容量，負載因數和<xref:System.Collections.IEqualityComparer>物件。</xref:System.Collections.IEqualityComparer>"
  remarks: "指定的初始容量，就不需要執行數個調整大小作業時新增元素至<xref:System.Collections.Hashtable>物件。</xref:System.Collections.Hashtable> 容量會自動視需要增加的負載因數為基礎。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。 1.0 的負載因數是速度及大小最佳平衡。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       <xref:System.Collections.IEqualityComparer>物件包含雜湊碼提供者和比較子。</xref:System.Collections.IEqualityComparer> 如果<xref:System.Collections.IEqualityComparer>用於<xref:System.Collections.Hashtable>建構函式、 物件做為索引鍵中<xref:System.Collections.Hashtable>不需要覆寫<xref:System.Object.GetHashCode%2A?displayProperty=fullName>和<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       雜湊碼提供者在該<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的索引鍵的雜湊程式碼 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       <xref:System.Collections.IEqualityComparer>可案例，例如執行不區分大小寫字串的查閱。</xref:System.Collections.IEqualityComparer>       這個建構函式為 O (`n`) 作業，其中`n`是`capacity`參數。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/30b60c47-7bce-44a2-8d17-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/30b60c47-7bce-44a2-8d17-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/30b60c47-7bce-44a2-8d17-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "大約項目數， <xref href=&quot;System.Collections.Hashtable&quot;> </xref>一開始可包含物件。"
    - id: loadFactor
      type: System.Single
      description: "從 0.1 到 1.0 之間，提供最佳效能的預設值會乘以範圍之數字。 結果是雜湊桶項的最大比例。"
    - id: equalityComparer
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>物件，定義要使用的雜湊碼提供者和比較子<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IEqualityComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>使用預設雜湊碼提供者和預設比較子。 預設雜湊碼提供者是每個索引鍵實作&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;和預設比較子是每個索引鍵實作&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小於零。       -或-<code>loadFactor</code>小於 0.1。       -或-<code>loadFactor</code>大於 1.0。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>指定字典中的項目複製到新的類別<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。 新<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件具有相等的項目數複製，初始容量，並使用指定的負載因數、 雜湊碼提供者和比較子。"
  remarks: "初始容量設定為來源字典中的項目數。 容量會自動視需要增加的負載因數為基礎。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。 1.0 的負載因數是速度及大小最佳平衡。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       雜湊碼提供者在該雜湊程式碼中的索引鍵<xref:System.Collections.Hashtable>物件。</xref:System.Collections.Hashtable> 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       自訂的雜湊碼提供者和自訂比較子以啟用案例，例如執行不區分大小寫字串的查閱。       新的項目<xref:System.Collections.Hashtable>都會依照相同的順序，以列舉值逐一<xref:System.Collections.IDictionary>物件。</xref:System.Collections.IDictionary> </xref:System.Collections.Hashtable>       這個建構函式為 O (`n`) 作業，其中`n`是中的項目數`d`參數。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cs[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/csharp/c67b166f-bc6a-49e5-9bd7-_1.cs)]\n [!code-cpp[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/cpp/c67b166f-bc6a-49e5-9bd7-_1.cpp)]\n [!code-vb[System.Collections.Hashtable_ctorDictionaryFloat#1](~/add/codesnippet/visualbasic/c67b166f-bc6a-49e5-9bd7-_1.vb)]"
  syntax:
    content: public Hashtable (System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: d
      type: System.Collections.IDictionary
      description: "<xref:System.Collections.IDictionary>要複製到新物件<xref href=&quot;System.Collections.Hashtable&quot;></xref>物件。</xref:System.Collections.IDictionary>"
    - id: loadFactor
      type: System.Single
      description: "從 0.1 到 1.0 之間，提供最佳效能的預設值會乘以範圍之數字。 結果是雜湊桶項的最大比例。"
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref>物件，提供雜湊碼的所有索引鍵中<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>使用預設雜湊碼提供者，這是每個索引鍵實作&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;。"
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>物件用來判斷兩個索引鍵是否相等。</xref:System.Collections.IComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>表示使用預設比較子，這是每個索引鍵實作&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>d</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>loadFactor</code>小於 0.1。       -或-<code>loadFactor</code>大於 1.0。"
  platform:
  - net462
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  id: '#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)'
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化新的空白執行個體<xref href=&quot;System.Collections.Hashtable&quot;></xref>類別使用指定的初始容量，載入因數、 雜湊碼提供者和比較子。"
  remarks: "指定的初始容量，就不需要執行數個調整大小作業時新增元素至<xref:System.Collections.Hashtable>物件。</xref:System.Collections.Hashtable> 容量會自動視需要增加的負載因數為基礎。       載入因數是雜湊桶項的最大比例。 較小的負載因數表示代價是會增加的記憶體耗用量的查閱速度較快。 1.0 的負載因數是速度及大小最佳平衡。       當實際的負載因數會到達指定的負載因數時，bucket 的數目會自動增加到大於兩次目前的 bucket 數目最小質數。       雜湊碼提供者在該<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的索引鍵的雜湊程式碼 預設雜湊碼提供者是<xref:System.Object.GetHashCode%2A?displayProperty=fullName>.</xref:System.Object.GetHashCode%2A?displayProperty=fullName>機碼的實作       比較子判斷兩個索引鍵是否相等。 在每個索引鍵<xref:System.Collections.Hashtable>必須是唯一的。</xref:System.Collections.Hashtable> 預設比較子是<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>索引鍵的實作       自訂的雜湊碼提供者和自訂比較子以啟用案例，例如執行不區分大小寫字串的查閱。       這個建構函式為 O (`n`) 作業，其中`n`是`capacity`參數。"
  example:
  - "The following code example creates hash tables using different <xref:System.Collections.Hashtable> constructors and demonstrates the differences in the behavior of the hash tables, even if each one contains the same elements.  \n  \n [!code-cpp[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/cpp/86ed2545-c9ee-4654-a1a4-_1.cpp)]\n [!code-cs[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/csharp/86ed2545-c9ee-4654-a1a4-_1.cs)]\n [!code-vb[System.Collections.Hashtable_ctorIntFloat#1](~/add/codesnippet/visualbasic/86ed2545-c9ee-4654-a1a4-_1.vb)]"
  syntax:
    content: public Hashtable (int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
    parameters:
    - id: capacity
      type: System.Int32
      description: "大約項目數， <xref href=&quot;System.Collections.Hashtable&quot;> </xref>一開始可包含物件。"
    - id: loadFactor
      type: System.Single
      description: "從 0.1 到 1.0 之間，提供最佳效能的預設值會乘以範圍之數字。 結果是雜湊桶項的最大比例。"
    - id: hcp
      type: System.Collections.IHashCodeProvider
      description: "<xref href=&quot;System.Collections.IHashCodeProvider&quot;> </xref>物件，提供雜湊碼的所有索引鍵中<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>使用預設雜湊碼提供者，這是每個索引鍵實作&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;。"
    - id: comparer
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>物件用來判斷兩個索引鍵是否相等。</xref:System.Collections.IComparer>       - <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>表示使用預設比較子，這是每個索引鍵實作&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;。"
  overload: System.Collections.Hashtable.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小於零。       -或-<code>loadFactor</code>小於 0.1。       -或-<code>loadFactor</code>大於 1.0。"
  platform:
  - net462
- uid: System.Collections.Hashtable.Add(System.Object,System.Object)
  id: Add(System.Object,System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Add(Object,Object)
  nameWithType: Hashtable.Add(Object,Object)
  fullName: System.Collections.Hashtable.Add(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "將具有指定之索引鍵和值的項目<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "金鑰不能`null`，但是值可以是。       具有其狀態和其雜湊碼值之間沒有關聯的物件通常不應做為索引鍵。 例如，字串物件做為索引鍵是優於使用 StringBuilder 物件。       您也可以使用<xref:System.Collections.Hashtable.Item%2A>加入新項目，藉由設定機碼值的屬性不存在於<xref:System.Collections.Hashtable>; 例如， `myCollection[&quot;myNonexistentKey&quot;] = myValue`。</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable.Item%2A> 不過，如果指定的索引鍵已存在於<xref:System.Collections.Hashtable>，設定<xref:System.Collections.Hashtable.Item%2A>屬性會覆寫舊的值。</xref:System.Collections.Hashtable.Item%2A> </xref:System.Collections.Hashtable> 相反地，加入方法不會修改現有的項目。       如果<xref:System.Collections.Hashtable.Count%2A>的容量小於<xref:System.Collections.Hashtable>，這個方法是 o （1） 運算。</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable.Count%2A> 如果需要增加，以容納新項目容量，這個方法會變成 O (`n`) 作業，其中`n`為<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Add Example#1](~/add/codesnippet/cpp/m-system.collections.has_6_1.cpp)]\n [!code-cs[Classic Hashtable.Add Example#1](~/add/codesnippet/csharp/m-system.collections.has_6_1.cs)]\n [!code-vb[Classic Hashtable.Add Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_6_1.vb)]"
  syntax:
    content: public virtual void Add (object key, object value);
    parameters:
    - id: key
      type: System.Object
      description: "若要加入的項目索引鍵。"
    - id: value
      type: System.Object
      description: "要加入之元素的值。 這個值可以是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Hashtable.Add*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "具有相同索引鍵的項目已經存在於<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref>處於唯讀狀態。       -或- <xref href=&quot;System.Collections.Hashtable&quot;> </xref>有固定的大小。"
  platform:
  - net462
- uid: System.Collections.Hashtable.Clear
  id: Clear
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Clear()
  nameWithType: Hashtable.Clear()
  fullName: System.Collections.Hashtable.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "移除所有項目從<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "<xref:System.Collections.Hashtable.Count%2A>已設為零，並從項目集合的其他物件的參考也會釋放。</xref:System.Collections.Hashtable.Count%2A> 容量會維持不變。       這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.has_10_1.cpp)]\n [!code-vb[Classic Hashtable.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_10_1.vb)]\n [!code-cs[Classic Hashtable.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.has_10_1.cs)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Hashtable.Clear*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref>處於唯讀狀態。"
  platform:
  - net462
- uid: System.Collections.Hashtable.Clone
  id: Clone
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Clone()
  nameWithType: Hashtable.Clone()
  fullName: System.Collections.Hashtable.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "建立的淺層複本<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "集合的淺層複本只會複製元素的集合，不論它們是參考類型或實值類型，但是不會複製參考所參考的物件。 新的集合中的參考都指向相同原始集合中的參考所指向的物件。       相反地，項目複製集合的深層複本，並直接或間接參考之項目，所有項目。       <xref:System.Collections.Hashtable>複製具有相同的計數，相同的容量，相同的<xref:System.Collections.IHashCodeProvider>實作，並<xref:System.Collections.IComparer>與原始<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>實作</xref:System.Collections.IComparer>相同的</xref:System.Collections.IHashCodeProvider></xref:System.Collections.Hashtable>       這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "淺層複本<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  overload: System.Collections.Hashtable.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.comparer
  id: comparer
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: comparer
  nameWithType: Hashtable.comparer
  fullName: System.Collections.Hashtable.comparer
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得或設定<xref:System.Collections.IComparer>用於<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IComparer>"
  remarks: "擷取這個屬性的值是一種 o （1） 運算。"
  syntax:
    content: protected System.Collections.IComparer comparer { get; set; }
    return:
      type: System.Collections.IComparer
      description: "<xref:System.Collections.IComparer>用於<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IComparer>"
  overload: System.Collections.Hashtable.comparer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "屬性設定為值，但使用<xref:System.Collections.IEqualityComparer>.</xref:System.Collections.IEqualityComparer>建立雜湊資料表"
  platform:
  - net462
- uid: System.Collections.Hashtable.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Hashtable.Contains(Object)
  fullName: System.Collections.Hashtable.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "決定是否<xref href=&quot;System.Collections.Hashtable&quot;></xref>包含特定索引鍵。"
  remarks: "包含實作<xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName>.</xref:System.Collections.IDictionary.Contains%2A?displayProperty=fullName> 它的行為就像<xref:System.Collections.Hashtable.ContainsKey%2A>.</xref:System.Collections.Hashtable.ContainsKey%2A>       這個方法是一種 o （1） 運算。       從.NET Framework 2.0 開始，這個方法會使用集合的物件<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`來判斷項目是否存在。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在舊版的.NET Framework 中，藉由進行這項判斷<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`上集合中物件的參數。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_12_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_12_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_12_1.vb)]"
  syntax:
    content: public virtual bool Contains (object key);
    parameters:
    - id: key
      type: System.Object
      description: "要在中尋找的索引鍵<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Collections.Hashtable&quot;></xref>包含具有指定的項目索引鍵，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Hashtable.Contains*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.ContainsKey(System.Object)
  id: ContainsKey(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: ContainsKey(Object)
  nameWithType: Hashtable.ContainsKey(Object)
  fullName: System.Collections.Hashtable.ContainsKey(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "決定是否<xref href=&quot;System.Collections.Hashtable&quot;></xref>包含特定索引鍵。"
  remarks: "這個方法的行為就像<xref:System.Collections.Hashtable.Contains%2A>.</xref:System.Collections.Hashtable.Contains%2A>       這個方法是一種 o （1） 運算。       從.NET Framework 2.0 開始，這個方法會使用集合的物件<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`來判斷項目是否存在。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在舊版的.NET Framework 中，藉由進行這項判斷<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`上集合中物件的參數。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_7_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_7_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_7_1.vb)]"
  syntax:
    content: public virtual bool ContainsKey (object key);
    parameters:
    - id: key
      type: System.Object
      description: "要在中尋找的索引鍵<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Collections.Hashtable&quot;></xref>包含具有指定的項目索引鍵，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Hashtable.ContainsKey*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.ContainsValue(System.Object)
  id: ContainsValue(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: ContainsValue(Object)
  nameWithType: Hashtable.ContainsValue(Object)
  fullName: System.Collections.Hashtable.ContainsValue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "決定是否<xref href=&quot;System.Collections.Hashtable&quot;></xref>包含特定值。"
  remarks: "項目的值<xref:System.Collections.Hashtable>與指定的值使用<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Collections.Hashtable>       這個方法會執行線性搜尋;因此，這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>       從.NET Framework 2.0 開始，這個方法會使用集合的物件<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`來判斷項目是否存在。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在舊版的.NET Framework 中，藉由進行這項判斷<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`item`上集合中物件的參數。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  example:
  - "The following example shows how to determine whether the <xref:System.Collections.Hashtable> contains a specific element.  \n  \n [!code-cpp[Classic Hashtable.Contains Example#1](~/add/codesnippet/cpp/m-system.collections.has_9_1.cpp)]\n [!code-cs[Classic Hashtable.Contains Example#1](~/add/codesnippet/csharp/m-system.collections.has_9_1.cs)]\n [!code-vb[Classic Hashtable.Contains Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_9_1.vb)]"
  syntax:
    content: public virtual bool ContainsValue (object value);
    parameters:
    - id: value
      type: System.Object
      description: "要在中尋找值<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。 這個值可以是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Collections.Hashtable&quot;></xref>包含具有指定的項目<code> value </code>，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Hashtable.ContainsValue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Hashtable.CopyTo(Array,Int32)
  fullName: System.Collections.Hashtable.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "複製<xref href=&quot;System.Collections.Hashtable&quot;></xref>到一維的元素<xref:System.Array>指定索引處的執行個體。</xref:System.Array>"
  remarks: "項目複製至<xref:System.Array>列舉值逐一<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>所在的相同順序</xref:System.Array>       若要複製中的索引鍵<xref:System.Collections.Hashtable>，使用`Hashtable.Keys.CopyTo`。</xref:System.Collections.Hashtable>       若要複製的值中<xref:System.Collections.Hashtable>，使用`Hashtable.Values.CopyTo`。</xref:System.Collections.Hashtable>       這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>"
  example:
  - "The following example shows how to copy the list of keys or the list of values in a <xref:System.Collections.Hashtable> into a one-dimensional <xref:System.Array>.  \n  \n [!code-cs[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.has_0_1.cs)]\n [!code-vb[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_0_1.vb)]\n [!code-cpp[Classic Hashtable.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.has_0_1.cpp)]"
  syntax:
    content: public virtual void CopyTo (Array array, int arrayIndex);
    parameters:
    - id: array
      type: System.Array
      description: "一維<xref:System.Array>也就是目的<xref:System.Collections.DictionaryEntry>從複製物件<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.DictionaryEntry> </xref:System.Array> <xref:System.Array>必須有以零為起始的索引。</xref:System.Array>"
    - id: arrayIndex
      type: System.Int32
      description: "中以零為起始的索引`array`由此開始複製。"
  overload: System.Collections.Hashtable.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>arrayIndex</code>小於零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>是多維的。       -在來源中的項目數<xref href=&quot;System.Collections.Hashtable&quot;></xref>大於可用空間<code>arrayIndex</code>至目的地結尾<code>array</code>。"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "來源類型<xref href=&quot;System.Collections.Hashtable&quot;></xref>無法自動轉換成目的地類型<code> array </code>。"
  platform:
  - net462
- uid: System.Collections.Hashtable.Count
  id: Count
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Count
  nameWithType: Hashtable.Count
  fullName: System.Collections.Hashtable.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得中所包含的索引鍵/值組數目<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "擷取這個屬性的值是一種 o （1） 運算。"
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "中所包含的索引鍵/值組數目<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  overload: System.Collections.Hashtable.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.EqualityComparer
  id: EqualityComparer
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
  fullName: System.Collections.Hashtable.EqualityComparer
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得<xref:System.Collections.IEqualityComparer>用於<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IEqualityComparer>"
  remarks: "<xref:System.Collections.IEqualityComparer>包含的比較子和雜湊碼提供者。</xref:System.Collections.IEqualityComparer> 如果<xref:System.Collections.IEqualityComparer>用於<xref:System.Collections.Hashtable>建構函式、 物件做為索引鍵中<xref:System.Collections.Hashtable>不需要覆寫<xref:System.Object.GetHashCode%2A?displayProperty=fullName>和<xref:System.Object.Equals%2A?displayProperty=fullName>方法。</xref:System.Object.Equals%2A?displayProperty=fullName> </xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> </xref:System.Collections.IEqualityComparer>       擷取這個屬性的值是一種 o （1） 運算。"
  syntax:
    content: protected System.Collections.IEqualityComparer EqualityComparer { get; }
    return:
      type: System.Collections.IEqualityComparer
      description: "<xref:System.Collections.IEqualityComparer>用於<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IEqualityComparer>"
  overload: System.Collections.Hashtable.EqualityComparer*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "屬性設定為值，但雜湊資料表建立使用<xref href=&quot;System.Collections.IHashCodeProvider&quot;></xref>和<xref:System.Collections.IComparer>。</xref:System.Collections.IComparer>"
  platform:
  - net462
- uid: System.Collections.Hashtable.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Hashtable.GetEnumerator()
  fullName: System.Collections.Hashtable.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "傳回<xref:System.Collections.IDictionaryEnumerator>逐一<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.IDictionaryEnumerator>"
  remarks: "[Visual Basic、 C#]      `foreach` C# 語言的陳述式 (`for each`在 Visual Basic 中) 會隱藏列舉值的複雜度。  因此，使用`foreach`建議，而不是直接管理 列舉值。       列舉程式可以用來讀取集合中的資料，但無法用於修改基礎集合。       一開始，列舉程式位在集合中的第一個項目之前。 <xref:System.Collections.IEnumerator.Reset%2A>也會列舉值帶回至這個位置。</xref:System.Collections.IEnumerator.Reset%2A>  此位置<xref:System.Collections.IEnumerator.Current%2A>是未定義。</xref:System.Collections.IEnumerator.Current%2A> 因此，您必須呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>前進的第一個元素之前讀取<xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A>值集合的列舉值</xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>會傳回相同的物件直到<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>稱為。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>設定<xref:System.Collections.IEnumerator.Current%2A>下一個項目。</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       如果<xref:System.Collections.IEnumerator.MoveNext%2A>超過集合的列舉值的結尾會位於集合中的最後一個元素之後和<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 列舉值位於這個位置上，後續呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>也會傳回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> 如果最後一個呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`，<xref:System.Collections.IEnumerator.Current%2A>是未定義。</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 若要設定<xref:System.Collections.IEnumerator.Current%2A>的第一個元素的集合，您可以呼叫<xref:System.Collections.IEnumerator.Reset%2A>後面加上<xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       只要集合維持不變，列舉程式就持續有效。 如果對集合進行變更，例如加入、 修改或刪除元素，列舉程式會永久失效，且其行為未定義。       列舉程式沒有集合的獨佔存取因此，列舉集合在本質上並非安全執行緒的程序。  若要保證列舉過程的執行緒安全，您可以鎖定在整個列舉過程的集合。  若要讓集合以便進行讀取和寫入的多重執行緒能夠存取，您必須實作自己的同步處理。       這個方法是一種 o （1） 運算。       因為序列化和還原序列化的列舉值<xref:System.Collections.Hashtable>可能會導致變成重新排列項目，就不可能繼續列舉型別，而不需呼叫<xref:System.Collections.IEnumerator.Reset%2A>方法。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  example:
  - "The following example compares the use of GetEnumerator and `foreach` to enumerate the contents of a <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable Example#2](~/add/codesnippet/cpp/m-system.collections.has_3_1.cpp)]\n [!code-cs[Classic Hashtable Example#2](~/add/codesnippet/csharp/m-system.collections.has_3_1.cs)]\n [!code-vb[Classic Hashtable Example#2](~/add/codesnippet/visualbasic/m-system.collections.has_3_1.vb)]"
  syntax:
    content: public virtual System.Collections.IDictionaryEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IDictionaryEnumerator
      description: "An <xref:System.Collections.IDictionaryEnumerator> for the <xref href=&quot;System.Collections.Hashtable&quot;></xref>.</xref:System.Collections.IDictionaryEnumerator>"
  overload: System.Collections.Hashtable.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.GetHash(System.Object)
  id: GetHash(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetHash(Object)
  nameWithType: Hashtable.GetHash(Object)
  fullName: System.Collections.Hashtable.GetHash(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "傳回指定之索引鍵的雜湊碼。"
  remarks: "如果雜湊表已建立具有特定<xref:System.Collections.IHashCodeProvider>實作，這個方法會使用該雜湊碼提供者; 否則它會使用<xref:System.Object.GetHashCode%2A?displayProperty=fullName>實作`key`。</xref:System.Object.GetHashCode%2A?displayProperty=fullName> </xref:System.Collections.IHashCodeProvider>       這個方法是一種 o （1） 運算。"
  syntax:
    content: protected virtual int GetHash (object key);
    parameters:
    - id: key
      type: System.Object
      description: "<xref:System.Object>雜湊程式碼是要傳回。</xref:System.Object>"
    return:
      type: System.Int32
      description: "雜湊碼<code> key </code>。"
  overload: System.Collections.Hashtable.GetHash*
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  id: GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "實作<xref href=&quot;System.Runtime.Serialization.ISerializable&quot;></xref>介面，並傳回序列化所需的資料<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>"
  syntax:
    content: public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    parameters:
    - id: info
      type: System.Runtime.Serialization.SerializationInfo
      description: "A <xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>物件，其中包含要序列化所需的資訊<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
    - id: context
      type: System.Runtime.Serialization.StreamingContext
      description: "A<xref:System.Runtime.Serialization.StreamingContext>物件，其中包含來源和目的地相關聯之序列化資料流<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Runtime.Serialization.StreamingContext>"
  overload: System.Collections.Hashtable.GetObjectData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>info</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "集合已修改。"
  platform:
  - net462
- uid: System.Collections.Hashtable.hcp
  id: hcp
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: hcp
  nameWithType: Hashtable.hcp
  fullName: System.Collections.Hashtable.hcp
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得或設定可以分配雜湊程式碼的物件。"
  remarks: "擷取這個屬性的值是一種 o （1） 運算。"
  syntax:
    content: protected System.Collections.IHashCodeProvider hcp { get; set; }
    return:
      type: System.Collections.IHashCodeProvider
      description: "物件，其可以分配雜湊碼。"
  overload: System.Collections.Hashtable.hcp*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "屬性設定為值，但使用<xref:System.Collections.IEqualityComparer>.</xref:System.Collections.IEqualityComparer>建立雜湊資料表"
  platform:
  - net462
- uid: System.Collections.Hashtable.IsFixedSize
  id: IsFixedSize
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
  fullName: System.Collections.Hashtable.IsFixedSize
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得值，指出是否<xref href=&quot;System.Collections.Hashtable&quot;></xref>有固定的大小。"
  remarks: "具有固定大小的集合不允許在集合建立後，但允許修改現有的項目後新增或移除項目。       具有固定大小的集合是唯讀的集合只以防止新增或移除項目; 包裝函式因此，如果變更基礎的集合，包括新增或移除項目，固定大小的集合會反映這些變更。       擷取這個屬性的值是一種 o （1） 運算。"
  syntax:
    content: public virtual bool IsFixedSize { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Collections.Hashtable&quot;></xref>有固定大小，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Hashtable.IsFixedSize*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.IsReadOnly
  id: IsReadOnly
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
  fullName: System.Collections.Hashtable.IsReadOnly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得值，指出是否<xref href=&quot;System.Collections.Hashtable&quot;></xref>處於唯讀狀態。"
  remarks: "是唯讀的集合不允許在集合建立後增加、 移除或修改項目。       是唯讀的集合是唯讀的集合只具有可防止修改集合的包裝函式因此，如果基礎集合進行變更，唯讀的集合會反映這些變更。       擷取這個屬性的值是一種 o （1） 運算。"
  syntax:
    content: public virtual bool IsReadOnly { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Collections.Hashtable&quot;></xref>是唯讀，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Hashtable.IsReadOnly*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
  fullName: System.Collections.Hashtable.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得值，指出是否存取<xref href=&quot;System.Collections.Hashtable&quot;></xref>是同步 （安全執行緒）。"
  remarks: "A<xref:System.Collections.Hashtable>可以同時支援一個寫入器與多個讀取器。</xref:System.Collections.Hashtable> 若要支援多個寫入器，所有作業必須都透過包裝函式所傳回<xref:System.Collections.Hashtable.Synchronized%2A>方法。</xref:System.Collections.Hashtable.Synchronized%2A>       透過集合進行列舉在本質上並不是執行緒安全的程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。       下列程式碼範例示範如何鎖定集合使用<xref:System.Collections.Hashtable.SyncRoot%2A>在整個列舉過程︰ [!code-cpp[傳統 Hashtable.IsSynchronized 範例&#2;](~/add/codesnippet/cpp/p-system.collections.has_1_1.cpp)][!code-vb[傳統 Hashtable.IsSynchronized 範例&#2;](~/add/codesnippet/visualbasic/p-system.collections.has_1_1.vb)][!code-cs[傳統 Hashtable.IsSynchronized 範例&#2;](~/add/codesnippet/csharp/p-system.collections.has_1_1.cs) ]     </xref:System.Collections.Hashtable.SyncRoot%2A>"
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Hashtable>, determine if a <xref:System.Collections.Hashtable> is synchronized, and use a synchronized <xref:System.Collections.Hashtable>.  \n  \n [!code-cs[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.has_1_2.cs)]\n [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.has_1_2.cpp)]\n [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.has_1_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果存取<xref href=&quot;System.Collections.Hashtable&quot;></xref>是同步 （安全執行緒），否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Hashtable.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.Item(System.Object)
  id: Item(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Item(Object)
  nameWithType: Hashtable.Item(Object)
  fullName: System.Collections.Hashtable.Item(Object)
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得或設定與指定之索引鍵相關聯的值。"
  remarks: "這個屬性會提供可以使用下列語法存取集合中的特定元素的能力︰ `myCollection[key]`。       您也可以使用此項目屬性來加入新項目中不存在的索引鍵的值設定<xref:System.Collections.Hashtable>; 例如， `myCollection[&quot;myNonexistentKey&quot;] = myValue`。</xref:System.Collections.Hashtable> 不過，如果指定的索引鍵已存在於<xref:System.Collections.Hashtable>，項目屬性設定會覆寫舊的值。</xref:System.Collections.Hashtable> 相反地，<xref:System.Collections.Hashtable.Add%2A>方法不會修改現有的項目。</xref:System.Collections.Hashtable.Add%2A>       金鑰不能`null`，但是值可以是。 若要在區別`null`傳回因為找不到指定的索引鍵和`null`傳回指定之索引鍵的值，所以`null`，使用<xref:System.Collections.Hashtable.Contains%2A>方法或<xref:System.Collections.Hashtable.ContainsKey%2A>方法來判斷是否索引鍵存在於清單中。</xref:System.Collections.Hashtable.ContainsKey%2A> </xref:System.Collections.Hashtable.Contains%2A>       擷取這個屬性的值是 o （1） 運算。設定屬性，也是一種 o （1） 運算。       C# 語言使用關鍵字來定義索引，而不必實作<xref:System.Collections.IList.Item%2A>屬性。</xref:System.Collections.IList.Item%2A> Visual Basic 實作項目作為預設屬性，提供相同的索引功能。"
  syntax:
    content: public virtual object this[object key] { get; set; }
    parameters:
    - id: key
      type: System.Object
      description: "索引鍵來取得或設定其值。"
    return:
      type: System.Object
      description: "具有指定索引鍵相關聯的值。 如果找不到指定的索引鍵，嘗試取得它傳回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，並嘗試將它設定建立使用指定的索引鍵的新項目。"
  overload: System.Collections.Hashtable.Item*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "此屬性設定和<xref href=&quot;System.Collections.Hashtable&quot;></xref>處於唯讀狀態。       -或-此屬性設定， <code> key </code>不存在於集合中，而<xref href=&quot;System.Collections.Hashtable&quot;></xref>有固定的大小。"
  platform:
  - net462
- uid: System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  id: KeyEquals(System.Object,System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: KeyEquals(Object,Object)
  nameWithType: Hashtable.KeyEquals(Object,Object)
  fullName: System.Collections.Hashtable.KeyEquals(Object,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "比較特定<xref:System.Object>中指定的索引鍵<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Object>"
  remarks: "如果雜湊表已建立具有特定<xref:System.Collections.IComparer>實作中，這個方法會使用該比較子; 也就是說， <xref:System.Collections.IComparer.Compare%2A>(`item`， `key`)。</xref:System.Collections.IComparer.Compare%2A> </xref:System.Collections.IComparer> 否則，它會使用`item.Equals(key)`。       這個方法是一種 o （1） 運算。"
  syntax:
    content: protected virtual bool KeyEquals (object item, object key);
    parameters:
    - id: item
      type: System.Object
      description: "<xref:System.Object>要與比較`key`。</xref:System.Object>"
    - id: key
      type: System.Object
      description: "中的索引鍵<xref href=&quot;System.Collections.Hashtable&quot;></xref>要與比較`item`。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>item</code> and <code>key</code> are equal; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Hashtable.KeyEquals*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>item</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>key</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.Keys
  id: Keys
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Keys
  nameWithType: Hashtable.Keys
  fullName: System.Collections.Hashtable.Keys
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得<xref:System.Collections.ICollection>包含中的索引鍵<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.ICollection>"
  remarks: "中的索引鍵的順序<xref:System.Collections.ICollection>並未指定，但它是關聯值中的相同順序<xref:System.Collections.ICollection>傳回<xref:System.Collections.Hashtable.Values%2A>方法。</xref:System.Collections.Hashtable.Values%2A> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection>       傳回<xref:System.Collections.ICollection>不是靜態的複本; 相反地，<xref:System.Collections.ICollection>是指回原始<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中索引鍵</xref:System.Collections.ICollection>的</xref:System.Collections.ICollection> 因此，變更<xref:System.Collections.Hashtable>才會反映在<xref:System.Collections.ICollection>.</xref:System.Collections.ICollection>繼續</xref:System.Collections.Hashtable>       擷取這個屬性的值是一種 o （1） 運算。"
  syntax:
    content: public virtual System.Collections.ICollection Keys { get; }
    return:
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>包含中的索引鍵<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.ICollection>"
  overload: System.Collections.Hashtable.Keys*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.OnDeserialization(System.Object)
  id: OnDeserialization(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: OnDeserialization(Object)
  nameWithType: Hashtable.OnDeserialization(Object)
  fullName: System.Collections.Hashtable.OnDeserialization(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "實作<xref href=&quot;System.Runtime.Serialization.ISerializable&quot;></xref>介面，並引發還原序列化完成時，還原序列化事件。"
  remarks: "這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Hashtable.Count%2A>。</xref:System.Collections.Hashtable.Count%2A>       因為序列化和還原序列化的列舉值<xref:System.Collections.Hashtable>可能會導致變成重新排列項目，就不可能繼續列舉型別，而不需呼叫<xref:System.Collections.IEnumerator.Reset%2A>方法。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.Hashtable>"
  syntax:
    content: public virtual void OnDeserialization (object sender);
    parameters:
    - id: sender
      type: System.Object
      description: "還原序列化事件的來源。"
  overload: System.Collections.Hashtable.OnDeserialization*
  exceptions:
  - type: System.Runtime.Serialization.SerializationException
    commentId: T:System.Runtime.Serialization.SerializationException
    description: "<xref href=&quot;System.Runtime.Serialization.SerializationInfo&quot;> </xref>目前相關聯的物件<xref href=&quot;System.Collections.Hashtable&quot;></xref>無效。"
  platform:
  - net462
- uid: System.Collections.Hashtable.Remove(System.Object)
  id: Remove(System.Object)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Remove(Object)
  nameWithType: Hashtable.Remove(Object)
  fullName: System.Collections.Hashtable.Remove(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "移除具有指定之索引鍵的項目<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "如果<xref:System.Collections.Hashtable>不包含具有指定之索引鍵項目<xref:System.Collections.Hashtable>維持不變。</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> 擲不回任何例外狀況。       這個方法是一種 o （1） 運算。"
  example:
  - "The following example shows how to remove elements from the <xref:System.Collections.Hashtable>.  \n  \n [!code-cpp[Classic Hashtable.Remove Example#1](~/add/codesnippet/cpp/m-system.collections.has_13_1.cpp)]\n [!code-cs[Classic Hashtable.Remove Example#1](~/add/codesnippet/csharp/m-system.collections.has_13_1.cs)]\n [!code-vb[Classic Hashtable.Remove Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_13_1.vb)]"
  syntax:
    content: public virtual void Remove (object key);
    parameters:
    - id: key
      type: System.Object
      description: "要移除之項目的索引鍵。"
  overload: System.Collections.Hashtable.Remove*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>key</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref>處於唯讀狀態。       -或- <xref href=&quot;System.Collections.Hashtable&quot;> </xref>有固定的大小。"
  platform:
  - net462
- uid: System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  id: Synchronized(System.Collections.Hashtable)
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Synchronized(Hashtable)
  nameWithType: Hashtable.Synchronized(Hashtable)
  fullName: System.Collections.Hashtable.Synchronized(Hashtable)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "傳回同步 （安全執行緒） 包裝函式<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "已同步處理方法具備執行緒安全之多個讀取器和寫入器。 此外，可確保同步處理的包裝函式，會寫入一次只能有一個寫入器。       透過集合進行列舉在本質上並不是安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。       下列程式碼範例示範如何鎖定集合使用<xref:System.Collections.Hashtable.SyncRoot%2A>在整個列舉過程︰ [!code-cpp[傳統 Hashtable.IsSynchronized 範例&#2;](~/add/codesnippet/cpp/m-system.collections.has_11_1.cpp)][!code-vb[傳統 Hashtable.IsSynchronized 範例&#2;](~/add/codesnippet/visualbasic/m-system.collections.has_11_1.vb)][!code-cs[傳統 Hashtable.IsSynchronized 範例&#2;](~/add/codesnippet/csharp/m-system.collections.has_11_1.cs) ]這個方法是 o （1） 運算。    </xref:System.Collections.Hashtable.SyncRoot%2A>"
  example:
  - "The following example shows how to synchronize a <xref:System.Collections.Hashtable>, determine if a <xref:System.Collections.Hashtable> is synchronized, and use a synchronized <xref:System.Collections.Hashtable>.  \n  \n [!code-cs[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.has_11_2.cs)]\n [!code-cpp[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.has_11_2.cpp)]\n [!code-vb[Classic Hashtable.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.has_11_2.vb)]"
  syntax:
    content: public static System.Collections.Hashtable Synchronized (System.Collections.Hashtable table);
    parameters:
    - id: table
      type: System.Collections.Hashtable
      description: "<xref href=&quot;System.Collections.Hashtable&quot;> </xref>來同步處理。"
    return:
      type: System.Collections.Hashtable
      description: "同步處理 （安全執行緒） 包裝函式<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  overload: System.Collections.Hashtable.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>table</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Hashtable.SyncRoot
  id: SyncRoot
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
  fullName: System.Collections.Hashtable.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得物件，可用來同步處理存取具備<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  remarks: "若要建立的同步化的版本<xref:System.Collections.Hashtable>，使用<xref:System.Collections.Hashtable.Synchronized%2A>方法。</xref:System.Collections.Hashtable.Synchronized%2A> </xref:System.Collections.Hashtable> 不過，在衍生的類別可以提供自己的同步處理的版本<xref:System.Collections.Hashtable>使用 SyncRoot 屬性。</xref:System.Collections.Hashtable> 同步處理的程式碼必須在上執行作業的 SyncRoot <xref:System.Collections.Hashtable>，不是直接在<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable> </xref:System.Collections.Hashtable> 這可確保衍生自其他物件的集合正常運作。 具體而言，保持正常的同步處理與其他可能同時修改的執行緒<xref:System.Collections.Hashtable>物件。</xref:System.Collections.Hashtable>       透過集合進行列舉在本質上並不是執行緒安全的程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。       下列程式碼範例示範如何中鎖定集合，在整個列舉過程中使用 syncroot 同步︰ [!code-cpp[傳統 Hashtable.IsSynchronized 範例&#2;](~/add/codesnippet/cpp/p-system.collections.has_0_1.cpp)][!code-vb[傳統 Hashtable.IsSynchronized 範例&#2;](~/add/codesnippet/visualbasic/p-system.collections.has_0_1.vb)][!code-cs[傳統 Hashtable.IsSynchronized 範例&#2;    ](~/add/codesnippet/csharp/p-system.collections.has_0_1.cs)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "物件，可用來同步處理存取具備<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。"
  overload: System.Collections.Hashtable.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  id: System#Collections#IEnumerable#GetEnumerator
  isEii: true
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.Collections.Hashtable.System.Collections.IEnumerable.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "傳回逐一查看集合的列舉值。"
  remarks: "[Visual Basic、 C#]      `foreach` C# 語言的陳述式 (`for each`在 Visual Basic 中) 會隱藏列舉值的複雜度。  因此，使用`foreach`建議，而不是直接管理 列舉值。       列舉程式可以用來讀取集合中的資料，但無法用於修改基礎集合。       一開始，列舉程式位在集合中的第一個項目之前。 <xref:System.Collections.IEnumerator.Reset%2A>也會列舉值帶回至這個位置。</xref:System.Collections.IEnumerator.Reset%2A> 在這個位置上，呼叫<xref:System.Collections.IEnumerator.Current%2A>擲回例外狀況。</xref:System.Collections.IEnumerator.Current%2A> 因此，您必須呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>前進的第一個元素之前讀取<xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A>值集合的列舉值</xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>會傳回相同的物件直到<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>稱為。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>設定<xref:System.Collections.IEnumerator.Current%2A>下一個項目。</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       如果<xref:System.Collections.IEnumerator.MoveNext%2A>超過集合的列舉值的結尾會位於集合中的最後一個元素之後和<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 列舉值位於這個位置上，後續呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>也會傳回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> 如果最後一個呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`，則呼叫<xref:System.Collections.IEnumerator.Current%2A>擲回例外狀況。</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 若要設定<xref:System.Collections.IEnumerator.Current%2A>的第一個元素的集合，您可以呼叫<xref:System.Collections.IEnumerator.Reset%2A>後面加上<xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       只要集合維持不變，列舉程式就持續有效。 如果對集合進行變更，例如加入、 修改或刪除元素，列舉值無效，而且下一個呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>擲回<xref:System.InvalidOperationException>.</xref:System.InvalidOperationException> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 如果之間修改集合<xref:System.Collections.IEnumerator.MoveNext%2A>和<xref:System.Collections.IEnumerator.Current%2A>，<xref:System.Collections.IEnumerator.Current%2A>傳回項目所設定，即使列舉值已經無效。</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A>       列舉程式沒有集合的獨佔存取因此，列舉集合在本質上並非安全執行緒的程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。       這個方法是一種 o （1） 運算。"
  syntax:
    content: System.Collections.IEnumerator IEnumerable.GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "<xref:System.Collections.IEnumerator>，可用來逐一查看集合。</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Hashtable.Values
  id: Values
  parent: System.Collections.Hashtable
  langs:
  - csharp
  name: Values
  nameWithType: Hashtable.Values
  fullName: System.Collections.Hashtable.Values
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得<xref:System.Collections.ICollection>包含中的值<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.ICollection>"
  remarks: "中值的順序<xref:System.Collections.ICollection>並未指定，但它是關聯的索引鍵中的相同順序<xref:System.Collections.ICollection>傳回<xref:System.Collections.Hashtable.Keys%2A>方法。</xref:System.Collections.Hashtable.Keys%2A> </xref:System.Collections.ICollection> </xref:System.Collections.ICollection>       傳回<xref:System.Collections.ICollection>不是靜態的複本; 相反地，<xref:System.Collections.ICollection>原始<xref:System.Collections.Hashtable>.</xref:System.Collections.Hashtable>中的值是指回</xref:System.Collections.ICollection></xref:System.Collections.ICollection> 因此，變更<xref:System.Collections.Hashtable>才會反映在<xref:System.Collections.ICollection>.</xref:System.Collections.ICollection>繼續</xref:System.Collections.Hashtable>       擷取這個屬性的值是一種 o （1） 運算。"
  syntax:
    content: public virtual System.Collections.ICollection Values { get; }
    return:
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>包含中的值<xref href=&quot;System.Collections.Hashtable&quot;> </xref>。</xref:System.Collections.ICollection>"
  overload: System.Collections.Hashtable.Values*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Runtime.Serialization.SerializationException
  isExternal: true
  name: System.Runtime.Serialization.SerializationException
- uid: System.Collections.Hashtable.#ctor
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable()
  nameWithType: Hashtable.Hashtable()
  fullName: System.Collections.Hashtable.Hashtable()
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary)
  nameWithType: Hashtable.Hashtable(IDictionary)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary)
- uid: System.Collections.IDictionary
  parent: System.Collections
  isExternal: true
  name: IDictionary
  nameWithType: IDictionary
  fullName: System.Collections.IDictionary
- uid: System.Collections.Hashtable.#ctor(System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IEqualityComparer)
- uid: System.Collections.IEqualityComparer
  parent: System.Collections
  isExternal: true
  name: IEqualityComparer
  nameWithType: IEqualityComparer
  fullName: System.Collections.IEqualityComparer
- uid: System.Collections.Hashtable.#ctor(System.Int32)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32)
  nameWithType: Hashtable.Hashtable(Int32)
  fullName: System.Collections.Hashtable.Hashtable(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single)
  nameWithType: Hashtable.Hashtable(IDictionary,Single)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Hashtable.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IHashCodeProvider,IComparer)
- uid: System.Collections.IHashCodeProvider
  parent: System.Collections
  isExternal: false
  name: IHashCodeProvider
  nameWithType: IHashCodeProvider
  fullName: System.Collections.IHashCodeProvider
- uid: System.Collections.IComparer
  parent: System.Collections
  isExternal: true
  name: IComparer
  nameWithType: IComparer
  fullName: System.Collections.IComparer
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single)
  nameWithType: Hashtable.Hashtable(Int32,Single)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single)
- uid: System.Collections.Hashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.Hashtable(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.Hashtable(SerializationInfo,StreamingContext)
- uid: System.Runtime.Serialization.SerializationInfo
  parent: System.Runtime.Serialization
  isExternal: false
  name: SerializationInfo
  nameWithType: SerializationInfo
  fullName: System.Runtime.Serialization.SerializationInfo
- uid: System.Runtime.Serialization.StreamingContext
  parent: System.Runtime.Serialization
  isExternal: true
  name: StreamingContext
  nameWithType: StreamingContext
  fullName: System.Runtime.Serialization.StreamingContext
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single,IEqualityComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IEqualityComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IEqualityComparer)
- uid: System.Collections.Hashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(IDictionary,Single,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  nameWithType: Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
  fullName: System.Collections.Hashtable.Hashtable(Int32,Single,IHashCodeProvider,IComparer)
- uid: System.Collections.Hashtable.Add(System.Object,System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Add(Object,Object)
  nameWithType: Hashtable.Add(Object,Object)
  fullName: System.Collections.Hashtable.Add(Object,Object)
- uid: System.Collections.Hashtable.Clear
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clear()
  nameWithType: Hashtable.Clear()
  fullName: System.Collections.Hashtable.Clear()
- uid: System.Collections.Hashtable.Clone
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clone()
  nameWithType: Hashtable.Clone()
  fullName: System.Collections.Hashtable.Clone()
- uid: System.Collections.Hashtable.comparer
  parent: System.Collections.Hashtable
  isExternal: false
  name: comparer
  nameWithType: Hashtable.comparer
  fullName: System.Collections.Hashtable.comparer
- uid: System.Collections.Hashtable.Contains(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Contains(Object)
  nameWithType: Hashtable.Contains(Object)
  fullName: System.Collections.Hashtable.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Hashtable.ContainsKey(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsKey(Object)
  nameWithType: Hashtable.ContainsKey(Object)
  fullName: System.Collections.Hashtable.ContainsKey(Object)
- uid: System.Collections.Hashtable.ContainsValue(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsValue(Object)
  nameWithType: Hashtable.ContainsValue(Object)
  fullName: System.Collections.Hashtable.ContainsValue(Object)
- uid: System.Collections.Hashtable.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Hashtable
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Hashtable.CopyTo(Array,Int32)
  fullName: System.Collections.Hashtable.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Hashtable.Count
  parent: System.Collections.Hashtable
  isExternal: false
  name: Count
  nameWithType: Hashtable.Count
  fullName: System.Collections.Hashtable.Count
- uid: System.Collections.Hashtable.EqualityComparer
  parent: System.Collections.Hashtable
  isExternal: false
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
  fullName: System.Collections.Hashtable.EqualityComparer
- uid: System.Collections.Hashtable.GetEnumerator
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetEnumerator()
  nameWithType: Hashtable.GetEnumerator()
  fullName: System.Collections.Hashtable.GetEnumerator()
- uid: System.Collections.IDictionaryEnumerator
  parent: System.Collections
  isExternal: true
  name: IDictionaryEnumerator
  nameWithType: IDictionaryEnumerator
  fullName: System.Collections.IDictionaryEnumerator
- uid: System.Collections.Hashtable.GetHash(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetHash(Object)
  nameWithType: Hashtable.GetHash(Object)
  fullName: System.Collections.Hashtable.GetHash(Object)
- uid: System.Collections.Hashtable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetObjectData(SerializationInfo,StreamingContext)
  nameWithType: Hashtable.GetObjectData(SerializationInfo,StreamingContext)
  fullName: System.Collections.Hashtable.GetObjectData(SerializationInfo,StreamingContext)
- uid: System.Collections.Hashtable.hcp
  parent: System.Collections.Hashtable
  isExternal: false
  name: hcp
  nameWithType: Hashtable.hcp
  fullName: System.Collections.Hashtable.hcp
- uid: System.Collections.Hashtable.IsFixedSize
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
  fullName: System.Collections.Hashtable.IsFixedSize
- uid: System.Collections.Hashtable.IsReadOnly
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
  fullName: System.Collections.Hashtable.IsReadOnly
- uid: System.Collections.Hashtable.IsSynchronized
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
  fullName: System.Collections.Hashtable.IsSynchronized
- uid: System.Collections.Hashtable.Item(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Item(Object)
  nameWithType: Hashtable.Item(Object)
  fullName: System.Collections.Hashtable.Item(Object)
- uid: System.Collections.Hashtable.KeyEquals(System.Object,System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: KeyEquals(Object,Object)
  nameWithType: Hashtable.KeyEquals(Object,Object)
  fullName: System.Collections.Hashtable.KeyEquals(Object,Object)
- uid: System.Collections.Hashtable.Keys
  parent: System.Collections.Hashtable
  isExternal: false
  name: Keys
  nameWithType: Hashtable.Keys
  fullName: System.Collections.Hashtable.Keys
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Hashtable.OnDeserialization(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: OnDeserialization(Object)
  nameWithType: Hashtable.OnDeserialization(Object)
  fullName: System.Collections.Hashtable.OnDeserialization(Object)
- uid: System.Collections.Hashtable.Remove(System.Object)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Remove(Object)
  nameWithType: Hashtable.Remove(Object)
  fullName: System.Collections.Hashtable.Remove(Object)
- uid: System.Collections.Hashtable.Synchronized(System.Collections.Hashtable)
  parent: System.Collections.Hashtable
  isExternal: false
  name: Synchronized(Hashtable)
  nameWithType: Hashtable.Synchronized(Hashtable)
  fullName: System.Collections.Hashtable.Synchronized(Hashtable)
- uid: System.Collections.Hashtable
  parent: System.Collections
  isExternal: false
  name: Hashtable
  nameWithType: Hashtable
  fullName: System.Collections.Hashtable
- uid: System.Collections.Hashtable.SyncRoot
  parent: System.Collections.Hashtable
  isExternal: false
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
  fullName: System.Collections.Hashtable.SyncRoot
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator
  parent: System.Collections.Hashtable
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator()
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator()
  fullName: System.Collections.Hashtable.System.Collections.IEnumerable.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Hashtable.Values
  parent: System.Collections.Hashtable
  isExternal: false
  name: Values
  nameWithType: Hashtable.Values
  fullName: System.Collections.Hashtable.Values
- uid: System.Collections.Hashtable.#ctor*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Hashtable
  nameWithType: Hashtable.Hashtable
- uid: System.Collections.Hashtable.Add*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Add
  nameWithType: Hashtable.Add
- uid: System.Collections.Hashtable.Clear*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clear
  nameWithType: Hashtable.Clear
- uid: System.Collections.Hashtable.Clone*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Clone
  nameWithType: Hashtable.Clone
- uid: System.Collections.Hashtable.comparer*
  parent: System.Collections.Hashtable
  isExternal: false
  name: comparer
  nameWithType: Hashtable.comparer
- uid: System.Collections.Hashtable.Contains*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Contains
  nameWithType: Hashtable.Contains
- uid: System.Collections.Hashtable.ContainsKey*
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsKey
  nameWithType: Hashtable.ContainsKey
- uid: System.Collections.Hashtable.ContainsValue*
  parent: System.Collections.Hashtable
  isExternal: false
  name: ContainsValue
  nameWithType: Hashtable.ContainsValue
- uid: System.Collections.Hashtable.CopyTo*
  parent: System.Collections.Hashtable
  isExternal: false
  name: CopyTo
  nameWithType: Hashtable.CopyTo
- uid: System.Collections.Hashtable.Count*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Count
  nameWithType: Hashtable.Count
- uid: System.Collections.Hashtable.EqualityComparer*
  parent: System.Collections.Hashtable
  isExternal: false
  name: EqualityComparer
  nameWithType: Hashtable.EqualityComparer
- uid: System.Collections.Hashtable.GetEnumerator*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetEnumerator
  nameWithType: Hashtable.GetEnumerator
- uid: System.Collections.Hashtable.GetHash*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetHash
  nameWithType: Hashtable.GetHash
- uid: System.Collections.Hashtable.GetObjectData*
  parent: System.Collections.Hashtable
  isExternal: false
  name: GetObjectData
  nameWithType: Hashtable.GetObjectData
- uid: System.Collections.Hashtable.hcp*
  parent: System.Collections.Hashtable
  isExternal: false
  name: hcp
  nameWithType: Hashtable.hcp
- uid: System.Collections.Hashtable.IsFixedSize*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsFixedSize
  nameWithType: Hashtable.IsFixedSize
- uid: System.Collections.Hashtable.IsReadOnly*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsReadOnly
  nameWithType: Hashtable.IsReadOnly
- uid: System.Collections.Hashtable.IsSynchronized*
  parent: System.Collections.Hashtable
  isExternal: false
  name: IsSynchronized
  nameWithType: Hashtable.IsSynchronized
- uid: System.Collections.Hashtable.Item*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Item
  nameWithType: Hashtable.Item
- uid: System.Collections.Hashtable.KeyEquals*
  parent: System.Collections.Hashtable
  isExternal: false
  name: KeyEquals
  nameWithType: Hashtable.KeyEquals
- uid: System.Collections.Hashtable.Keys*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Keys
  nameWithType: Hashtable.Keys
- uid: System.Collections.Hashtable.OnDeserialization*
  parent: System.Collections.Hashtable
  isExternal: false
  name: OnDeserialization
  nameWithType: Hashtable.OnDeserialization
- uid: System.Collections.Hashtable.Remove*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Remove
  nameWithType: Hashtable.Remove
- uid: System.Collections.Hashtable.Synchronized*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Synchronized
  nameWithType: Hashtable.Synchronized
- uid: System.Collections.Hashtable.SyncRoot*
  parent: System.Collections.Hashtable
  isExternal: false
  name: SyncRoot
  nameWithType: Hashtable.SyncRoot
- uid: System.Collections.Hashtable.System#Collections#IEnumerable#GetEnumerator*
  parent: System.Collections.Hashtable
  isExternal: false
  name: System.Collections.IEnumerable.GetEnumerator
  nameWithType: Hashtable.System.Collections.IEnumerable.GetEnumerator
- uid: System.Collections.Hashtable.Values*
  parent: System.Collections.Hashtable
  isExternal: false
  name: Values
  nameWithType: Hashtable.Values
