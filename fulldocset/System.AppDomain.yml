### YamlMime:ManagedReference
items:
- uid: System.AppDomain
  id: AppDomain
  children:
  - System.AppDomain.ActivationContext
  - System.AppDomain.AppendPrivatePath(System.String)
  - System.AppDomain.ApplicationIdentity
  - System.AppDomain.ApplicationTrust
  - System.AppDomain.ApplyPolicy(System.String)
  - System.AppDomain.AssemblyLoad
  - System.AppDomain.AssemblyResolve
  - System.AppDomain.BaseDirectory
  - System.AppDomain.ClearPrivatePath
  - System.AppDomain.ClearShadowCopyPath
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.CreateDomain(System.String)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  - System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  - System.AppDomain.CreateInstance(System.String,System.String)
  - System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String)
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  - System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  - System.AppDomain.CurrentDomain
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  - System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  - System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  - System.AppDomain.DomainManager
  - System.AppDomain.DomainUnload
  - System.AppDomain.DynamicDirectory
  - System.AppDomain.Evidence
  - System.AppDomain.ExecuteAssembly(System.String)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssembly(System.String,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  - System.AppDomain.ExecuteAssemblyByName(System.String)
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  - System.AppDomain.FirstChanceException
  - System.AppDomain.FriendlyName
  - System.AppDomain.GetAssemblies
  - System.AppDomain.GetCurrentThreadId
  - System.AppDomain.GetData(System.String)
  - System.AppDomain.GetType
  - System.AppDomain.Id
  - System.AppDomain.InitializeLifetimeService
  - System.AppDomain.IsCompatibilitySwitchSet(System.String)
  - System.AppDomain.IsDefaultAppDomain
  - System.AppDomain.IsFinalizingForUnload
  - System.AppDomain.IsFullyTrusted
  - System.AppDomain.IsHomogenous
  - System.AppDomain.Load(System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName)
  - System.AppDomain.Load(System.String)
  - System.AppDomain.Load(System.Byte[],System.Byte[])
  - System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  - System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  - System.AppDomain.MonitoringIsEnabled
  - System.AppDomain.MonitoringSurvivedMemorySize
  - System.AppDomain.MonitoringSurvivedProcessMemorySize
  - System.AppDomain.MonitoringTotalAllocatedMemorySize
  - System.AppDomain.MonitoringTotalProcessorTime
  - System.AppDomain.PermissionSet
  - System.AppDomain.ProcessExit
  - System.AppDomain.ReflectionOnlyAssemblyResolve
  - System.AppDomain.ReflectionOnlyGetAssemblies
  - System.AppDomain.RelativeSearchPath
  - System.AppDomain.ResourceResolve
  - System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  - System.AppDomain.SetCachePath(System.String)
  - System.AppDomain.SetData(System.String,System.Object)
  - System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  - System.AppDomain.SetDynamicBase(System.String)
  - System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  - System.AppDomain.SetShadowCopyFiles
  - System.AppDomain.SetShadowCopyPath(System.String)
  - System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  - System.AppDomain.SetupInformation
  - System.AppDomain.ShadowCopyFiles
  - System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  - System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  - System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  - System.AppDomain.ToString
  - System.AppDomain.TypeResolve
  - System.AppDomain.UnhandledException
  - System.AppDomain.Unload(System.AppDomain)
  langs:
  - csharp
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
  type: Class
  summary: "代表應用程式定義域，也就是應用程式執行的隔離的環境。 這個類別無法被繼承。"
  remarks: "應用程式定義域，由 AppDomain 物件表示，協助您為執行 managed 程式碼提供隔離、 卸載和安全性界限。      -使用應用程式定義域來隔離可能會讓處理序關閉的工作。 如果正在執行的工作之 appdomain 的狀態變得不穩定，AppDomain 可以卸載而不會影響處理程序。 當處理程序必須執行很長，不需要重新啟動時，這很重要。 您也可以使用應用程式定義域來隔離不應共用資料的工作。      -如果預設應用程式定義域載入組件，它不能從記憶體中卸載的情況，而處理序正在執行。 不過，如果您開啟第二個應用程式定義域載入並執行組件時，組件會卸載應用程式定義域卸載時。 您可以使用這項技術來減少偶爾使用大型 Dll 的長時間執行程序的工作集。       多個應用程式定義域可以單一處理序中執行;不過，沒有任何應用程式定義域和執行緒之間的一對一關聯性。 數個執行緒可以屬於單一應用程式定義域，並給定的執行緒並不會侷限於單一應用程式定義域，在任何時候，而執行緒執行單一應用程式網域中。       使用建立應用程式定義域<xref:System.AppDomain.CreateDomain%2A>方法。</xref:System.AppDomain.CreateDomain%2A> AppDomain 的執行個體用來載入並執行組件 (<xref:System.Reflection.Assembly>)。</xref:System.Reflection.Assembly> AppDomain 中不會再使用時，它可以卸載。       AppDomain 類別會實作一組可讓應用程式回應載入組件時，當應用程式定義域都將被解除載入，或擲回未處理的例外狀況的事件。       如需有關如何使用應用程式定義域的詳細資訊，請參閱[應用程式定義域](~/add/includes/ajax-current-ext-md.md)。       這個類別會實作<xref:System.MarshalByRefObject>， <xref:System._AppDomain>，和<xref:System.Security.IEvidenceFactory>介面。</xref:System.Security.IEvidenceFactory> </xref:System._AppDomain> </xref:System.MarshalByRefObject>       您絕對不要建立 AppDomain 物件的遠端執行包裝函式。 如此一來，無法發行該 AppDomain 中，例如公開方法的遠端參考<xref:System.AppDomain.CreateInstance%2A>遠端存取和有效終結該 AppDomain 的 程式碼存取安全性。</xref:System.AppDomain.CreateInstance%2A> 連接到遠端 AppDomain 的惡意用戶端無法取得 AppDomain 本身有權存取任何資源的存取權。 無法建立遠端使用包裝函式，以擴充任何型別<xref:System.MarshalByRefObject>以及實作可能由惡意用戶端用來略過安全性系統的方法。</xref:System.MarshalByRefObject>      > [!CAUTION] > 的預設值為<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>屬性是`false`。</xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName> 這項設定是不安全的服務。 若要防止服務下載部分信任程式碼，將此屬性設定為`true`。"
  example:
  - "This example shows how to create a new AppDomain, instantiate a type in that new AppDomain, and communicate with that type’s object. In addition, this example shows how to unload the AppDomain causing the object to be garbage collected.  \n  \n [!code-vb[AppDomainX#1](~/add/codesnippet/visualbasic/t-system.appdomain_1.vb)]\n [!code-cs[AppDomainX#1](~/add/codesnippet/csharp/t-system.appdomain_1.cs)]\n [!code-cpp[AppDomainX#1](~/add/codesnippet/cpp/t-system.appdomain_1.cpp)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  implements:
  - System._AppDomain
  - System.Security.IEvidenceFactory
  inheritedMembers:
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.AppDomain.ActivationContext
  id: ActivationContext
  parent: System.AppDomain
  langs:
  - csharp
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得目前應用程式定義域的啟動內容。"
  syntax:
    content: public ActivationContext ActivationContext { get; }
    return:
      type: System.ActivationContext
      description: "物件，表示目前的應用程式定義域的啟動內容或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果網域中不有任何啟動內容。"
  overload: System.AppDomain.ActivationContext*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AppendPrivatePath(System.String)
  id: AppendPrivatePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "將指定的目錄名稱附加至私用路徑清單。"
  remarks: "不建議使用此屬性，因為它可能會探查路徑的組件之後變更它們已經載入。 使用<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>屬性改為。</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>       私用的路徑或相對搜尋路徑是相對於組件解析程式其中探查私用組件的基底目錄路徑。"
  syntax:
    content: public void AppendPrivatePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "要附加至私用路徑的目錄名稱。"
  overload: System.AppDomain.AppendPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.ApplicationIdentity
  id: ApplicationIdentity
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得應用程式定義域中的應用程式的識別。"
  syntax:
    content: public ApplicationIdentity ApplicationIdentity { get; }
    return:
      type: System.ApplicationIdentity
      description: "物件，可識別應用程式定義域中的應用程式。"
  overload: System.AppDomain.ApplicationIdentity*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplicationTrust
  id: ApplicationTrust
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得描述應用程式和應用程式是否有允許其執行的信任層級授與權限資訊。"
  syntax:
    content: public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }
    return:
      type: System.Security.Policy.ApplicationTrust
      description: "封裝應用程式定義域中的應用程式的權限和信任資訊的物件。"
  overload: System.AppDomain.ApplicationTrust*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ApplyPolicy(System.String)
  id: ApplyPolicy(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "傳回已套用原則之後，組件的顯示名稱。"
  remarks: "方法會採用組件 ApplyPolicy 顯示名稱，並傳回原則後顯示名稱。 這是您需要載入組件使用 「 原則 」，因為僅限反映的內容不會套用原則時相當實用。"
  syntax:
    content: public string ApplyPolicy (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "組件顯示名稱，形式所提供&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;屬性。"
    return:
      type: System.String
      description: "已套用原則之後，則字串，包含組件顯示名稱。"
  overload: System.AppDomain.ApplyPolicy*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyLoad
  id: AssemblyLoad
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "載入組件時，就會發生。"
  remarks: "<xref:System.AssemblyLoadEventHandler>委派這個事件指出哪些組件已載入。</xref:System.AssemblyLoadEventHandler>       若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。</xref:System.Security.SecurityException>       如需處理事件的詳細資訊，請參閱[事件](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following sample demonstrates the AssemblyLoad event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_AssemblyLoad#1](~/add/codesnippet/csharp/e-system.appdomain.assem_1_1.cs)]\n [!code-vb[AppDomain_AssemblyLoad#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_1_1.vb)]\n [!code-cpp[AppDomain_AssemblyLoad#1](~/add/codesnippet/cpp/e-system.appdomain.assem_1_1.cpp)]"
  syntax:
    content: public event AssemblyLoadEventHandler AssemblyLoad;
    return:
      type: System.AssemblyLoadEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.AssemblyResolve
  id: AssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "發生於組件解析失敗時。"
  remarks: "它負責<xref:System.ResolveEventHandler>傳回組件由所指定的這個事件<xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>屬性，或傳回 null，如果組件無法辨識。</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> </xref:System.ResolveEventHandler> 組件必須載入執行內容。如果載入僅限反映的內容時，會引發這個事件的負載將會失敗。       如需使用這個事件的指引，請參閱[解析組件載入](~/add/includes/ajax-current-ext-md.md)。       開頭為[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>屬性會傳回要求無法解析組件載入的組件。</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 例如，載入器可能無法載入要求的組件的相依性，因為要求的組件和其相依性不探查路徑中。 了解要求的組件的識別可能有助於在尋找相依性或識別最正確的版本，如果使用多個版本的相依性。 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>      > [!IMPORTANT] > 開頭[!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]、<xref:System.ResolveEventHandler>引發的所有組件，包括資源組件。</xref:System.ResolveEventHandler> 在舊版中，資源組件不引發事件。 如果當地語系化的作業系統，此處理常式可能會多次呼叫︰ 每個文化特性在後援鍊結中的一次。       對於此事件，<xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>屬性在套用原則之前，會傳回組件名稱。</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>      > [!IMPORTANT] > 如果多個事件處理常式註冊這個事件，事件 handlersarecalled 順序的事件處理常式傳回的值之前，不是`null`。 會忽略後續的事件處理常式。       如需處理事件的詳細資訊，請參閱[事件](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following sample demonstrates the AssemblyResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cpp[AssemblyResolve#1](~/add/codesnippet/cpp/e-system.appdomain.assem_0_1.cpp)]\n [!code-cs[AssemblyResolve#1](~/add/codesnippet/csharp/e-system.appdomain.assem_0_1.cs)]\n [!code-vb[AssemblyResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.assem_0_1.vb)]"
  syntax:
    content: public event ResolveEventHandler AssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.BaseDirectory
  id: BaseDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得組件解析程式用來探查組件的基底目錄。"
  remarks: "這個屬性會對應至<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>屬性。</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> 它也可使用擷取<xref:System.AppDomain.GetData%2A>與字串&quot;APPBASE&quot;的方法。</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain. The example then uses the BaseDirectory property to obtain the base directory path, for display to the console.  \n  \n [!code-cs[ADSetup#1](~/add/codesnippet/csharp/p-system.appdomain.based_1.cs)]\n [!code-cpp[ADSetup#1](~/add/codesnippet/cpp/p-system.appdomain.based_1.cpp)]\n [!code-vb[ADSetup#1](~/add/codesnippet/visualbasic/p-system.appdomain.based_1.vb)]"
  syntax:
    content: public string BaseDirectory { get; }
    return:
      type: System.String
      description: "表示組件解析程式用來探查組件的基底目錄。"
  overload: System.AppDomain.BaseDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.ClearPrivatePath
  id: ClearPrivatePath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "指定的空字串的私用組件位置的路徑重設 (&quot;&quot;)。"
  remarks: "私用路徑是相對於 common language runtime 會搜尋來尋找私用組件的基底目錄路徑。       如需詳細資訊，請參閱<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>"
  example:
  - "The following code example demonstrates how to use the ClearPrivatePath method to remove all entries from the list of private paths to search when assemblies are loaded.  \n  \n This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADClearPrivatePath#1](~/add/codesnippet/cpp/m-system.appdomain.clear_1.cpp)]\n [!code-cs[ADClearPrivatePath#1](~/add/codesnippet/csharp/m-system.appdomain.clear_1.cs)]\n [!code-vb[ADClearPrivatePath#1](~/add/codesnippet/visualbasic/m-system.appdomain.clear_1.vb)]"
  syntax:
    content: public void ClearPrivatePath ();
    parameters: []
  overload: System.AppDomain.ClearPrivatePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.ClearShadowCopyPath
  id: ClearShadowCopyPath
  parent: System.AppDomain
  langs:
  - csharp
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "將包含空字串的陰影複製組件目錄清單重設 (&quot;&quot;)。"
  remarks: "陰影複製路徑是儲存的陰影複製組件的所在目錄的清單。       如需詳細資訊，請參閱<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>和[陰影複製組件](~/add/includes/ajax-current-ext-md.md)。</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>"
  syntax:
    content: public void ClearShadowCopyPath ();
    parameters: []
  overload: System.AppDomain.ClearShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  id: CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定 COM 類型的新執行個體。 參數會指定包含組件包含類型的檔案名稱和型別的名稱。"
  remarks: "使用這個方法，而不需要載入的型別在本機從遠端建立物件。       傳回值必須解除包裝以存取實際物件。       A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>屬性的值`true`必須應用於明確或預設 COM 型別，此方法來建立執行個體的該類型; 否則<xref:System.TypeLoadException>就會擲回。</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  example:
  - "The following sample demonstrates  \n  \n [!code-cs[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/csharp/m-system.appdomain.creat_4_1.cs)]\n [!code-vb[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_4_1.vb)]\n [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/add/codesnippet/cpp/m-system.appdomain.creat_4_1.cpp)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "包含定義要求之類型的組件的檔案名稱。"
    - id: typeName
      type: System.String
      description: "要求的型別名稱。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "物件的包裝函式所指定的新執行個體， <code> typeName </code>。 傳回值需要解除包裝以存取實際物件。"
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "無法載入型別。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到公用的無參數建構函式。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>找不到。"
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>是抽象類別。       -或者-這個成員以晚期繫結機制叫用。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "呼叫者無法提供啟動屬性的物件沒有繼承自<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyName</code>為空字串 (&quot;&quot;)。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的組件。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "所參考的 COM 物件是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定 COM 類型的新執行個體。 參數會指定包含組件包含類型的檔案名稱和型別的名稱。"
  remarks: "使用這個方法，而不需要載入的型別在本機從遠端建立物件。       傳回值必須解除包裝以存取實際物件。       A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>屬性的值`true`必須應用於明確或預設 COM 型別，此方法來建立執行個體的該類型; 否則<xref:System.TypeLoadException>就會擲回。</xref:System.TypeLoadException> </xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=fullName>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包含定義要求之類型的組件的檔案名稱。"
    - id: typeName
      type: System.String
      description: "要求的型別名稱。"
    - id: hashValue
      type: System.Byte[]
      description: "代表計算的雜湊程式碼的值。"
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "表示組件資訊清單所使用的雜湊演算法。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "物件的包裝函式所指定的新執行個體， <code> typeName </code>。 傳回值需要解除包裝以存取實際物件。"
  overload: System.AppDomain.CreateComInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "無法載入型別。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到公用的無參數建構函式。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>找不到。"
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "<code>typeName</code>是抽象類別。       -或者-這個成員以晚期繫結機制叫用。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "呼叫者無法提供啟動屬性的物件沒有繼承自<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>assemblyFile</code>為空字串 (&quot;&quot;)。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的組件。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "所參考的 COM 物件是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String)
  id: CreateDomain(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立新的應用程式定義域具有指定名稱。"
  remarks: "`friendlyName`參數的目的在於識別讓人了以有意義的方式中的網域。 此字串應該是適合在使用者介面中顯示。       這個方法多載會使用<xref:System.AppDomainSetup>來自預設應用程式定義域的資訊。</xref:System.AppDomainSetup>"
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_1_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_1_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_1_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName);
    parameters:
    - id: friendlyName
      type: System.String
      description: "網域的好記的名稱。"
    return:
      type: System.AppDomain
      description: "新建立的應用程式定義域。"
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  id: CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立新的應用程式定義域具有指定名稱，使用提供的辨識項。"
  remarks: "This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the CreateDomain overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_0_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/m-system.appdomain.creat_0_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/m-system.appdomain.creat_0_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);
    parameters:
    - id: friendlyName
      type: System.String
      description: "網域的好記的名稱。 此易記名稱可以顯示在使用者介面，以識別該定義域中。 如需詳細資訊，請參閱<xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "建立應用程式定義域中執行的程式碼的身分識別的辨識項。 傳遞<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>使用目前的應用程式定義域的辨識項。"
    return:
      type: System.AppDomain
      description: "新建立的應用程式定義域。"
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立新的應用程式定義域，使用指定的名稱、 辨識項和應用程式定義域設定資訊。"
  remarks: "If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/f22a5c12-7605-4011-8d1c-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/f22a5c12-7605-4011-8d1c-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/f22a5c12-7605-4011-8d1c-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);
    parameters:
    - id: friendlyName
      type: System.String
      description: "網域的好記的名稱。 此易記名稱可以顯示在使用者介面，以識別該定義域中。 如需詳細資訊，請參閱<xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "建立應用程式定義域中執行的程式碼的身分識別的辨識項。 傳遞<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>使用目前的應用程式定義域的辨識項。"
    - id: info
      type: System.AppDomainSetup
      description: "物件，包含應用程式定義域初始化資訊。"
    return:
      type: System.AppDomain
      description: "新建立的應用程式定義域。"
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立新的應用程式定義域，使用指定的名稱、 辨識項、 應用程式定義域設定資訊、 預設權限集和完全信任組件的陣列。"
  remarks: "您必須設定<xref:System.AppDomainSetup.ApplicationBase%2A>屬性<xref:System.AppDomainSetup>物件，您會提供`info`。</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ApplicationBase%2A> 否則，會擲回例外狀況。       如果`securityInfo`是未提供，使用目前的應用程式定義域的辨識項。       針對提供的資料`grantSet`和`fullTrustAssemblies`用來建立<xref:System.Security.Policy.ApplicationTrust>物件新的應用程式定義域。</xref:System.Security.Policy.ApplicationTrust>"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, System.Security.Policy.StrongName[] fullTrustAssemblies);
    parameters:
    - id: friendlyName
      type: System.String
      description: "網域的好記的名稱。 此易記名稱可以顯示在使用者介面，以識別該定義域中。 如需詳細資訊，請參閱<xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>的描述"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "建立應用程式定義域中執行的程式碼的身分識別的辨識項。 傳遞<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>使用目前的應用程式定義域的辨識項。"
    - id: info
      type: System.AppDomainSetup
      description: "物件，包含應用程式定義域初始化資訊。"
    - id: grantSet
      type: System.Security.PermissionSet
      description: "預設權限集授與所有組件載入至新的應用程式定義域不具有特定授權。"
    - id: fullTrustAssemblies
      type: System.Security.Policy.StrongName[]
      description: "新的應用程式定義域中信任的代表組件視為完全的強式名稱的陣列。"
    return:
      type: System.AppDomain
      description: "新建立的應用程式定義域。"
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "應用程式定義域<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。       -或-<xref:System.AppDomainSetup.ApplicationBase*>上未設定屬性<xref href=&quot;System.AppDomainSetup&quot;></xref>物件，提供給<code> info </code>。</xref:System.AppDomainSetup.ApplicationBase*>"
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "具有指定名稱，使用辨識項、 應用程式基底路徑、 相對搜尋路徑和參數，指定是否要對應用程式定義域載入組件的陰影複製建立新的應用程式定義域。"
  remarks: "If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  example:
  - "The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.  \n  \n [!code-vb[AppDomain_Setup#1](~/add/codesnippet/visualbasic/9bed52ed-b275-4e3a-b9e6-_1.vb)]\n [!code-cs[AppDomain_Setup#1](~/add/codesnippet/csharp/9bed52ed-b275-4e3a-b9e6-_1.cs)]\n [!code-cpp[AppDomain_Setup#1](~/add/codesnippet/cpp/9bed52ed-b275-4e3a-b9e6-_1.cpp)]"
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
    parameters:
    - id: friendlyName
      type: System.String
      description: "網域的好記的名稱。 此易記名稱可以顯示在使用者介面，以識別該定義域中。 如需詳細資訊，請參閱<xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "建立應用程式定義域中執行的程式碼的身分識別的辨識項。 傳遞<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>使用目前的應用程式定義域的辨識項。"
    - id: appBasePath
      type: System.String
      description: "表示組件解析程式用來探查組件的基底目錄。 如需詳細資訊，請參閱<xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "組件解析程式應該在其中探查私用組件之基底目錄的相對路徑。 如需詳細資訊，請參閱<xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "如果<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>，組件的陰影複本載入這個應用程式定義域。"
    return:
      type: System.AppDomain
      description: "新建立的應用程式定義域。"
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  id: CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "具有指定名稱，使用辨識項、 應用程式基底路徑、 相對搜尋路徑和參數，指定是否要對應用程式定義域載入組件的陰影複製建立新的應用程式定義域。 指定當初始化應用程式定義域時，會叫用的回呼方法和傳遞給該回呼方法的字串引數的陣列。"
  remarks: "The method represented by `adInit` is executed in the context of the newly created application domain.  \n  \n If `securityInfo` is not supplied, the evidence from the current application domain is used.  \n  \n For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A>and [Shadow Copying Assemblies](~/add/includes/ajax-current-ext-md.md).  \n  \n> [!IMPORTANT]\n>  Do not use this method overload to create sandboxed application domains. Beginning with the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain. Use the [CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=False&autoUpgrade=False) method overload to create sandboxed application domains."
  syntax:
    content: public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);
    parameters:
    - id: friendlyName
      type: System.String
      description: "網域的好記的名稱。 此易記名稱可以顯示在使用者介面，以識別該定義域中。 如需詳細資訊，請參閱<xref:System.AppDomain.FriendlyName*>.</xref:System.AppDomain.FriendlyName*>"
    - id: securityInfo
      type: System.Security.Policy.Evidence
      description: "建立應用程式定義域中執行的程式碼的身分識別的辨識項。 傳遞<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>使用目前的應用程式定義域的辨識項。"
    - id: appBasePath
      type: System.String
      description: "表示組件解析程式用來探查組件的基底目錄。 如需詳細資訊，請參閱<xref:System.AppDomain.BaseDirectory*>.</xref:System.AppDomain.BaseDirectory*>"
    - id: appRelativeSearchPath
      type: System.String
      description: "組件解析程式應該在其中探查私用組件之基底目錄的相對路徑。 如需詳細資訊，請參閱<xref:System.AppDomain.RelativeSearchPath*>.</xref:System.AppDomain.RelativeSearchPath*>"
    - id: shadowCopyFiles
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要對應用程式定義域載入組件的陰影複製。"
    - id: adInit
      type: System.AppDomainInitializer
      description: "<xref href=&quot;System.AppDomainInitializer&quot;> </xref>代表時所叫用的回呼方法的委派新<xref href=&quot;System.AppDomain&quot;></xref>物件初始化。"
    - id: adInitArgs
      type: System.String[]
      description: "陣列的字串引數傳遞至所代表的回呼`adInit`，當新<xref href=&quot;System.AppDomain&quot;></xref>物件初始化。"
    return:
      type: System.AppDomain
      description: "新建立的應用程式定義域。"
  overload: System.AppDomain.CreateDomain*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>friendlyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  id: CreateInstance(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定組件中定義之指定類型的新執行個體。"
  remarks: "這個方法會呼叫預設建構函式`typeName`。       請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</xref:System.Reflection.AssemblyName>       嘗試在不是目前的應用程式定義域的目標應用程式定義域呼叫 CreateInstance 會導致目標應用程式定義域中的組件成功的負載。 因為<xref:System.Reflection.Assembly>不<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>目前的應用程式定義域載入組件，common language runtime 會嘗試對目前的應用程式定義域載入組件，而且負載可能會失敗。</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> 目前的應用程式定義域中載入的組件可能從不同的兩個應用程式定義域的路徑設定是否先載入的組件不同。"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "組件的顯示名稱。 請參閱&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "物件的包裝函式所指定的新執行個體， <code> typeName </code>。 傳回值需要解除包裝以存取實際物件。"
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyName</code>已編譯的版本還要更新。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>找不到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有呼叫這個建構函式的權限。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到相符的公用建構函式。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>找不到在<code>assemblyName</code>。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "這個執行個體是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  id: CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定組件中定義之指定類型的新執行個體。 參數會指定啟動屬性的陣列。"
  remarks: "這個方法會呼叫預設建構函式`typeName`。       請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</xref:System.Reflection.AssemblyName>       嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標的應用程式定義域中不是目前的應用程式定義域會在目標應用程式定義域中的組件載入成功。</xref:System.AppDomain.CreateInstance%2A> 因為<xref:System.Reflection.Assembly>不<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>目前的應用程式定義域載入組件，common language runtime 會嘗試對目前的應用程式定義域載入組件，而且負載可能會失敗。</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> 目前的應用程式定義域中載入的組件可能從不同的兩個應用程式定義域的路徑設定是否先載入的組件不同。"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "組件的顯示名稱。 請參閱&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    - id: activationAttributes
      type: System.Object[]
      description: "陣列的一個或多個屬性可參與啟動過程。 陣列通常只包含單一<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>物件，指定用以啟動遠端物件的 URL。       這個參數與啟動用戶端的物件。用戶端啟動是傳統的技術，保留回溯相容性，但不是建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "物件的包裝函式所指定的新執行個體， <code> typeName </code>。 傳回值需要解除包裝以存取實際物件。"
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyName</code>已編譯的版本還要更新。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>找不到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有呼叫這個建構函式的權限。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到相符的公用建構函式。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "呼叫者無法提供啟動屬性的物件沒有繼承自<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>找不到在<code>assemblyName</code>。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "這個執行個體是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定組件中定義之指定類型的新執行個體。 參數會指定繫結器、 繫結旗標、 建構函式引數、 用來解譯引數和選擇性的啟動屬性的特定文化特性資訊。"
  remarks: "請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</xref:System.Reflection.AssemblyName>       嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標的應用程式定義域中不是目前的應用程式定義域會在目標應用程式定義域中的組件載入成功。</xref:System.AppDomain.CreateInstance%2A> 因為<xref:System.Reflection.Assembly>不<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>目前的應用程式定義域載入組件，common language runtime 會嘗試對目前的應用程式定義域載入組件，而且負載可能會失敗。</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> 目前的應用程式定義域中載入的組件可能從不同的兩個應用程式定義域的路徑設定是否先載入的組件不同。"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "組件的顯示名稱。 請參閱&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    - id: ignoreCase
      type: System.Boolean
      description: "布林值，指定是否要或不執行區分大小寫的搜尋。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "零或多個會影響搜尋的位元旗標的組合`typeName`建構函式。 如果`bindingAttr`為零，區分大小寫的搜尋會針對公用建構函式執行。"
    - id: binder
      type: System.Reflection.Binder
      description: "物件，來啟用繫結、 強制引數類型、 成員的引動過程和擷取<xref:System.Reflection.MemberInfo>物件，使用反映。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，預設的繫結器會使用。"
    - id: args
      type: System.Object[]
      description: "要傳遞給建構函式引數。 這個引數陣列必須符合在數目、 順序和類型的參數叫用的建構函式。 如果預設建構函式是慣用的`args`必須是空陣列或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "特定文化特性資訊，可控管的強制型轉`args`宣告的正式類型`typeName`建構函式。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、<xref:System.Globalization.CultureInfo>會使用目前的執行緒。</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "陣列的一個或多個屬性可參與啟動過程。 陣列通常只包含單一<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>物件，指定用以啟動遠端物件的 URL。       這個參數與啟動用戶端的物件。 用戶端啟動是傳統的技術，保留回溯相容性，但不是建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "物件的包裝函式所指定的新執行個體， <code> typeName </code>。 傳回值需要解除包裝以存取實際物件。"
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的組件。       -或-<code>assemblyName</code>編譯版本的 common language runtime 比目前載入的版本。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>找不到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有呼叫這個建構函式的權限。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到任何相符的建構函式。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "呼叫者無法提供啟動屬性的物件沒有繼承自<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>找不到在<code>assemblyName</code>。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "這個執行個體是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定組件中定義之指定類型的新執行個體。 參數會指定繫結器、 繫結旗標、 建構函式引數、 用來解譯引數、 啟動屬性，以及建立類型的授權的特定文化特性資訊。"
  remarks: "請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</xref:System.Reflection.AssemblyName>       嘗試呼叫<xref:System.AppDomain.CreateInstance%2A>目標的應用程式定義域中不是目前的應用程式定義域會在目標應用程式定義域中的組件載入成功。</xref:System.AppDomain.CreateInstance%2A> 因為<xref:System.Reflection.Assembly>不<xref:System.MarshalByRefObject>，當這個方法會嘗試傳回<xref:System.Reflection.Assembly>目前的應用程式定義域載入組件，common language runtime 會嘗試對目前的應用程式定義域載入組件，而且負載可能會失敗。</xref:System.Reflection.Assembly> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly> 目前的應用程式定義域中載入的組件可能從不同的兩個應用程式定義域的路徑設定是否先載入的組件不同。"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "組件的顯示名稱。 請參閱&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    - id: ignoreCase
      type: System.Boolean
      description: "布林值，指定是否要或不執行區分大小寫的搜尋。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "零或多個會影響搜尋的位元旗標的組合`typeName`建構函式。 如果`bindingAttr`為零，區分大小寫的搜尋會針對公用建構函式執行。"
    - id: binder
      type: System.Reflection.Binder
      description: "物件，來啟用繫結、 強制引數類型、 成員的引動過程和擷取<xref:System.Reflection.MemberInfo>物件，使用反映。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，預設的繫結器會使用。"
    - id: args
      type: System.Object[]
      description: "要傳遞給建構函式引數。 這個引數陣列必須符合在數目、 順序和類型的參數叫用的建構函式。 如果預設建構函式是慣用的`args`必須是空陣列或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "特定文化特性資訊，可控管的強制型轉`args`宣告的正式類型`typeName`建構函式。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、<xref:System.Globalization.CultureInfo>會使用目前的執行緒。</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "陣列的一個或多個屬性可參與啟動過程。 陣列通常只包含單一<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>物件，指定用以啟動遠端物件的 URL。       這個參數與啟動用戶端的物件。用戶端啟動是傳統的技術，保留回溯相容性，但不是建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。"
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "用來授權建立資訊`typeName`。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "物件的包裝函式所指定的新執行個體， <code> typeName </code>。 傳回值需要解除包裝以存取實際物件。"
  overload: System.AppDomain.CreateInstance*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyName</code>已編譯的版本還要更新。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>找不到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有呼叫這個建構函式的權限。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到任何相符的建構函式。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "呼叫者無法提供啟動屬性的物件沒有繼承自<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 未啟用舊版 CAS 原則， <code> securityAttributes </code>應該是<xref uid=&quot;langword_csharp_null.&quot; name=&quot;null.&quot; href=&quot;&quot;></xref>"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>找不到在<code>assemblyName</code>。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "這個執行個體是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  id: CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定類型的新執行個體。 參數指定型別定義所在的組件和型別的名稱。"
  remarks: "這是便利的方法<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstance%2A>組合 這個方法會呼叫預設建構函式`typeName`。       請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</xref:System.Reflection.AssemblyName> 請參閱<xref:System.Type.FullName%2A?displayProperty=fullName>屬性的格式`typeName`。</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > 如果您進行早期繫結呼叫的方法`M`型別的物件的`T1`CreateInstanceAndUnwrap，所傳回，該方法進行早期繫結呼叫的方法類型的物件來`T2`組件中`C`目前組件或包含的組件以外`T1`，組件`C`會載入目前應用程式定義域。 即使早期繫結呼叫，就會發生此載入`T1.M()`中的主體進行<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。</xref:System.Reflection.Emit.DynamicMethod> 如果目前的定義域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的定義域之後嘗試載入組件`C`，負載可能會失敗。"
  example:
  - "The following code example shows the simplest way to execute code in another application domain. The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>. The `Worker` class defines a method that displays the name of the application domain in which it is executing. The example creates instances of `Worker` in the default application domain and in a new application domain.  \n  \n> [!NOTE]\n>  The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.  \n  \n [!code-cpp[CreateInstanceAndUnwrap2#1](~/add/codesnippet/cpp/m-system.appdomain.creat_2_1.cpp)]\n [!code-cs[CreateInstanceAndUnwrap2#1](~/add/codesnippet/csharp/m-system.appdomain.creat_2_1.cs)]\n [!code-vb[CreateInstanceAndUnwrap2#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_2_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "組件的顯示名稱。 請參閱&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    return:
      type: System.Object
      description: "所指定的物件執行個體<code> typeName </code>。"
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到相符的公用建構函式。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>找不到在<code>assemblyName</code>。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>找不到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有呼叫這個建構函式的權限。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyName</code>已編譯的版本還要更新。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定類型的新執行個體。 參數會指定定義類型所在的組件、 類型、 名稱和啟動屬性的陣列。"
  remarks: "這是便利的方法<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstance%2A>組合 這個方法會呼叫預設建構函式`typeName`。       請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</xref:System.Reflection.AssemblyName> 請參閱<xref:System.Type.FullName%2A?displayProperty=fullName>屬性的格式`typeName`。</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > 如果您進行早期繫結呼叫的方法`M`型別的物件的`T1`所傳回<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，而該方法的型別物件的方法的早期繫結呼叫`T2`組件中`C`目前組件或包含的組件以外`T1`，組件`C`會載入目前應用程式定義域。</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 即使早期繫結呼叫，就會發生此載入`T1.M()`中的主體進行<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。</xref:System.Reflection.Emit.DynamicMethod> 如果目前的定義域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的定義域之後嘗試載入組件`C`，負載可能會失敗。"
  example:
  - >-
    [!code-cpp[ADDyno#1](~/add/codesnippet/cpp/ec186439-6d54-4090-82e0-_1.cpp)]
     [!code-cs[ADDyno#1](~/add/codesnippet/csharp/ec186439-6d54-4090-82e0-_1.cs)]
     [!code-vb[ADDyno#1](~/add/codesnippet/visualbasic/ec186439-6d54-4090-82e0-_1.vb)]
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "組件的顯示名稱。 請參閱&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    - id: activationAttributes
      type: System.Object[]
      description: "陣列的一個或多個屬性可參與啟動過程。 陣列通常只包含單一<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>物件，指定用以啟動遠端物件的 URL。       這個參數與啟動用戶端的物件。用戶端啟動是傳統的技術，保留回溯相容性，但不是建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。"
    return:
      type: System.Object
      description: "所指定的物件執行個體<code> typeName </code>。"
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到相符的公用建構函式。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>找不到在<code>assemblyName</code>。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>找不到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有呼叫這個建構函式的權限。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "呼叫者無法提供啟動屬性的物件沒有繼承自<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyName</code>已編譯的版本還要更新。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定組件，指定是否忽略類型名稱的大小寫; 定義的指定類型的新執行個體繫結屬性和繫結器，可用來選取要建立; 類型引數的建構函式。文化特性，和啟動屬性。"
  remarks: "這是便利的方法<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstance%2A>組合       請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</xref:System.Reflection.AssemblyName> 請參閱<xref:System.Type.FullName%2A?displayProperty=fullName>屬性的格式`typeName`。</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > 如果您進行早期繫結呼叫的方法`M`型別的物件的`T1`所傳回<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，而該方法的型別物件的方法的早期繫結呼叫`T2`組件中`C`目前組件或包含的組件以外`T1`，組件`C`會載入目前應用程式定義域。</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 即使早期繫結呼叫，就會發生此載入`T1.M()`中的主體進行<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。</xref:System.Reflection.Emit.DynamicMethod> 如果目前的定義域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的定義域之後嘗試載入組件`C`，負載可能會失敗。"
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/7b1dcc86-9680-463d-b78c-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/7b1dcc86-9680-463d-b78c-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/7b1dcc86-9680-463d-b78c-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "組件的顯示名稱。 請參閱&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    - id: ignoreCase
      type: System.Boolean
      description: "布林值，指定是否要或不執行區分大小寫的搜尋。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "零或多個會影響搜尋的位元旗標的組合`typeName`建構函式。 如果`bindingAttr`為零，區分大小寫的搜尋會針對公用建構函式執行。"
    - id: binder
      type: System.Reflection.Binder
      description: "物件，來啟用繫結、 強制引數類型、 成員的引動過程和擷取<xref:System.Reflection.MemberInfo>物件，使用反映。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，預設的繫結器會使用。"
    - id: args
      type: System.Object[]
      description: "要傳遞給建構函式引數。 這個引數陣列必須符合在數目、 順序和類型的參數叫用的建構函式。 如果預設建構函式是慣用的`args`必須是空陣列或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "特定文化特性物件，用於管理類型的強制型轉。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、 <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref>會使用目前的執行緒。"
    - id: activationAttributes
      type: System.Object[]
      description: "陣列的一個或多個屬性可參與啟動過程。 陣列通常只包含單一<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>物件。 指定用以啟動遠端物件的 URL。       這個參數與啟動用戶端的物件。 用戶端啟動是傳統的技術，保留回溯相容性，但不是建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。"
    return:
      type: System.Object
      description: "所指定的物件執行個體<code> typeName </code>。"
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到任何相符的建構函式。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>找不到在<code>assemblyName</code>。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>找不到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有呼叫這個建構函式的權限。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "呼叫者無法提供啟動屬性的物件沒有繼承自<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的組件。       -或-<code>assemblyName</code>編譯版本的 common language runtime 比目前載入的版本。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定類型的新執行個體。 參數指定的型別，以及如何尋找和建立它的名稱。"
  remarks: "這是便利的方法<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstance%2A>組合       請參閱<xref:System.Reflection.AssemblyName>格式的`assemblyName`。</xref:System.Reflection.AssemblyName> 請參閱<xref:System.Type.FullName%2A?displayProperty=fullName>屬性的格式`typeName`。</xref:System.Type.FullName%2A?displayProperty=fullName>      > [!NOTE] > 如果您進行早期繫結呼叫的方法`M`型別的物件的`T1`所傳回<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>，而該方法的型別物件的方法的早期繫結呼叫`T2`組件中`C`目前組件或包含的組件以外`T1`，組件`C`會載入目前應用程式定義域。</xref:System.AppDomain.CreateInstanceAndUnwrap%2A> 即使早期繫結呼叫，就會發生此載入`T1.M()`中的主體進行<xref:System.Reflection.Emit.DynamicMethod>，或是使用其他動態產生的程式碼。</xref:System.Reflection.Emit.DynamicMethod> 如果目前的定義域是預設網域，組件`C`程序結束之前無法卸載。 如果目前的定義域之後嘗試載入組件`C`，負載可能會失敗。"
  example:
  - "The following sample demonstrates the use of the `ignoreCase` parameter.  \n  \n [!code-cs[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/csharp/8e0d44ad-3def-4658-8d9d-_1.cs)]\n [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/cpp/8e0d44ad-3def-4658-8d9d-_1.cpp)]\n [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/add/codesnippet/visualbasic/8e0d44ad-3def-4658-8d9d-_1.vb)]"
  syntax:
    content: public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "組件的顯示名稱。 請參閱&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    - id: ignoreCase
      type: System.Boolean
      description: "布林值，指定是否要或不執行區分大小寫的搜尋。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "零或多個會影響搜尋的位元旗標的組合`typeName`建構函式。 如果`bindingAttr`為零，區分大小寫的搜尋會針對公用建構函式執行。"
    - id: binder
      type: System.Reflection.Binder
      description: "物件，來啟用繫結、 強制引數類型、 成員的引動過程和擷取<xref:System.Reflection.MemberInfo>物件，使用反映。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，預設的繫結器會使用。"
    - id: args
      type: System.Object[]
      description: "要傳遞給建構函式引數。 這個引數陣列必須符合在數目、 順序和類型的參數叫用的建構函式。 如果預設建構函式是慣用的`args`必須是空陣列或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "特定文化特性物件，用於管理類型的強制型轉。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、 <xref uid=&quot;langword_csharp_CultureInfo&quot; name=&quot;CultureInfo&quot; href=&quot;&quot;> </xref>會使用目前的執行緒。"
    - id: activationAttributes
      type: System.Object[]
      description: "陣列的一個或多個屬性可參與啟動過程。 陣列通常只包含單一<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>物件，指定用以啟動遠端物件的 URL。       這個參數與啟動用戶端的物件。 用戶端啟動是傳統的技術，保留回溯相容性，但不是建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。"
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "用來授權建立資訊`typeName`。"
    return:
      type: System.Object
      description: "所指定的物件執行個體<code> typeName </code>。"
  overload: System.AppDomain.CreateInstanceAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>or <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到任何相符的建構函式。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typename</code>找不到在<code>assemblyName</code>。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>找不到。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有呼叫這個建構函式的權限。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "呼叫者無法提供啟動屬性的物件沒有繼承自<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyName</code>已編譯的版本還要更新。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  id: CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定組件檔案中定義的指定類型的新執行個體。"
  remarks: "預設建構函式`typeName`叫用。       如需詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       CreateInstanceFrom 方法用來建立目標應用程式定義域，從中進行呼叫，在應用程式定義域以外的執行個體之目標應用程式定義域會載入 組件。 不過，如果呼叫的應用程式定義域中執行個體解除包裝，使用包裝的執行個體所規定的方式可能會導致要呼叫的應用程式定義域載入組件。 例如，執行個體已解除包裝之後，可能會要求其類型資訊，才能呼叫其方法晚期繫結。 組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。      -如果相同的組件的另一個版本先前已載入至呼叫的應用程式定義域，或如果呼叫的應用程式定義域的載入路徑是不同的目標應用程式定義域的例外狀況例如<xref:System.MissingMethodException>可能會發生。</xref:System.MissingMethodException>      -如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>試圖轉換執行個體可能會擲回。</xref:System.InvalidCastException>"
  example:
  - "The following example shows how to use the CreateInstanceFrom method overload to create an instance of an object in a target application domain and call its methods.  \n  \n The example defines the `MarshallableExample` class, which can be marshaled across application domain boundaries. The example builds a path to the currently executing assembly, creates a target application domain, and uses the CreateInstanceFrom method overload to load the example assembly into the target application domain and create an instance of `MarshallableExample`.  \n  \n> [!NOTE]\n>  The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=fullName> method is used to load the assembly.  \n  \n After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:  \n  \n-   Invoking a method with late binding, using reflection. This requires type information, which causes the assembly to be loaded into the application domain of the caller. (In this example, it is already loaded.)  \n  \n-   Casting the object to an interface known to both the caller and the callee. If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.  \n  \n-   Using the object directly when its type is known to the caller. The assembly must be loaded into the application domain of the caller.  \n  \n Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain. That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain. See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cs[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/csharp/m-system.appdomain.creat_3_1.cs)]\n [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/cpp/m-system.appdomain.creat_3_1.cpp)]\n [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/add/codesnippet/visualbasic/m-system.appdomain.creat_3_1.vb)]"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "名稱，包括路徑，包含定義要求之類型的組件的檔案。 使用載入的組件<xref:System.Reflection.Assembly.LoadFrom*>方法。</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "新的執行個體的包裝函式物件或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。 傳回值需要解除包裝以存取實際物件。"
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>找不到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>找不到在<code>assemblyFile</code>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到沒有無參數的公用建構函式。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有足夠的權限，呼叫這個建構函式。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyFile</code>已編譯的版本還要更新。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "這個執行個體是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定組件檔案中定義的指定類型的新執行個體。"
  remarks: "預設建構函式`typeName`叫用。       如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域以外進行呼叫的應用程式定義域中的執行個體、 組件會在目標應用程式定義域中載入。</xref:System.AppDomain.CreateInstanceFrom%2A> 不過，如果呼叫的應用程式定義域中執行個體解除包裝，使用包裝的執行個體所規定的方式可能會導致要呼叫的應用程式定義域載入組件。 例如，執行個體已解除包裝之後，可能會要求其類型資訊，才能呼叫其方法晚期繫結。 組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。      -如果相同的組件的另一個版本先前已載入至呼叫的應用程式定義域，或如果呼叫的應用程式定義域的載入路徑是不同的目標應用程式定義域的例外狀況例如<xref:System.MissingMethodException>可能會發生。</xref:System.MissingMethodException>      -如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>試圖轉換執行個體可能會擲回。</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "名稱，包括路徑，包含定義要求之類型的組件的檔案。 使用載入的組件<xref:System.Reflection.Assembly.LoadFrom*>方法。</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    - id: activationAttributes
      type: System.Object[]
      description: "陣列的一個或多個屬性可參與啟動過程。 陣列通常只包含單一<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>物件，指定用以啟動遠端物件的 URL。       這個參數與啟動用戶端的物件。用戶端啟動是傳統的技術，保留回溯相容性，但不是建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "新的執行個體的包裝函式物件或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。 傳回值需要解除包裝以存取實際物件。"
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>找不到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>找不到在<code>assemblyFile</code>。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有足夠的權限，呼叫這個建構函式。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到相符的公用建構函式。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "呼叫者無法提供啟動屬性的物件沒有繼承自<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyFile</code>已編譯的版本還要更新。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "這個執行個體是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定組件檔案中定義的指定類型的新執行個體。"
  remarks: "如需詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域以外進行呼叫的應用程式定義域中的執行個體、 組件會在目標應用程式定義域中載入。</xref:System.AppDomain.CreateInstanceFrom%2A> 不過，如果呼叫的應用程式定義域中執行個體解除包裝，使用包裝的執行個體所規定的方式可能會導致要呼叫的應用程式定義域載入組件。 例如，執行個體已解除包裝之後，可能會要求其類型資訊，才能呼叫其方法晚期繫結。 組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。      -如果相同的組件的另一個版本先前已載入至呼叫的應用程式定義域，或如果呼叫的應用程式定義域的載入路徑是不同的目標應用程式定義域的例外狀況例如<xref:System.MissingMethodException>可能會發生。</xref:System.MissingMethodException>      -如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>試圖轉換執行個體可能會擲回。</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "名稱，包括路徑，包含定義要求之類型的組件的檔案。 使用載入的組件<xref:System.Reflection.Assembly.LoadFrom*>方法。</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    - id: ignoreCase
      type: System.Boolean
      description: "布林值，指定是否要或不執行區分大小寫的搜尋。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "零或多個會影響搜尋的位元旗標的組合`typeName`建構函式。 如果`bindingAttr`為零，區分大小寫的搜尋會針對公用建構函式執行。"
    - id: binder
      type: System.Reflection.Binder
      description: "物件，來啟用繫結、 強制引數類型、 成員的引動過程和擷取<xref:System.Reflection.MemberInfo>透過反映的物件。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，預設的繫結器會使用。"
    - id: args
      type: System.Object[]
      description: "要傳遞給建構函式引數。 這個引數陣列必須符合在數目、 順序和類型的參數叫用的建構函式。 如果預設建構函式是慣用的`args`必須是空陣列或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "特定文化特性資訊，可控管的強制型轉`args`宣告的正式類型`typeName`建構函式。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、<xref:System.Globalization.CultureInfo>會使用目前的執行緒。</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "陣列的一個或多個屬性可參與啟動過程。 陣列通常只包含單一<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>物件，指定用以啟動遠端物件的 URL。       這個參數與啟動用戶端的物件。 用戶端啟動是傳統的技術，保留回溯相容性，但不是建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "新的執行個體的包裝函式物件或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。 傳回值需要解除包裝以存取實際物件。"
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "呼叫者無法提供啟動屬性的物件沒有繼承自<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>找不到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>找不到在<code>assemblyFile</code>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到相符的公用建構函式。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有足夠的權限，呼叫這個建構函式。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的組件。       -或-<code>assemblyFile</code>編譯版本的 common language runtime 比目前載入的版本。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "這個執行個體是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定組件檔案中定義的指定類型的新執行個體。"
  remarks: "如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>       當<xref:System.AppDomain.CreateInstanceFrom%2A>方法用來建立目標應用程式定義域以外進行呼叫的應用程式定義域中的執行個體、 組件會在目標應用程式定義域中載入。</xref:System.AppDomain.CreateInstanceFrom%2A> 不過，如果呼叫的應用程式定義域中執行個體解除包裝，使用包裝的執行個體所規定的方式可能會導致要呼叫的應用程式定義域載入組件。 例如，執行個體已解除包裝之後，可能會要求其類型資訊，才能呼叫其方法晚期繫結。 組件載入至呼叫的應用程式定義域時，可能會發生例外狀況。      -如果相同的組件的另一個版本先前已載入至呼叫的應用程式定義域，或如果呼叫的應用程式定義域的載入路徑是不同的目標應用程式定義域的例外狀況例如<xref:System.MissingMethodException>可能會發生。</xref:System.MissingMethodException>      -如果呼叫的應用程式定義域呼叫早期繫結執行個體的型別，<xref:System.InvalidCastException>試圖轉換執行個體可能會擲回。</xref:System.InvalidCastException>"
  syntax:
    content: public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "名稱，包括路徑，包含定義要求之類型的組件的檔案。 使用載入的組件<xref:System.Reflection.Assembly.LoadFrom*>方法。</xref:System.Reflection.Assembly.LoadFrom*>"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    - id: ignoreCase
      type: System.Boolean
      description: "布林值，指定是否要或不執行區分大小寫的搜尋。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "零或多個會影響搜尋的位元旗標的組合`typeName`建構函式。 如果`bindingAttr`為零，區分大小寫的搜尋會針對公用建構函式執行。"
    - id: binder
      type: System.Reflection.Binder
      description: "物件，來啟用繫結、 強制引數類型、 成員的引動過程和擷取<xref:System.Reflection.MemberInfo>透過反映的物件。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，預設的繫結器會使用。"
    - id: args
      type: System.Object[]
      description: "要傳遞給建構函式引數。 這個引數陣列必須符合在數目、 順序和類型的參數叫用的建構函式。 如果預設建構函式是慣用的`args`必須是空陣列或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "特定文化特性資訊，可控管的強制型轉`args`宣告的正式類型`typeName`建構函式。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、<xref:System.Globalization.CultureInfo>會使用目前的執行緒。</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "陣列的一個或多個屬性可參與啟動過程。 陣列通常只包含單一<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>物件，指定用以啟動遠端物件的 URL。       這個參數與啟動用戶端的物件。 用戶端啟動是傳統的技術，保留回溯相容性，但不是建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。"
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "用來授權建立資訊`typeName`。"
    return:
      type: System.Runtime.Remoting.ObjectHandle
      description: "新的執行個體的包裝函式物件或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。 傳回值需要解除包裝以存取實際物件。"
  overload: System.AppDomain.CreateInstanceFrom*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "呼叫者無法提供啟動屬性的物件沒有繼承自<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。       -or-       <code>securityAttributes</code> is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 未啟用舊版 CAS 原則， <code> securityAttributes </code>應該<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>找不到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>找不到在<code>assemblyFile</code>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到相符的公用建構函式。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有足夠的權限，呼叫這個建構函式。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyFile</code>已編譯的版本還要更新。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "這個執行個體是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  id: CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定組件檔案中定義的指定類型的新執行個體。"
  remarks: "這是便利的方法<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstanceFrom%2A>組合 這個方法會呼叫預設建構函式`typeName`。       如需詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "檔案名稱和定義要求之類型的組件路徑。"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    return:
      type: System.Object
      description: "要求的物件，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。"
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>找不到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>找不到在<code>assemblyName</code>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到沒有無參數的公用建構函式。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有足夠的權限，呼叫這個建構函式。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyName</code>已編譯的版本還要更新。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定組件檔案中定義的指定類型的新執行個體。"
  remarks: "這是便利的方法<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstanceFrom%2A>組合 這個方法會呼叫預設建構函式`typeName`。       如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "檔案名稱和定義要求之類型的組件路徑。"
    - id: typeName
      type: System.String
      description: "要求的型別，包括命名空間，但不是組件的完整限定的名稱 (請參閱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性)。"
    - id: activationAttributes
      type: System.Object[]
      description: "陣列的一個或多個屬性可參與啟動過程。 陣列通常只包含單一<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>物件，指定用以啟動遠端物件的 URL。       這個參數與啟動用戶端的物件。用戶端啟動是傳統的技術，保留回溯相容性，但不是建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。"
    return:
      type: System.Object
      description: "要求的物件，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。"
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "呼叫者無法提供啟動屬性的物件沒有繼承自<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>找不到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>找不到在<code>assemblyName</code>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到沒有無參數的公用建構函式。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有足夠的權限，呼叫這個建構函式。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyName</code>已編譯的版本還要更新。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定義在指定的組件檔案中，指定是否忽略類型名稱的大小寫; 指定類型的新執行個體繫結屬性和繫結器，可用來選取要建立; 類型引數的建構函式。文化特性，和啟動屬性。"
  remarks: "這是便利的方法<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstanceFrom%2A>組合       如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "檔案名稱和定義要求之類型的組件路徑。"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    - id: ignoreCase
      type: System.Boolean
      description: "布林值，指定是否要或不執行區分大小寫的搜尋。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "零或多個會影響搜尋的位元旗標的組合`typeName`建構函式。 如果`bindingAttr`為零，區分大小寫的搜尋會針對公用建構函式執行。"
    - id: binder
      type: System.Reflection.Binder
      description: "物件，來啟用繫結、 強制引數類型、 成員的引動過程和擷取<xref:System.Reflection.MemberInfo>透過反映的物件。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，預設的繫結器會使用。"
    - id: args
      type: System.Object[]
      description: "要傳遞給建構函式引數。 這個引數陣列必須符合在數目、 順序和類型的參數叫用的建構函式。 如果預設建構函式是慣用的`args`必須是空陣列或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "特定文化特性資訊，可控管的強制型轉`args`宣告的正式類型`typeName`建構函式。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、<xref:System.Globalization.CultureInfo>會使用目前的執行緒。</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "陣列的一個或多個屬性可參與啟動過程。 陣列通常只包含單一<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>物件，指定用以啟動遠端物件的 URL。       這個參數與啟動用戶端的物件。 用戶端啟動是傳統的技術，保留回溯相容性，但不是建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。"
    return:
      type: System.Object
      description: "要求的物件，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。"
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "呼叫者無法提供啟動屬性的物件沒有繼承自<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>找不到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>找不到在<code>assemblyName</code>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到相符的公用建構函式。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有足夠的權限，呼叫這個建構函式。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的組件。       -或-<code>assemblyName</code>較新版的通用語言執行平台編譯，版本，目前已載入。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  platform:
  - net462
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  id: CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定組件檔案中定義的指定類型的新執行個體。"
  remarks: "這是便利的方法<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName>.</xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=fullName></xref:System.AppDomain.CreateInstanceFrom%2A>組合       如需有關這個方法的詳細資訊，請參閱<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>方法。</xref:System.Activator.CreateInstanceFrom%2A?displayProperty=fullName>"
  syntax:
    content: public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
    parameters:
    - id: assemblyName
      type: System.String
      description: "檔案名稱和定義要求之類型的組件路徑。"
    - id: typeName
      type: System.String
      description: "所要求的類型，包括命名空間，但不是組件所傳回的完整的名稱&lt;xref:System.Type.FullName%2A?displayProperty=fullName&gt;屬性。"
    - id: ignoreCase
      type: System.Boolean
      description: "布林值，指定是否要或不執行區分大小寫的搜尋。"
    - id: bindingAttr
      type: System.Reflection.BindingFlags
      description: "零或多個會影響搜尋的位元旗標的組合`typeName`建構函式。 如果`bindingAttr`為零，區分大小寫的搜尋會針對公用建構函式執行。"
    - id: binder
      type: System.Reflection.Binder
      description: "物件，來啟用繫結、 強制引數類型、 成員的引動過程和擷取<xref:System.Reflection.MemberInfo>透過反映的物件。</xref:System.Reflection.MemberInfo> 如果`binder`是 null，預設的繫結器會使用。"
    - id: args
      type: System.Object[]
      description: "要傳遞給建構函式引數。 這個引數陣列必須符合在數目、 順序和類型的參數叫用的建構函式。 如果預設建構函式是慣用的`args`必須是空陣列或 null。"
    - id: culture
      type: System.Globalization.CultureInfo
      description: "特定文化特性資訊，可控管的強制型轉`args`宣告的正式類型`typeName`建構函式。 如果`culture`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>、<xref:System.Globalization.CultureInfo>會使用目前的執行緒。</xref:System.Globalization.CultureInfo>"
    - id: activationAttributes
      type: System.Object[]
      description: "陣列的一個或多個屬性可參與啟動過程。 陣列通常只包含單一<xref href=&quot;System.Runtime.Remoting.Activation.UrlAttribute&quot;></xref>物件，指定用以啟動遠端物件的 URL。       這個參數與啟動用戶端的物件。 用戶端啟動是傳統的技術，保留回溯相容性，但不是建議用於新的開發。 分散式應用程式應該改用 Windows Communication Foundation。"
    - id: securityAttributes
      type: System.Security.Policy.Evidence
      description: "用來授權建立資訊`typeName`。"
    return:
      type: System.Object
      description: "要求的物件，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<code> typeName </code>找不到。"
  overload: System.AppDomain.CreateInstanceFromAndUnwrap*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -or-       <code>typeName</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "呼叫者無法提供啟動屬性的物件沒有繼承自<xref href=&quot;System.MarshalByRefObject&quot;> </xref>。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyName</code>找不到。"
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "<code>typeName</code>找不到在<code>assemblyName</code>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "找不到相符的公用建構函式。"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "呼叫端沒有足夠的權限，呼叫這個建構函式。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyName</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyName</code>已編譯的版本還要更新。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  platform:
  - net462
- uid: System.AppDomain.CurrentDomain
  id: CurrentDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得目前應用程式定義域目前<xref href=&quot;System.Threading.Thread&quot;> </xref>。"
  remarks: ''
  example:
  - "The following code example creates a new application domain. The CurrentDomain property is used to obtain an <xref:System.AppDomain> object that represents the current application domain. The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.curre_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.curre_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.curre_1.cs)]"
  syntax:
    content: public static AppDomain CurrentDomain { get; }
    return:
      type: System.AppDomain
      description: "目前的應用程式定義域。"
  overload: System.AppDomain.CurrentDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定義動態組件使用指定的名稱和存取模式。"
  remarks: "這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > 在開發期間發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並且包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`參數可確保已驗證的 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the DefineDynamicAssembly method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/ec69fa93-4aea-4fc8-90e1-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/ec69fa93-4aea-4fc8-90e1-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/ec69fa93-4aea-4fc8-90e1-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "動態組件的唯一識別。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "給動態組件的存取模式。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "使用指定的名稱和存取模式的動態組件。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>屬性<code> name </code>泛空白字元的開頭或包含向前或向後斜線。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定義動態組件具有指定的名稱、 存取模式和自訂屬性。"
  remarks: "您可以使用這個方法多載來指定無法正常運作除非建立動態組件時，它們會套用的屬性。 例如，安全性等屬性時<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作會建立動態組件後，如果。</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       這個方法應用於只在目前的應用程式定義域中定義動態組件。 如需有關這項限制的詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>       中引進這個方法多載[!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]。"
  example:
  - "The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>. The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.  \n  \n The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute. The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters. The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.  \n  \n The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the DefineDynamicAssembly method as the only element of an array.  \n  \n The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.  \n  \n [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/cpp/02b9ff71-a699-4692-a2ae-_1.cpp)]\n [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/visualbasic/02b9ff71-a699-4692-a2ae-_1.vb)]\n [!code-cs[DefineDynamicAssemblyWithAttributes#1](~/add/codesnippet/csharp/02b9ff71-a699-4692-a2ae-_1.cs)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "動態組件的唯一識別。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "給動態組件的存取模式。"
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "可列舉屬性套用至組件，清單或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果有任何屬性。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "使用指定的名稱和功能的動態組件。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>屬性<code> name </code>以空白字元開頭或包含向前或向後斜線。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定義動態組件，使用指定的名稱、 存取模式和辨識項。"
  remarks: "只有完全受信任的呼叫端可以提供其`evidence`定義動態<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>時 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與權限。</xref:System.Security.Policy.Evidence> 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`是`null`，執行階段將複製的權限集合，也就是目前授與及拒絕呼叫者的集合，<xref:System.Reflection.Assembly>來動態<xref:System.Reflection.Assembly>所定義，並將原則標示為已解決。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       如果動態<xref:System.Reflection.Assembly>會儲存到磁碟，後續的載入時，會與位置關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > 在開發期間發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並且包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`參數可確保已驗證的 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.  \n  \n First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.  \n  \n The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`. During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly. The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly. The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/1d1d705b-aac9-4233-8756-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/1d1d705b-aac9-4233-8756-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/1d1d705b-aac9-4233-8756-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "動態組件的唯一識別。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "將用來存取動態組件的模式。"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "提供給動態組件的辨識項。 辨識項使用不變，與最終用於原則解析的辨識項組。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "使用指定的名稱和功能的動態組件。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>屬性<code> name </code>泛空白字元的開頭或包含向前或向後斜線。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定義動態組件，使用指定的名稱、 存取模式和儲存目錄。"
  remarks: "這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > 在開發期間發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並且包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`參數可確保已驗證的 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/f3a30d18-28ff-4503-b1c6-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/f3a30d18-28ff-4503-b1c6-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/f3a30d18-28ff-4503-b1c6-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "動態組件的唯一識別。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "將用來存取動態組件的模式。"
    - id: dir
      type: System.String
      description: "儲存組件的目錄名稱。 如果`dir`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，目錄會預設為目前的目錄。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "使用指定的名稱和功能的動態組件。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>屬性<code> name </code>泛空白字元的開頭或包含向前或向後斜線。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定義動態組件具有指定的名稱、 存取模式和自訂屬性，並使用指定的來源做為安全性內容。"
  remarks: "您可以使用這個方法多載來指定無法正常運作除非建立動態組件時，它們會套用的屬性。 例如，安全性等屬性時<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作會建立動態組件後，如果。</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       這個方法應用於只在目前的應用程式定義域中定義動態組件。 如需有關這項限制的詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes, System.Security.SecurityContextSource securityContextSource);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "動態組件的唯一識別。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "給動態組件的存取模式。"
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "可列舉屬性套用至組件，清單或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果有任何屬性。"
    - id: securityContextSource
      type: System.Security.SecurityContextSource
      description: "安全性內容的來源。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "使用指定的名稱和功能的動態組件。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>屬性<code> name </code>以空白字元開頭或包含向前或向後斜線。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "值<code> securityContextSource </code>不是其中一個列舉值。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定義動態組件，使用指定的名稱、 存取模式、 儲存目錄和辨識項。"
  remarks: "只有完全受信任的呼叫端可以提供其`evidence`定義動態<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>時 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與權限。</xref:System.Security.Policy.Evidence> 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`是`null`，執行階段將複製的權限集合，也就是目前授與及拒絕呼叫者的集合，<xref:System.Reflection.Assembly>來動態<xref:System.Reflection.Assembly>所定義，並將原則標示為已解決。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       如果動態<xref:System.Reflection.Assembly>會儲存到磁碟，後續的載入時，會與位置關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>      > [!NOTE] > 在開發期間發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並且包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`參數可確保已驗證的 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</xref:System.Security.SecurityException>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/2cf98986-7843-48cf-a73f-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/2cf98986-7843-48cf-a73f-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/2cf98986-7843-48cf-a73f-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "動態組件的唯一識別。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "將用來存取動態組件的模式。"
    - id: dir
      type: System.String
      description: "儲存組件的目錄名稱。 如果`dir`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，目錄會預設為目前的目錄。"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "提供給動態組件的辨識項。 辨識項使用不變，與最終用於原則解析的辨識項組。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "使用指定的名稱和功能的動態組件。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>屬性<code> name </code>泛空白字元的開頭或包含向前或向後斜線。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定義動態組件，使用指定的名稱、 存取模式和權限要求。"
  remarks: "針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`不會使用，除非已儲存並載入記憶體的動態組件。 不會儲存到磁碟，請使用多載的暫時性組件的指定權限要求<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項也會為要求的權限，並提供為<xref:System.Security.Policy.Evidence>物件。</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > 在開發期間發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並且包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`參數可確保已驗證的 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</xref:System.Security.SecurityException>       這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/be48f0dd-e58f-4a8c-bdad-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/be48f0dd-e58f-4a8c-bdad-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/be48f0dd-e58f-4a8c-bdad-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "動態組件的唯一識別。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "將用來存取動態組件的模式。"
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "必要的權限要求。"
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "選擇性的權限要求。"
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "拒絕的權限要求。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "使用指定的名稱和功能的動態組件。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>屬性<code> name </code>泛空白字元的開頭或包含向前或向後斜線。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定義動態組件，使用指定的名稱、 存取模式、 儲存目錄和同步處理選項。"
  remarks: "您可以使用這個方法多載來指定無法正常運作除非建立動態組件時，它們會套用的屬性。 例如，安全性等屬性時<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作會建立動態組件後，如果。</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       如果`isSynchronized`是`true`，產生的下列方法<xref:System.Reflection.Emit.AssemblyBuilder>將同步處理︰ <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> 如果這些方法的兩個不同的執行緒上呼叫，其中一個會封鎖直到另完成為止。"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "動態組件的唯一識別。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "將用來存取動態組件的模式。"
    - id: dir
      type: System.String
      description: "將儲存動態組件的目錄名稱。 如果`dir`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，會使用目前的目錄。"
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要同步建立模組、 類型和成員中的動態組件。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "可列舉屬性套用至組件，清單或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果有任何屬性。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "使用指定的名稱和功能的動態組件。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>屬性<code> name </code>以空白字元開頭或包含向前或向後斜線。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定義動態組件，使用指定的名稱、 存取模式、 辨識項和權限要求。"
  remarks: "針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，並載入記憶體。      > [!NOTE] > 在開發期間發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`參數可確保已驗證的 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</xref:System.Security.SecurityException>       只有完全受信任的呼叫端可以提供其`evidence`定義動態<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>時 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與權限。</xref:System.Security.Policy.Evidence> 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`是`null`，執行階段將複製的權限集合，也就是目前授與及拒絕呼叫者的集合，<xref:System.Reflection.Assembly>來動態<xref:System.Reflection.Assembly>所定義，並將原則標示為已解決。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       如果動態<xref:System.Reflection.Assembly>會儲存到磁碟，後續的載入時，會與位置關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/7d7c7162-9e00-4b91-93d0-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/7d7c7162-9e00-4b91-93d0-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/7d7c7162-9e00-4b91-93d0-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "動態組件的唯一識別。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "將用來存取動態組件的模式。"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "提供給動態組件的辨識項。 辨識項使用不變，與最終用於原則解析的辨識項組。"
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "必要的權限要求。"
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "選擇性的權限要求。"
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "拒絕的權限要求。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "使用指定的名稱和功能的動態組件。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>屬性<code> name </code>泛空白字元的開頭或包含向前或向後斜線。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定義動態組件，使用指定的名稱、 存取模式、 儲存目錄和權限要求。"
  remarks: "針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`不會使用，除非已儲存並載入記憶體的動態組件。 不會儲存到磁碟，請使用多載的暫時性組件的指定權限要求<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項也會為要求的權限，並提供為<xref:System.Security.Policy.Evidence>物件。</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.DefineDynamicAssembly%2A>      > [!NOTE] > 在開發期間發出動態組件的程式碼，建議您使用的多載<xref:System.AppDomain.DefineDynamicAssembly%2A>方法所指定的辨識項和權限，提供您想要並且包含的動態組件的辨識項<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> </xref:System.AppDomain.DefineDynamicAssembly%2A> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`參數可確保已驗證的 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</xref:System.Security.SecurityException>       這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0fc3676e-96ff-42c6-ad25-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0fc3676e-96ff-42c6-ad25-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0fc3676e-96ff-42c6-ad25-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "動態組件的唯一識別。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "將用來存取動態組件的模式。"
    - id: dir
      type: System.String
      description: "儲存組件的目錄名稱。 如果`dir`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，目錄會預設為目前的目錄。"
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "必要的權限要求。"
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "選擇性的權限要求。"
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "拒絕的權限要求。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "使用指定的名稱和功能的動態組件。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>屬性<code> name </code>泛空白字元的開頭或包含向前或向後斜線。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定義動態組件，使用指定的名稱、 存取模式、 儲存目錄、 辨識項和權限要求。"
  remarks: "針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，並載入記憶體。      > [!NOTE] > 在開發期間發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`參數可確保已驗證的 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</xref:System.Security.SecurityException>       只有完全受信任的呼叫端可以提供其`evidence`定義動態<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>時 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與權限。</xref:System.Security.Policy.Evidence> 部分信任的呼叫端必須提供 null `evidence`。 如果`evidence`是`null`，執行階段將複製的權限集合，也就是目前授與及拒絕呼叫者的集合，<xref:System.Reflection.Assembly>來動態<xref:System.Reflection.Assembly>所定義，並將原則標示為已解決。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       如果動態<xref:System.Reflection.Assembly>會儲存到磁碟，後續的載入時，會與位置關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       這個方法應該只可用來在目前的應用程式定義域中定義動態組件。 如需詳細資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/0baa3466-02cf-4d9c-bb66-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/0baa3466-02cf-4d9c-bb66-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/0baa3466-02cf-4d9c-bb66-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "動態組件的唯一識別。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "將用來存取動態組件的模式。"
    - id: dir
      type: System.String
      description: "儲存組件的目錄名稱。 如果`dir`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，目錄會預設為目前的目錄。"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "提供給動態組件的辨識項。 辨識項使用不變，與最終用於原則解析的辨識項組。"
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "必要的權限要求。"
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "選擇性的權限要求。"
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "拒絕的權限要求。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "使用指定的名稱和功能的動態組件。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>屬性<code> name </code>泛空白字元的開頭或包含向前或向後斜線。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定義動態組件，使用指定的名稱、 存取模式、 儲存目錄、 辨識項、 權限要求和同步處理選項。"
  remarks: "針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`才會使用`evidence`也提供，或如果儲存動態組件，並載入記憶體。      > [!NOTE] > 在開發期間發出動態組件的程式碼，建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>中`refusedPermissions`。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> 包括<xref:System.Security.Permissions.SecurityPermissionFlag>中`refusedPermissions`參數可確保已驗證的 MSIL。</xref:System.Security.Permissions.SecurityPermissionFlag> 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼搭配使用時擲回。</xref:System.Security.SecurityException>       定義動態<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>時，只有完全受信任的呼叫端可以提供的辨識項 執行階段會將對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與權限。</xref:System.Security.Policy.Evidence> 部分信任的呼叫端必須提供`null`如`evidence`參數。 如果`evidence`是`null`，執行階段將複製的權限集合，也就是目前授與及拒絕呼叫者的集合，<xref:System.Reflection.Assembly>來動態<xref:System.Reflection.Assembly>所定義，並將原則標示為已解決。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       如果動態<xref:System.Reflection.Assembly>會儲存到磁碟，後續的載入時，會與位置關聯的原則為基礎的授與其中<xref:System.Reflection.Assembly>已儲存。</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>       如果`isSynchronized`是`true`，產生的下列方法<xref:System.Reflection.Emit.AssemblyBuilder>將同步處理︰ <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> 如果這些方法的兩個不同的執行緒上呼叫，其中一個會封鎖直到另完成為止。"
  example:
  - "The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/csharp/84dd3b17-5601-467b-b1e3-_1.cs)]\n [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/cpp/84dd3b17-5601-467b-b1e3-_1.cpp)]\n [!code-vb[AppDomain_DefineDynamicAssembly#1](~/add/codesnippet/visualbasic/84dd3b17-5601-467b-b1e3-_1.vb)]"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "動態組件的唯一識別。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "將用來存取動態組件的模式。"
    - id: dir
      type: System.String
      description: "將儲存動態組件的目錄名稱。 如果`dir`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，目錄會預設為目前的目錄。"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "提供給動態組件的辨識項。 辨識項使用不變，與最終用於原則解析的辨識項組。"
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "必要的權限要求。"
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "選擇性的權限要求。"
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "拒絕的權限要求。"
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要同步建立模組、 類型和成員中的動態組件。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "使用指定的名稱和功能的動態組件。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>屬性<code> name </code>泛空白字元的開頭或包含向前或向後斜線。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  id: DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  langs:
  - csharp
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "定義動態組件具有指定的名稱、 存取模式、 儲存目錄、 辨識項、 權限要求、 同步處理選項和自訂屬性。"
  remarks: "您可以使用這個方法多載來指定無法正常運作除非建立動態組件時，它們會套用的屬性。 例如，安全性等屬性時<xref:System.Security.SecurityTransparentAttribute>和<xref:System.Security.SecurityCriticalAttribute>無法正常運作會建立動態組件後，如果。</xref:System.Security.SecurityCriticalAttribute> </xref:System.Security.SecurityTransparentAttribute>       針對指定的權限要求`requiredPermissions`， `optionalPermissions`，和`refusedPermissions`參數，才使用`evidence`也提供參數，或如果儲存動態組件，並載入記憶體。      > [!NOTE] > 開發時發出動態組件的程式碼，我們建議您包含<xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName>加上旗標`refusedPermissions`參數。</xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=fullName> 納入這個旗標，可確保的 Microsoft intermediate language (MSIL)，即會驗證。 這項技術會偵測到無法驗證的程式碼，否則這可能會很難偵測到不小心產生。 這項技術的限制是，它也會使<xref:System.Security.SecurityException>要求完全信任的程式碼使用它時擲回。</xref:System.Security.SecurityException>       定義動態<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly>時，只有完全受信任的呼叫端可以提供辨識項 執行階段對應<xref:System.Security.Policy.Evidence>透過安全性原則，以判斷授與權限。</xref:System.Security.Policy.Evidence> 部分信任的呼叫端必須提供`null`如`evidence`參數。 如果`evidence`是`null`，執行階段將權限集合 （也就是，目前的授與及拒絕集） 從呼叫者的組件複製到正在定義，並將原則標記為已解決的動態組件。       如果在動態組件會儲存至磁碟，則後續載入時，會授與儲存動態組件的位置與相關聯的原則為基礎。       如果`isSynchronized`是`true`，產生的下列方法<xref:System.Reflection.Emit.AssemblyBuilder>將同步處理︰ <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>， <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>，和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。</xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> </xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> </xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> </xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> </xref:System.Reflection.Emit.AssemblyBuilder> 如果這些方法的兩個不同的執行緒上呼叫，其中一個會封鎖直到另完成為止。       中引進這個方法多載[!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]。"
  syntax:
    content: public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
    parameters:
    - id: name
      type: System.Reflection.AssemblyName
      description: "動態組件的唯一識別。"
    - id: access
      type: System.Reflection.Emit.AssemblyBuilderAccess
      description: "將用來存取動態組件的模式。"
    - id: dir
      type: System.String
      description: "將儲存動態組件的目錄名稱。 如果`dir`是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>，會使用目前的目錄。"
    - id: evidence
      type: System.Security.Policy.Evidence
      description: "提供給動態組件的辨識項。 辨識項使用不變，與最終用於原則解析的辨識項組。"
    - id: requiredPermissions
      type: System.Security.PermissionSet
      description: "必要的權限要求。"
    - id: optionalPermissions
      type: System.Security.PermissionSet
      description: "選擇性的權限要求。"
    - id: refusedPermissions
      type: System.Security.PermissionSet
      description: "拒絕的權限要求。"
    - id: isSynchronized
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要同步建立模組、 類型和成員中的動態組件。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: assemblyAttributes
      type: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
      description: "可列舉屬性套用至組件，清單或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果有任何屬性。"
    return:
      type: System.Reflection.Emit.AssemblyBuilder
      description: "使用指定的名稱和功能的動態組件。"
  overload: System.AppDomain.DefineDynamicAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "The <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;></xref> property of <code>name</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或- <xref uid=&quot;langword_csharp_Name&quot; name=&quot;Name&quot; href=&quot;&quot;> </xref>屬性<code> name </code>以空白字元開頭或包含向前或向後斜線。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  id: DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  langs:
  - csharp
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "指定的委派所識別的另一個應用程式定義域中執行程式碼。"
  remarks: '`callBackDelegate`可以指定封送處理傳值方式， <xref:System.MarshalByRefObject>，或<xref:System.ContextBoundObject>.</xref:System.ContextBoundObject> </xref:System.MarshalByRefObject>'
  example:
  - "The following sample demonstrates using a static DoCallBack method.  \n  \n [!code-vb[AppDomain_DoCallBack#1](~/add/codesnippet/visualbasic/m-system.appdomain.docal_1.vb)]\n [!code-cpp[AppDomain_DoCallBack#1](~/add/codesnippet/cpp/m-system.appdomain.docal_1.cpp)]\n [!code-cs[AppDomain_DoCallBack#1](~/add/codesnippet/csharp/m-system.appdomain.docal_1.cs)]  \n  \n The following sample demonstrates using the DoCallBack method by value.  \n  \n [!code-vb[AppDomain_DoCallBack#2](~/add/codesnippet/visualbasic/m-system.appdomain.docal_2.vb)]\n [!code-cs[AppDomain_DoCallBack#2](~/add/codesnippet/csharp/m-system.appdomain.docal_2.cs)]\n [!code-cpp[AppDomain_DoCallBack#2](~/add/codesnippet/cpp/m-system.appdomain.docal_2.cpp)]  \n  \n The following sample demonstrates using the DoCallBack method by reference.  \n  \n [!code-cpp[AppDomain_DoCallBack#3](~/add/codesnippet/cpp/m-system.appdomain.docal_3.cpp)]\n [!code-cs[AppDomain_DoCallBack#3](~/add/codesnippet/csharp/m-system.appdomain.docal_3.cs)]\n [!code-vb[AppDomain_DoCallBack#3](~/add/codesnippet/visualbasic/m-system.appdomain.docal_3.vb)]"
  syntax:
    content: public void DoCallBack (CrossAppDomainDelegate callBackDelegate);
    parameters:
    - id: callBackDelegate
      type: System.CrossAppDomainDelegate
      description: "指定要呼叫之方法的委派。"
  overload: System.AppDomain.DoCallBack*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>callBackDelegate</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomain.DomainManager
  id: DomainManager
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得應用程式定義域初始化時，由主應用程式提供的定義域管理員。"
  remarks: "受管理的主機，common language runtime (CLR) 可以提供網域管理員。 網域管理員可以參與初始化新的應用程式定義域，並提供其他管理員，例如<xref:System.Security.HostSecurityManager>，參與應用程式定義域的作業。</xref:System.Security.HostSecurityManager>"
  syntax:
    content: public AppDomainManager DomainManager { get; }
    return:
      type: System.AppDomainManager
      description: "物件，表示當初始化應用程式定義域，由主機提供的定義域管理員或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果已不提供任何定義域管理員。"
  overload: System.AppDomain.DomainManager*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DomainUnload
  id: DomainUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "發生時<xref href=&quot;System.AppDomain&quot;></xref>即將被解除載入。"
  remarks: "<xref:System.EventHandler>委派這個事件可以在應用程式網域卸載之前執行任何終止活動。</xref:System.EventHandler>       每個應用程式定義域中需要執行處理卸載時應該註冊此事件的事件處理常式。 不能使用共用的事件處理常式，因為<xref:System.EventHandler>委派不會識別正在卸載的網域。</xref:System.EventHandler>      > [!NOTE] > 預設應用程式定義域中永遠不會引發這個事件。       請勿在執行緒引發事件的相關假設。 可能比呼叫不同的執行緒上引發此事件<xref:System.AppDomain.Unload%2A>方法。</xref:System.AppDomain.Unload%2A>       如需處理事件的詳細資訊，請參閱[事件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public event EventHandler DomainUnload;
    return:
      type: System.EventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.DynamicDirectory
  id: DynamicDirectory
  parent: System.AppDomain
  langs:
  - csharp
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得組件解析程式用來探查動態建立組件的目錄。"
  remarks: "若要設定動態目錄，將指定之基底目錄路徑<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>屬性<xref:System.AppDomainSetup>將用來建立新的應用程式定義域的物件。</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> 修改指派給屬性的基底目錄路徑的簡單名稱是指派給字串的雜湊程式碼的子目錄<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>屬性，因此基底目錄的格式是*原始路徑*\\\\*雜湊碼*。</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName> 動態目錄是此基底目錄的子目錄。 其簡單的名稱為的值<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>屬性，因此其格式是*原始路徑*\\\\*雜湊碼*\\\\*應用程式名稱*。</xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>"
  example:
  - "The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.  \n  \n The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to \"Example\" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to \"C:\\DynamicAssemblyDir\". The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.  \n  \n> [!NOTE]\n>  The base directory in this example is intended to be outside the probing path for the example application. Be sure to compile the example in a different location. Delete the base directory and all its subdirectories each time you run the example.  \n  \n The example creates a new application domain, using the <xref:System.AppDomainSetup> object. The example uses the DynamicDirectory property to retrieve the name of the directory, so it can create the directory. (The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)  \n  \n The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory. The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`. Calling this method displays the name of the application domain.  \n  \n The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method. The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.  \n  \n You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example. The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`. This method does not have to have the same functionality as the one in the example; it can simply display a string to the console. The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0. When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/p-system.appdomain.dynam_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/p-system.appdomain.dynam_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.dynam_1.vb)]"
  syntax:
    content: public string DynamicDirectory { get; }
    return:
      type: System.String
      description: "組件解析程式用來探查動態建立組件的目錄。"
  overload: System.AppDomain.DynamicDirectory*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.Evidence
  id: Evidence
  parent: System.AppDomain
  langs:
  - csharp
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得<xref href=&quot;System.Security.Policy.Evidence&quot;></xref>與這個應用程式定義域相關聯。"
  syntax:
    content: public System.Security.Policy.Evidence Evidence { get; }
    return:
      type: System.Security.Policy.Evidence
      description: "這個應用程式定義域相關聯的辨識項。"
  overload: System.AppDomain.Evidence*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String)
  id: ExecuteAssembly(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "執行指定的檔案中所包含的組件。"
  remarks: "組件會開始在.NET Framework 標頭中指定的進入點執行。       這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。       這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       若要建立<xref:System.AppDomain>載入和執行，請使用<xref:System.AppDomain.CreateDomain%2A>方法。</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  example:
  - "The following sample demonstrates using one of the overloads of ExecuteAssembly on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_0_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_0_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_0_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包含要執行的組件的檔案名稱。"
    return:
      type: System.Int32
      description: "組件的進入點所傳回的值。"
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>找不到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyFile</code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定的組件有任何進入點。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "執行包含在指定的檔案中，使用指定的辨識項組件。"
  remarks: "組件會開始在.NET Framework 標頭中指定的進入點執行。       <xref:System.AppDomain.ExecuteAssembly%2A>方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。</xref:System.AppDomain.ExecuteAssembly%2A>       這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/8a3b95e3-eb51-4f5b-bb93-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/8a3b95e3-eb51-4f5b-bb93-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/8a3b95e3-eb51-4f5b-bb93-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包含要執行的組件的檔案名稱。"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "用於載入組件的辨識項。"
    return:
      type: System.Int32
      description: "組件的進入點所傳回的值。"
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>找不到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyFile</code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定的組件有任何進入點。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  id: ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "執行包含在指定的檔案中，使用指定的引數的組件。"
  remarks: "組件會開始在.NET Framework 標頭中指定的進入點執行。       這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。       這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/m-system.appdomain.execu_1_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/m-system.appdomain.execu_1_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/m-system.appdomain.execu_1_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包含要執行的組件的檔案名稱。"
    - id: args
      type: System.String[]
      description: "組件的進入點引數。"
    return:
      type: System.Int32
      description: "組件的進入點所傳回的值。"
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>找不到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的組件。       -或-<code>assemblyFile</code>編譯版本的 common language runtime 比目前載入的版本。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定的組件有任何進入點。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "執行包含在指定的檔案中，使用指定的辨識項和引數的組件。"
  remarks: "組件會開始在.NET Framework 標頭中指定的進入點執行。       這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。       這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/cb15b913-548c-4cb1-bbc5-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/cb15b913-548c-4cb1-bbc5-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/cb15b913-548c-4cb1-bbc5-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包含要執行的組件的檔案名稱。"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "組件提供的辨識項。"
    - id: args
      type: System.String[]
      description: "組件的進入點引數。"
    return:
      type: System.Int32
      description: "組件的進入點所傳回的值。"
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>找不到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyFile</code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 未啟用舊版 CAS 原則，<code>assemblySecurity</code>應該<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定的組件有任何進入點。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "執行包含在指定的檔案中，使用指定的引數、 雜湊值和雜湊演算法的組件。"
  remarks: "組件會開始在.NET Framework 標頭中指定的進入點執行。       這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。       這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/ccb3b356-1169-4d65-9fdd-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/ccb3b356-1169-4d65-9fdd-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/ccb3b356-1169-4d65-9fdd-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包含要執行的組件的檔案名稱。"
    - id: args
      type: System.String[]
      description: "組件的進入點引數。"
    - id: hashValue
      type: System.Byte[]
      description: "代表計算的雜湊程式碼的值。"
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "表示組件資訊清單所使用的雜湊演算法。"
    return:
      type: System.Int32
      description: "組件的進入點所傳回的值。"
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>找不到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的組件。       -或-<code>assemblyFile</code>編譯版本的 common language runtime 比目前載入的版本。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定的組件有任何進入點。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  id: ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "執行包含在指定的檔案中，使用指定的辨識項、 引數、 雜湊值和雜湊演算法的組件。"
  remarks: "組件會開始在.NET Framework 標頭中指定的進入點執行。       這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。       這個方法會載入組件使用<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> 您也可以執行使用的組件<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法，載入組件使用<xref:System.Reflection.Assembly.Load%2A>方法。</xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  example:
  - "Thefollowing sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.  \n  \n [!code-cpp[AppDomain_ExecuteAssembly#1](~/add/codesnippet/cpp/c176353b-cef5-4b78-b4a8-_1.cpp)]\n [!code-cs[AppDomain_ExecuteAssembly#1](~/add/codesnippet/csharp/c176353b-cef5-4b78-b4a8-_1.cs)]\n [!code-vb[AppDomain_ExecuteAssembly#1](~/add/codesnippet/visualbasic/c176353b-cef5-4b78-b4a8-_1.vb)]"
  syntax:
    content: public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
    parameters:
    - id: assemblyFile
      type: System.String
      description: "包含要執行的組件的檔案名稱。"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "組件提供的辨識項。"
    - id: args
      type: System.String[]
      description: "組件的進入點引數。"
    - id: hashValue
      type: System.Byte[]
      description: "代表計算的雜湊程式碼的值。"
    - id: hashAlgorithm
      type: System.Configuration.Assemblies.AssemblyHashAlgorithm
      description: "表示組件資訊清單所使用的雜湊演算法。"
    return:
      type: System.Int32
      description: "組件的進入點所傳回的值。"
  overload: System.AppDomain.ExecuteAssembly*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyFile</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyFile</code>找不到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyFile</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyFile</code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 未啟用舊版 CAS 原則，<code>assemblySecurity</code>應該<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定的組件有任何進入點。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  id: ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "執行需提供其顯示名稱的組件。"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入組件與<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       組件會開始在.NET Framework 標頭中指定的進入點執行。       這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。       若要建立<xref:System.AppDomain>載入和執行，請使用<xref:System.AppDomain.CreateDomain%2A>方法。</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName);
    parameters:
    - id: assemblyName
      type: System.String
      description: "組件的顯示名稱。 請參閱&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    return:
      type: System.Int32
      description: "組件的進入點所傳回的值。"
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "所指定的組件<code> assemblyName </code>找不到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "所指定的組件<code> assemblyName </code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code> assemblyName </code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "所指定的組件<code> assemblyName </code>已找到，但無法加以載入。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定的組件有任何進入點。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "執行指定的組件<xref:System.Reflection.AssemblyName>，使用指定的引數。</xref:System.Reflection.AssemblyName>"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入組件與<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       組件會開始在.NET Framework 標頭中指定的進入點執行。       這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。"
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "<xref:System.Reflection.AssemblyName>物件，代表組件名稱。</xref:System.Reflection.AssemblyName>"
    - id: args
      type: System.String[]
      description: "啟動處理程序時要傳遞的命令列引數。"
    return:
      type: System.Int32
      description: "組件的進入點所傳回的值。"
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "所指定的組件<code> assemblyName </code>找不到。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "所指定的組件<code> assemblyName </code>已找到，但無法加以載入。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "所指定的組件<code> assemblyName </code>不是有效的組件。       - <code> assemblyName </code>編譯版本的 common language runtime 比目前載入的版本。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定的組件有任何進入點。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "執行指定之顯示名稱，使用指定的辨識項組件。"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入組件與<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       組件會開始在.NET Framework 標頭中指定的進入點執行。       <xref:System.AppDomain.ExecuteAssemblyByName%2A>方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。</xref:System.AppDomain.ExecuteAssemblyByName%2A>      > [!NOTE] > 當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法<xref:System.Security.Policy.Evidence>參數，辨識項的片段會合併。</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代載入器所提供的辨識項的片段。</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyName
      type: System.String
      description: "組件的顯示名稱。 請參閱&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "用於載入組件的辨識項。"
    return:
      type: System.Int32
      description: "組件的進入點所傳回的值。"
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "所指定的組件<code> assemblyName </code>找不到。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "所指定的組件<code> assemblyName </code>已找到，但無法加以載入。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "所指定的組件<code> assemblyName </code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code> assemblyName </code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定的組件有任何進入點。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  id: ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "執行指定之顯示名稱，使用指定的引數的組件。"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入組件與<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       組件會開始在.NET Framework 標頭中指定的進入點執行。       這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "組件的顯示名稱。 請參閱&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: args
      type: System.String[]
      description: "啟動處理程序時要傳遞的命令列引數。"
    return:
      type: System.Int32
      description: "組件的進入點所傳回的值。"
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "所指定的組件<code> assemblyName </code>找不到。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "所指定的組件<code> assemblyName </code>已找到，但無法加以載入。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "所指定的組件<code> assemblyName </code>不是有效的組件。       - <code> assemblyName </code>編譯版本的 common language runtime 比目前載入的版本。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定的組件有任何進入點。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "執行指定的組件<xref:System.Reflection.AssemblyName>，使用指定的辨識項和引數。</xref:System.Reflection.AssemblyName>"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入組件與<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       組件會開始在.NET Framework 標頭中指定的進入點執行。       這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。      > [!NOTE] > 當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法<xref:System.Security.Policy.Evidence>參數，辨識項的片段會合併。</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代載入器所提供的辨識項的片段。</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.Reflection.AssemblyName
      description: "<xref:System.Reflection.AssemblyName>物件，代表組件名稱。</xref:System.Reflection.AssemblyName>"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "用於載入組件的辨識項。"
    - id: args
      type: System.String[]
      description: "啟動處理程序時要傳遞的命令列引數。"
    return:
      type: System.Int32
      description: "組件的進入點所傳回的值。"
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "所指定的組件<code> assemblyName </code>找不到。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "所指定的組件<code> assemblyName </code>已找到，但無法加以載入。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "所指定的組件<code> assemblyName </code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code> assemblyName </code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 未啟用舊版 CAS 原則，<code>assemblySecurity</code>應該<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定的組件有任何進入點。"
  platform:
  - net462
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  id: ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  langs:
  - csharp
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "執行指定之顯示名稱，使用指定的辨識項和引數的組件。"
  remarks: "<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法會提供類似的功能<xref:System.AppDomain.ExecuteAssembly%2A>方法，但指定的組件的顯示名稱或<xref:System.Reflection.AssemblyName>而不是檔案的位置。</xref:System.Reflection.AssemblyName> </xref:System.AppDomain.ExecuteAssembly%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 因此，<xref:System.AppDomain.ExecuteAssemblyByName%2A>載入組件與<xref:System.Reflection.Assembly.Load%2A>方法，而非<xref:System.Reflection.Assembly.LoadFile%2A>方法。</xref:System.Reflection.Assembly.LoadFile%2A> </xref:System.Reflection.Assembly.Load%2A> </xref:System.AppDomain.ExecuteAssemblyByName%2A>       組件會開始在.NET Framework 標頭中指定的進入點執行。       這個方法不會建立新的處理序或應用程式定義域，並不會在新的執行緒上執行的進入點方法。      > [!NOTE] > 當您使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法<xref:System.Security.Policy.Evidence>參數，辨識項的片段會合併。</xref:System.Security.Policy.Evidence> </xref:System.AppDomain.ExecuteAssemblyByName%2A> 做為引數提供的辨識項的片段<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法取代載入器所提供的辨識項的片段。</xref:System.AppDomain.ExecuteAssemblyByName%2A>"
  syntax:
    content: public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
    parameters:
    - id: assemblyName
      type: System.String
      description: "組件的顯示名稱。 請參閱&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "用於載入組件的辨識項。"
    - id: args
      type: System.String[]
      description: "啟動處理程序時要傳遞的命令列引數。"
    return:
      type: System.Int32
      description: "組件的進入點所傳回的值。"
  overload: System.AppDomain.ExecuteAssemblyByName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "所指定的組件<code> assemblyName </code>找不到。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "所指定的組件<code> assemblyName </code>已找到，但無法加以載入。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "所指定的組件<code> assemblyName </code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code> assemblyName </code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>assemblySecurity</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 未啟用舊版 CAS 原則，<code>assemblySecurity</code>應該<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "指定的組件有任何進入點。"
  platform:
  - net462
- uid: System.AppDomain.FirstChanceException
  id: FirstChanceException
  parent: System.AppDomain
  langs:
  - csharp
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "發生於例外狀況之前擲回 managed 程式碼，在執行階段例外狀況處理常式的呼叫堆疊中搜尋應用程式定義域。"
  remarks: "此事件是只有通知。 處理這個事件不會處理此例外狀況或會影響後續的例外狀況以任何方式處理。 在引發事件，並已叫用事件處理常式之後，common language runtime (CLR) 會開始搜尋的例外狀況處理常式。 FirstChanceException 提供應用程式定義域與第一個有機會檢查任何 managed 例外狀況。       每個應用程式定義域可以處理事件。 如果執行緒通過時執行呼叫的多個應用程式定義域，CLR 開始搜尋應用程式定義域中相符的例外狀況處理常式之前，已註冊的事件處理常式中，每個應用程式定義域中引發事件。 在處理事件之後，搜尋會針對應用程式定義域中相符的例外狀況處理常式。 如果找不到下, 一個應用程式定義域中引發事件。       您必須處理所有例外狀況發生在事件 FirstChanceException 事件處理常式。 否則，FirstChanceException 會引發以遞迴方式。 這可能會導致堆疊溢位和應用程式終止。 我們建議您為限制的執行區域 (Cer)，實作此事件的事件處理常式，以防止基礎結構相關例外狀況，例如記憶體不足或堆疊溢位處理例外狀況通知時，會影響虛擬機器。       不會引發這個事件的例外狀況，表示損毀的程序的狀態，例如存取違規，除非此事件處理常式為安全性關鍵的而且有<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>屬性。</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       在處理此通知事件時，common language runtime 會暫止執行緒中止。"
  example:
  - "The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain. Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain. The FirstChanceException event is handled in all application domains except `AD1`.  \n  \n> [!NOTE]\n>  In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/add/includes/ajax-current-ext-md.md).  \n  \n When the application domains have been created, the default application domain calls the `TestException` method for the first application domain. Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled. Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.  \n  \n When the last `Worker` object handles the exception, the FirstChanceException event is raised only in the last application domain. The other application domains never get a chance to handle the exception, so the event is not raised.  \n  \n When the last `Worker` object does not handle the exception, the FirstChanceException event is raised in each application domain that has an event handler. After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.  \n  \n> [!NOTE]\n>  To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers. Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.  \n  \n [!code-vb[System.AppDomain.FirstChanceException#1](~/add/codesnippet/visualbasic/e-system.appdomain.first_1.vb)]\n [!code-cs[System.AppDomain.FirstChanceException#1](~/add/codesnippet/csharp/e-system.appdomain.first_1.cs)]"
  syntax:
    content: public event EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> FirstChanceException;
    return:
      type: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.FriendlyName
  id: FriendlyName
  parent: System.AppDomain
  langs:
  - csharp
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得這個應用程式定義域的易記名稱。"
  remarks: "預設應用程式定義域的易記名稱是處理程序可執行檔的檔案名稱。 例如，如果用來啟動處理程序的可執行檔是`&quot;c:\\MyAppDirectory\\MyAssembly.exe&quot;`，預設應用程式定義域的易記名稱是`&quot;MyAssembly.exe&quot;`。"
  example:
  - "The following code example uses the FriendlyName property to get the friendly name of the current application domain. For the default application domain, the friendly name is the name of the application's executable file. The code example also displays additional information about the application domain.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomain.frien_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomain.frien_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomain.frien_1.cs)]"
  syntax:
    content: public string FriendlyName { get; }
    return:
      type: System.String
      description: "這個應用程式定義域的易記名稱。"
  overload: System.AppDomain.FriendlyName*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.GetAssemblies
  id: GetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得已載入至這個應用程式定義域的執行內容的組件。"
  remarks: ''
  example:
  - "The following code example uses the GetAssemblies method to get a list of all assemblies that have been loaded into the application domain. The assemblies are then displayed to the console.  \n  \n To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the GetAssemblies method.  \n  \n [!code-cpp[ADGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.getas_1.cpp)]\n [!code-cs[ADGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.getas_1.cs)]\n [!code-vb[ADGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.getas_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] GetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "這個應用程式定義域中的組件陣列。"
  overload: System.AppDomain.GetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.GetCurrentThreadId
  id: GetCurrentThreadId
  parent: System.AppDomain
  langs:
  - csharp
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得目前的執行緒識別項。"
  remarks: "使用<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>屬性，也就是穩定即使當.NET Framework 由支援 fiber （也就是輕量型執行緒） 的環境。</xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName>"
  syntax:
    content: public static int GetCurrentThreadId ();
    parameters: []
    return:
      type: System.Int32
      description: "為目前執行緒的識別項的 32 位元帶正負號的整數。"
  overload: System.AppDomain.GetCurrentThreadId*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.GetData(System.String)
  id: GetData(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得儲存在目前的應用程式定義域，針對指定之名稱的值。"
  remarks: "使用這個方法來擷取值的描述屬性<xref:System.AppDomain>.</xref:System.AppDomain>的這個執行個體的名稱資料組的內部快取中的項目 請注意，比較的`name`具有索引鍵-值組的名稱會區分大小寫。       快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。 您可以檢查其值與 GetData 方法中或對等<xref:System.AppDomainSetup>屬性。</xref:System.AppDomainSetup>       您可以插入或修改與您的使用者定義名稱資料組<xref:System.AppDomain.SetData%2A>方法，並檢查其值與 GetData 方法。</xref:System.AppDomain.SetData%2A>       下表描述`name`每個預先定義的系統項目和其相對應<xref:System.AppDomainSetup>屬性。</xref:System.AppDomainSetup>      |&quot;Name&quot; 的值 |屬性 |  |---------------------|--------------|  |&quot;APPBASE&quot;|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>|  |&quot;APP_CONFIG_FILE&quot;|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName>|  |&quot;APP_LAUNCH_URL&quot;|（沒有屬性）</xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=fullName> </xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName><br /><br /> &quot;APP_LAUNCH_URL 」 表示使用者之前的任何重新導向, 原本要求的 URL。 它只有時使用已啟動應用程式，例如 Internet Explorer 的瀏覽器。 並非所有瀏覽器提供此值。 |  |&quot;APP_NAME&quot;|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName>|  |&quot;BINPATH_PROBE_ONLY&quot;|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName>|  |&quot;CACHE_BASE&quot;|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>|  |&quot;CODE_DOWNLOAD_DISABLED&quot;|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName>|  |&quot;DEV_PATH&quot;|（沒有屬性） |  |&quot;DISALLOW_APP&quot;|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName>|  |&quot;DISALLOW_APP_BASE_PROBING&quot;|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName>|  |&quot;DISALLOW_APP_REDIRECTS&quot;|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName>|  |&quot;DYNAMIC_BASE&quot;|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName>|  |&quot;FORCE_CACHE_INSTALL&quot;|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>|  |&quot;LICENSE_FILE&quot;，或應用程式特定字串 |<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName>|  |&quot;LOADER_OPTIMIZATION&quot;|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName>|  |&quot;LOCATION_URI&quot;|（沒有屬性） |  |&quot;PRIVATE_BINPATH&quot;|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>|  |&quot;REGEX_DEFAULT_MATCH_TIMEOUT&quot;|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName></xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=fullName></xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=fullName></xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName></xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=fullName></xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=fullName></xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName></xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=fullName></xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=fullName><br /><br /> 「 REGEX_DEFAULT_MATCH_TIMEOUT&quot;不是系統的項目，並呼叫<xref:System.AppDomain.SetData%2A>方法也可以設定其值。 |  |&quot;SHADOW_COPY_DIRS&quot;|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName>|</xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=fullName></xref:System.AppDomain.SetData%2A>"
  example:
  - "The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain. The example then demonstrates how to use the GetData method to retrieve the data from these value pairs and display them to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.getda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.getda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.getda_1.cs)]"
  syntax:
    content: public object GetData (string name);
    parameters:
    - id: name
      type: System.String
      description: "預先定義的應用程式網域屬性的名稱或您已定義應用程式定義域屬性的名稱。"
    return:
      type: System.Object
      description: "值<code> name </code>屬性，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果屬性不存在。"
  overload: System.AppDomain.GetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.GetType
  id: GetType
  parent: System.AppDomain
  langs:
  - csharp
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得目前的執行個體的型別。"
  syntax:
    content: public Type GetType ();
    parameters: []
    return:
      type: System.Type
      description: "目前的執行個體的型別。"
  overload: System.AppDomain.GetType*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Id
  id: Id
  parent: System.AppDomain
  langs:
  - csharp
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得可唯一識別處理序中的之應用程式定義域的整數。"
  remarks: ''
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/p-system.appdomain.id_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/p-system.appdomain.id_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/p-system.appdomain.id_1.cs)]"
  syntax:
    content: public int Id { get; }
    return:
      type: System.Int32
      description: "識別應用程式定義域的整數。"
  overload: System.AppDomain.Id*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.InitializeLifetimeService
  id: InitializeLifetimeService
  parent: System.AppDomain
  langs:
  - csharp
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "提供<xref href=&quot;System.AppDomain&quot;></xref>無限的存留期由防止建立租用。"
  syntax:
    content: public override object InitializeLifetimeService ();
    parameters: []
    return:
      type: System.Object
      description: "Always <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  overload: System.AppDomain.InitializeLifetimeService*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  id: IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得可為 null 的布林值，指出是否已設定任何相容性參數，而且如果是，是否已設定指定的相容性參數。"
  remarks: "This method tests whether the specified compatibility switch has been set for the current application domain. Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.  They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=fullName> method before creating an application domain.  \n  \n The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.  \n  \n|Switch|Meaning|  \n|------------|-------------|  \n|\"NetFx40_LegacySecurityPolicy\"|Code access security (CAS) for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain. See [\\&lt;NetFx40_LegacySecurityPolicy\\&gt; Element](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md).|  \n|\"NetFx40_Legacy20SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] are enabled in this application domain. Its success requires sort00001000.dll to be installed. See [\\&lt;CompatSortNLSVersion\\&gt; Element](../Topic/%3CCompatSortNLSVersion%3E%20Element.md).|  \n|\"NetFx40_Legacy40SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain. Its success requires sort00060101.dll to be installed.|  \n|\"NetFx40_TimeSpanLegacyFormatMode\"|<xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain.  See [\\&lt;TimeSpan_LegacyFormatMode\\&gt; Element](../Topic/%3CTimeSpan_LegacyFormatMode%3E%20Element.md) and the \"Restoring Legacy TimeSpan Formatting\" section of the <xref:System.TimeSpan> topic.|  \n|\"UseRandomizedStringHashAlgorithm\"|The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains. See [\\&lt;UseRandomizedStringHashAlgorithm\\&gt; Element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md).|"
  syntax:
    content: public Nullable<bool> IsCompatibilitySwitchSet (string value);
    parameters:
    - id: value
      type: System.String
      description: "要測試的相容性參數。"
    return:
      type: System.Nullable{System.Boolean}
      description: "Null 參考 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>在 Visual Basic 中) 如果未不設定任何相容性參數則; 否則布林值，指出指定的相容性參數是否<code> value </code>設定。"
  overload: System.AppDomain.IsCompatibilitySwitchSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsDefaultAppDomain
  id: IsDefaultAppDomain
  parent: System.AppDomain
  langs:
  - csharp
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "傳回值，指出應用程式定義域是否為預設應用程式定義域，處理程序。"
  remarks: "每個受管理的程序具有預設應用程式定義域。 在 預設網域，開始執行。"
  example:
  - "The following code example creates a second application domain and displays information about the default domain and the new domain.  \n  \n [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/visualbasic/m-system.appdomain.isdef_1.vb)]\n [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/cpp/m-system.appdomain.isdef_1.cpp)]\n [!code-cs[System.AppDomain.IsDefaultAppDomain#1](~/add/codesnippet/csharp/m-system.appdomain.isdef_1.cs)]"
  syntax:
    content: public bool IsDefaultAppDomain ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果目前<xref href=&quot;System.AppDomain&quot;></xref>物件代表的預設應用程式定義域的處理序; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomain.IsDefaultAppDomain*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFinalizingForUnload
  id: IsFinalizingForUnload
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "指出此應用程式定義域正在卸載，並且正在由 common language runtime 最終處理它所包含的物件。"
  remarks: "物件的最終處理方法會提供物件的記憶體回收之前執行任何必要的清除作業的機會。 最終處理物件之後存取，但處於無效狀態，因此無法使用。 最後，記憶體回收完成，並回收物件。       物件的最終處理方法會呼叫其中一種在下列情況︰ 記憶體回收期間，當正在關閉通用語言執行平台，或包含物件的應用程式定義域卸載時。 IsFinalizingForUnload 方法會傳回`true`只能在最後一個的情況; 它不會傳回`true`如果最終處理而產生從常式回收或 CLR 關機。      > [!NOTE] > 若要判斷是否因為 CLR 關閉而最終處理，請使用<xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName>屬性。</xref:System.Environment.HasShutdownStarted%2A?displayProperty=fullName> 它會傳回`true`最終處理是否由於應用程式定義域正在卸載或 clr 正在關閉。       執行時在最終處理方法定義域卸載時，可能會想要存取另一個物件參考的靜態欄位，且具有最終處理方法。 不過，您無法可靠地達成因為所存取的物件可能有已完成。      > [!NOTE] > 這項規則的例外是<xref:System.Console>類別，這包含參考資料流物件的靜態欄位，但實作特殊讓您可以撰寫主控台中，即使在網域卸載或系統關機。</xref:System.Console>       使用此方法中的物件最終處理方法，以判斷是否包含物件的應用程式定義域正在卸載。 如果是這樣，您無法可靠地存取任何物件具有最終處理方法，並由靜態欄位參考。"
  syntax:
    content: public bool IsFinalizingForUnload ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果此應用程式網域卸載且 common language runtime 已開始叫用完成項;否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomain.IsFinalizingForUnload*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsFullyTrusted
  id: IsFullyTrusted
  parent: System.AppDomain
  langs:
  - csharp
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得值，指出載入目前應用程式定義域中的組件是否執行完全信任。"
  remarks: "這個方法一律會傳回`true`在桌面上執行的應用程式的預設應用程式定義域。 它會傳回`false`，使用所建立的沙箱化應用程式網域[AppDomain.CreateDomain (字串、 辨識項、 AppDomainSetup、 PermissionSet、 StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False)方法多載，除非應用程式定義域授與的權限相當於完全信任。"
  example:
  - "The following example demonstrates the IsFullyTrusted property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> property with fully trusted and partially trusted application domains. The fully trusted application domain is the default application domain for the application. The partially trusted application domain is created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload.  \n  \n The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries. The example creates a `Worker` object in the default application domain. It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly. The application domain is fully trusted, so both assemblies are fully trusted.  \n  \n The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method. Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.  \n  \n [!code-vb[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/visualbasic/p-system.appdomain.isful_1.vb)]\n [!code-cs[System.AppDomain.IsFullyTrusted#1](~/add/codesnippet/csharp/p-system.appdomain.isful_1.cs)]"
  syntax:
    content: public bool IsFullyTrusted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果載入目前應用程式定義域中的組件執行完全信任。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomain.IsFullyTrusted*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.IsHomogenous
  id: IsHomogenous
  parent: System.AppDomain
  langs:
  - csharp
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得值，指出目前的應用程式定義域是否有一組權限會授與給載入應用程式定義域的所有組件。"
  remarks: "This property returns `true` for sandboxed application domains that were created by using the [AppDomain.CreateDomain(String, Evidence, AppDomainSetup, PermissionSet, StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False) method overload. Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain. A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.  \n  \n Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.  \n  \n This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies."
  syntax:
    content: public bool IsHomogenous { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果目前的應用程式定義域具有一組同質性權限;否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomain.IsHomogenous*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[])
  id: Load(System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "載入<xref:System.Reflection.Assembly>具有通用物件檔案格式 (COFF) 映像包含發出的<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly>"
  remarks: "開頭為[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是在應用程式定義域的信任層級相同。       這個方法應用於僅將目前的應用程式定義域載入組件。 這個方法為了方便起見提供如互通性來電者無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>方法。</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> 至其他應用程式定義域載入組件，使用例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>方法       通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_1_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_1_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_1_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;></xref>也就是以 COFF 為基礎映像包含發出的組件。"
    return:
      type: System.Reflection.Assembly
      description: "載入的組件。"
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>rawAssembly</code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  id: Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "載入<xref:System.Reflection.Assembly>提供其<xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly>"
  remarks: "這個方法應用於僅將目前的應用程式定義域載入組件。 這個方法為了方便起見提供如互通性來電者無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>方法。</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> 至其他應用程式定義域載入組件，使用例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>方法       如果已載入要求的組件的版本，這個方法會傳回載入的組件，即使要求不同的版本。       提供的部分組件名稱`assemblyRef`不建議使用。 （部分的名稱會省略一或多個文化特性、 版本或公開金鑰語彙基元。 對於採用而不是字串的多載<xref:System.Reflection.AssemblyName>物件，&quot;MyAssembly，Version =&1;.0.0.0&quot;是部分名稱的範例和&quot;MyAssembly，Version =&1;.0.0.0，Culture = neutral，PublicKeyToken =&18;ab3442da84b47 」 是完整名稱的範例。)</xref:System.Reflection.AssemblyName>使用部分的名稱有對效能產生負面影響。 此外，部分組件名稱可以載入組件從全域組件快取中的應用程式基底目錄的組件的完全相同複本如果 (<xref:System.AppDomain.BaseDirectory%2A>或<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>)。</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName> </xref:System.AppDomain.BaseDirectory%2A>       如果目前<xref:System.AppDomain>物件都代表應用程式定義域`A`，而<xref:System.AppDomain.Load%2A>方法從應用程式定義域呼叫`B`，組件會載入至兩個應用程式網域。</xref:System.AppDomain.Load%2A> </xref:System.AppDomain> 例如，下列程式碼載入`MyAssembly`至新的應用程式定義域`ChildDomain`也到執行的程式碼的應用程式定義域︰ [!code-vb [System.AppDomain.Load#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_2_1.vb)][!code-cpp[System.AppDomain.Load#1](~/add/codesnippet/cpp/m-system.appdomain.load-_2_1.cpp)][!code-cs[System.AppDomain.Load#1](~/add/codesnippet/csharp/m-system.appdomain.load-_2_1.cs) ]組件載入兩個網域，因為<xref:System.Reflection.Assembly>不是衍生自<xref:System.MarshalByRefObject>，而因此傳回值的<xref:System.AppDomain.Load%2A>方法無法封送處理。</xref:System.AppDomain.Load%2A> </xref:System.MarshalByRefObject> </xref:System.Reflection.Assembly>     相反地，common language runtime 會嘗試對呼叫的應用程式定義域載入組件。 組件載入至兩個應用程式定義域可能會不同，如果路徑設定為兩個應用程式網域不同。      > [!NOTE] > 如果兩個<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName>屬性和<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName>屬性會設定，第一次嘗試載入組件會使用的顯示名稱 (包括所傳回的版本、 文化特性，依此類推，<xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName>屬性)。</xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=fullName> </xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> 如果找不到檔案，<xref:System.Reflection.AssemblyName.CodeBase%2A>屬性用來搜尋該組件。</xref:System.Reflection.AssemblyName.CodeBase%2A> 如果使用找到的組件<xref:System.Reflection.AssemblyName.CodeBase%2A>，會針對組件比對的顯示名稱。</xref:System.Reflection.AssemblyName.CodeBase%2A> 如果配對失敗，<xref:System.IO.FileLoadException>就會擲回。</xref:System.IO.FileLoadException>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "物件，描述要載入的組件。"
    return:
      type: System.Reflection.Assembly
      description: "載入的組件。"
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>找不到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyRef</code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  platform:
  - net462
- uid: System.AppDomain.Load(System.String)
  id: Load(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "載入<xref:System.Reflection.Assembly>提供其顯示名稱。</xref:System.Reflection.Assembly>"
  remarks: "這個方法應用於僅將目前的應用程式定義域載入組件。 這個方法為了方便起見提供如互通性來電者無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>方法。</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> 至其他應用程式定義域載入組件，使用例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>方法       通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString);
    parameters:
    - id: assemblyString
      type: System.String
      description: "組件的顯示名稱。 請參閱&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    return:
      type: System.Reflection.Assembly
      description: "載入的組件。"
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>找不到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyString</code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  id: Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "載入<xref:System.Reflection.Assembly>具有通用物件檔案格式 (COFF) 映像包含發出的<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly> 表示符號的未經處理位元組<xref:System.Reflection.Assembly>也會載入。</xref:System.Reflection.Assembly>"
  remarks: "開頭為[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是在應用程式定義域的信任層級相同。       這個方法應用於僅將目前的應用程式定義域載入組件。 這個方法為了方便起見提供如互通性來電者無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>方法。</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> 至其他應用程式定義域載入組件，使用例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>方法       通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/m-system.appdomain.load-_0_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/m-system.appdomain.load-_0_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/m-system.appdomain.load-_0_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;></xref>也就是以 COFF 為基礎映像包含發出的組件。"
    - id: rawSymbolStore
      type: System.Byte[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;></xref>包含表示組件符號的未經處理位元組。"
    return:
      type: System.Reflection.Assembly
      description: "載入的組件。"
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>rawAssembly</code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  platform:
  - net462
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  id: Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "載入<xref:System.Reflection.Assembly>提供其<xref:System.Reflection.AssemblyName>.</xref:System.Reflection.AssemblyName> </xref:System.Reflection.Assembly>"
  remarks: "這個方法應用於僅將目前的應用程式定義域載入組件。 這個方法為了方便起見提供如互通性來電者無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>方法。</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> 至其他應用程式定義域載入組件，使用例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>方法       通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyRef
      type: System.Reflection.AssemblyName
      description: "物件，描述要載入的組件。"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "用於載入組件的辨識項。"
    return:
      type: System.Reflection.Assembly
      description: "載入的組件。"
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyRef</code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyRef</code>找不到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyRef</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyRef</code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  platform:
  - net462
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  id: Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "載入<xref:System.Reflection.Assembly>提供其顯示名稱。</xref:System.Reflection.Assembly>"
  remarks: "這個方法應用於僅將目前的應用程式定義域載入組件。 這個方法為了方便起見提供如互通性來電者無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>方法。</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> 至其他應用程式定義域載入組件，使用例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>方法       通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  syntax:
    content: public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);
    parameters:
    - id: assemblyString
      type: System.String
      description: "組件的顯示名稱。 請參閱&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;。"
    - id: assemblySecurity
      type: System.Security.Policy.Evidence
      description: "用於載入組件的辨識項。"
    return:
      type: System.Reflection.Assembly
      description: "載入的組件。"
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>assemblyString</code>是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "<code>assemblyString</code>找不到。"
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>assemblyString</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>assemblyString</code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  platform:
  - net462
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  id: Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  langs:
  - csharp
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "載入<xref:System.Reflection.Assembly>具有通用物件檔案格式 (COFF) 映像包含發出的<xref:System.Reflection.Assembly>.</xref:System.Reflection.Assembly> </xref:System.Reflection.Assembly> 表示符號的未經處理位元組<xref:System.Reflection.Assembly>也會載入。</xref:System.Reflection.Assembly>"
  remarks: "開頭為[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]，使用這個方法載入的組件的信任層級是在應用程式定義域的信任層級相同。       這個方法應用於僅將目前的應用程式定義域載入組件。 這個方法為了方便起見提供如互通性來電者無法呼叫靜態<xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName>方法。</xref:System.Reflection.Assembly.Load%2A?displayProperty=fullName> 至其他應用程式定義域載入組件，使用例如<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</xref:System.AppDomain.CreateInstanceAndUnwrap%2A>方法       通用於所有多載，這個方法的資訊，請參閱<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法多載。</xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>"
  example:
  - "The following sample demonstrates the use of loading a raw assembly.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AppDomain_LoadRaw#1](~/add/codesnippet/visualbasic/1e204365-b0ec-4650-8d52-_1.vb)]\n [!code-cs[AppDomain_LoadRaw#1](~/add/codesnippet/csharp/1e204365-b0ec-4650-8d52-_1.cs)]\n [!code-cpp[AppDomain_LoadRaw#1](~/add/codesnippet/cpp/1e204365-b0ec-4650-8d52-_1.cpp)]"
  syntax:
    content: public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);
    parameters:
    - id: rawAssembly
      type: System.Byte[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;></xref>也就是以 COFF 為基礎映像包含發出的組件。"
    - id: rawSymbolStore
      type: System.Byte[]
      description: "類型的陣列<xref uid=&quot;langword_csharp_byte&quot; name=&quot;byte&quot; href=&quot;&quot;></xref>包含表示組件符號的未經處理位元組。"
    - id: securityEvidence
      type: System.Security.Policy.Evidence
      description: "用於載入組件的辨識項。"
    return:
      type: System.Reflection.Assembly
      description: "載入的組件。"
  overload: System.AppDomain.Load*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rawAssembly</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.BadImageFormatException
    commentId: T:System.BadImageFormatException
    description: "<code>rawAssembly</code>不是有效的組件。       -或-2.0 版或更新版本的 common language runtime 目前已載入和<code>rawAssembly</code>已編譯的版本還要更新。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  - type: System.IO.FileLoadException
    commentId: T:System.IO.FileLoadException
    description: "兩次使用兩個不同的辨識項載入組件或模組。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>securityEvidence</code>is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 未啟用舊版 CAS 原則，<code>securityEvidence</code>應該<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.MonitoringIsEnabled
  id: MonitoringIsEnabled
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定值，指出是否啟用 CPU 和記憶體監視應用程式定義域的目前處理序。 一旦處理序啟用監視，它不能停用。"
  remarks: "這`static`屬性 (`Shared`屬性在 Visual Basic) 控制 CPU 和記憶體監視的程序中的所有應用程式定義域。       如果您嘗試將此屬性設定為`false`、<xref:System.ArgumentException>擲回例外狀況，即使目前屬性的值是`false`。</xref:System.ArgumentException>       一旦啟用監視，您可以使用<xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>， <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>， <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>，和<xref:System.AppDomain.MonitoringTotalProcessorTime%2A>執行個體來監視個別的應用程式定義域的 CPU 和記憶體使用的屬性。</xref:System.AppDomain.MonitoringTotalProcessorTime%2A> </xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A> </xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>"
  syntax:
    content: public static bool MonitoringIsEnabled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果啟用監視。否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomain.MonitoringIsEnabled*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "目前的處理程序嘗試將值指派<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>給這個屬性。"
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  id: MonitoringSurvivedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得，未被記憶體回收，且已知正由目前應用程式定義域參考的位元組的數目。"
  remarks: "每次記憶體回收會更新統計資料。 不過，保證能夠精確只後執行完整的封鎖集合也就是的集合，其中包含所有層代和停止應用程式，這時集合就會發生。 例如，<xref:System.GC.Collect?displayProperty=fullName>方法多載會執行完整的封鎖集合。</xref:System.GC.Collect?displayProperty=fullName> （同時回收就會發生在背景中且不會封鎖應用程式。）"
  syntax:
    content: public long MonitoringSurvivedMemorySize { get; }
    return:
      type: System.Int64
      description: "存留的位元組數目。"
  overload: System.AppDomain.MonitoringSurvivedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>在 Visual Basic 中)<xref:System.AppDomain.MonitoringIsEnabled*>屬性設定為<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  id: MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得自上次回收處理程序中的所有應用程式網域的作業存留下來的位元組總數。"
  remarks: "完整的封鎖收集後，目前的位元組數目保留在即時此數字代表 managed 堆積。 它應該接近所報告的數字<xref:System.GC.GetTotalMemory%2A>方法。</xref:System.GC.GetTotalMemory%2A> 暫時收集之後，此數字代表的位元組數目目前保留要即時暫時層代中。"
  syntax:
    content: public static long MonitoringSurvivedProcessMemorySize { get; }
    return:
      type: System.Int64
      description: "處理程序的存留位元組總數。"
  overload: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>在 Visual Basic 中)<xref:System.AppDomain.MonitoringIsEnabled*>屬性設定為<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  id: MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得以位元組為單位建立以來，但不減去已回收的記憶體，由應用程式定義域所做的所有記憶體配置的大小總計。"
  syntax:
    content: public long MonitoringTotalAllocatedMemorySize { get; }
    return:
      type: System.Int64
      description: "所有記憶體配置的大小總計。"
  overload: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>在 Visual Basic 中)<xref:System.AppDomain.MonitoringIsEnabled*>屬性設定為<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.MonitoringTotalProcessorTime
  id: MonitoringTotalProcessorTime
  parent: System.AppDomain
  langs:
  - csharp
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得後程序啟動後，在目前應用程式定義域中執行時用掉的所有執行緒的處理器總時間。"
  remarks: "總時間所報告之應用程式定義域中包含應用程式定義域中執行程序中的每個執行緒所花費的時間。       呼叫 unmanaged 程式碼的執行緒仍會關聯於應用程式定義域，並執行 unmanaged 程式碼會報告已呼叫的應用程式定義域所花費的處理器時間。       當執行緒被封鎖或睡眠中，它不會耗用處理器時間。"
  syntax:
    content: public TimeSpan MonitoringTotalProcessorTime { get; }
    return:
      type: System.TimeSpan
      description: "目前的應用程式定義域的處理器總時間。"
  overload: System.AppDomain.MonitoringTotalProcessorTime*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_static&quot; name=&quot;static&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Shared&quot; name=&quot;Shared&quot; href=&quot;&quot;> </xref>在 Visual Basic 中)<xref:System.AppDomain.MonitoringIsEnabled*>屬性設定為<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.AppDomain.MonitoringIsEnabled*>"
  platform:
  - net462
- uid: System.AppDomain.PermissionSet
  id: PermissionSet
  parent: System.AppDomain
  langs:
  - csharp
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得沙箱應用程式定義域的權限集。"
  remarks: "使用所建立的沙箱化應用程式定義域[AppDomain.CreateDomain (字串、 辨識項、 AppDomainSetup、 PermissionSet、 StrongName\\[\\])](assetId:///M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])?qualifyHint=True&autoUpgrade=False)方法多載有一組同質性權限; 也就是相同的權限集授與給所有載入應用程式定義域的部分信任組件。 沙箱應用程式定義域 （選擇性） 具有免套用此權限集，並改為以完全信任執行的強式名稱組件的清單。"
  syntax:
    content: public System.Security.PermissionSet PermissionSet { get; }
    return:
      type: System.Security.PermissionSet
      description: "沙箱應用程式定義域的權限集。"
  overload: System.AppDomain.PermissionSet*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ProcessExit
  id: ProcessExit
  parent: System.AppDomain
  langs:
  - csharp
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "發生於預設應用程式定義域的父處理序結束時。"
  remarks: "<xref:System.EventHandler>針對此事件可以執行終止活動，例如關閉檔案，釋放儲存體等等，在處理序結束前。</xref:System.EventHandler>       從.NET Framework 2.0 版開始，每個應用程式定義域中註冊事件處理常式會引發這個事件。      > [!NOTE] > 所有 ProcessExit 事件處理常式的執行時間總計是受到限制，就如同所有完成的執行時間總計是在處理序關機有限。 預設值為兩秒。 受管理的主機可以呼叫來變更這個執行階段[iclrpolicymanager:: Settimeout](~/add/includes/ajax-current-ext-md.md)方法[OPR_ProcessExit](~/add/includes/ajax-current-ext-md.md)列舉值。       在.NET framework 1.0 和 1.1 版中，此事件是引發只在預設應用程式網域中，而且只有在預設應用程式定義域中註冊事件處理常式。       若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。</xref:System.Security.SecurityException>       如需處理事件的詳細資訊，請參閱[事件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public event EventHandler ProcessExit;
    return:
      type: System.EventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  id: ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "發生於僅限反映的內容中的組件解析失敗。"
  remarks: "在僅限反映的內容中，會不會自動解析相依性。 而且必須預先載入或傳回為這個事件處理常式。 當組件具有尚未載入到僅限反映的內容相依性，會引發這個事件。 遺失的相依性由指定<xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>屬性。</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName> <xref:System.ResolveEventHandler>對於這個事件必須傳回符合相依性的組件。</xref:System.ResolveEventHandler> 傳回的組件必須載入到僅限反映的內容。      > [!IMPORTANT] > 會引發這個事件僅針對遺失的相依性的組件載入僅限反映的內容 (例如，藉由使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName>方法)。</xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName> 如果找不到要載入的組件時，它不會引發。       開頭為[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>屬性會傳回要求無法解析組件載入的組件。</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 了解要求的組件的識別可能會用來識別正確版本的相依性，如果一個以上的版本可用。 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       對於此事件，<xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>屬性在套用原則之前，會傳回組件名稱。</xref:System.ResolveEventArgs.Name%2A?displayProperty=fullName>       如需處理事件的詳細資訊，請參閱[事件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public event ResolveEventHandler ReflectionOnlyAssemblyResolve;
    return:
      type: System.ResolveEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  id: ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  langs:
  - csharp
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "傳回已載入至應用程式定義域的僅限反映的內容之組件。"
  remarks: "這個方法會傳回已載入僅限反映之內容的組件。 若要取得已載入的組件的執行，請使用<xref:System.AppDomain.GetAssemblies%2A>方法。</xref:System.AppDomain.GetAssemblies%2A>"
  example:
  - "The following code example loads the System.dll assembly into the execution context and then into the reflection-only context. The <xref:System.AppDomain.GetAssemblies%2A> and ReflectionOnlyGetAssemblies methods are used to display the assemblies loaded into each context.  \n  \n [!code-cs[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/csharp/m-system.appdomain.refle_1.cs)]\n [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/cpp/m-system.appdomain.refle_1.cpp)]\n [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/add/codesnippet/visualbasic/m-system.appdomain.refle_1.vb)]"
  syntax:
    content: public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();
    parameters: []
    return:
      type: System.Reflection.Assembly[]
      description: "陣列<xref:System.Reflection.Assembly>物件代表組件載入至應用程式定義域的僅限反映的內容。</xref:System.Reflection.Assembly>"
  overload: System.AppDomain.ReflectionOnlyGetAssemblies*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試對卸載的應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.RelativeSearchPath
  id: RelativeSearchPath
  parent: System.AppDomain
  langs:
  - csharp
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得私用組件的組件解析程式應該探查基底目錄下的路徑。"
  remarks: "私用組件會部署在相同的目錄結構與應用程式。 如果 RelativeSearchPath 屬性所指定的路徑不在<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>，則會忽略它。</xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=fullName>       這個屬性會傳回使用<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>.</xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=fullName>所設定的值"
  syntax:
    content: public string RelativeSearchPath { get; }
    return:
      type: System.String
      description: "組件解析程式應該在其中探查私用組件的基底目錄下的路徑。"
  overload: System.AppDomain.RelativeSearchPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.ResourceResolve
  id: ResourceResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "發生於資源的解析失敗，因為該資源不是有效的連結或內嵌資源組件中。"
  remarks: "<xref:System.ResolveEventHandler>這個事件可以嘗試找出包含資源的組件，並傳回它。</xref:System.ResolveEventHandler>      > [!IMPORTANT] > 如果解析失敗，因為沒有檔案找不到有效的連結資源，不會引發這個事件。 如果找不到資訊清單資源資料流，但不是會引發如果找不到個別的資源索引鍵，就會引發此事件。       開頭為[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>屬性包含組件要求的資源。</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。</xref:System.Security.SecurityException>       如需處理事件的詳細資訊，請參閱[事件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public event ResolveEventHandler ResourceResolve;
    return:
      type: System.ResolveEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  id: SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立這個應用程式定義域的安全性原則層級。"
  remarks: "載入組件之前呼叫這個方法<xref:System.AppDomain>效果的安全性原則的順序。</xref:System.AppDomain>"
  example:
  - "The following example demonstrates how to use the SetAppDomainPolicymethod to set the security policy level of an application domain.  \n  \n [!code-cs[ADSetAppDomainPolicy#1](~/add/codesnippet/csharp/m-system.appdomain.setap_1.cs)]\n [!code-cpp[ADSetAppDomainPolicy#1](~/add/codesnippet/cpp/m-system.appdomain.setap_1.cpp)]\n [!code-vb[ADSetAppDomainPolicy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setap_1.vb)]"
  syntax:
    content: public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);
    parameters:
    - id: domainPolicy
      type: System.Security.Policy.PolicyLevel
      description: "安全性原則層級。"
  overload: System.AppDomain.SetAppDomainPolicy*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domainPolicy</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "已設定安全性原則層級。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.SetCachePath(System.String)
  id: SetCachePath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定的目錄路徑，做為組件的陰影複製所在的位置。"
  remarks: "如果，則會忽略快取路徑<xref:System.AppDomainSetup.ApplicationName%2A>屬性未設定。</xref:System.AppDomainSetup.ApplicationName%2A> 請參閱<xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>屬性。</xref:System.AppDomainSetup.CachePath%2A?displayProperty=fullName>       如需陰影複製的詳細資訊請參閱[陰影複製組件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public void SetCachePath (string path);
    parameters:
    - id: path
      type: System.String
      description: "陰影複本位置的完整的路徑。"
  overload: System.AppDomain.SetCachePath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object)
  id: SetData(System.String,System.Object)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "指定的值指派給指定的應用程式定義域屬性。"
  remarks: "使用這個方法來插入的項目，或修改的值描述屬性<xref:System.AppDomain>.</xref:System.AppDomain>的這個執行個體的名稱資料組的內部快取中的項目       快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。 您無法插入或修改使用此方法的系統項目。 嘗試修改系統項目方法呼叫沒有任何作用中。此方法不會擲回例外狀況。 您可以檢查的<xref:System.AppDomain.GetData%2A>方法或<xref:System.AppDomainSetup>屬性所述<xref:System.AppDomain.GetData%2A>.</xref:System.AppDomain.GetData%2A></xref:System.AppDomainSetup>相等</xref:System.AppDomain.GetData%2A>的系統項目的值       您可以呼叫此方法以設定的預設逾時間隔由 「 REGEX_DEFAULT_MATCH_TIMEOUT&quot;評估規則運算式模式的值做為值`name`引數和<xref:System.TimeSpan>表示逾時間隔的值為`data`引數。</xref:System.TimeSpan> 也可以插入或修改這個方法與您自己的使用者定義名稱資料組並且檢查其值與<xref:System.AppDomain.GetData%2A>方法。</xref:System.AppDomain.GetData%2A>"
  example:
  - "The following example demonstrates how to use the SetData method to create a new value pair. The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.  \n  \n [!code-cpp[ADGetData#1](~/add/codesnippet/cpp/m-system.appdomain.setda_1.cpp)]\n [!code-vb[ADGetData#1](~/add/codesnippet/visualbasic/m-system.appdomain.setda_1.vb)]\n [!code-cs[ADGetData#1](~/add/codesnippet/csharp/m-system.appdomain.setda_1.cs)]"
  syntax:
    content: public void SetData (string name, object data);
    parameters:
    - id: name
      type: System.String
      description: "若要建立或變更使用者定義的應用程式定義域屬性的名稱。"
    - id: data
      type: System.Object
      description: "屬性的值。"
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  id: SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "指定的值指派給指定的應用程式定義域的屬性，會擷取該屬性時呼叫端要求的指定權限。"
  remarks: "使用這個方法來插入或修改自己使用者定義的項目，描述應用程式定義域屬性的名稱/資料組的內部快取中。 當您插入項目時，您可以指定權限要求來擷取項目時，強制執行。此外，您可以呼叫此方法以設定的預設逾時間隔由 「 REGEX_DEFAULT_MATCH_TIMEOUT&quot;評估規則運算式模式的值做為值`name`引數和<xref:System.TimeSpan>表示逾時間隔的值為`data`引數。</xref:System.TimeSpan>       您無法使用這個方法的安全性要求給系統定義的屬性字串。       快取會自動包含預先定義的系統建立應用程式定義域時，會插入的項目。 您無法插入或修改使用此方法的系統項目。 嘗試修改系統項目方法呼叫沒有任何作用中。此方法不會擲回例外狀況。 您可以檢查與系統項目的值<xref:System.AppDomain.GetData%2A>方法或對等<xref:System.AppDomainSetup>的 < 備註 > 一節所述的內容<xref:System.AppDomain.GetData%2A>方法。</xref:System.AppDomain.GetData%2A> </xref:System.AppDomainSetup> </xref:System.AppDomain.GetData%2A>"
  syntax:
    content: public void SetData (string name, object data, System.Security.IPermission permission);
    parameters:
    - id: name
      type: System.String
      description: "若要建立或變更使用者定義的應用程式定義域屬性的名稱。"
    - id: data
      type: System.Object
      description: "屬性的值。"
    - id: permission
      type: System.Security.IPermission
      description: "要求的使用權限的呼叫端會擷取該屬性時。"
  overload: System.AppDomain.SetData*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>name</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>name</code>指定的系統定義的屬性字串和<code>permission</code>不<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomain.SetDynamicBase(System.String)
  id: SetDynamicBase(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定的目錄路徑，做為存放及存取動態產生的檔案的子目錄的基底目錄。"
  remarks: "這個方法會設定<xref:System.AppDomainSetup.DynamicBase%2A>屬性內部的<xref:System.AppDomainSetup>與這個執行個體相關聯。</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.DynamicBase%2A>"
  example:
  - "This method is now obsolete, and should not be used for new development. The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property. For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=fullName> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/m-system.appdomain.setdy_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/m-system.appdomain.setdy_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/m-system.appdomain.setdy_1.vb)]"
  syntax:
    content: public void SetDynamicBase (string path);
    parameters:
    - id: path
      type: System.String
      description: "已儲存動態組件之子目錄的基底目錄的完整的路徑。"
  overload: System.AppDomain.SetDynamicBase*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  id: SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "指定如何只要執行緒嘗試繫結至主體，此應用程式定義域中執行時，主體和身分識別的物件就應該附加至執行緒。"
  remarks: "設定此值才會生效，如果您使用之前設定<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>屬性。</xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName> 例如，如果您設定<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>到指定的主體 （例如，泛型主體），然後使用 SetPrincipalPolicy 方法，以設定<xref:System.Security.Principal.PrincipalPolicy>至<xref:System.Security.Principal.PrincipalPolicy>，目前的主體會保留泛型主體。</xref:System.Security.Principal.PrincipalPolicy> </xref:System.Security.Principal.PrincipalPolicy> </xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=fullName>"
  example:
  - "The following example shows the effect on threads of using the SetPrincipalPolicy method to change the principal policy of the application domain. It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setpr_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setpr_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setpr_1.cs)]"
  syntax:
    content: public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);
    parameters:
    - id: policy
      type: System.Security.Principal.PrincipalPolicy
      description: "其中一個<xref href=&quot;System.Security.Principal.PrincipalPolicy&quot;></xref>值，指定要附加至執行緒之主體物件的類型。"
  overload: System.AppDomain.SetPrincipalPolicy*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyFiles
  id: SetShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "開啟陰影複製。"
  remarks: "如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[adproperties#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_0_1.cpp)]\n [!code-vb[adproperties#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_0_1.vb)]\n [!code-cs[adproperties#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_0_1.cs)]"
  syntax:
    content: public void SetShadowCopyFiles ();
    parameters: []
  overload: System.AppDomain.SetShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  id: SetShadowCopyPath(System.String)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "建立指定的目錄路徑，做為要陰影複製的組件的位置。"
  remarks: "根據預設，陰影複製包含經由探查所找到的所有組件。 SetShadowCopyPath 方法會限制所指定目錄中的組件的陰影複製`path`。       SetShadowCopyPath 方法未指定要在其中搜尋組件的其他目錄。 要陰影複製組件已經必須位於搜尋路徑，例如在<xref:System.AppDomain.BaseDirectory%2A>.</xref:System.AppDomain.BaseDirectory%2A> SetShadowCopyPath 方法指定的搜尋路徑有資格要陰影複製。       這個方法會設定<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>屬性內部的<xref:System.AppDomainSetup>與這個執行個體相關聯。</xref:System.AppDomainSetup> </xref:System.AppDomainSetup.ShadowCopyDirectories%2A>       如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "This method is now obsolete, and should not be used for new development.  \n  \n [!code-cpp[ADShadowCopy#1](~/add/codesnippet/cpp/m-system.appdomain.setsh_1_1.cpp)]\n [!code-vb[ADShadowCopy#1](~/add/codesnippet/visualbasic/m-system.appdomain.setsh_1_1.vb)]\n [!code-cs[ADShadowCopy#1](~/add/codesnippet/csharp/m-system.appdomain.setsh_1_1.cs)]"
  syntax:
    content: public void SetShadowCopyPath (string path);
    parameters:
    - id: path
      type: System.String
      description: "目錄名稱，其中的每個名稱以分號隔開的清單。"
  overload: System.AppDomain.SetShadowCopyPath*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  id: SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  langs:
  - csharp
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "設定預設的主體物件附加至執行緒，當他們嘗試繫結至主體，此應用程式定義域中執行時。"
  remarks: ''
  example:
  - "The following example shows the effect of using the SetThreadPrincipal method to change the principal that is available for attaching to threads that are executing in the application domain. It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.  \n  \n [!code-cpp[ADPrincipal#1](~/add/codesnippet/cpp/m-system.appdomain.setth_1.cpp)]\n [!code-vb[ADPrincipal#1](~/add/codesnippet/visualbasic/m-system.appdomain.setth_1.vb)]\n [!code-cs[ADPrincipal#1](~/add/codesnippet/csharp/m-system.appdomain.setth_1.cs)]"
  syntax:
    content: public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);
    parameters:
    - id: principal
      type: System.Security.Principal.IPrincipal
      description: "要附加至執行緒的主體物件。"
  overload: System.AppDomain.SetThreadPrincipal*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>principal</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.Policy.PolicyException
    commentId: T:System.Security.Policy.PolicyException
    description: "已設定執行緒主體。"
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.SetupInformation
  id: SetupInformation
  parent: System.AppDomain
  langs:
  - csharp
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得這個執行個體的應用程式定義域組態資訊。"
  syntax:
    content: public AppDomainSetup SetupInformation { get; }
    return:
      type: System.AppDomainSetup
      description: "應用程式定義域初始化資訊。"
  overload: System.AppDomain.SetupInformation*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.ShadowCopyFiles
  id: ShadowCopyFiles
  parent: System.AppDomain
  langs:
  - csharp
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得是否設定應用程式定義域來陰影複製檔案的指示。"
  remarks: "如需詳細資訊，請參閱<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>和[陰影複製組件](~/add/includes/ajax-current-ext-md.md)。</xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=fullName>"
  syntax:
    content: public bool ShadowCopyFiles { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果設定應用程式定義域來陰影複製檔案;否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomain.ShadowCopyFiles*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "嘗試卸載應用程式定義域執行作業。"
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "將一組名稱對應至一組對應的分派識別項。"
  remarks: "這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetIDsOfNames`，請參閱 MSDN Library。"
  syntax:
    content: void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);
    parameters:
    - id: riid
      type: System.Guid
      description: "保留供將來使用。 必須是 IID_NULL。"
    - id: rgszNames
      type: System.IntPtr
      description: "傳入的對應名稱的陣列。"
    - id: cNames
      type: System.UInt32
      description: "要對應的名稱計數。"
    - id: lcid
      type: System.UInt32
      description: "地區設定內容，用於解譯名稱。"
    - id: rgDispId
      type: System.IntPtr
      description: "呼叫端配置的陣列，用於接收對應於名稱的 Id。"
  overload: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "使用 COM 的晚期繫結存取`IDispatch`不支援的介面。"
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  id: System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "擷取的類型資訊物件，然後可以用來取得介面的型別資訊。"
  remarks: "這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetTypeInfo`，請參閱 MSDN Library。"
  syntax:
    content: void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);
    parameters:
    - id: iTInfo
      type: System.UInt32
      description: "要傳回的類型資訊。"
    - id: lcid
      type: System.UInt32
      description: "型別資訊的地區設定識別項。"
    - id: ppTInfo
      type: System.IntPtr
      description: "接收到要求的類型資訊物件的指標。"
  overload: System.AppDomain.System#_AppDomain#GetTypeInfo*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "使用 COM 的晚期繫結存取`IDispatch`不支援的介面。"
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  id: System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "擷取物件提供 （0 或 1） 的類型資訊介面數目。"
  remarks: "這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::GetTypeInfoCount`，請參閱 MSDN Library。"
  syntax:
    content: void _AppDomain.GetTypeInfoCount (out uint pcTInfo);
    parameters:
    - id: pcTInfo
      type: System.UInt32
      description: "指向接收物件提供的類型資訊介面數目的位置。"
  overload: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "使用 COM 的晚期繫結存取`IDispatch`不支援的介面。"
  platform:
  - net462
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  id: System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  isEii: true
  parent: System.AppDomain
  langs:
  - csharp
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "提供屬性和物件所公開的方法存取權。"
  remarks: "這個方法會從 unmanaged 程式碼，是對存取 managed 類別，並不應該從 managed 程式碼呼叫。 如需有關`IDispatch::Invoke`，請參閱 MSDN Library。"
  syntax:
    content: void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    parameters:
    - id: dispIdMember
      type: System.UInt32
      description: "辨識成員。"
    - id: riid
      type: System.Guid
      description: "保留供將來使用。 必須是 IID_NULL。"
    - id: lcid
      type: System.UInt32
      description: "地區設定內容，用於解譯引數。"
    - id: wFlags
      type: System.Int16
      description: "描述呼叫之內容的旗標。"
    - id: pDispParams
      type: System.IntPtr
      description: "此結構包含引數陣列，為具名引數，以及陣列中的項目數目的計數的引數 Dispid 陣列指標。"
    - id: pVarResult
      type: System.IntPtr
      description: "儲存結果之位置的指標。"
    - id: pExcepInfo
      type: System.IntPtr
      description: "包含例外狀況資訊的結構指標。"
    - id: puArgErr
      type: System.IntPtr
      description: "發生錯誤的第一個引數索引。"
  overload: System.AppDomain.System#_AppDomain#Invoke*
  exceptions:
  - type: System.NotImplementedException
    commentId: T:System.NotImplementedException
    description: "使用 COM 的晚期繫結存取`IDispatch`不支援的介面。"
  platform:
  - net462
- uid: System.AppDomain.ToString
  id: ToString
  parent: System.AppDomain
  langs:
  - csharp
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得包含在應用程式定義域及任何內容原則的易記名稱的字串表示。"
  remarks: ''
  example:
  - "The following code example displays the return value of the ToString method.  \n  \n [!code-cpp[ADToString#1](~/add/codesnippet/cpp/m-system.appdomain.tostr_1.cpp)]\n [!code-cs[ADToString#1](~/add/codesnippet/csharp/m-system.appdomain.tostr_1.cs)]\n [!code-vb[ADToString#1](~/add/codesnippet/visualbasic/m-system.appdomain.tostr_1.vb)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "常值字串串連起來所構成的字串&quot;Name:&quot;，易記名稱的應用程式定義域和內容原則的字串表示或字串&quot;There are no context policies。&quot;"
  overload: System.AppDomain.ToString*
  exceptions:
  - type: System.AppDomainUnloadedException
    commentId: T:System.AppDomainUnloadedException
    description: "代表由目前的應用程式網域<xref href=&quot;System.AppDomain&quot;></xref>已卸載。"
  platform:
  - net462
- uid: System.AppDomain.TypeResolve
  id: TypeResolve
  parent: System.AppDomain
  langs:
  - csharp
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "發生於類型解析失敗時。"
  remarks: "當 common language runtime 無法判斷組件可以建立要求的型別時，就會發生 TypeResolve 事件。 如果類型定義在動態組件，或動態組件中未定義型別，但執行階段不知道哪個組件中定義此類型，也可能會發生。 後者的情況可能會發生時<xref:System.Type.GetType%2A?displayProperty=fullName>呼叫組件名稱不合格的型別名稱。</xref:System.Type.GetType%2A?displayProperty=fullName>       <xref:System.ResolveEventHandler>針對此事件可以嘗試找出並建立型別。</xref:System.ResolveEventHandler>       不過，TypeResolve 事件不會發生執行階段知道不可能在特定的組件中尋找的型別。 例如，不會不會發生此事件類型中找不到靜態組件因為執行階段知道類型無法以動態方式加入至靜態組件。       開頭為[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>屬性包含要求的類型之組件。</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName> 如需詳細資訊，請參閱<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>.</xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=fullName>       若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。</xref:System.Security.SecurityException>       如需處理事件的詳細資訊，請參閱[事件](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following sample demonstrates the TypeResolve event.  \n  \n For this code example to run, you must provide the fully qualified assembly name. For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-cs[AppDomain_TypeResolve#1](~/add/codesnippet/csharp/e-system.appdomain.typer_1.cs)]\n [!code-vb[AppDomain_TypeResolve#1](~/add/codesnippet/visualbasic/e-system.appdomain.typer_1.vb)]\n [!code-cpp[AppDomain_TypeResolve#1](~/add/codesnippet/cpp/e-system.appdomain.typer_1.cpp)]"
  syntax:
    content: public event ResolveEventHandler TypeResolve;
    return:
      type: System.ResolveEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.UnhandledException
  id: UnhandledException
  parent: System.AppDomain
  langs:
  - csharp
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
  type: Event
  assemblies:
  - mscorlib
  namespace: System
  summary: "發生於未攔截到例外狀況。"
  remarks: "這個事件會提供無法攔截的例外狀況的通知。 它可讓應用程式系統預設處理常式報告給使用者的例外狀況和終止應用程式之前記錄例外狀況的相關資訊。 應用程式的狀態相關的足夠資訊是否可用，則可能會採取其他動作，例如儲存供稍後復原程式資料。 請謹慎，因為當未處理例外狀況程式資料可能變成損毀。      > [!NOTE] > 在.NET framework 1.0 和 1.1 版中，應用程式終止和偵錯選項會向使用者報告就會引發此事件之前，而非之後。       在任何應用程式定義域中，可以處理這個事件。 不過，此事件不一定會引發例外狀況的發生位置的應用程式定義域中。 只有當執行緒在整個堆疊已回溯而不尋找適用的例外狀況處理常式，因此可能引發此事件的第一個位置是在該執行緒的來源應用程式定義域中，會形成未處理例外狀況。      > [!NOTE] > In the.NET Framework 1.0 和 1.1 版，只針對應用程式啟動時，系統所建立的預設應用程式定義域發生此事件。 如果應用程式建立其他應用程式定義域，這些應用程式定義域中指定此事件的委派沒有任何作用。       如果預設應用程式定義域中處理 UnhandledException 事件，會引發此事件發生的任何執行緒，不論在執行緒啟動哪些應用程式定義域中任何未處理例外狀況。 如果在執行緒啟動 UnhandledException 具有事件處理常式的應用程式定義域中，應用程式定義域中引發事件。 如果應用程式定義域不是預設應用程式定義域，而且也沒有事件處理常式預設應用程式定義域中，會引發兩個應用程式定義域中。       比方說，假設在執行緒啟動應用程式定義域&quot;AD1 」，呼叫的方法&quot;AD2，」 的應用程式定義域中，從該處呼叫應用程式定義域&quot;AD3 」，方法會擲回例外狀況。 UnhandledException 事件可以引發的第一個應用程式網域是&quot;AD1&quot;。 如果應用程式定義域不是預設應用程式定義域，也可能引發此事件的預設應用程式定義域。      > [!NOTE] > UnhandledException 事件的事件處理常式正在執行時，common language runtime 會暫停執行緒中止。       如果事件處理常式具有<xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>屬性與適當的旗標，此事件處理常式會被視為限制的執行區域。</xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>       從開始[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]，不會引發這個事件的例外狀況，損毀的處理程序的狀態，例如，堆疊溢位，或存取違規，除非此事件處理常式為安全性關鍵的而且有<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>屬性。</xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>       在.NET framework 1.0 和 1.1 版中，主應用程式執行緒以外的執行緒中發生未處理例外狀況捕捉到的執行階段，因此不會造成應用程式結束。 因此，它可能會 UnhandledException 引發的事件，而不需要應用程式終止。 從.NET Framework 2.0 版開始，這個子執行緒中的未處理例外狀況的支援已移除，因為這類的無訊息失敗的累積效果包含效能降低、 損毀的資料和鎖定，且很難進行偵錯。 如需詳細資訊，包括清單的情況下，執行階段不會終止，請參閱[Managed 執行緒中的例外狀況](~/add/includes/ajax-current-ext-md.md)。       若要註冊此事件的事件處理常式，您必須擁有必要的權限，或<xref:System.Security.SecurityException>就會擲回。</xref:System.Security.SecurityException>       如需處理事件的詳細資訊，請參閱[事件](~/add/includes/ajax-current-ext-md.md)。      ## 其他事件的未處理例外狀況的特定應用程式模型，事件可以清空的其他事件，如果主應用程式執行緒中發生未處理的例外狀況之 UnhandledException。       使用 Windows Form 應用程式，在未處理主應用程式執行緒發生原因的例外狀況<xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName>會引發事件。</xref:System.Windows.Forms.Application.ThreadException?displayProperty=fullName> 如果處理此事件，預設行為是未處理的例外狀況不會終止該應用程式，雖然應用程式處於未知狀態。 在此情況下，不會引發 UnhandledException 事件。 可以變更此行為，藉由使用應用程式組態檔，或是利用<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName>方法，以將模式變更為<xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName>之前的<xref:System.Windows.Forms.Application.ThreadException>事件處理常式是勾的註冊。</xref:System.Windows.Forms.Application.ThreadException> </xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=fullName> </xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=fullName> 只適用於主應用程式執行緒。 UnhandledException 事件都會引發在其他執行緒中擲回未處理的例外狀況。       從 Microsoft Visual Studio 2005 開始，Visual Basic 應用程式架構可以提供另一個事件中主應用程式執行緒的未處理例外狀況。 請參閱<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName>事件。</xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=fullName> 這個事件必須與 UnhandledException，所使用的事件引數物件同名但具有不同屬性的事件引數物件。 特別是，此事件的引數物件具有<xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>屬性，可讓應用程式繼續執行，而忽略未處理的例外狀況 （並讓應用程式處於未知狀態）。</xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> 在此情況下，不會引發 UnhandledException 事件。"
  example:
  - "The followingexample demonstrates the UnhandledException event. It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain. It then throws two exceptions. The first is handled by a **try/catch** block. The second is unhandled and invokes the `MyHandle` routine before the application terminates.  \n  \n [!code-cs[AppDomain_UnhandledException#1](~/add/codesnippet/csharp/e-system.appdomain.unhan_1.cs)]\n [!code-vb[AppDomain_UnhandledException#1](~/add/codesnippet/visualbasic/e-system.appdomain.unhan_1.vb)]\n [!code-cpp[AppDomain_UnhandledException#1](~/add/codesnippet/cpp/e-system.appdomain.unhan_1.cpp)]"
  syntax:
    content: public event UnhandledExceptionEventHandler UnhandledException;
    return:
      type: System.UnhandledExceptionEventHandler
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.AppDomain.Unload(System.AppDomain)
  id: Unload(System.AppDomain)
  parent: System.AppDomain
  langs:
  - csharp
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "卸載指定的應用程式定義域。"
  remarks: ".NET Framework 2.0 版中已有執行緒專門用來卸載應用程式定義域。 這可改善可靠性，尤其是當裝載.NET Framework。 當執行緒呼叫卸載時，目標網域已標示為卸載。 專用的執行緒嘗試卸載定義域，並在網域中的所有執行緒都會都中止。 如果執行緒不會中止，例如因為它正在執行 unmanaged 程式碼，或因為它正在執行`finally`區塊，然後在一段時間之後<xref:System.CannotUnloadAppDomainException>初次呼叫卸載執行緒擲回。</xref:System.CannotUnloadAppDomainException> 如果無法最終中止的執行緒結束，則目標網域未卸載。 因此，在.NET Framework 2.0 版`domain`不保證卸除，因為它可能無法終止正在執行的執行緒。      > [!NOTE] > 在某些情況下，呼叫卸載會導致立即<xref:System.CannotUnloadAppDomainException>，例如如果呼叫在完成項。</xref:System.CannotUnloadAppDomainException>       中的執行緒`domain`使用終止<xref:System.Threading.Thread.Abort%2A>方法，就會擲回<xref:System.Threading.ThreadAbortException>執行緒中。</xref:System.Threading.ThreadAbortException> </xref:System.Threading.Thread.Abort%2A> 雖然執行緒應該會立即結束，它會繼續執行的無法預期的時間量以`finally`子句。      ## 版本相容性 In the.NET Framework 1.0 和 1.1，如果在執行之執行緒的呼叫卸載`domain`，另一個執行緒已啟動執行卸載作業。 如果`domain`無法卸載，<xref:System.CannotUnloadAppDomainException>不在原始執行緒呼叫卸載該執行緒中擲回。</xref:System.CannotUnloadAppDomainException> 不過，如果呼叫執行緒卸載外部執行`domain`，執行緒會收到例外狀況。"
  example:
  - "The following code example shows how to unload an application domain.  \n  \n [!code-cpp[ADUnload#1](~/add/codesnippet/cpp/m-system.appdomain.unloa_1.cpp)]\n [!code-vb[ADUnload#1](~/add/codesnippet/visualbasic/m-system.appdomain.unloa_1.vb)]\n [!code-cs[ADUnload#1](~/add/codesnippet/csharp/m-system.appdomain.unloa_1.cs)]"
  syntax:
    content: public static void Unload (AppDomain domain);
    parameters:
    - id: domain
      type: System.AppDomain
      description: "卸載應用程式定義域。"
  overload: System.AppDomain.Unload*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>domain</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.CannotUnloadAppDomainException
    commentId: T:System.CannotUnloadAppDomainException
    description: "<code>domain</code>無法卸載。"
  - type: System.Exception
    commentId: T:System.Exception
    description: "卸載程序期間發生錯誤。"
  platform:
  - net462
references:
- uid: System.MarshalByRefObject
  isExternal: false
  name: System.MarshalByRefObject
- uid: System.AppDomainUnloadedException
  parent: System
  isExternal: false
  name: AppDomainUnloadedException
  nameWithType: AppDomainUnloadedException
  fullName: System.AppDomainUnloadedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.TypeLoadException
  isExternal: true
  name: System.TypeLoadException
- uid: System.MissingMethodException
  isExternal: true
  name: System.MissingMethodException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.MemberAccessException
  isExternal: true
  name: System.MemberAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.BadImageFormatException
  isExternal: true
  name: System.BadImageFormatException
- uid: System.IO.FileLoadException
  isExternal: true
  name: System.IO.FileLoadException
- uid: System.NullReferenceException
  isExternal: true
  name: System.NullReferenceException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.MethodAccessException
  isExternal: true
  name: System.MethodAccessException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.Security.Policy.PolicyException
  parent: System.Security.Policy
  isExternal: false
  name: PolicyException
  nameWithType: PolicyException
  fullName: System.Security.Policy.PolicyException
- uid: System.NotImplementedException
  isExternal: true
  name: System.NotImplementedException
- uid: System.CannotUnloadAppDomainException
  parent: System
  isExternal: false
  name: CannotUnloadAppDomainException
  nameWithType: CannotUnloadAppDomainException
  fullName: System.CannotUnloadAppDomainException
- uid: System.Exception
  isExternal: true
  name: System.Exception
- uid: System.AppDomain.ActivationContext
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
  fullName: System.AppDomain.ActivationContext
- uid: System.ActivationContext
  parent: System
  isExternal: false
  name: ActivationContext
  nameWithType: ActivationContext
  fullName: System.ActivationContext
- uid: System.AppDomain.AppendPrivatePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath(String)
  nameWithType: AppDomain.AppendPrivatePath(String)
  fullName: System.AppDomain.AppendPrivatePath(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.AppDomain.ApplicationIdentity
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
  fullName: System.AppDomain.ApplicationIdentity
- uid: System.ApplicationIdentity
  parent: System
  isExternal: false
  name: ApplicationIdentity
  nameWithType: ApplicationIdentity
  fullName: System.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
  fullName: System.AppDomain.ApplicationTrust
- uid: System.Security.Policy.ApplicationTrust
  parent: System.Security.Policy
  isExternal: false
  name: ApplicationTrust
  nameWithType: ApplicationTrust
  fullName: System.Security.Policy.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy(String)
  nameWithType: AppDomain.ApplyPolicy(String)
  fullName: System.AppDomain.ApplyPolicy(String)
- uid: System.AppDomain.AssemblyLoad
  parent: System.AppDomain
  isExternal: false
  name: AssemblyLoad
  nameWithType: AppDomain.AssemblyLoad
  fullName: System.AppDomain.AssemblyLoad
- uid: System.AssemblyLoadEventHandler
  parent: System
  isExternal: false
  name: AssemblyLoadEventHandler
  nameWithType: AssemblyLoadEventHandler
  fullName: System.AssemblyLoadEventHandler
- uid: System.AppDomain.AssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: AssemblyResolve
  nameWithType: AppDomain.AssemblyResolve
  fullName: System.AppDomain.AssemblyResolve
- uid: System.ResolveEventHandler
  parent: System
  isExternal: false
  name: ResolveEventHandler
  nameWithType: ResolveEventHandler
  fullName: System.ResolveEventHandler
- uid: System.AppDomain.BaseDirectory
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
  fullName: System.AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath()
  nameWithType: AppDomain.ClearPrivatePath()
  fullName: System.AppDomain.ClearPrivatePath()
- uid: System.AppDomain.ClearShadowCopyPath
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath()
  nameWithType: AppDomain.ClearShadowCopyPath()
  fullName: System.AppDomain.ClearShadowCopyPath()
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String)
- uid: System.Runtime.Remoting.ObjectHandle
  parent: System.Runtime.Remoting
  isExternal: false
  name: ObjectHandle
  nameWithType: ObjectHandle
  fullName: System.Runtime.Remoting.ObjectHandle
- uid: System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.CreateComInstanceFrom(String,String,Byte[],AssemblyHashAlgorithm)
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Configuration.Assemblies.AssemblyHashAlgorithm
  parent: System.Configuration.Assemblies
  isExternal: false
  name: AssemblyHashAlgorithm
  nameWithType: AssemblyHashAlgorithm
  fullName: System.Configuration.Assemblies.AssemblyHashAlgorithm
- uid: System.AppDomain.CreateDomain(System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String)
  nameWithType: AppDomain.CreateDomain(String)
  fullName: System.AppDomain.CreateDomain(String)
- uid: System.AppDomain
  parent: System
  isExternal: false
  name: AppDomain
  nameWithType: AppDomain
  fullName: System.AppDomain
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence)
  nameWithType: AppDomain.CreateDomain(String,Evidence)
  fullName: System.AppDomain.CreateDomain(String,Evidence)
- uid: System.Security.Policy.Evidence
  parent: System.Security.Policy
  isExternal: false
  name: Evidence
  nameWithType: Evidence
  fullName: System.Security.Policy.Evidence
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup)
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup)
- uid: System.AppDomainSetup
  parent: System
  isExternal: false
  name: AppDomainSetup
  nameWithType: AppDomainSetup
  fullName: System.AppDomainSetup
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,AppDomainSetup,PermissionSet,StrongName[])
- uid: System.Security.PermissionSet
  parent: System.Security
  isExternal: false
  name: PermissionSet
  nameWithType: PermissionSet
  fullName: System.Security.PermissionSet
- uid: System.Security.Policy.StrongName[]
  parent: System.Security.Policy
  isExternal: false
  name: StrongName
  nameWithType: StrongName
  fullName: System.Security.Policy.StrongName[]
  spec.csharp:
  - uid: System.Security.Policy.StrongName
    name: StrongName
    nameWithType: StrongName
    fullName: StrongName[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean)
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  nameWithType: AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
  fullName: System.AppDomain.CreateDomain(String,Evidence,String,String,Boolean,AppDomainInitializer,String[])
- uid: System.AppDomainInitializer
  parent: System
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainInitializer
  fullName: System.AppDomainInitializer
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String)
  nameWithType: AppDomain.CreateInstance(String,String)
  fullName: System.AppDomain.CreateInstance(String,String)
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Object[])
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.Reflection.BindingFlags
  parent: System.Reflection
  isExternal: false
  name: BindingFlags
  nameWithType: BindingFlags
  fullName: System.Reflection.BindingFlags
- uid: System.Reflection.Binder
  parent: System.Reflection
  isExternal: false
  name: Binder
  nameWithType: Binder
  fullName: System.Reflection.Binder
- uid: System.Globalization.CultureInfo
  parent: System.Globalization
  isExternal: true
  name: CultureInfo
  nameWithType: CultureInfo
  fullName: System.Globalization.CultureInfo
- uid: System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstance(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String)
  nameWithType: AppDomain.CreateInstanceFrom(String,String)
  fullName: System.AppDomain.CreateInstanceFrom(String,String)
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFrom(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String)
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[])
- uid: System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
  fullName: System.AppDomain.CreateInstanceFromAndUnwrap(String,String,Boolean,BindingFlags,Binder,Object[],CultureInfo,Object[],Evidence)
- uid: System.AppDomain.CurrentDomain
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
  fullName: System.AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess)
- uid: System.Reflection.Emit.AssemblyBuilder
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilder
  nameWithType: AssemblyBuilder
  fullName: System.Reflection.Emit.AssemblyBuilder
- uid: System.Reflection.AssemblyName
  parent: System.Reflection
  isExternal: true
  name: AssemblyName
  nameWithType: AssemblyName
  fullName: System.Reflection.AssemblyName
- uid: System.Reflection.Emit.AssemblyBuilderAccess
  parent: System.Reflection.Emit
  isExternal: true
  name: AssemblyBuilderAccess
  nameWithType: AssemblyBuilderAccess
  fullName: System.Reflection.Emit.AssemblyBuilderAccess
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>)
- uid: System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<CustomAttributeBuilder>
  nameWithType: IEnumerable<CustomAttributeBuilder>
  fullName: System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.Reflection.Emit.CustomAttributeBuilder>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Reflection.Emit.CustomAttributeBuilder
    name: CustomAttributeBuilder
    nameWithType: CustomAttributeBuilder
    fullName: CustomAttributeBuilder
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,IEnumerable<CustomAttributeBuilder>,SecurityContextSource)
- uid: System.Security.SecurityContextSource
  parent: System.Security
  isExternal: false
  name: SecurityContextSource
  nameWithType: SecurityContextSource
  fullName: System.Security.SecurityContextSource
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean)
- uid: System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  nameWithType: AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
  fullName: System.AppDomain.DefineDynamicAssembly(AssemblyName,AssemblyBuilderAccess,String,Evidence,PermissionSet,PermissionSet,PermissionSet,Boolean,IEnumerable<CustomAttributeBuilder>)
- uid: System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack(CrossAppDomainDelegate)
  nameWithType: AppDomain.DoCallBack(CrossAppDomainDelegate)
  fullName: System.AppDomain.DoCallBack(CrossAppDomainDelegate)
- uid: System.CrossAppDomainDelegate
  parent: System
  isExternal: false
  name: CrossAppDomainDelegate
  nameWithType: CrossAppDomainDelegate
  fullName: System.CrossAppDomainDelegate
- uid: System.AppDomain.DomainManager
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
  fullName: System.AppDomain.DomainManager
- uid: System.AppDomainManager
  parent: System
  isExternal: false
  name: AppDomainManager
  nameWithType: AppDomainManager
  fullName: System.AppDomainManager
- uid: System.AppDomain.DomainUnload
  parent: System.AppDomain
  isExternal: false
  name: DomainUnload
  nameWithType: AppDomain.DomainUnload
  fullName: System.AppDomain.DomainUnload
- uid: System.EventHandler
  parent: System
  isExternal: true
  name: EventHandler
  nameWithType: EventHandler
  fullName: System.EventHandler
- uid: System.AppDomain.DynamicDirectory
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
  fullName: System.AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
  fullName: System.AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String)
  nameWithType: AppDomain.ExecuteAssembly(String)
  fullName: System.AppDomain.ExecuteAssembly(String)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[])
- uid: System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  nameWithType: AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
  fullName: System.AppDomain.ExecuteAssembly(String,Evidence,String[],Byte[],AssemblyHashAlgorithm)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String)
  nameWithType: AppDomain.ExecuteAssemblyByName(String)
  fullName: System.AppDomain.ExecuteAssemblyByName(String)
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence)
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence)
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence)
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(AssemblyName,Evidence,String[])
- uid: System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName(String,Evidence,String[])
  nameWithType: AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
  fullName: System.AppDomain.ExecuteAssemblyByName(String,Evidence,String[])
- uid: System.AppDomain.FirstChanceException
  parent: System.AppDomain
  isExternal: false
  name: FirstChanceException
  nameWithType: AppDomain.FirstChanceException
  fullName: System.AppDomain.FirstChanceException
- uid: System.EventHandler{System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<FirstChanceExceptionEventArgs>
  nameWithType: EventHandler<FirstChanceExceptionEventArgs>
  fullName: System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs
    name: FirstChanceExceptionEventArgs
    nameWithType: FirstChanceExceptionEventArgs
    fullName: FirstChanceExceptionEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.FriendlyName
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
  fullName: System.AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies()
  nameWithType: AppDomain.GetAssemblies()
  fullName: System.AppDomain.GetAssemblies()
- uid: System.Reflection.Assembly[]
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly[]
  spec.csharp:
  - uid: System.Reflection.Assembly
    name: Assembly
    nameWithType: Assembly
    fullName: Assembly[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomain.GetCurrentThreadId
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId()
  nameWithType: AppDomain.GetCurrentThreadId()
  fullName: System.AppDomain.GetCurrentThreadId()
- uid: System.AppDomain.GetData(System.String)
  parent: System.AppDomain
  isExternal: false
  name: GetData(String)
  nameWithType: AppDomain.GetData(String)
  fullName: System.AppDomain.GetData(String)
- uid: System.AppDomain.GetType
  parent: System.AppDomain
  isExternal: false
  name: GetType()
  nameWithType: AppDomain.GetType()
  fullName: System.AppDomain.GetType()
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.AppDomain.Id
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
  fullName: System.AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService()
  nameWithType: AppDomain.InitializeLifetimeService()
  fullName: System.AppDomain.InitializeLifetimeService()
- uid: System.AppDomain.IsCompatibilitySwitchSet(System.String)
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet(String)
  nameWithType: AppDomain.IsCompatibilitySwitchSet(String)
  fullName: System.AppDomain.IsCompatibilitySwitchSet(String)
- uid: System.Nullable{System.Boolean}
  parent: System
  isExternal: true
  name: Nullable<Boolean>
  nameWithType: Nullable<Boolean>
  fullName: System.Nullable<System.Boolean>
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    nameWithType: Nullable
    fullName: Nullable<System.Boolean>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    nameWithType: Boolean
    fullName: Boolean
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomain.IsDefaultAppDomain
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain()
  nameWithType: AppDomain.IsDefaultAppDomain()
  fullName: System.AppDomain.IsDefaultAppDomain()
- uid: System.AppDomain.IsFinalizingForUnload
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload()
  nameWithType: AppDomain.IsFinalizingForUnload()
  fullName: System.AppDomain.IsFinalizingForUnload()
- uid: System.AppDomain.IsFullyTrusted
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
  fullName: System.AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
  fullName: System.AppDomain.IsHomogenous
- uid: System.AppDomain.Load(System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[])
  nameWithType: AppDomain.Load(Byte[])
  fullName: System.AppDomain.Load(Byte[])
- uid: System.Reflection.Assembly
  parent: System.Reflection
  isExternal: true
  name: Assembly
  nameWithType: Assembly
  fullName: System.Reflection.Assembly
- uid: System.AppDomain.Load(System.Reflection.AssemblyName)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName)
  nameWithType: AppDomain.Load(AssemblyName)
  fullName: System.AppDomain.Load(AssemblyName)
- uid: System.AppDomain.Load(System.String)
  parent: System.AppDomain
  isExternal: false
  name: Load(String)
  nameWithType: AppDomain.Load(String)
  fullName: System.AppDomain.Load(String)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[])
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[])
  nameWithType: AppDomain.Load(Byte[],Byte[])
  fullName: System.AppDomain.Load(Byte[],Byte[])
- uid: System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(AssemblyName,Evidence)
  nameWithType: AppDomain.Load(AssemblyName,Evidence)
  fullName: System.AppDomain.Load(AssemblyName,Evidence)
- uid: System.AppDomain.Load(System.String,System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(String,Evidence)
  nameWithType: AppDomain.Load(String,Evidence)
  fullName: System.AppDomain.Load(String,Evidence)
- uid: System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)
  parent: System.AppDomain
  isExternal: false
  name: Load(Byte[],Byte[],Evidence)
  nameWithType: AppDomain.Load(Byte[],Byte[],Evidence)
  fullName: System.AppDomain.Load(Byte[],Byte[],Evidence)
- uid: System.AppDomain.MonitoringIsEnabled
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
  fullName: System.AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
  fullName: System.AppDomain.MonitoringSurvivedMemorySize
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
  fullName: System.AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
  fullName: System.AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
  fullName: System.AppDomain.MonitoringTotalProcessorTime
- uid: System.TimeSpan
  parent: System
  isExternal: true
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
- uid: System.AppDomain.PermissionSet
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
  fullName: System.AppDomain.PermissionSet
- uid: System.AppDomain.ProcessExit
  parent: System.AppDomain
  isExternal: false
  name: ProcessExit
  nameWithType: AppDomain.ProcessExit
  fullName: System.AppDomain.ProcessExit
- uid: System.AppDomain.ReflectionOnlyAssemblyResolve
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyAssemblyResolve
  nameWithType: AppDomain.ReflectionOnlyAssemblyResolve
  fullName: System.AppDomain.ReflectionOnlyAssemblyResolve
- uid: System.AppDomain.ReflectionOnlyGetAssemblies
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies()
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies()
  fullName: System.AppDomain.ReflectionOnlyGetAssemblies()
- uid: System.AppDomain.RelativeSearchPath
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
  fullName: System.AppDomain.RelativeSearchPath
- uid: System.AppDomain.ResourceResolve
  parent: System.AppDomain
  isExternal: false
  name: ResourceResolve
  nameWithType: AppDomain.ResourceResolve
  fullName: System.AppDomain.ResourceResolve
- uid: System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy(PolicyLevel)
  nameWithType: AppDomain.SetAppDomainPolicy(PolicyLevel)
  fullName: System.AppDomain.SetAppDomainPolicy(PolicyLevel)
- uid: System.Security.Policy.PolicyLevel
  parent: System.Security.Policy
  isExternal: false
  name: PolicyLevel
  nameWithType: PolicyLevel
  fullName: System.Security.Policy.PolicyLevel
- uid: System.AppDomain.SetCachePath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath(String)
  nameWithType: AppDomain.SetCachePath(String)
  fullName: System.AppDomain.SetCachePath(String)
- uid: System.AppDomain.SetData(System.String,System.Object)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object)
  nameWithType: AppDomain.SetData(String,Object)
  fullName: System.AppDomain.SetData(String,Object)
- uid: System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)
  parent: System.AppDomain
  isExternal: false
  name: SetData(String,Object,IPermission)
  nameWithType: AppDomain.SetData(String,Object,IPermission)
  fullName: System.AppDomain.SetData(String,Object,IPermission)
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.AppDomain.SetDynamicBase(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase(String)
  nameWithType: AppDomain.SetDynamicBase(String)
  fullName: System.AppDomain.SetDynamicBase(String)
- uid: System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy(PrincipalPolicy)
  nameWithType: AppDomain.SetPrincipalPolicy(PrincipalPolicy)
  fullName: System.AppDomain.SetPrincipalPolicy(PrincipalPolicy)
- uid: System.Security.Principal.PrincipalPolicy
  parent: System.Security.Principal
  isExternal: false
  name: PrincipalPolicy
  nameWithType: PrincipalPolicy
  fullName: System.Security.Principal.PrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles()
  nameWithType: AppDomain.SetShadowCopyFiles()
  fullName: System.AppDomain.SetShadowCopyFiles()
- uid: System.AppDomain.SetShadowCopyPath(System.String)
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath(String)
  nameWithType: AppDomain.SetShadowCopyPath(String)
  fullName: System.AppDomain.SetShadowCopyPath(String)
- uid: System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal(IPrincipal)
  nameWithType: AppDomain.SetThreadPrincipal(IPrincipal)
  fullName: System.AppDomain.SetThreadPrincipal(IPrincipal)
- uid: System.Security.Principal.IPrincipal
  parent: System.Security.Principal
  isExternal: true
  name: IPrincipal
  nameWithType: IPrincipal
  fullName: System.Security.Principal.IPrincipal
- uid: System.AppDomain.SetupInformation
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
  fullName: System.AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
  fullName: System.AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)
- uid: System.Guid
  parent: System
  isExternal: true
  name: Guid
  nameWithType: Guid
  fullName: System.Guid
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.UInt32
  parent: System
  isExternal: true
  name: UInt32
  nameWithType: UInt32
  fullName: System.UInt32
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfo(UInt32,UInt32,IntPtr)
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount(UInt32)
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
  fullName: System.AppDomain.System._AppDomain.GetTypeInfoCount(UInt32)
- uid: System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  nameWithType: AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
  fullName: System.AppDomain.System._AppDomain.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)
- uid: System.Int16
  parent: System
  isExternal: true
  name: Int16
  nameWithType: Int16
  fullName: System.Int16
- uid: System.AppDomain.ToString
  parent: System.AppDomain
  isExternal: false
  name: ToString()
  nameWithType: AppDomain.ToString()
  fullName: System.AppDomain.ToString()
- uid: System.AppDomain.TypeResolve
  parent: System.AppDomain
  isExternal: false
  name: TypeResolve
  nameWithType: AppDomain.TypeResolve
  fullName: System.AppDomain.TypeResolve
- uid: System.AppDomain.UnhandledException
  parent: System.AppDomain
  isExternal: false
  name: UnhandledException
  nameWithType: AppDomain.UnhandledException
  fullName: System.AppDomain.UnhandledException
- uid: System.UnhandledExceptionEventHandler
  parent: System
  isExternal: false
  name: UnhandledExceptionEventHandler
  nameWithType: UnhandledExceptionEventHandler
  fullName: System.UnhandledExceptionEventHandler
- uid: System.AppDomain.Unload(System.AppDomain)
  parent: System.AppDomain
  isExternal: false
  name: Unload(AppDomain)
  nameWithType: AppDomain.Unload(AppDomain)
  fullName: System.AppDomain.Unload(AppDomain)
- uid: System.AppDomain.ActivationContext*
  parent: System.AppDomain
  isExternal: false
  name: ActivationContext
  nameWithType: AppDomain.ActivationContext
- uid: System.AppDomain.AppendPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: AppendPrivatePath
  nameWithType: AppDomain.AppendPrivatePath
- uid: System.AppDomain.ApplicationIdentity*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationIdentity
  nameWithType: AppDomain.ApplicationIdentity
- uid: System.AppDomain.ApplicationTrust*
  parent: System.AppDomain
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomain.ApplicationTrust
- uid: System.AppDomain.ApplyPolicy*
  parent: System.AppDomain
  isExternal: false
  name: ApplyPolicy
  nameWithType: AppDomain.ApplyPolicy
- uid: System.AppDomain.BaseDirectory*
  parent: System.AppDomain
  isExternal: false
  name: BaseDirectory
  nameWithType: AppDomain.BaseDirectory
- uid: System.AppDomain.ClearPrivatePath*
  parent: System.AppDomain
  isExternal: false
  name: ClearPrivatePath
  nameWithType: AppDomain.ClearPrivatePath
- uid: System.AppDomain.ClearShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: ClearShadowCopyPath
  nameWithType: AppDomain.ClearShadowCopyPath
- uid: System.AppDomain.CreateComInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateComInstanceFrom
  nameWithType: AppDomain.CreateComInstanceFrom
- uid: System.AppDomain.CreateDomain*
  parent: System.AppDomain
  isExternal: false
  name: CreateDomain
  nameWithType: AppDomain.CreateDomain
- uid: System.AppDomain.CreateInstance*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstance
  nameWithType: AppDomain.CreateInstance
- uid: System.AppDomain.CreateInstanceAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceAndUnwrap
  nameWithType: AppDomain.CreateInstanceAndUnwrap
- uid: System.AppDomain.CreateInstanceFrom*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFrom
  nameWithType: AppDomain.CreateInstanceFrom
- uid: System.AppDomain.CreateInstanceFromAndUnwrap*
  parent: System.AppDomain
  isExternal: false
  name: CreateInstanceFromAndUnwrap
  nameWithType: AppDomain.CreateInstanceFromAndUnwrap
- uid: System.AppDomain.CurrentDomain*
  parent: System.AppDomain
  isExternal: false
  name: CurrentDomain
  nameWithType: AppDomain.CurrentDomain
- uid: System.AppDomain.DefineDynamicAssembly*
  parent: System.AppDomain
  isExternal: false
  name: DefineDynamicAssembly
  nameWithType: AppDomain.DefineDynamicAssembly
- uid: System.AppDomain.DoCallBack*
  parent: System.AppDomain
  isExternal: false
  name: DoCallBack
  nameWithType: AppDomain.DoCallBack
- uid: System.AppDomain.DomainManager*
  parent: System.AppDomain
  isExternal: false
  name: DomainManager
  nameWithType: AppDomain.DomainManager
- uid: System.AppDomain.DynamicDirectory*
  parent: System.AppDomain
  isExternal: false
  name: DynamicDirectory
  nameWithType: AppDomain.DynamicDirectory
- uid: System.AppDomain.Evidence*
  parent: System.AppDomain
  isExternal: false
  name: Evidence
  nameWithType: AppDomain.Evidence
- uid: System.AppDomain.ExecuteAssembly*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssembly
  nameWithType: AppDomain.ExecuteAssembly
- uid: System.AppDomain.ExecuteAssemblyByName*
  parent: System.AppDomain
  isExternal: false
  name: ExecuteAssemblyByName
  nameWithType: AppDomain.ExecuteAssemblyByName
- uid: System.AppDomain.FriendlyName*
  parent: System.AppDomain
  isExternal: false
  name: FriendlyName
  nameWithType: AppDomain.FriendlyName
- uid: System.AppDomain.GetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: GetAssemblies
  nameWithType: AppDomain.GetAssemblies
- uid: System.AppDomain.GetCurrentThreadId*
  parent: System.AppDomain
  isExternal: false
  name: GetCurrentThreadId
  nameWithType: AppDomain.GetCurrentThreadId
- uid: System.AppDomain.GetData*
  parent: System.AppDomain
  isExternal: false
  name: GetData
  nameWithType: AppDomain.GetData
- uid: System.AppDomain.GetType*
  parent: System.AppDomain
  isExternal: false
  name: GetType
  nameWithType: AppDomain.GetType
- uid: System.AppDomain.Id*
  parent: System.AppDomain
  isExternal: false
  name: Id
  nameWithType: AppDomain.Id
- uid: System.AppDomain.InitializeLifetimeService*
  parent: System.AppDomain
  isExternal: false
  name: InitializeLifetimeService
  nameWithType: AppDomain.InitializeLifetimeService
- uid: System.AppDomain.IsCompatibilitySwitchSet*
  parent: System.AppDomain
  isExternal: false
  name: IsCompatibilitySwitchSet
  nameWithType: AppDomain.IsCompatibilitySwitchSet
- uid: System.AppDomain.IsDefaultAppDomain*
  parent: System.AppDomain
  isExternal: false
  name: IsDefaultAppDomain
  nameWithType: AppDomain.IsDefaultAppDomain
- uid: System.AppDomain.IsFinalizingForUnload*
  parent: System.AppDomain
  isExternal: false
  name: IsFinalizingForUnload
  nameWithType: AppDomain.IsFinalizingForUnload
- uid: System.AppDomain.IsFullyTrusted*
  parent: System.AppDomain
  isExternal: false
  name: IsFullyTrusted
  nameWithType: AppDomain.IsFullyTrusted
- uid: System.AppDomain.IsHomogenous*
  parent: System.AppDomain
  isExternal: false
  name: IsHomogenous
  nameWithType: AppDomain.IsHomogenous
- uid: System.AppDomain.Load*
  parent: System.AppDomain
  isExternal: false
  name: Load
  nameWithType: AppDomain.Load
- uid: System.AppDomain.MonitoringIsEnabled*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringIsEnabled
  nameWithType: AppDomain.MonitoringIsEnabled
- uid: System.AppDomain.MonitoringSurvivedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedMemorySize
  nameWithType: AppDomain.MonitoringSurvivedMemorySize
- uid: System.AppDomain.MonitoringSurvivedProcessMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringSurvivedProcessMemorySize
  nameWithType: AppDomain.MonitoringSurvivedProcessMemorySize
- uid: System.AppDomain.MonitoringTotalAllocatedMemorySize*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalAllocatedMemorySize
  nameWithType: AppDomain.MonitoringTotalAllocatedMemorySize
- uid: System.AppDomain.MonitoringTotalProcessorTime*
  parent: System.AppDomain
  isExternal: false
  name: MonitoringTotalProcessorTime
  nameWithType: AppDomain.MonitoringTotalProcessorTime
- uid: System.AppDomain.PermissionSet*
  parent: System.AppDomain
  isExternal: false
  name: PermissionSet
  nameWithType: AppDomain.PermissionSet
- uid: System.AppDomain.ReflectionOnlyGetAssemblies*
  parent: System.AppDomain
  isExternal: false
  name: ReflectionOnlyGetAssemblies
  nameWithType: AppDomain.ReflectionOnlyGetAssemblies
- uid: System.AppDomain.RelativeSearchPath*
  parent: System.AppDomain
  isExternal: false
  name: RelativeSearchPath
  nameWithType: AppDomain.RelativeSearchPath
- uid: System.AppDomain.SetAppDomainPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetAppDomainPolicy
  nameWithType: AppDomain.SetAppDomainPolicy
- uid: System.AppDomain.SetCachePath*
  parent: System.AppDomain
  isExternal: false
  name: SetCachePath
  nameWithType: AppDomain.SetCachePath
- uid: System.AppDomain.SetData*
  parent: System.AppDomain
  isExternal: false
  name: SetData
  nameWithType: AppDomain.SetData
- uid: System.AppDomain.SetDynamicBase*
  parent: System.AppDomain
  isExternal: false
  name: SetDynamicBase
  nameWithType: AppDomain.SetDynamicBase
- uid: System.AppDomain.SetPrincipalPolicy*
  parent: System.AppDomain
  isExternal: false
  name: SetPrincipalPolicy
  nameWithType: AppDomain.SetPrincipalPolicy
- uid: System.AppDomain.SetShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyFiles
  nameWithType: AppDomain.SetShadowCopyFiles
- uid: System.AppDomain.SetShadowCopyPath*
  parent: System.AppDomain
  isExternal: false
  name: SetShadowCopyPath
  nameWithType: AppDomain.SetShadowCopyPath
- uid: System.AppDomain.SetThreadPrincipal*
  parent: System.AppDomain
  isExternal: false
  name: SetThreadPrincipal
  nameWithType: AppDomain.SetThreadPrincipal
- uid: System.AppDomain.SetupInformation*
  parent: System.AppDomain
  isExternal: false
  name: SetupInformation
  nameWithType: AppDomain.SetupInformation
- uid: System.AppDomain.ShadowCopyFiles*
  parent: System.AppDomain
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomain.ShadowCopyFiles
- uid: System.AppDomain.System#_AppDomain#GetIDsOfNames*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetIDsOfNames
  nameWithType: AppDomain.System._AppDomain.GetIDsOfNames
- uid: System.AppDomain.System#_AppDomain#GetTypeInfo*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfo
  nameWithType: AppDomain.System._AppDomain.GetTypeInfo
- uid: System.AppDomain.System#_AppDomain#GetTypeInfoCount*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.GetTypeInfoCount
  nameWithType: AppDomain.System._AppDomain.GetTypeInfoCount
- uid: System.AppDomain.System#_AppDomain#Invoke*
  parent: System.AppDomain
  isExternal: false
  name: System._AppDomain.Invoke
  nameWithType: AppDomain.System._AppDomain.Invoke
- uid: System.AppDomain.ToString*
  parent: System.AppDomain
  isExternal: false
  name: ToString
  nameWithType: AppDomain.ToString
- uid: System.AppDomain.Unload*
  parent: System.AppDomain
  isExternal: false
  name: Unload
  nameWithType: AppDomain.Unload
