### YamlMime:ManagedReference
items:
- uid: System.Net.Sockets.TcpListener
  id: TcpListener
  children:
  - System.Net.Sockets.TcpListener.#ctor(System.Int32)
  - System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  - System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  - System.Net.Sockets.TcpListener.AcceptSocket
  - System.Net.Sockets.TcpListener.AcceptSocketAsync
  - System.Net.Sockets.TcpListener.AcceptTcpClient
  - System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  - System.Net.Sockets.TcpListener.Active
  - System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)
  - System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)
  - System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  - System.Net.Sockets.TcpListener.Create(System.Int32)
  - System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)
  - System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)
  - System.Net.Sockets.TcpListener.ExclusiveAddressUse
  - System.Net.Sockets.TcpListener.LocalEndpoint
  - System.Net.Sockets.TcpListener.Pending
  - System.Net.Sockets.TcpListener.Server
  - System.Net.Sockets.TcpListener.Start
  - System.Net.Sockets.TcpListener.Start(System.Int32)
  - System.Net.Sockets.TcpListener.Stop
  langs:
  - csharp
  name: TcpListener
  nameWithType: TcpListener
  fullName: System.Net.Sockets.TcpListener
  type: Class
  summary: "會接聽 TCP 網路用戶端的連接。"
  remarks: "TcpListener 類別提供接聽及接受連入連線要求中封鎖同步模式的簡單方法。 您可以使用<xref:System.Net.Sockets.TcpClient>或<xref:System.Net.Sockets.Socket>要用來連接 TcpListener。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpClient> 建立 TcpListener 使用<xref:System.Net.IPEndPoint>，本機 IP 位址和連接埠號碼或連接埠的數字。</xref:System.Net.IPEndPoint> 指定<xref:System.Net.IPAddress.Any>本機 IP 位址和本機連接埠號碼，如果您希望基礎服務提供者，針對您指定這些值為 0。</xref:System.Net.IPAddress.Any> 如果您選擇這樣做，您可以使用<xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>內容來識別已指派的資訊之後已連接的通訊端。</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       使用<xref:System.Net.Sockets.TcpListener.Start%2A>開始接聽連入連線要求的方法。</xref:System.Net.Sockets.TcpListener.Start%2A> <xref:System.Net.Sockets.TcpListener.Start%2A>將佇列連入連線，直到您呼叫的<xref:System.Net.Sockets.TcpListener.Stop%2A>方法，或它已經排入佇列<xref:System.Net.Sockets.SocketOptionName>.</xref:System.Net.Sockets.SocketOptionName></xref:System.Net.Sockets.TcpListener.Stop%2A>嗎</xref:System.Net.Sockets.TcpListener.Start%2A> 使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>或<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>提取來自內送連接要求佇列的連接。</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> 這兩個方法會封鎖。 如果您想要避免封鎖，您可以使用<xref:System.Net.Sockets.TcpListener.Pending%2A>方法，以判斷連線要求是否有可用的佇列中。</xref:System.Net.Sockets.TcpListener.Pending%2A>       呼叫<xref:System.Net.Sockets.TcpListener.Stop%2A>方法，關閉 TcpListener。</xref:System.Net.Sockets.TcpListener.Stop%2A>      > [!NOTE] ><xref:System.Net.Sockets.TcpListener.Stop%2A>方法不會關閉任何已接受的連接。</xref:System.Net.Sockets.TcpListener.Stop%2A> 您必須負責個別關閉這些項目。"
  example:
  - "The following code example creates a TcpListener.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener#1](~/add/codesnippet/cpp/t-system.net.sockets.tcp_0_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener#1](~/add/codesnippet/csharp/t-system.net.sockets.tcp_0_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener#1](~/add/codesnippet/visualbasic/t-system.net.sockets.tcp_0_1.vb)]  \n  \n See <xref:System.Net.Sockets.TcpClient> for a client example."
  syntax:
    content: public class TcpListener
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: TcpListener(Int32)
  nameWithType: TcpListener.TcpListener(Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(Int32)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "初始化的新執行個體<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>指定通訊埠接聽的類別。"
  remarks: "這個建構函式已過時。 使用<xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=fullName>或<xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=fullName>建構函式。</xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=fullName> </xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=fullName>       這個建構函式可讓您指定要接聽連入連線嘗試的連接埠號碼。 這個建構函式，以基礎的服務提供者會指派最適當的網路位址。 如果您並不在意哪些本機連接埠使用，您可以指定連接埠號碼 0。 在此情況下，服務提供者會指派可用的通訊埠編號介於 1024年到 5000 之間。 如果您使用此方法時，您可以探索哪些本機網路位址和通訊埠編號已被指派使用<xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>屬性。</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       呼叫<xref:System.Net.Sockets.TcpListener.Start%2A>開始接聽連入連線嘗試的方法。</xref:System.Net.Sockets.TcpListener.Start%2A>"
  example:
  - "The following code example creates a <xref:System.Net.Sockets.TcpListener> using a local port number.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/cpp/m-system.net.sockets.tcp_18_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/csharp/m-system.net.sockets.tcp_18_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_18_1.vb)]"
  syntax:
    content: public TcpListener (int port);
    parameters:
    - id: port
      type: System.Int32
      description: "用來接聽連入連線嘗試的連接埠。"
  overload: System.Net.Sockets.TcpListener.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>port</code>不是介於<xref:System.Net.IPEndPoint.MinPort>和<xref:System.Net.IPEndPoint.MaxPort>。"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  id: '#ctor(System.Net.IPEndPoint)'
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: TcpListener(IPEndPoint)
  nameWithType: TcpListener.TcpListener(IPEndPoint)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPEndPoint)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "初始化的新執行個體<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>類別指定的本機端點。"
  remarks: "這個建構函式可讓您指定的本機 IP 位址和通訊埠編號上接聽連入連線嘗試。 之前使用這個建構函式，您必須建立<xref:System.Net.IPEndPoint>使用所需的本機 IP 位址和連接埠號碼。</xref:System.Net.IPEndPoint> 將此變數傳遞<xref:System.Net.IPEndPoint>做為建構函式`localEP`參數。</xref:System.Net.IPEndPoint>       如果您並不在意哪些本機位址指派，您可以建立<xref:System.Net.IPEndPoint>使用<xref:System.Net.IPAddress.Any?displayProperty=fullName>位址參數，以及基礎的服務提供者會指派最適當的網路位址。</xref:System.Net.IPAddress.Any?displayProperty=fullName> </xref:System.Net.IPEndPoint> 這有助於簡化您的應用程式，如果您有多個網路介面。 如果您並不在意哪些本機連接埠使用，您可以建立<xref:System.Net.IPEndPoint>使用連接埠號碼 0。</xref:System.Net.IPEndPoint> 在此情況下，服務提供者會指派可用的通訊埠編號介於 1024年到 5000 之間。 如果您使用此方法時，您可以探索哪些本機網路位址和通訊埠編號已被指派使用<xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>屬性。</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       呼叫<xref:System.Net.Sockets.TcpListener.Start%2A>開始接聽連入連線嘗試的方法。</xref:System.Net.Sockets.TcpListener.Start%2A>      > [!NOTE] > 應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example creates an instance of the <xref:System.Net.Sockets.TcpListener> class using the local endpoint.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_20_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_20_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_20_1.vb)]"
  syntax:
    content: public TcpListener (System.Net.IPEndPoint localEP);
    parameters:
    - id: localEP
      type: System.Net.IPEndPoint
      description: "<xref:System.Net.IPEndPoint>，代表要繫結<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>的接聽程式的本機端點</xref:System.Net.IPEndPoint>"
  overload: System.Net.Sockets.TcpListener.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>localEP</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  id: '#ctor(System.Net.IPAddress,System.Int32)'
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: TcpListener(IPAddress,Int32)
  nameWithType: TcpListener.TcpListener(IPAddress,Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPAddress,Int32)
  type: Constructor
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "初始化的新執行個體<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>接聽連入連線的類別會嘗試在指定的本機 IP 位址和連接埠號碼。"
  remarks: "這個建構函式可讓您指定的本機 IP 位址和通訊埠編號上接聽連入連線嘗試。 呼叫這個建構函式之前您必須先建立<xref:System.Net.IPAddress>使用所需的本機位址。</xref:System.Net.IPAddress> 將此變數傳遞<xref:System.Net.IPAddress>做為建構函式`localaddr`參數。</xref:System.Net.IPAddress> 如果您並不在意哪些本機位址指派，指定<xref:System.Net.IPAddress.Any?displayProperty=fullName>如`localaddr`參數和基礎的服務提供者將會指派最適當的網路位址。</xref:System.Net.IPAddress.Any?displayProperty=fullName> 這有助於簡化您的應用程式，如果您有多個網路介面。 如果您並不在意哪些本機連接埠使用，您可以指定連接埠號碼 0。 在此情況下，服務提供者會指派可用的通訊埠編號介於 1024年到 5000 之間。 如果您使用此方法時，您可以探索哪些本機網路位址和通訊埠編號已被指派使用<xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>屬性。</xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>       呼叫<xref:System.Net.Sockets.TcpListener.Start%2A>開始接聽連入連線嘗試的方法。</xref:System.Net.Sockets.TcpListener.Start%2A>      > [!NOTE] > 應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example creates an instance of the <xref:System.Net.Sockets.TcpListener> class using a local IP address and port number.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/cpp/m-system.net.sockets.tcp_19_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/csharp/m-system.net.sockets.tcp_19_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_19_1.vb)]"
  syntax:
    content: public TcpListener (System.Net.IPAddress localaddr, int port);
    parameters:
    - id: localaddr
      type: System.Net.IPAddress
      description: "<xref:System.Net.IPAddress>表示本機 IP 位址。</xref:System.Net.IPAddress>"
    - id: port
      type: System.Int32
      description: "用來接聽連入連線嘗試的連接埠。"
  overload: System.Net.Sockets.TcpListener.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>localaddr</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>port</code>不是介於<xref:System.Net.IPEndPoint.MinPort>和<xref:System.Net.IPEndPoint.MaxPort>。"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptSocket
  id: AcceptSocket
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptSocket()
  nameWithType: TcpListener.AcceptSocket()
  fullName: System.Net.Sockets.TcpListener.AcceptSocket()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "接受暫止的連接要求。"
  remarks: "AcceptSocket 是封鎖的方法會傳回<xref:System.Net.Sockets.Socket>可用來傳送和接收資料。</xref:System.Net.Sockets.Socket> 如果您想要避免封鎖，使用<xref:System.Net.Sockets.TcpListener.Pending%2A>方法來判斷連線要求是否有可用的連入連線佇列中。</xref:System.Net.Sockets.TcpListener.Pending%2A>       <xref:System.Net.Sockets.Socket>傳回初始化與遠端主機的 IP 位址和連接埠號碼。</xref:System.Net.Sockets.Socket> 您可以使用任一<xref:System.Net.Sockets.Socket.Send%2A>和<xref:System.Net.Sockets.Socket.Receive%2A>中可用的方法<xref:System.Net.Sockets.Socket>類別來與遠端主機通訊。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.Receive%2A> </xref:System.Net.Sockets.Socket.Send%2A> 完畢時使用<xref:System.Net.Sockets.Socket>，務必呼叫其<xref:System.Net.Sockets.Socket.Close%2A>方法。</xref:System.Net.Sockets.Socket.Close%2A> </xref:System.Net.Sockets.Socket> 如果您的應用程式相當簡單，請考慮使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法，而不是 AcceptSocket 方法。</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpClient>您提供簡單的方法來傳送和接收資料，透過封鎖同步模式中的網路。</xref:System.Net.Sockets.TcpClient>      > [!NOTE] > 應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "In the following code example, the AcceptSocket method is used to return a <xref:System.Net.Sockets.Socket>. This <xref:System.Net.Sockets.Socket> is used to communicate with the newly connected client.  \n  \n [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/cpp/m-system.net.sockets.tcp_7_1.cpp)]\n [!code-cs[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/csharp/m-system.net.sockets.tcp_7_1.cs)]\n [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_7_1.vb)]"
  syntax:
    content: public System.Net.Sockets.Socket AcceptSocket ();
    parameters: []
    return:
      type: System.Net.Sockets.Socket
      description: "A<xref:System.Net.Sockets.Socket>用來傳送和接收資料。</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.AcceptSocket*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "藉由呼叫<xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>尚未啟動接聽程式"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptSocketAsync
  id: AcceptSocketAsync
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptSocketAsync()
  nameWithType: TcpListener.AcceptSocketAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptSocketAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "以非同步作業會接受暫止的連接要求。"
  remarks: "這項作業不會封鎖。 傳回<xref:System.Threading.Tasks.Task%601>已接受通訊端連線之後，物件會完成。</xref:System.Threading.Tasks.Task%601>       <xref:System.Net.Sockets.Socket>中傳回<xref:System.Threading.Tasks.Task%601>初始化與遠端主機的 IP 位址和連接埠號碼。</xref:System.Threading.Tasks.Task%601> </xref:System.Net.Sockets.Socket> 您可以使用任一<xref:System.Net.Sockets.Socket.Send%2A>和<xref:System.Net.Sockets.Socket.Receive%2A>中可用的方法<xref:System.Net.Sockets.Socket>類別來與遠端主機通訊。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.Receive%2A> </xref:System.Net.Sockets.Socket.Send%2A> 完畢時使用<xref:System.Net.Sockets.Socket>，務必呼叫其<xref:System.Net.Sockets.Socket.Close%2A>方法。</xref:System.Net.Sockets.Socket.Close%2A> </xref:System.Net.Sockets.Socket> 如果您的應用程式相當簡單，請考慮使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法，而不是 AcceptSocketAsync 方法。</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpClient>您提供簡單的方法來傳送和接收資料，透過封鎖同步模式中的網路。</xref:System.Net.Sockets.TcpClient>      > [!NOTE] > 應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public System.Threading.Tasks.Task<System.Net.Sockets.Socket> AcceptSocketAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task{System.Net.Sockets.Socket}
      description: "傳回&lt;xref:System.Threading.Tasks.Task%601&gt;工作物件，表示非同步作業。 &lt;Xref:System.Threading.Tasks.Task%601.Result%2A&gt;工作物件上的屬性會傳回<xref:System.Net.Sockets.Socket>用來傳送和接收資料。</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.AcceptSocketAsync*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "藉由呼叫<xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>尚未啟動接聽程式"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptTcpClient
  id: AcceptTcpClient
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptTcpClient()
  nameWithType: TcpListener.AcceptTcpClient()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClient()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "接受暫止的連接要求。"
  remarks: "AcceptTcpClient 是封鎖的方法會傳回<xref:System.Net.Sockets.TcpClient>可用來傳送和接收資料。</xref:System.Net.Sockets.TcpClient> 使用<xref:System.Net.Sockets.TcpListener.Pending%2A>方法來判斷是否連線要求可以使用連入連線佇列，是否您想要避免封鎖。</xref:System.Net.Sockets.TcpListener.Pending%2A>       使用<xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName>方法，以取得基礎<xref:System.Net.Sockets.NetworkStream>的傳回<xref:System.Net.Sockets.TcpClient>。</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName> <xref:System.Net.Sockets.NetworkStream>會為您提供方法來傳送和接收的遠端主機。</xref:System.Net.Sockets.NetworkStream> 如果您是透過與<xref:System.Net.Sockets.TcpClient>，務必呼叫其<xref:System.Net.Sockets.TcpClient.Close%2A>方法。</xref:System.Net.Sockets.TcpClient.Close%2A> </xref:System.Net.Sockets.TcpClient> 如果您想要更大的彈性比<xref:System.Net.Sockets.TcpClient>提供，請考慮使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> </xref:System.Net.Sockets.TcpClient>      > [!NOTE] > 應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "In the following code example, the AcceptTcpClient method is used to return a <xref:System.Net.Sockets.TcpClient>. This <xref:System.Net.Sockets.TcpClient> is used to communicate with the newly connected client.  \n  \n [!code-cs[Classic TcpListenerExample#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_15_1.cs)]\n [!code-cpp[Classic TcpListenerExample#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_15_1.cpp)]\n [!code-vb[Classic TcpListenerExample#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_15_1.vb)]"
  syntax:
    content: public System.Net.Sockets.TcpClient AcceptTcpClient ();
    parameters: []
    return:
      type: System.Net.Sockets.TcpClient
      description: "A <xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref>用來傳送和接收資料。"
  overload: System.Net.Sockets.TcpListener.AcceptTcpClient*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "藉由呼叫<xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>尚未啟動接聽程式"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "使用&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;屬性，以取得特定的錯誤碼。 當您取得這個程式碼時，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  id: AcceptTcpClientAsync
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AcceptTcpClientAsync()
  nameWithType: TcpListener.AcceptTcpClientAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClientAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "以非同步作業會接受暫止的連接要求。"
  remarks: "這項作業不會封鎖。 傳回<xref:System.Threading.Tasks.Task%601>已接受 TCP 連線之後，物件會完成。</xref:System.Threading.Tasks.Task%601>       使用<xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName>方法，以取得基礎<xref:System.Net.Sockets.NetworkStream>傳回<xref:System.Net.Sockets.TcpClient><xref:System.Threading.Tasks.Task%601>。</xref:System.Threading.Tasks.Task%601> </xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.NetworkStream> </xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=fullName> <xref:System.Net.Sockets.NetworkStream>會為您提供方法來傳送和接收的遠端主機。</xref:System.Net.Sockets.NetworkStream> 如果您是透過與<xref:System.Net.Sockets.TcpClient>，務必呼叫其<xref:System.Net.Sockets.TcpClient.Close%2A>方法。</xref:System.Net.Sockets.TcpClient.Close%2A> </xref:System.Net.Sockets.TcpClient> 如果您想要更大的彈性比<xref:System.Net.Sockets.TcpClient>提供，請考慮使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>或<xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A>.</xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> </xref:System.Net.Sockets.TcpClient>      > [!NOTE] > 應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public System.Threading.Tasks.Task<System.Net.Sockets.TcpClient> AcceptTcpClientAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task{System.Net.Sockets.TcpClient}
      description: "傳回&lt;xref:System.Threading.Tasks.Task%601&gt;工作物件，表示非同步作業。 &lt;Xref:System.Threading.Tasks.Task%601.Result%2A&gt;工作物件上的屬性會傳回<xref href=&quot;System.Net.Sockets.TcpClient&quot;></xref>用來傳送和接收資料。"
  overload: System.Net.Sockets.TcpListener.AcceptTcpClientAsync*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "藉由呼叫<xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>尚未啟動接聽程式"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "使用&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;屬性，以取得特定的錯誤碼。 當您取得這個程式碼時，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Active
  id: Active
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Active
  nameWithType: TcpListener.Active
  fullName: System.Net.Sockets.TcpListener.Active
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得值，指出是否<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>主動接聽用戶端連線。"
  remarks: "類別衍生自<xref:System.Net.Sockets.TcpListener>可以使用這個屬性來判斷如果<xref:System.Net.Sockets.Socket>目前正在接聽連入連線嘗試。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener> <xref:System.Net.Sockets.TcpClient.Active%2A>屬性可以用來避免多餘<xref:System.Net.Sockets.TcpListener.Start%2A>嘗試。</xref:System.Net.Sockets.TcpListener.Start%2A> </xref:System.Net.Sockets.TcpClient.Active%2A>"
  syntax:
    content: protected bool Active { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>主動接聽，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.TcpListener.Active*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)
  id: AllowNatTraversal(System.Boolean)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: AllowNatTraversal(Boolean)
  nameWithType: TcpListener.AllowNatTraversal(Boolean)
  fullName: System.Net.Sockets.TcpListener.AllowNatTraversal(Boolean)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "啟用或停用上的網路位址轉譯 (NAT) 周遊<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>執行個體。"
  remarks: "AllowNatTraversal 方法用來啟用或停用的 NAT 周遊<xref:System.Net.Sockets.TcpListener>執行個體。</xref:System.Net.Sockets.TcpListener> 您可以使用 Teredo、 6to4 或 ISATAP 通道提供 NAT 周遊。       當`allowed`參數為 false，<xref:System.Net.Sockets.SocketOptionName>相關聯的通訊端上的選項設定為<xref:System.Net.Sockets.IPProtectionLevel>.</xref:System.Net.Sockets.IPProtectionLevel> </xref:System.Net.Sockets.SocketOptionName> 此明確地停用的 NAT 周遊<xref:System.Net.Sockets.TcpListener>執行個體。</xref:System.Net.Sockets.TcpListener>       當`allowed`參數為 true，<xref:System.Net.Sockets.SocketOptionName>相關聯的通訊端上的選項設定為<xref:System.Net.Sockets.IPProtectionLevel>.</xref:System.Net.Sockets.IPProtectionLevel> </xref:System.Net.Sockets.SocketOptionName> 這可能會讓 NAT 周遊<xref:System.Net.Sockets.TcpListener>根據在系統上的防火牆規則。</xref:System.Net.Sockets.TcpListener>       AllowNatTraversal 方法必須在呼叫之前叫用<xref:System.Net.Sockets.TcpListener.Start%2A>方法開始接聽連入連線要求 （繫結通訊端） 之前。</xref:System.Net.Sockets.TcpListener.Start%2A> 如果之後呼叫 AllowNatTraversal 方法<xref:System.Net.Sockets.TcpListener.Start%2A>方法，則<xref:System.InvalidOperationException>就會擲回。</xref:System.InvalidOperationException> </xref:System.Net.Sockets.TcpListener.Start%2A>       Teredo 位址是 IPv6 位址首碼為 2001年:: / 32。 Teredo 位址可透過一般的 DNS 名稱解析傳回或列舉為指派給本機介面的 IPv6 位址。"
  syntax:
    content: public void AllowNatTraversal (bool allowed);
    parameters:
    - id: allowed
      type: System.Boolean
      description: "布林值，指定是否要啟用或停用的 NAT 周遊。"
  overload: System.Net.Sockets.TcpListener.AllowNatTraversal*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "在呼叫<xref:System.Net.Sockets.TcpListener.Start*>方法</xref:System.Net.Sockets.TcpListener.Start*>之後呼叫 AllowNatTraversal 方法"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)
  id: BeginAcceptSocket(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: BeginAcceptSocket(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptSocket(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptSocket(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "開始非同步作業以接受連入連線嘗試。"
  remarks: "非同步 BeginAcceptSocket 作業必須完成呼叫<xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A>方法。</xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> 一般而言，方法由叫用`callback`委派。       這個方法不會封鎖直到作業完成為止。 若要封鎖的作業完成之前，請使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法。</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>       如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/add/includes/ajax-current-ext-md.md)。      > [!NOTE] >，您可以呼叫<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>屬性傳回之<xref:System.Net.Sockets.Socket>來識別遠端主機的網路位址和連接埠號碼。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>      > [!NOTE] > 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>屬性來取得特定錯誤碼，並請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件位於 MSDN library 中[http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/)如需詳細的錯誤說明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] > 應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates the use of the BeginAcceptSocket method to create and connect a socket. The callback delegate calls the <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/cpp/1d0c3046-b366-41a2-aab6-_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/csharp/1d0c3046-b366-41a2-aab6-_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/visualbasic/1d0c3046-b366-41a2-aab6-_1.vb)]"
  syntax:
    content: public IAsyncResult BeginAcceptSocket (AsyncCallback callback, object state);
    parameters:
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>委派，參考要叫用作業完成時的方法。</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "使用者定義的物件，其中包含接受作業的相關資訊。 這個物件傳遞至`callback`委派作業完成時。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>參考非同步<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>建立</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.TcpListener.BeginAcceptSocket*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "嘗試存取通訊端時發生錯誤。 請參閱 < 備註 > 一節，如需詳細資訊。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref:System.Net.Sockets.Socket>已關閉。</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  id: BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: BeginAcceptTcpClient(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "開始非同步作業以接受連入連線嘗試。"
  remarks: "非同步 BeginAcceptTcpClient 作業必須完成呼叫<xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A>方法。</xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> 一般而言，方法由叫用`callback`委派。       這個方法不會封鎖直到作業完成為止。 若要封鎖的作業完成之前，請使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法。</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>       如需使用非同步程式設計模型的詳細資訊，請參閱[呼叫同步方法以非同步方式](~/add/includes/ajax-current-ext-md.md)。      > [!NOTE] > 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>屬性來取得特定錯誤碼，並請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件位於 MSDN library 中[http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/)如需詳細的錯誤說明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] > 應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates the use of the BeginAcceptTcpClient method to create and connect a socket. The callback delegate calls the <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/cpp/5290dfb8-7e8f-4cf6-b64e-_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/csharp/5290dfb8-7e8f-4cf6-b64e-_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/visualbasic/5290dfb8-7e8f-4cf6-b64e-_1.vb)]"
  syntax:
    content: public IAsyncResult BeginAcceptTcpClient (AsyncCallback callback, object state);
    parameters:
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>委派，參考要叫用作業完成時的方法。</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "使用者定義的物件，其中包含接受作業的相關資訊。 這個物件傳遞至`callback`委派作業完成時。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>會參考非同步建立<xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref>。</xref:System.IAsyncResult>"
  overload: System.Net.Sockets.TcpListener.BeginAcceptTcpClient*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "嘗試存取通訊端時發生錯誤。 請參閱 < 備註 > 一節，如需詳細資訊。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "<xref:System.Net.Sockets.Socket>已關閉。</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Create(System.Int32)
  id: Create(System.Int32)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Create(Int32)
  nameWithType: TcpListener.Create(Int32)
  fullName: System.Net.Sockets.TcpListener.Create(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "建立新<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>指定通訊埠上接聽的執行個體。"
  syntax:
    content: public static System.Net.Sockets.TcpListener Create (int port);
    parameters:
    - id: port
      type: System.Int32
      description: "用來接聽連入連線嘗試的連接埠。"
    return:
      type: System.Net.Sockets.TcpListener
      description: "Returns <xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>.       新<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>指定通訊埠上接聽的執行個體。"
  overload: System.Net.Sockets.TcpListener.Create*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)
  id: EndAcceptSocket(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: EndAcceptSocket(IAsyncResult)
  nameWithType: TcpListener.EndAcceptSocket(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptSocket(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "以非同步方式接受連入連線嘗試，並建立新<xref:System.Net.Sockets.Socket>來處理遠端主機通訊。</xref:System.Net.Sockets.Socket>"
  remarks: "這個方法會封鎖直到作業完成。 若要以同步方式執行這項作業，使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法。</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>      > [!NOTE] >，您可以呼叫<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>屬性傳回之<xref:System.Net.Sockets.Socket>來識別遠端主機的網路位址和連接埠號碼。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>      > [!NOTE] > 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>屬性來取得特定錯誤碼，並請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件位於 MSDN library 中[http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/)如需詳細的錯誤說明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] > 應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates the use of the <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> method to create and connect a socket. The callback delegate calls the EndAcceptSocket method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/cpp/m-system.net.sockets.tcp_14_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/csharp/m-system.net.sockets.tcp_14_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#4](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_14_1.vb)]"
  syntax:
    content: public System.Net.Sockets.Socket EndAcceptSocket (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>呼叫所傳回的<xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*>方法。</xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*> </xref:System.IAsyncResult>"
    return:
      type: System.Net.Sockets.Socket
      description: "A <xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>       <xref:System.Net.Sockets.Socket>用來傳送和接收資料。</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.EndAcceptSocket*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基礎<xref:System.Net.Sockets.Socket>已關閉。</xref:System.Net.Sockets.Socket>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> asyncResult </code>參數不是由呼叫<xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*>方法。</xref:System.Net.Sockets.TcpListener.BeginAcceptSocket*>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "之前已呼叫 EndAcceptSocket 方法。"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "嘗試存取<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>時發生錯誤 請參閱 < 備註 > 一節，如需詳細資訊。"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)
  id: EndAcceptTcpClient(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: EndAcceptTcpClient(IAsyncResult)
  nameWithType: TcpListener.EndAcceptTcpClient(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptTcpClient(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "以非同步方式接受連入連線嘗試，並建立新<xref href=&quot;System.Net.Sockets.TcpClient&quot;></xref>來處理遠端主機通訊。"
  remarks: "這個方法會封鎖直到作業完成。 若要以同步方式執行這項作業，使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法。</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>      > [!NOTE] >，您可以呼叫<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>基礎通訊端的屬性 (<xref:System.Net.Sockets.TcpClient.Client%2A>) 來識別遠端主機的網路位址和連接埠號碼。</xref:System.Net.Sockets.TcpClient.Client%2A> </xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>      > [!NOTE] > 如果您收到<xref:System.Net.Sockets.SocketException>，使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>屬性來取得特定錯誤碼，並請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件位於 MSDN library 中[http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/)如需詳細的錯誤說明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> </xref:System.Net.Sockets.SocketException>      > [!NOTE] > 應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates the use of the <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> method to create and connect a socket. The callback delegate calls the EndAcceptTcpClient method to end the asynchronous request.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/cpp/m-system.net.sockets.tcp_8_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/csharp/m-system.net.sockets.tcp_8_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#5](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_8_1.vb)]"
  syntax:
    content: public System.Net.Sockets.TcpClient EndAcceptTcpClient (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>呼叫所傳回的<xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient*>方法。</xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient*> </xref:System.IAsyncResult>"
    return:
      type: System.Net.Sockets.TcpClient
      description: "A <xref href=&quot;System.Net.Sockets.TcpClient&quot;></xref>.       <xref href=&quot;System.Net.Sockets.TcpClient&quot;> </xref>用來傳送和接收資料。"
  overload: System.Net.Sockets.TcpListener.EndAcceptTcpClient*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.ExclusiveAddressUse
  id: ExclusiveAddressUse
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: ExclusiveAddressUse
  nameWithType: TcpListener.ExclusiveAddressUse
  fullName: System.Net.Sockets.TcpListener.ExclusiveAddressUse
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得或設定<xref:System.Boolean>值，指定是否<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>允許只能有一個接聽特定通訊埠的基礎通訊端</xref:System.Boolean>"
  remarks: "根據預設，多個接聽程式可以接聽特定通訊埠。 不過，只有其中一個接聽程式可以執行網路流量傳送至連接埠的作業。 如果多個接聽程式所要繫結至特定的連接埠，則具有更特定的 IP 位址會處理傳送至該通訊埠的網路流量。 您可以使用<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>屬性可防止多個接聽程式接聽特定通訊埠</xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>       設定這個屬性，然後再呼叫<xref:System.Net.Sockets.TcpListener.Start%2A>，或呼叫<xref:System.Net.Sockets.TcpListener.Stop%2A>方法並將這個屬性。</xref:System.Net.Sockets.TcpListener.Stop%2A> </xref:System.Net.Sockets.TcpListener.Start%2A>"
  example:
  - "The following code example gets and sets the ExclusiveAddressUse property.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#2](~/add/codesnippet/cpp/p-system.net.sockets.tcp_9_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#2](~/add/codesnippet/csharp/p-system.net.sockets.tcp_9_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#2](~/add/codesnippet/visualbasic/p-system.net.sockets.tcp_9_1.vb)]"
  syntax:
    content: public bool ExclusiveAddressUse { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>允許只有一個<xref href=&quot;System.Net.Sockets.TcpListener&quot;></xref>為接聽特定的通訊埠; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 。 預設值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>為 Windows Server 2003 和 Windows XP Service Pack 2 和更新版本，和<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>對於所有其他版本。"
  overload: System.Net.Sockets.TcpListener.ExclusiveAddressUse*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref>已啟動。 呼叫<xref href=&quot;System.Net.Sockets.TcpListener.Stop&quot;></xref>方法並將其設定<xref:System.Net.Sockets.Socket.ExclusiveAddressUse*>屬性。</xref:System.Net.Sockets.Socket.ExclusiveAddressUse*>"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "嘗試存取基礎通訊端時發生錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "基礎<xref:System.Net.Sockets.Socket>已關閉。</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.LocalEndpoint
  id: LocalEndpoint
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: LocalEndpoint
  nameWithType: TcpListener.LocalEndpoint
  fullName: System.Net.Sockets.TcpListener.LocalEndpoint
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得基礎<xref:System.Net.EndPoint>的目前<xref href=&quot;System.Net.Sockets.TcpListener&quot;> </xref>。</xref:System.Net.EndPoint>"
  remarks: "您可以使用 LocalEndpoint 屬性來識別用來接聽內送的用戶端連接要求，通訊端連線建立之後的區域網路介面和連接埠號碼。 您必須先轉換此<xref:System.Net.EndPoint>至<xref:System.Net.IPEndPoint>。</xref:System.Net.IPEndPoint> </xref:System.Net.EndPoint> 您可以接著呼叫<xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName>屬性，以擷取本機 IP 位址，而<xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName>屬性，以擷取本機連接埠號碼。</xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> </xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName>"
  example:
  - "The following code example displays the local IP address and port number on which the <xref:System.Net.Sockets.TcpListener> is listening for incoming connection requests.  \n  \n [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/cpp/p-system.net.sockets.tcp_5_1.cpp)]\n [!code-cs[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/csharp/p-system.net.sockets.tcp_5_1.cs)]\n [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/visualbasic/p-system.net.sockets.tcp_5_1.vb)]"
  syntax:
    content: public System.Net.EndPoint LocalEndpoint { get; }
    return:
      type: System.Net.EndPoint
      description: "<xref:System.Net.EndPoint>的<xref:System.Net.Sockets.Socket>繫結。</xref:System.Net.Sockets.Socket> </xref:System.Net.EndPoint>"
  overload: System.Net.Sockets.TcpListener.LocalEndpoint*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Pending
  id: Pending
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Pending()
  nameWithType: TcpListener.Pending()
  fullName: System.Net.Sockets.TcpListener.Pending()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "判斷是否有暫止的連接要求。"
  remarks: "此非封鎖的方法會判斷是否有任何暫止的連接要求。 因為<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>和<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法封鎖執行，直到<xref:System.Net.Sockets.TcpListener.Start%2A>方法已放入佇列的連入連線要求，暫止的方法可以用來判斷連線是否可用，然後再嘗試將同意這些授權條款。</xref:System.Net.Sockets.TcpListener.Start%2A> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>"
  example:
  - "The following code example checks the Pending method. If a connection request is waiting to be accepted, then a call to the <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> method is made.  \n  \n [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_5_1.cpp)]\n [!code-cs[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_5_1.cs)]\n [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_5_1.vb)]"
  syntax:
    content: public bool Pending ();
    parameters: []
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果連接為擱置中。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.Sockets.TcpListener.Pending*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "藉由呼叫<xref:System.Net.Sockets.TcpListener.Start*>.</xref:System.Net.Sockets.TcpListener.Start*>尚未啟動接聽程式"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Server
  id: Server
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Server
  nameWithType: TcpListener.Server
  fullName: System.Net.Sockets.TcpListener.Server
  type: Property
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "取得基礎網路<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  remarks: "<xref:System.Net.Sockets.TcpListener>建立<xref:System.Net.Sockets.Socket>接聽內送的用戶端連接要求。</xref:System.Net.Sockets.Socket></xref:System.Net.Sockets.TcpListener> 類別衍生自<xref:System.Net.Sockets.TcpListener>可以使用這個屬性，以取得此<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener> 使用基礎<xref:System.Net.Sockets.Socket>伺服器屬性所傳回，如果您需要存取超過其<xref:System.Net.Sockets.TcpListener>提供。</xref:System.Net.Sockets.TcpListener> </xref:System.Net.Sockets.Socket>      > [!NOTE] > 伺服器屬性只會傳回<xref:System.Net.Sockets.Socket>用來接聽內送的用戶端連接要求。</xref:System.Net.Sockets.Socket> 使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法接受暫止的連接要求，並取得<xref:System.Net.Sockets.Socket>來傳送和接收資料。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> 您也可以使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法接受暫止的連接要求，並取得<xref:System.Net.Sockets.TcpClient>來傳送和接收資料。</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>"
  example:
  - "The following code example demonstrates the use of the Server property. The underlying <xref:System.Net.Sockets.Socket> is retrieved and the <xref:System.Net.Sockets.SocketOptionName><xref:System.Net.Sockets.Socket> option is configured to time out after 10 seconds if data still remains in the network buffer after the connection is closed.  \n  \n [!code-vb[TcpListenerProtectedMembers1#1](~/add/codesnippet/visualbasic/p-system.net.sockets.tcp_10_1.vb)]\n [!code-cs[TcpListenerProtectedMembers1#1](~/add/codesnippet/csharp/p-system.net.sockets.tcp_10_1.cs)]"
  syntax:
    content: public System.Net.Sockets.Socket Server { get; }
    return:
      type: System.Net.Sockets.Socket
      description: "基礎<xref:System.Net.Sockets.Socket>.</xref:System.Net.Sockets.Socket>"
  overload: System.Net.Sockets.TcpListener.Server*
  exceptions: []
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Start
  id: Start
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Start()
  nameWithType: TcpListener.Start()
  fullName: System.Net.Sockets.TcpListener.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "開始接聽連入連線要求。"
  remarks: "Start 方法初始化基礎<xref:System.Net.Sockets.Socket>、 將它繫結至的本機端點和接聽連入連線嘗試。</xref:System.Net.Sockets.Socket> Start 方法如果收到連線要求時，將要求排入佇列，並繼續接聽其他要求，直到您呼叫<xref:System.Net.Sockets.TcpListener.Stop%2A>方法。</xref:System.Net.Sockets.TcpListener.Stop%2A> 如果<xref:System.Net.Sockets.TcpListener>收到連接要求它有已排入佇列的連線數目上限之後，它將會擲回<xref:System.Net.Sockets.SocketException>用戶端上。</xref:System.Net.Sockets.SocketException> </xref:System.Net.Sockets.TcpListener>       若要從連入連線佇列中移除連接，請使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法或<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法。</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法會從佇列移除的連接，並傳回<xref:System.Net.Sockets.TcpClient>可用來傳送和接收資料。</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法會傳回<xref:System.Net.Sockets.Socket>可用來執行相同的動作。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> 如果您的應用程式只需要同步 I/O，請使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> 對於更詳細的行為控制項，使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>.</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> 這兩種方法封鎖，直到連接要求佇列中可用為止。       使用<xref:System.Net.Sockets.TcpListener.Stop%2A>方法，關閉<xref:System.Net.Sockets.TcpListener>並停止接聽。</xref:System.Net.Sockets.TcpListener> </xref:System.Net.Sockets.TcpListener.Stop%2A> 您必須負責個別關閉已接受的連接。      > [!NOTE] > 應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates how Start is used to listen for incoming client connection attempts.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/cpp/m-system.net.sockets.tcp_6_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/csharp/m-system.net.sockets.tcp_6_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_6_1.vb)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Net.Sockets.TcpListener.Start*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "使用&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;屬性，以取得特定的錯誤碼。 當您取得這個程式碼時，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Start(System.Int32)
  id: Start(System.Int32)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Start(Int32)
  nameWithType: TcpListener.Start(Int32)
  fullName: System.Net.Sockets.TcpListener.Start(Int32)
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "開始接聽連入連線要求的暫止的連接數目上限。"
  remarks: "<xref:System.Net.Sockets.TcpListener.Start%2A>方法會初始化基礎<xref:System.Net.Sockets.Socket>、 將它繫結至的本機端點和接聽連入連線嘗試。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.Start%2A> 如果收到連線要求時，<xref:System.Net.Sockets.TcpListener.Start%2A>將要求排入佇列並繼續接聽其他要求，直到您呼叫<xref:System.Net.Sockets.TcpListener.Stop%2A>方法。</xref:System.Net.Sockets.TcpListener.Stop%2A> </xref:System.Net.Sockets.TcpListener.Start%2A> 如果<xref:System.Net.Sockets.TcpListener>收到連接要求時，它有已排入佇列的則會擲回的連線數目上限之後<xref:System.Net.Sockets.SocketException>用戶端上。</xref:System.Net.Sockets.SocketException> </xref:System.Net.Sockets.TcpListener>       若要從連入連線佇列中移除連接，請使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法或<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法。</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>方法會從佇列移除的連接，並傳回<xref:System.Net.Sockets.TcpClient>可用來傳送和接收資料。</xref:System.Net.Sockets.TcpClient> </xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法會傳回<xref:System.Net.Sockets.Socket>可用來執行相同的動作。</xref:System.Net.Sockets.Socket> </xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> 如果您的應用程式只需要同步 I/O，請使用<xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>.</xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> 如需詳細的行為的控制項，使用<xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>方法。</xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> 這兩種方法封鎖，直到連接要求佇列中可用為止。       使用<xref:System.Net.Sockets.TcpListener.Stop%2A>方法，關閉<xref:System.Net.Sockets.TcpListener>並停止接聽。</xref:System.Net.Sockets.TcpListener> </xref:System.Net.Sockets.TcpListener.Stop%2A> 您必須負責個別關閉已接受的連接。      > [!NOTE] > 使用<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>屬性來取得特定錯誤碼，並請參閱 Windows Sockets 第 2 版 API 錯誤的程式碼文件位於 MSDN library 中[http://msdn.microsoft.com/library/](http://msdn.microsoft.com/library/)如需詳細的錯誤說明。</xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName>      > [!NOTE] > 應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates how <xref:System.Net.Sockets.TcpListener.Start%2A> is used to listen for incoming client connection attempts.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/cpp/m-system.net.sockets.tcp_17_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/csharp/m-system.net.sockets.tcp_17_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener1#3](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_17_1.vb)]"
  syntax:
    content: public void Start (int backlog);
    parameters:
    - id: backlog
      type: System.Int32
      description: "擱置連線佇列的長度上限。"
  overload: System.Net.Sockets.TcpListener.Start*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "存取通訊端時發生錯誤。 請參閱 < 備註 > 一節，如需詳細資訊。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>  backlog </code>參數小於零或超過允許的連線數目上限。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "基礎<xref:System.Net.Sockets.Socket>為 null。</xref:System.Net.Sockets.Socket>"
  platform:
  - net462
- uid: System.Net.Sockets.TcpListener.Stop
  id: Stop
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  name: Stop()
  nameWithType: TcpListener.Stop()
  fullName: System.Net.Sockets.TcpListener.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Net.Sockets
  summary: "關閉接聽程式。"
  remarks: "停止關閉接聽程式。 佇列中的任何不被接受的連接要求將會遺失。 遠端主機連線正在等待被接受，將會擲回<xref:System.Net.Sockets.SocketException>.</xref:System.Net.Sockets.SocketException> 您必須負責個別關閉已接受的連接。      > [!NOTE] > 應用程式中啟用網路追蹤時，這個成員會輸出追蹤資訊。 如需詳細資訊，請參閱[網路追蹤.NET Framework 中](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates using the Stop method to close the underlying <xref:System.Net.Sockets.Socket>.  \n  \n [!code-cpp[System.Net.Sockets.TcpListener#1](~/add/codesnippet/cpp/m-system.net.sockets.tcp_9_1.cpp)]\n [!code-cs[System.Net.Sockets.TcpListener#1](~/add/codesnippet/csharp/m-system.net.sockets.tcp_9_1.cs)]\n [!code-vb[System.Net.Sockets.TcpListener#1](~/add/codesnippet/visualbasic/m-system.net.sockets.tcp_9_1.vb)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Net.Sockets.TcpListener.Stop*
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "使用&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;屬性，以取得特定的錯誤碼。 當您取得這個程式碼時，您可以參考 Windows Sockets 第 2 版 API 錯誤的程式碼中的文件 MSDN 如需詳細的錯誤說明。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Net.Sockets.SocketException
  isExternal: true
  name: System.Net.Sockets.SocketException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Net.Sockets.TcpListener.#ctor(System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener(Int32)
  nameWithType: TcpListener.TcpListener(Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener(IPEndPoint)
  nameWithType: TcpListener.TcpListener(IPEndPoint)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPEndPoint)
- uid: System.Net.IPEndPoint
  parent: System.Net
  isExternal: true
  name: IPEndPoint
  nameWithType: IPEndPoint
  fullName: System.Net.IPEndPoint
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener(IPAddress,Int32)
  nameWithType: TcpListener.TcpListener(IPAddress,Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(IPAddress,Int32)
- uid: System.Net.IPAddress
  parent: System.Net
  isExternal: true
  name: IPAddress
  nameWithType: IPAddress
  fullName: System.Net.IPAddress
- uid: System.Net.Sockets.TcpListener.AcceptSocket
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocket()
  nameWithType: TcpListener.AcceptSocket()
  fullName: System.Net.Sockets.TcpListener.AcceptSocket()
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: true
  name: Socket
  nameWithType: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.TcpListener.AcceptSocketAsync
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocketAsync()
  nameWithType: TcpListener.AcceptSocketAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptSocketAsync()
- uid: System.Threading.Tasks.Task{System.Net.Sockets.Socket}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Socket>
  nameWithType: Task<Socket>
  fullName: System.Threading.Tasks.Task<System.Net.Sockets.Socket>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Net.Sockets.Socket>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Net.Sockets.Socket
    name: Socket
    nameWithType: Socket
    fullName: Socket
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.Sockets.TcpListener.AcceptTcpClient
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClient()
  nameWithType: TcpListener.AcceptTcpClient()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClient()
- uid: System.Net.Sockets.TcpClient
  parent: System.Net.Sockets
  isExternal: false
  name: TcpClient
  nameWithType: TcpClient
  fullName: System.Net.Sockets.TcpClient
- uid: System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClientAsync()
  nameWithType: TcpListener.AcceptTcpClientAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClientAsync()
- uid: System.Threading.Tasks.Task{System.Net.Sockets.TcpClient}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<TcpClient>
  nameWithType: Task<TcpClient>
  fullName: System.Threading.Tasks.Task<System.Net.Sockets.TcpClient>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Net.Sockets.TcpClient>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Net.Sockets.TcpClient
    name: TcpClient
    nameWithType: TcpClient
    fullName: TcpClient
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.Sockets.TcpListener.Active
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Active
  nameWithType: TcpListener.Active
  fullName: System.Net.Sockets.TcpListener.Active
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AllowNatTraversal(Boolean)
  nameWithType: TcpListener.AllowNatTraversal(Boolean)
  fullName: System.Net.Sockets.TcpListener.AllowNatTraversal(Boolean)
- uid: System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptSocket(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptSocket(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptSocket(AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptTcpClient(AsyncCallback,Object)
  nameWithType: TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
  fullName: System.Net.Sockets.TcpListener.BeginAcceptTcpClient(AsyncCallback,Object)
- uid: System.Net.Sockets.TcpListener.Create(System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Create(Int32)
  nameWithType: TcpListener.Create(Int32)
  fullName: System.Net.Sockets.TcpListener.Create(Int32)
- uid: System.Net.Sockets.TcpListener
  parent: System.Net.Sockets
  isExternal: false
  name: TcpListener
  nameWithType: TcpListener
  fullName: System.Net.Sockets.TcpListener
- uid: System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptSocket(IAsyncResult)
  nameWithType: TcpListener.EndAcceptSocket(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptSocket(IAsyncResult)
- uid: System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptTcpClient(IAsyncResult)
  nameWithType: TcpListener.EndAcceptTcpClient(IAsyncResult)
  fullName: System.Net.Sockets.TcpListener.EndAcceptTcpClient(IAsyncResult)
- uid: System.Net.Sockets.TcpListener.ExclusiveAddressUse
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: ExclusiveAddressUse
  nameWithType: TcpListener.ExclusiveAddressUse
  fullName: System.Net.Sockets.TcpListener.ExclusiveAddressUse
- uid: System.Net.Sockets.TcpListener.LocalEndpoint
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: LocalEndpoint
  nameWithType: TcpListener.LocalEndpoint
  fullName: System.Net.Sockets.TcpListener.LocalEndpoint
- uid: System.Net.EndPoint
  parent: System.Net
  isExternal: true
  name: EndPoint
  nameWithType: EndPoint
  fullName: System.Net.EndPoint
- uid: System.Net.Sockets.TcpListener.Pending
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Pending()
  nameWithType: TcpListener.Pending()
  fullName: System.Net.Sockets.TcpListener.Pending()
- uid: System.Net.Sockets.TcpListener.Server
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Server
  nameWithType: TcpListener.Server
  fullName: System.Net.Sockets.TcpListener.Server
- uid: System.Net.Sockets.TcpListener.Start
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Start()
  nameWithType: TcpListener.Start()
  fullName: System.Net.Sockets.TcpListener.Start()
- uid: System.Net.Sockets.TcpListener.Start(System.Int32)
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Start(Int32)
  nameWithType: TcpListener.Start(Int32)
  fullName: System.Net.Sockets.TcpListener.Start(Int32)
- uid: System.Net.Sockets.TcpListener.Stop
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Stop()
  nameWithType: TcpListener.Stop()
  fullName: System.Net.Sockets.TcpListener.Stop()
- uid: System.Net.Sockets.TcpListener.#ctor*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: TcpListener
  nameWithType: TcpListener.TcpListener
- uid: System.Net.Sockets.TcpListener.AcceptSocket*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocket
  nameWithType: TcpListener.AcceptSocket
- uid: System.Net.Sockets.TcpListener.AcceptSocketAsync*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptSocketAsync
  nameWithType: TcpListener.AcceptSocketAsync
- uid: System.Net.Sockets.TcpListener.AcceptTcpClient*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClient
  nameWithType: TcpListener.AcceptTcpClient
- uid: System.Net.Sockets.TcpListener.AcceptTcpClientAsync*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AcceptTcpClientAsync
  nameWithType: TcpListener.AcceptTcpClientAsync
- uid: System.Net.Sockets.TcpListener.Active*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Active
  nameWithType: TcpListener.Active
- uid: System.Net.Sockets.TcpListener.AllowNatTraversal*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: AllowNatTraversal
  nameWithType: TcpListener.AllowNatTraversal
- uid: System.Net.Sockets.TcpListener.BeginAcceptSocket*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptSocket
  nameWithType: TcpListener.BeginAcceptSocket
- uid: System.Net.Sockets.TcpListener.BeginAcceptTcpClient*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: BeginAcceptTcpClient
  nameWithType: TcpListener.BeginAcceptTcpClient
- uid: System.Net.Sockets.TcpListener.Create*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Create
  nameWithType: TcpListener.Create
- uid: System.Net.Sockets.TcpListener.EndAcceptSocket*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptSocket
  nameWithType: TcpListener.EndAcceptSocket
- uid: System.Net.Sockets.TcpListener.EndAcceptTcpClient*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: EndAcceptTcpClient
  nameWithType: TcpListener.EndAcceptTcpClient
- uid: System.Net.Sockets.TcpListener.ExclusiveAddressUse*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: ExclusiveAddressUse
  nameWithType: TcpListener.ExclusiveAddressUse
- uid: System.Net.Sockets.TcpListener.LocalEndpoint*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: LocalEndpoint
  nameWithType: TcpListener.LocalEndpoint
- uid: System.Net.Sockets.TcpListener.Pending*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Pending
  nameWithType: TcpListener.Pending
- uid: System.Net.Sockets.TcpListener.Server*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Server
  nameWithType: TcpListener.Server
- uid: System.Net.Sockets.TcpListener.Start*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Start
  nameWithType: TcpListener.Start
- uid: System.Net.Sockets.TcpListener.Stop*
  parent: System.Net.Sockets.TcpListener
  isExternal: false
  name: Stop
  nameWithType: TcpListener.Stop
