### YamlMime:ManagedReference
items:
- uid: System.Net.HttpListener
  id: HttpListener
  children:
  - System.Net.HttpListener.#ctor
  - System.Net.HttpListener.Abort
  - System.Net.HttpListener.AuthenticationSchemes
  - System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  - System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  - System.Net.HttpListener.Close
  - System.Net.HttpListener.DefaultServiceNames
  - System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  - System.Net.HttpListener.ExtendedProtectionPolicy
  - System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  - System.Net.HttpListener.GetContext
  - System.Net.HttpListener.GetContextAsync
  - System.Net.HttpListener.IgnoreWriteExceptions
  - System.Net.HttpListener.IsListening
  - System.Net.HttpListener.IsSupported
  - System.Net.HttpListener.Prefixes
  - System.Net.HttpListener.Realm
  - System.Net.HttpListener.Start
  - System.Net.HttpListener.Stop
  - System.Net.HttpListener.System#IDisposable#Dispose
  - System.Net.HttpListener.TimeoutManager
  - System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  langs:
  - csharp
  name: HttpListener
  nameWithType: HttpListener
  fullName: System.Net.HttpListener
  type: Class
  summary: "提供簡單、 以程式設計方式控制的 HTTP 通訊協定接聽程式。 這個類別無法被繼承。"
  remarks: "Using the HttpListener class, you can create a simple HTTP protocol listener that responds to HTTP requests. The listener is active for the lifetime of the HttpListener object and runs within your application with its permissions.  \n  \n> [!NOTE]\n>  This class is available only on computers running the Windows XP SP2 or Windows Server 2003 operating systems. If you attempt to create an HttpListener object on a computer that is running an earlier operating system, the constructor throws a <xref:System.PlatformNotSupportedException> exception.  \n  \n To use HttpListener, create a new instance of the class using the HttpListener constructor and use the <xref:System.Net.HttpListener.Prefixes%2A> property to gain access to the collection that holds the strings that specify which Uniform Resource Identifier (URI) prefixes the HttpListener should process.  \n  \n A URI prefix string is composed of a scheme (http or https), a host, an optional port, and an optional path. An example of a complete prefix string is \"`http://www.contoso.com:8080/customerData``/`\". Prefixes must end in a forward slash (\"/\"). The HttpListener object with the prefix that most closely matches a requested URI responds to the request. Multiple HttpListener objects cannot add the same prefix; a <xref:System.ComponentModel.Win32Exception> exception is thrown if a HttpListener adds a prefix that is already in use.  \n  \n When a port is specified, the host element can be replaced with \"*\" to indicate that the HttpListener accepts requests sent to the port if the requested URI does not match any other prefix. For example, to receive all requests sent to port 8080 when the requested URI is not handled by any HttpListener, the prefix is \"`http://*:8080``/`\". Similarly, to specify that the HttpListener accepts all requests sent to a port, replace the host element with the \"+\" character, \"`https://+:8080`\". The \"\\*\" and \"+\" characters can be present in prefixes that include paths.  \n  \n Starting with .NET 4.5.3 and Windows 10, wildcard subdomains are supported in URI prefixes that are managed by an HttpListener object. To specify a wildcard subdomain, use the \"*\" character as part of the hostname in a URI prefix: for example, `http://*.foo.com/`, and pass this as the argument to the HttpListenerPrefixCollection.Add method. This will work on .NET 4.5.3 and Windows 10; in earlier versions, this would generate an <xref:System.Net.HttpListenerException>  \n  \n To begin listening for requests from clients, add the URI prefixes to the collection and call the <xref:System.Net.HttpListener.Start%2A> method. HttpListener offers both synchronous and asynchronous models for processing client requests. Requests and their associated responses are accessed using the <xref:System.Net.HttpListenerContext> object returned by the <xref:System.Net.HttpListener.GetContext%2A> method or its asynchronous counterparts, the <xref:System.Net.HttpListener.BeginGetContext%2A> and <xref:System.Net.HttpListener.EndGetContext%2A> methods.  \n  \n The synchronous model is appropriate if your application should block while waiting for a client request and if you want to process only one request at a time. Using the synchronous model, call the <xref:System.Net.HttpListener.GetContext%2A> method, which waits for a client to send a request. The method returns an <xref:System.Net.HttpListenerContext> object to you for processing when one occurs.  \n  \n In the more complex asynchronous model, your application does not block while waiting for requests and each request is processed in its own execution thread. Use the <xref:System.Net.HttpListener.BeginGetContext%2A> method to specify an application-defined method to be called for each incoming request. Within that method, call the <xref:System.Net.HttpListener.EndGetContext%2A> method to obtain the request, process it, and respond.  \n  \n In either model, incoming requests are accessed using the <xref:System.Net.HttpListenerContext.Request%2A?displayProperty=fullName> property and are represented by <xref:System.Net.HttpListenerRequest> objects. Similarly, responses are accessed using the <xref:System.Net.HttpListenerContext.Response%2A?displayProperty=fullName> property and are represented by <xref:System.Net.HttpListenerResponse> objects. These objects share some functionality with the <xref:System.Net.HttpWebRequest> and <xref:System.Net.HttpWebResponse> objects, but the latter objects cannot be used in conjunction with HttpListener because they implement client, not server, behaviors.  \n  \n An HttpListener can require client authentication. You can either specify a particular scheme to use for authentication, or you can specify a delegate that determines the scheme to use. You must require some form of authentication to obtain information about the client's identity. For additional information, see the <xref:System.Net.HttpListenerContext.User%2A>, <xref:System.Net.HttpListener.AuthenticationSchemes%2A>, and <xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A> properties.  \n  \n> [!NOTE]\n>  If you create an HttpListener using https, you must select a Server Certificate for that listener. Otherwise, an <xref:System.Net.HttpWebRequest> query of this HttpListener will fail with an unexpected close of the connection.  \n  \n> [!NOTE]\n>  You can configure Server Certificates and other listener options by using HttpCfg.exe. See [http://msdn.microsoft.com/library/default.asp?url=/library/en-us/http/http/httpcfg_exe.asp](http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp) for more details. The executable is shipped with Windows Server 2003, or can be built from source code available in the Platform SDK.  \n  \n> [!NOTE]\n>  If you specify multiple authentication schemes for the HttpListener, the listener will challenge clients in the following order: `Negotiate`, `NTLM`, `Digest`, and then `Basic`."
  example:
  - "The following code example demonstrates using a HttpListener.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/t-system.net.httplistener_1.cs)]"
  syntax:
    content: 'public sealed class HttpListener : IDisposable'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Net.HttpListener.#ctor
  id: '#ctor'
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: HttpListener()
  nameWithType: HttpListener.HttpListener()
  fullName: System.Net.HttpListener.HttpListener()
  type: Constructor
  assemblies:
  - System
  namespace: System.Net
  summary: "初始化的新執行個體<xref href=&quot;System.Net.HttpListener&quot;></xref>類別。"
  remarks: "之前使用此建構函式所傳回的執行個體，您必須叫用其<xref:System.Net.HttpListener.Start%2A>方法。</xref:System.Net.HttpListener.Start%2A>"
  example:
  - "The following code example demonstrates using the <xref:System.Net.HttpListener> constructor to create a new <xref:System.Net.HttpListener> object. For the complete example, see the <xref:System.Net.HttpListener> class topic.  \n  \n [!code-cs[Net_listener_Basic#9](~/add/codesnippet/csharp/m-system.net.httplistene_20_1.cs)]"
  syntax:
    content: public HttpListener ();
    parameters: []
  overload: System.Net.HttpListener.#ctor*
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "這個類別不能在目前的作業系統。 Windows Server 2003 或 Windows XP SP2，才能使用這個類別的執行個體。"
  platform:
  - net462
- uid: System.Net.HttpListener.Abort
  id: Abort
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Abort()
  nameWithType: HttpListener.Abort()
  fullName: System.Net.HttpListener.Abort()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "關閉<xref href=&quot;System.Net.HttpListener&quot;></xref>物件立即，並捨棄所有目前排入佇列的要求。"
  remarks: "這個方法會處置此接聽程式所持有的所有資源。 任何暫止要求都無法完成。       之後呼叫這個方法，您會收到<xref:System.ObjectDisposedException>如果您嘗試使用這個<xref:System.Net.HttpListener>.</xref:System.Net.HttpListener> </xref:System.ObjectDisposedException>"
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#11](~/add/codesnippet/csharp/m-system.net.httplistene_4_1.cs)]"
  syntax:
    content: public void Abort ();
    parameters: []
  overload: System.Net.HttpListener.Abort*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.AuthenticationSchemes
  id: AuthenticationSchemes
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
  fullName: System.Net.HttpListener.AuthenticationSchemes
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "取得或設定用來驗證用戶端的配置。"
  remarks: "<xref:System.Net.HttpListener>使用指定的配置來驗證所有連入要求。</xref:System.Net.HttpListener> <xref:System.Net.HttpListener.GetContext%2A>和<xref:System.Net.HttpListener.EndGetContext%2A>方法才會傳回傳入的用戶端要求<xref:System.Net.HttpListener>順利通過驗證的要求。</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.EndGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A>       您可以使用查閱成功驗證的用戶端的身分識別<xref:System.Net.HttpListenerContext.User%2A?displayProperty=fullName>屬性。</xref:System.Net.HttpListenerContext.User%2A?displayProperty=fullName>       如果您想<xref:System.Net.HttpListener>物件以使用不同的驗證機制會根據所接收的要求特性 (例如，要求的<xref:System.Net.HttpListenerRequest.Url%2A>或<xref:System.Net.HttpListenerRequest.UserHostName%2A>屬性)，您必須實作的方法所選擇的驗證配置。</xref:System.Net.HttpListenerRequest.UserHostName%2A> </xref:System.Net.HttpListenerRequest.Url%2A> </xref:System.Net.HttpListener> 如需有關如何執行這項操作的指示，請參閱<xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>屬性文件。</xref:System.Net.HttpListener.AuthenticationSchemeSelectorDelegate%2A>      > [!NOTE] > 來設定這個屬性，以啟用 Digest，NTLM 或交涉要求<xref:System.Security.Permissions.SecurityPermission>、 <xref:System.Security.Permissions.SecurityPermissionFlag>.</xref:System.Security.Permissions.SecurityPermissionFlag> </xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "The following code example demonstrates using the AuthenticationSchemes property to specify an authentication scheme.  \n  \n [!code-cs[Net_listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_0_1.cs)]"
  syntax:
    content: public System.Net.AuthenticationSchemes AuthenticationSchemes { get; set; }
    return:
      type: System.Net.AuthenticationSchemes
      description: "位元組合<xref:System.Net.AuthenticationSchemes>列舉值，指出用戶端的驗證方式。</xref:System.Net.AuthenticationSchemes> 預設值是<xref:System.Net.AuthenticationSchemes>.</xref:System.Net.AuthenticationSchemes>"
  overload: System.Net.HttpListener.AuthenticationSchemes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  id: AuthenticationSchemeSelectorDelegate
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
  fullName: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "取得或設定委派，呼叫以判斷用來驗證用戶端的通訊協定。"
  remarks: "> [!NOTE]> 如果您想要用於特定的執行個體所處理的所有要求相同的驗證通訊協定<xref:System.Net.HttpListener>，您不需要設定此屬性。</xref:System.Net.HttpListener> 若要指定要用於所有用戶端要求的通訊協定，使用<xref:System.Net.HttpListener.AuthenticationSchemes%2A>屬性。</xref:System.Net.HttpListener.AuthenticationSchemes%2A>       如果用戶端沒有在其標頭，指定驗證資訊<xref:System.Net.HttpListener>呼叫指定的每個未驗證的傳入要求，來判斷，如果有的話，要使用通訊協定來驗證用戶端的委派。</xref:System.Net.HttpListener> <xref:System.Net.HttpListener.GetContext%2A>和<xref:System.Net.HttpListener.EndGetContext%2A>方法會傳回傳入的要求才<xref:System.Net.HttpListener>成功驗證要求。</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.EndGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A> 如果無法驗證要求，<xref:System.Net.HttpListener>自動傳送回去 401 回應。</xref:System.Net.HttpListener> 您可以取得已成功驗證用戶端使用的身分識別<xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=fullName>屬性。</xref:System.Web.HttpRequest.LogonUserIdentity%2A?displayProperty=fullName>       委派的驗證通訊協定的應用程式專屬方法來選擇適合您想要的執行個體<xref:System.Net.HttpListener>使用不同的驗證通訊協定會根據所接收的要求特性 (例如，要求的<xref:System.Net.HttpListenerRequest.Url%2A>或<xref:System.Net.HttpListenerRequest.UserHostAddress%2A>屬性)。</xref:System.Net.HttpListenerRequest.UserHostAddress%2A> </xref:System.Net.HttpListenerRequest.Url%2A> </xref:System.Net.HttpListener>      > [!NOTE] > 來設定這個屬性，以啟用 Digest，NTLM 或交涉要求<xref:System.Security.Permissions.SecurityPermission>、 <xref:System.Security.Permissions.SecurityPermissionFlag>.</xref:System.Security.Permissions.SecurityPermissionFlag> </xref:System.Security.Permissions.SecurityPermission>"
  example:
  - "The following code example sets the value of this property.  \n  \n [!code-vb[NclListener#2](~/add/codesnippet/visualbasic/p-system.net.httplistene_2_1.vb)]\n [!code-cs[NclListener#2](~/add/codesnippet/csharp/p-system.net.httplistene_2_1.cs)]  \n  \n The following code example provides an implementation of a method invoked by an <xref:System.Net.AuthenticationSchemeSelector> delegate.  \n  \n [!code-vb[NclListener#1](~/add/codesnippet/visualbasic/p-system.net.httplistene_2_2.vb)]\n [!code-cs[NclListener#1](~/add/codesnippet/csharp/p-system.net.httplistene_2_2.cs)]"
  syntax:
    content: public System.Net.AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; set; }
    return:
      type: System.Net.AuthenticationSchemeSelector
      description: "<xref href=&quot;System.Net.AuthenticationSchemeSelector&quot;> </xref>用來選取驗證通訊協定的方法會叫用的委派。 預設值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
- uid: System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  id: BeginGetContext(System.AsyncCallback,System.Object)
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: BeginGetContext(AsyncCallback,Object)
  nameWithType: HttpListener.BeginGetContext(AsyncCallback,Object)
  fullName: System.Net.HttpListener.BeginGetContext(AsyncCallback,Object)
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "開始非同步擷取傳入要求。"
  remarks: "BeginGetContext 方法開始的非同步 （非封鎖） 呼叫接收內送的用戶端要求。 之前呼叫這個方法，您必須呼叫<xref:System.Net.HttpListener.Start%2A>方法並加入至少一個統一資源識別元 (URI) 前置詞加 URI 字串，以接聽<xref:System.Net.HttpListenerPrefixCollection>傳回<xref:System.Net.HttpListener.Prefixes%2A>屬性。</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A>       非同步作業必須完成呼叫<xref:System.Net.HttpListener.EndGetContext%2A>方法。</xref:System.Net.HttpListener.EndGetContext%2A> 一般而言，方法由叫用`callback`委派。       在作業完成時，這個方法不會封鎖。 若要取得連入要求和區塊的作業完成之前，呼叫<xref:System.Net.HttpListener.GetContext%2A>方法。</xref:System.Net.HttpListener.GetContext%2A>       如需使用非同步程式設計模型的詳細資訊，請參閱[非同步呼叫同步方法](~/add/includes/ajax-current-ext-md.md)"
  example:
  - "The following code example demonstrates using the BeginGetContext method to specify a callback method that will handle incoming client requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_13_1.cs)]  \n  \n The following code example implements a callback method.  \n  \n [!code-cs[Net_Listener_Basic#13](~/add/codesnippet/csharp/m-system.net.httplistene_13_2.cs)]"
  syntax:
    content: public IAsyncResult BeginGetContext (AsyncCallback callback, object state);
    parameters:
    - id: callback
      type: System.AsyncCallback
      description: "<xref:System.AsyncCallback>委派，參考要使用用戶端要求時叫用方法。</xref:System.AsyncCallback>"
    - id: state
      type: System.Object
      description: "使用者定義的物件，其中包含作業的相關資訊。 這個物件傳遞至`callback`委派作業完成時。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>物件，表示非同步作業的狀態。</xref:System.IAsyncResult>"
  overload: System.Net.HttpListener.BeginGetContext*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Win32 函式呼叫失敗。 請檢查例外狀況的<xref:System.Net.HttpListenerException.ErrorCode*>屬性，以判斷造成例外狀況。</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "此物件尚未啟動，或目前已停止。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
- uid: System.Net.HttpListener.Close
  id: Close
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Close()
  nameWithType: HttpListener.Close()
  fullName: System.Net.HttpListener.Close()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "關閉<xref href=&quot;System.Net.HttpListener&quot;> </xref>。"
  remarks: "之後呼叫這個方法，您無法再使用<xref:System.Net.HttpListener>物件。</xref:System.Net.HttpListener> 若要暫時暫停<xref:System.Net.HttpListener>物件，請使用<xref:System.Net.HttpListener.Stop%2A>方法。</xref:System.Net.HttpListener.Stop%2A> </xref:System.Net.HttpListener>       這個方法關閉清單<xref:System.Net.HttpListener>物件，而不處理要求排入佇列。</xref:System.Net.HttpListener> 任何暫止要求都無法完成。"
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/m-system.net.httplistene_10_1.cs)]"
  syntax:
    content: public void Close ();
    parameters: []
  overload: System.Net.HttpListener.Close*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.DefaultServiceNames
  id: DefaultServiceNames
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
  fullName: System.Net.HttpListener.DefaultServiceNames
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "取得服務提供者名稱 (Spn) 的預設清單，由已註冊前置詞所決定。"
  remarks: "The DefaultServiceNames property is used with integrated Windows authentication to provide extended protection. The list of SPNs is initialized from the <xref:System.Net.HttpListener.Prefixes%2A> property when accessed and cleared when new prefixes are added to the <xref:System.Net.HttpListener.Prefixes%2A> property.  \n  \n The DefaultServiceNames property is used if an application doesn't set the <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames%2A> property on its extended protection policy.  \n  \n The <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection> that is retrieved with the DefaultServiceNames property is built from the <xref:System.Net.HttpListener.Prefixes%2A> property according to the following rules:  \n  \n1.  If the hostname is \"+\", \"*\", or an IPv4 or IPv6 literal (equivalent to \"\\*\" but restricted to a specific local interface), the following SPN is added:  \n  \n `\"HTTP/\"` plus the fully qualified domain name of the computer.  \n  \n1.  If the hostname contains no dots (no domains or subdomains), an attempt is made to resolve the fully-qualified domain name using DNS (the same behavior used by <xref:System.Net.HttpWebRequest>). If the fully-qualified domain name can be resolved, the following SPNs are added:  \n  \n `\"HTTP/\"` plus the hostname (the short name).  \n  \n `\"HTTP/\"` plus the fully qualified domain name for the hostname.  \n  \n1.  If the hostname contains not dots (no domains or subdomains) and a fully-qualified domain name can't be resolved, the following SPN is added:  \n  \n `\"HTTP/\"` plus the hostname.  \n  \n1.  If the hostname contains dots (domains or subdomains), the following SPN is added:  \n  \n `\"HTTP/\"` plus the hostname.  \n  \n The DefaultServiceNames property can be used by an application to review the list of default SPNs which will be used for authentication if no custom list is supplied. If other SPNs are needed, an application can add them using one of the <xref:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge%2A> methods.  \n  \n It is not safe when using extended protection to make policy decisions based on the requested URL, since this can be spoofed. Rather, applications should rely on the <xref:System.Net.HttpListenerRequest.LocalEndPoint%2A> or <xref:System.Net.HttpListenerRequest.RemoteEndPoint%2A> properties to make such policy decisions."
  syntax:
    content: public System.Security.Authentication.ExtendedProtection.ServiceNameCollection DefaultServiceNames { get; }
    return:
      type: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
      description: "A <xref href=&quot;System.Security.Authentication.ExtendedProtection.ServiceNameCollection&quot;> </xref> ，其中包含之 Spn 的清單。"
  overload: System.Net.HttpListener.DefaultServiceNames*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  id: EndGetContext(System.IAsyncResult)
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: EndGetContext(IAsyncResult)
  nameWithType: HttpListener.EndGetContext(IAsyncResult)
  fullName: System.Net.HttpListener.EndGetContext(IAsyncResult)
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "完成非同步作業以擷取內送的用戶端要求。"
  remarks: "EndGetContext 呼叫方法時，通常出現在應用程式定義的回呼方法的委派中，以取得所叫用<xref:System.Net.HttpListenerContext>物件，包含傳入的用戶端要求和其相關聯的回應。</xref:System.Net.HttpListenerContext> 這個方法完成作業，藉由呼叫先前已啟動<xref:System.Net.HttpListener.BeginGetContext%2A>方法。</xref:System.Net.HttpListener.BeginGetContext%2A> 如果作業尚未完成，這個方法會封鎖，直到它執行。       由於呼叫 EndGetContext 方法都需要<xref:System.Net.HttpListener>物件，這個物件通常會傳遞至回呼方法的使用狀態物件傳遞至<xref:System.Net.HttpListener.BeginGetContext%2A>方法。</xref:System.Net.HttpListener.BeginGetContext%2A> </xref:System.Net.HttpListener> 您可以使用，以取得此狀態物件<xref:System.IAsyncResult.AsyncState%2A>屬性`asyncResult`物件。</xref:System.IAsyncResult.AsyncState%2A>       如需使用非同步程式設計模型的詳細資訊，請參閱[非同步呼叫同步方法](~/add/includes/ajax-current-ext-md.md)"
  example:
  - "The following code example shows the implementation of a callback method that calls the EndGetContext method.  \n  \n [!code-cs[Net_Listener_Basic#13](~/add/codesnippet/csharp/m-system.net.httplistene_1_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerContext EndGetContext (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>時啟動非同步作業所取得的物件。</xref:System.IAsyncResult>"
    return:
      type: System.Net.HttpListenerContext
      description: "<xref href=&quot;System.Net.HttpListenerContext&quot;> </xref>物件，代表用戶端要求。"
  overload: System.Net.HttpListener.EndGetContext*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>asyncResult</code>藉由呼叫未取得<xref:System.Net.HttpListener.BeginGetContext*>方法。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已呼叫 EndGetContext 方法指定<code> asyncResult </code>物件。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
- uid: System.Net.HttpListener.ExtendedProtectionPolicy
  id: ExtendedProtectionPolicy
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
  fullName: System.Net.HttpListener.ExtendedProtectionPolicy
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "取得或設定<xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;></xref>用於工作階段延伸保護。"
  remarks: "ExtendedProtectionPolicy 屬性搭配整合式 Windows 驗證，以提供延伸的保護。 ExtendedProtectionPolicy 屬性所允許的延伸的保護原則，為整個組態<xref:System.Net.HttpListener>工作階段。</xref:System.Net.HttpListener> <xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A>屬性可讓每個要求的延伸的保護原則的組態。</xref:System.Net.HttpListener.ExtendedProtectionSelectorDelegate%2A>       <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A>屬性必須是`null`。</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> <xref:System.Net.HttpListener>執行個體直接從自己的 TLS 工作階段取得通道繫結權杖 (CBT) 有一個。</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy ExtendedProtectionPolicy { get; set; }
    return:
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "A <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> ，指定要使用擴充保護的原則。"
  overload: System.Net.HttpListener.ExtendedProtectionPolicy*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "嘗試設定 ExtendedProtectionPolicy 屬性，但<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>屬性不是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "嘗試將 ExtendedProtectionPolicy 屬性設定為<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "嘗試設定之後的 ExtendedProtectionPolicy 屬性<xref:System.Net.HttpListener.Start*>已呼叫方法。</xref:System.Net.HttpListener.Start*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement*>屬性設定為<xref href=&quot;System.Security.Authentication.ExtendedProtection.PolicyEnforcement&quot;></xref>不支援擴充的保護的平台上。</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement*>"
  platform:
  - net462
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  id: ExtendedProtectionSelectorDelegate
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
  fullName: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "取得或設定委派，呼叫以判斷<xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;></xref>来用於每個要求。"
  remarks: "<xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A>屬性搭配整合式 Windows 驗證以提供延伸的保護。</xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> <xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A>屬性所允許的延伸的保護原則，為整個組態<xref:System.Net.HttpListener>工作階段。</xref:System.Net.HttpListener> </xref:System.Net.HttpListener.ExtendedProtectionPolicy%2A> ExtendedProtectionSelectorDelegate 屬性可讓每個個別要求的延伸的保護原則的設定。       <xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A>屬性必須是`null`。</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding%2A> <xref:System.Net.HttpListener>執行個體直接從自己的 TLS 工作階段取得通道繫結權杖 (CBT) 有一個。</xref:System.Net.HttpListener>       針對每個要求中，委派可以選擇的設定，<xref:System.Net.HttpListener>執行個體會使用提供延伸的保護。</xref:System.Net.HttpListener>       如果委派傳回`null`對於這個屬性，這代表<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>其中的<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A>屬性設定為<xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement>.</xref:System.Security.Authentication.ExtendedProtection.PolicyEnforcement> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement%2A> </xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>"
  syntax:
    content: public System.Net.HttpListener.ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; set; }
    return:
      type: System.Net.HttpListener.ExtendedProtectionSelector
      description: "A <xref href=&quot;System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy&quot;> </xref> ，指定要使用擴充保護的原則。"
  overload: System.Net.HttpListener.ExtendedProtectionSelectorDelegate*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "嘗試設定 ExtendedProtectionSelectorDelegate 屬性，但<xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>屬性必須是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。</xref:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding*>"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "嘗試將 ExtendedProtectionSelectorDelegate 屬性設定為<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "嘗試設定 ExtendedProtectionSelectorDelegate 屬性之後<xref:System.Net.HttpListener.Start*>已呼叫方法。</xref:System.Net.HttpListener.Start*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "您嘗試在不支援擴充的保護的平台上設定 ExtendedProtectionSelectorDelegate 屬性。"
  platform:
  - net462
- uid: System.Net.HttpListener.GetContext
  id: GetContext
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: GetContext()
  nameWithType: HttpListener.GetContext()
  fullName: System.Net.HttpListener.GetContext()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "等候傳入要求，並傳回其中一個接收時。"
  remarks: "之前呼叫這個方法，您必須呼叫<xref:System.Net.HttpListener.Start%2A>方法並加入至少一個接聽所加入的 URI 字串的 URI 前置詞<xref:System.Net.HttpListenerPrefixCollection>傳回<xref:System.Net.HttpListener.Prefixes%2A>屬性。</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A> 前置詞的詳細說明，請參閱<xref:System.Net.HttpListener>類別概觀。</xref:System.Net.HttpListener>       這個方法會封鎖等候傳入要求。 如果您想要進行處理以非同步方式 （在個別執行緒上） 中，以供您的應用程式不會封鎖連入要求，請使用<xref:System.Net.HttpListener.BeginGetContext%2A>方法。</xref:System.Net.HttpListener.BeginGetContext%2A>"
  example:
  - "The following code example demonstrates calling this method.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/m-system.net.httplistene_19_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerContext GetContext ();
    parameters: []
    return:
      type: System.Net.HttpListenerContext
      description: "<xref href=&quot;System.Net.HttpListenerContext&quot;> </xref>物件，代表用戶端要求。"
  overload: System.Net.HttpListener.GetContext*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Win32 函式呼叫失敗。 請檢查例外狀況的<xref:System.Net.HttpListenerException.ErrorCode*>屬性，以判斷造成例外狀況。</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "此物件尚未啟動，或目前已停止。       -或- <xref href=&quot;System.Net.HttpListener&quot;> </xref>並沒有任何的統一資源識別元 (URI) 前置詞，以回應。 請參閱 < 備註 >。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
- uid: System.Net.HttpListener.GetContextAsync
  id: GetContextAsync
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: GetContextAsync()
  nameWithType: HttpListener.GetContextAsync()
  fullName: System.Net.HttpListener.GetContextAsync()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "等候傳入要求以非同步作業。"
  remarks: "這項作業不會封鎖。 傳回<xref:System.Threading.Tasks.Task%601>物件將會完成時收到內送要求。</xref:System.Threading.Tasks.Task%601>       之前呼叫這個方法，您必須呼叫<xref:System.Net.HttpListener.Start%2A>方法並加入至少一個接聽所加入的 URI 字串的 URI 前置詞<xref:System.Net.HttpListenerPrefixCollection>傳回<xref:System.Net.HttpListener.Prefixes%2A>屬性。</xref:System.Net.HttpListener.Prefixes%2A> </xref:System.Net.HttpListenerPrefixCollection> </xref:System.Net.HttpListener.Start%2A> 前置詞的詳細說明，請參閱<xref:System.Net.HttpListener>類別概觀。</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Threading.Tasks.Task<System.Net.HttpListenerContext> GetContextAsync ();
    parameters: []
    return:
      type: System.Threading.Tasks.Task{System.Net.HttpListenerContext}
      description: "傳回&lt;xref:System.Threading.Tasks.Task%601&gt;。       工作物件，表示非同步作業。 &lt;Xref:System.Threading.Tasks.Task%601.Result%2A&gt;工作物件上的屬性會傳回<xref href=&quot;System.Net.HttpListenerContext&quot;></xref>物件，代表用戶端要求。"
  overload: System.Net.HttpListener.GetContextAsync*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.IgnoreWriteExceptions
  id: IgnoreWriteExceptions
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
  fullName: System.Net.HttpListener.IgnoreWriteExceptions
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "取得或設定<xref:System.Boolean>值，指定您的應用程式是否接收發生的例外狀況時<xref href=&quot;System.Net.HttpListener&quot;></xref>傳送回應至用戶端。</xref:System.Boolean>"
  remarks: "將此屬性設定為`true`如果您的應用程式不需要回應，已成功傳送給每個用戶端。"
  example:
  - "The following code example demonstrates setting this property.  \n  \n [!code-cs[Net_Listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_31_1.cs)]"
  syntax:
    content: public bool IgnoreWriteExceptions { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個<xref href=&quot;System.Net.HttpListener&quot;></xref>不應該傳回例外狀況發生時傳送回應至用戶端; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.HttpListener.IgnoreWriteExceptions*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
- uid: System.Net.HttpListener.IsListening
  id: IsListening
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IsListening
  nameWithType: HttpListener.IsListening
  fullName: System.Net.HttpListener.IsListening
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "取得值，指出是否<xref href=&quot;System.Net.HttpListener&quot;></xref>已啟動。"
  remarks: "若要啟動<xref:System.Net.HttpListener>，呼叫<xref:System.Net.HttpListener.Start%2A>方法。</xref:System.Net.HttpListener.Start%2A> </xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using this property to determine the listening state of an instance.  \n  \n [!code-cs[Net_Listener_Basic#1](~/add/codesnippet/csharp/p-system.net.httplistene_41_1.cs)]"
  syntax:
    content: public bool IsListening { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Net.HttpListener&quot;></xref>已啟動; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.HttpListener.IsListening*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.IsSupported
  id: IsSupported
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: IsSupported
  nameWithType: HttpListener.IsSupported
  fullName: System.Net.HttpListener.IsSupported
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "取得值，指出是否<xref href=&quot;System.Net.HttpListener&quot;></xref>可以搭配目前的作業系統。"
  remarks: "這個類別是只能在執行 Windows XP SP2 或 Windows Server 2003 作業系統的電腦上使用。"
  example:
  - "The following code example demonstrates the use of the IsSupported property to detect whether an <xref:System.Net.HttpListener> object can be used with the current operating system.  \n  \n [!code-cs[Net_Listener_Basic#2](~/add/codesnippet/csharp/p-system.net.httplistene_21_1.cs)]"
  syntax:
    content: public static bool IsSupported { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.Net.HttpListener&quot;></xref>支援，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.HttpListener.IsSupported*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.Prefixes
  id: Prefixes
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Prefixes
  nameWithType: HttpListener.Prefixes
  fullName: System.Net.HttpListener.Prefixes
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "取得這個處理的統一資源識別元 (URI) 前置詞<xref href=&quot;System.Net.HttpListener&quot;></xref>物件。"
  remarks: "前置詞會採用標準格式。 前置詞的詳細說明，請參閱<xref:System.Net.HttpListener>類別概觀。</xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using the Prefixes property to obtain and print the URI prefixes that are handled.  \n  \n [!code-cs[Net_Listener_Basic#1](~/add/codesnippet/csharp/p-system.net.httplistene_24_1.cs)]"
  syntax:
    content: public System.Net.HttpListenerPrefixCollection Prefixes { get; }
    return:
      type: System.Net.HttpListenerPrefixCollection
      description: "<xref href=&quot;System.Net.HttpListenerPrefixCollection&quot;> </xref>所包含的 URI 前置詞這個<xref href=&quot;System.Net.HttpListener&quot;></xref>物件設定來處理。"
  overload: System.Net.HttpListener.Prefixes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
- uid: System.Net.HttpListener.Realm
  id: Realm
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Realm
  nameWithType: HttpListener.Realm
  fullName: System.Net.HttpListener.Realm
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "取得或設定領域或與此相關聯的資源分割<xref href=&quot;System.Net.HttpListener&quot;></xref>物件。"
  remarks: "伺服器使用領域來分割受保護的資源;每個資料分割可以有自己的驗證配置和 （或） 授權資料庫。 領域只用於基本和摘要式驗證。 用戶端成功驗證之後，驗證是適用於對指定領域中的所有資源。 領域的詳細說明，請參閱 RFC 2617 在[http://www.ietf.org](http://www.ietf.org)。       執行個體<xref:System.Net.HttpListener>有只有一個相關聯的領域。</xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates setting the Realm property.  \n  \n [!code-cs[Net_Listener_Basic#10](~/add/codesnippet/csharp/p-system.net.httplistene_26_1.cs)]"
  syntax:
    content: public string Realm { get; set; }
    return:
      type: System.String
      description: "A<xref:System.String>值，其中包含相關聯的領域名稱<xref href=&quot;System.Net.HttpListener&quot;></xref>物件。</xref:System.String>"
  overload: System.Net.HttpListener.Realm*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
- uid: System.Net.HttpListener.Start
  id: Start
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Start()
  nameWithType: HttpListener.Start()
  fullName: System.Net.HttpListener.Start()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "可讓這個執行個體接收傳入要求。"
  remarks: "必須呼叫這個方法，才能呼叫<xref:System.Net.HttpListener.GetContext%2A>或<xref:System.Net.HttpListener.BeginGetContext%2A>方法。</xref:System.Net.HttpListener.BeginGetContext%2A> </xref:System.Net.HttpListener.GetContext%2A>       之後您已經啟動<xref:System.Net.HttpListener>物件，您可以使用<xref:System.Net.HttpListener.Stop%2A>方法來停止它。</xref:System.Net.HttpListener.Stop%2A> </xref:System.Net.HttpListener>      > [!NOTE] > 如果這個接聽程式執行個體使用 https，您必須安裝並選取 伺服器憑證。 否則，<xref:System.Net.HttpWebRequest>這個查詢<xref:System.Net.HttpListener>會失敗，意外的關閉的連接。</xref:System.Net.HttpListener> </xref:System.Net.HttpWebRequest> 您可以使用 HttpCfg.exe 來設定伺服器憑證和其他接聽程式選項。 請參閱[http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp](http://msdn.microsoft.com/library/default.asp?url=/library/http/http/httpcfg_exe.asp)如需詳細資訊。"
  example:
  - "The following code example demonstrates using the Start method to begin processing incoming requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_12_1.cs)]"
  syntax:
    content: public void Start ();
    parameters: []
  overload: System.Net.HttpListener.Start*
  exceptions:
  - type: System.Net.HttpListenerException
    commentId: T:System.Net.HttpListenerException
    description: "Win32 函式呼叫失敗。 請檢查例外狀況的<xref:System.Net.HttpListenerException.ErrorCode*>屬性，以判斷造成例外狀況。</xref:System.Net.HttpListenerException.ErrorCode*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
- uid: System.Net.HttpListener.Stop
  id: Stop
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: Stop()
  nameWithType: HttpListener.Stop()
  fullName: System.Net.HttpListener.Stop()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "使得這個執行個體停止接收內送要求。"
  remarks: "如果這個執行個體已停止，呼叫這個方法沒有任何作用。       之後您已停止的<xref:System.Net.HttpListener>物件，您可以使用<xref:System.Net.HttpListener.Start%2A>方法來重新啟動它。</xref:System.Net.HttpListener.Start%2A> </xref:System.Net.HttpListener>"
  example:
  - "The following code example demonstrates using the Stop method to stop processing incoming requests.  \n  \n [!code-cs[Net_Listener_Basic#12](~/add/codesnippet/csharp/m-system.net.httplistene_5_1.cs)]"
  syntax:
    content: public void Stop ();
    parameters: []
  overload: System.Net.HttpListener.Stop*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
- uid: System.Net.HttpListener.System#IDisposable#Dispose
  id: System#IDisposable#Dispose
  isEii: true
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: System.IDisposable.Dispose()
  nameWithType: HttpListener.System.IDisposable.Dispose()
  fullName: System.Net.HttpListener.System.IDisposable.Dispose()
  type: Method
  assemblies:
  - System
  namespace: System.Net
  summary: "這所持有的資源釋出<xref href=&quot;System.Net.HttpListener&quot;></xref>物件。"
  remarks: "應用程式應該使用<xref:System.Net.HttpListener.Close%2A>方法，而非呼叫這個方法。</xref:System.Net.HttpListener.Close%2A>"
  syntax:
    content: void IDisposable.Dispose ();
    parameters: []
  overload: System.Net.HttpListener.System#IDisposable#Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.TimeoutManager
  id: TimeoutManager
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
  fullName: System.Net.HttpListener.TimeoutManager
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "這個逾時管理員<xref href=&quot;System.Net.HttpListener&quot;></xref>執行個體。"
  remarks: "逾時管理員定義的連接逾時限制此<xref:System.Net.HttpListener>執行個體。</xref:System.Net.HttpListener>"
  syntax:
    content: public System.Net.HttpListenerTimeoutManager TimeoutManager { get; }
    return:
      type: System.Net.HttpListenerTimeoutManager
      description: "Returns <xref href=&quot;System.Net.HttpListenerTimeoutManager&quot;></xref>.       這個逾時管理員<xref href=&quot;System.Net.HttpListener&quot;></xref>執行個體。"
  overload: System.Net.HttpListener.TimeoutManager*
  exceptions: []
  platform:
  - net462
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  id: UnsafeConnectionNtlmAuthentication
  parent: System.Net.HttpListener
  langs:
  - csharp
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
  fullName: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  type: Property
  assemblies:
  - System
  namespace: System.Net
  summary: "取得或設定<xref:System.Boolean>值，控制是否使用 NTLM 時，其他使用相同傳輸控制通訊協定 (TCP) 連接的要求需要驗證。</xref:System.Boolean>"
  remarks: "當這個屬性設定為`true`透過特定的 TCP 連接的第一個要求會使用 NTLM 進行驗證，透過相同的 TCP 連線的後續要求將會使用處理的驗證資訊 (<xref:System.Security.Principal.IIdentity>) 的初始要求。</xref:System.Security.Principal.IIdentity>       當 NTLM 不驗證通訊協定時，此屬性沒有任何作用。 做為驗證通訊協定指定交涉時，這個屬性才 NTLM 是實際的通訊協定用於驗證，就會有效果。      > [!NOTE] > 時將此屬性設定為`true`可提升效能，因為<xref:System.Net.HttpListener>不傳送其他 NTLM 驗證挑戰，不需要提供驗證資訊的所有要求中有安全性風險。</xref:System.Net.HttpListener> 您必須決定是否值得冒這個風險效能提升。"
  example:
  - "The following code example demonstrates setting this property.  \n  \n [!code-cs[Net_Listener_Basic#14](~/add/codesnippet/csharp/p-system.net.httplistene_34_1.cs)]"
  syntax:
    content: public bool UnsafeConnectionNtlmAuthentication { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref:System.Security.Principal.IIdentity>的第一個要求將會被用於相同連接上的後續要求，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Security.Principal.IIdentity> 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "此物件已關閉。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.Net.HttpListenerException
  parent: System.Net
  isExternal: false
  name: HttpListenerException
  nameWithType: HttpListenerException
  fullName: System.Net.HttpListenerException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Net.HttpListener.#ctor
  parent: System.Net.HttpListener
  isExternal: false
  name: HttpListener()
  nameWithType: HttpListener.HttpListener()
  fullName: System.Net.HttpListener.HttpListener()
- uid: System.Net.HttpListener.Abort
  parent: System.Net.HttpListener
  isExternal: false
  name: Abort()
  nameWithType: HttpListener.Abort()
  fullName: System.Net.HttpListener.Abort()
- uid: System.Net.HttpListener.AuthenticationSchemes
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
  fullName: System.Net.HttpListener.AuthenticationSchemes
- uid: System.Net.AuthenticationSchemes
  parent: System.Net
  isExternal: true
  name: AuthenticationSchemes
  nameWithType: AuthenticationSchemes
  fullName: System.Net.AuthenticationSchemes
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
  fullName: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate
- uid: System.Net.AuthenticationSchemeSelector
  parent: System.Net
  isExternal: false
  name: AuthenticationSchemeSelector
  nameWithType: AuthenticationSchemeSelector
  fullName: System.Net.AuthenticationSchemeSelector
- uid: System.Net.HttpListener.BeginGetContext(System.AsyncCallback,System.Object)
  parent: System.Net.HttpListener
  isExternal: false
  name: BeginGetContext(AsyncCallback,Object)
  nameWithType: HttpListener.BeginGetContext(AsyncCallback,Object)
  fullName: System.Net.HttpListener.BeginGetContext(AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Net.HttpListener.Close
  parent: System.Net.HttpListener
  isExternal: false
  name: Close()
  nameWithType: HttpListener.Close()
  fullName: System.Net.HttpListener.Close()
- uid: System.Net.HttpListener.DefaultServiceNames
  parent: System.Net.HttpListener
  isExternal: false
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
  fullName: System.Net.HttpListener.DefaultServiceNames
- uid: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: ServiceNameCollection
  nameWithType: ServiceNameCollection
  fullName: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
- uid: System.Net.HttpListener.EndGetContext(System.IAsyncResult)
  parent: System.Net.HttpListener
  isExternal: false
  name: EndGetContext(IAsyncResult)
  nameWithType: HttpListener.EndGetContext(IAsyncResult)
  fullName: System.Net.HttpListener.EndGetContext(IAsyncResult)
- uid: System.Net.HttpListenerContext
  parent: System.Net
  isExternal: false
  name: HttpListenerContext
  nameWithType: HttpListenerContext
  fullName: System.Net.HttpListenerContext
- uid: System.Net.HttpListener.ExtendedProtectionPolicy
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
  fullName: System.Net.HttpListener.ExtendedProtectionPolicy
- uid: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: ExtendedProtectionPolicy
  fullName: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
  fullName: System.Net.HttpListener.ExtendedProtectionSelectorDelegate
- uid: System.Net.HttpListener.ExtendedProtectionSelector
  parent: System.Net
  isExternal: false
  name: HttpListener+ExtendedProtectionSelector
  nameWithType: HttpListener+ExtendedProtectionSelector
  fullName: System.Net.HttpListener+ExtendedProtectionSelector
- uid: System.Net.HttpListener.GetContext
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContext()
  nameWithType: HttpListener.GetContext()
  fullName: System.Net.HttpListener.GetContext()
- uid: System.Net.HttpListener.GetContextAsync
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContextAsync()
  nameWithType: HttpListener.GetContextAsync()
  fullName: System.Net.HttpListener.GetContextAsync()
- uid: System.Threading.Tasks.Task{System.Net.HttpListenerContext}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<HttpListenerContext>
  nameWithType: Task<HttpListenerContext>
  fullName: System.Threading.Tasks.Task<System.Net.HttpListenerContext>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Net.HttpListenerContext>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Net.HttpListenerContext
    name: HttpListenerContext
    nameWithType: HttpListenerContext
    fullName: HttpListenerContext
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.Net.HttpListener.IgnoreWriteExceptions
  parent: System.Net.HttpListener
  isExternal: false
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
  fullName: System.Net.HttpListener.IgnoreWriteExceptions
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Net.HttpListener.IsListening
  parent: System.Net.HttpListener
  isExternal: false
  name: IsListening
  nameWithType: HttpListener.IsListening
  fullName: System.Net.HttpListener.IsListening
- uid: System.Net.HttpListener.IsSupported
  parent: System.Net.HttpListener
  isExternal: false
  name: IsSupported
  nameWithType: HttpListener.IsSupported
  fullName: System.Net.HttpListener.IsSupported
- uid: System.Net.HttpListener.Prefixes
  parent: System.Net.HttpListener
  isExternal: false
  name: Prefixes
  nameWithType: HttpListener.Prefixes
  fullName: System.Net.HttpListener.Prefixes
- uid: System.Net.HttpListenerPrefixCollection
  parent: System.Net
  isExternal: false
  name: HttpListenerPrefixCollection
  nameWithType: HttpListenerPrefixCollection
  fullName: System.Net.HttpListenerPrefixCollection
- uid: System.Net.HttpListener.Realm
  parent: System.Net.HttpListener
  isExternal: false
  name: Realm
  nameWithType: HttpListener.Realm
  fullName: System.Net.HttpListener.Realm
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Net.HttpListener.Start
  parent: System.Net.HttpListener
  isExternal: false
  name: Start()
  nameWithType: HttpListener.Start()
  fullName: System.Net.HttpListener.Start()
- uid: System.Net.HttpListener.Stop
  parent: System.Net.HttpListener
  isExternal: false
  name: Stop()
  nameWithType: HttpListener.Stop()
  fullName: System.Net.HttpListener.Stop()
- uid: System.Net.HttpListener.System#IDisposable#Dispose
  parent: System.Net.HttpListener
  isExternal: false
  name: System.IDisposable.Dispose()
  nameWithType: HttpListener.System.IDisposable.Dispose()
  fullName: System.Net.HttpListener.System.IDisposable.Dispose()
- uid: System.Net.HttpListener.TimeoutManager
  parent: System.Net.HttpListener
  isExternal: false
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
  fullName: System.Net.HttpListener.TimeoutManager
- uid: System.Net.HttpListenerTimeoutManager
  parent: System.Net
  isExternal: false
  name: HttpListenerTimeoutManager
  nameWithType: HttpListenerTimeoutManager
  fullName: System.Net.HttpListenerTimeoutManager
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
  parent: System.Net.HttpListener
  isExternal: false
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
  fullName: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication
- uid: System.Net.HttpListener.#ctor*
  parent: System.Net.HttpListener
  isExternal: false
  name: HttpListener
  nameWithType: HttpListener.HttpListener
- uid: System.Net.HttpListener.Abort*
  parent: System.Net.HttpListener
  isExternal: false
  name: Abort
  nameWithType: HttpListener.Abort
- uid: System.Net.HttpListener.AuthenticationSchemes*
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemes
  nameWithType: HttpListener.AuthenticationSchemes
- uid: System.Net.HttpListener.AuthenticationSchemeSelectorDelegate*
  parent: System.Net.HttpListener
  isExternal: false
  name: AuthenticationSchemeSelectorDelegate
  nameWithType: HttpListener.AuthenticationSchemeSelectorDelegate
- uid: System.Net.HttpListener.BeginGetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: BeginGetContext
  nameWithType: HttpListener.BeginGetContext
- uid: System.Net.HttpListener.Close*
  parent: System.Net.HttpListener
  isExternal: false
  name: Close
  nameWithType: HttpListener.Close
- uid: System.Net.HttpListener.DefaultServiceNames*
  parent: System.Net.HttpListener
  isExternal: false
  name: DefaultServiceNames
  nameWithType: HttpListener.DefaultServiceNames
- uid: System.Net.HttpListener.EndGetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: EndGetContext
  nameWithType: HttpListener.EndGetContext
- uid: System.Net.HttpListener.ExtendedProtectionPolicy*
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionPolicy
  nameWithType: HttpListener.ExtendedProtectionPolicy
- uid: System.Net.HttpListener.ExtendedProtectionSelectorDelegate*
  parent: System.Net.HttpListener
  isExternal: false
  name: ExtendedProtectionSelectorDelegate
  nameWithType: HttpListener.ExtendedProtectionSelectorDelegate
- uid: System.Net.HttpListener.GetContext*
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContext
  nameWithType: HttpListener.GetContext
- uid: System.Net.HttpListener.GetContextAsync*
  parent: System.Net.HttpListener
  isExternal: false
  name: GetContextAsync
  nameWithType: HttpListener.GetContextAsync
- uid: System.Net.HttpListener.IgnoreWriteExceptions*
  parent: System.Net.HttpListener
  isExternal: false
  name: IgnoreWriteExceptions
  nameWithType: HttpListener.IgnoreWriteExceptions
- uid: System.Net.HttpListener.IsListening*
  parent: System.Net.HttpListener
  isExternal: false
  name: IsListening
  nameWithType: HttpListener.IsListening
- uid: System.Net.HttpListener.IsSupported*
  parent: System.Net.HttpListener
  isExternal: false
  name: IsSupported
  nameWithType: HttpListener.IsSupported
- uid: System.Net.HttpListener.Prefixes*
  parent: System.Net.HttpListener
  isExternal: false
  name: Prefixes
  nameWithType: HttpListener.Prefixes
- uid: System.Net.HttpListener.Realm*
  parent: System.Net.HttpListener
  isExternal: false
  name: Realm
  nameWithType: HttpListener.Realm
- uid: System.Net.HttpListener.Start*
  parent: System.Net.HttpListener
  isExternal: false
  name: Start
  nameWithType: HttpListener.Start
- uid: System.Net.HttpListener.Stop*
  parent: System.Net.HttpListener
  isExternal: false
  name: Stop
  nameWithType: HttpListener.Stop
- uid: System.Net.HttpListener.System#IDisposable#Dispose*
  parent: System.Net.HttpListener
  isExternal: false
  name: System.IDisposable.Dispose
  nameWithType: HttpListener.System.IDisposable.Dispose
- uid: System.Net.HttpListener.TimeoutManager*
  parent: System.Net.HttpListener
  isExternal: false
  name: TimeoutManager
  nameWithType: HttpListener.TimeoutManager
- uid: System.Net.HttpListener.UnsafeConnectionNtlmAuthentication*
  parent: System.Net.HttpListener
  isExternal: false
  name: UnsafeConnectionNtlmAuthentication
  nameWithType: HttpListener.UnsafeConnectionNtlmAuthentication
