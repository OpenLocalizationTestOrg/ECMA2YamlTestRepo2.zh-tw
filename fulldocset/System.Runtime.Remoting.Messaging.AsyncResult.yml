### YamlMime:ManagedReference
items:
- uid: System.Runtime.Remoting.Messaging.AsyncResult
  id: AsyncResult
  children:
  - System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate
  - System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)
  - System.Runtime.Remoting.Messaging.AsyncResult.AsyncState
  - System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle
  - System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously
  - System.Runtime.Remoting.Messaging.AsyncResult.EndInvokeCalled
  - System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage
  - System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted
  - System.Runtime.Remoting.Messaging.AsyncResult.NextSink
  - System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl(System.Runtime.Remoting.Messaging.IMessageCtrl)
  - System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)
  langs:
  - csharp
  name: AsyncResult
  nameWithType: AsyncResult
  fullName: System.Runtime.Remoting.Messaging.AsyncResult
  type: Class
  summary: "封裝委派上非同步作業的結果。"
  remarks: "AsyncResult 類別是與搭配使用非同步方法呼叫使用委派。 <xref:System.IAsyncResult>從委派的傳回`BeginInvoke`方法可以轉換成 AsyncResult。</xref:System.IAsyncResult> AsyncResult 具有<xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A>屬性可保存委派物件上叫用非同步呼叫。</xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate%2A>       如需有關`BeginInvoke`和非同步呼叫使用委派，請參閱[非同步程式設計使用委派](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example demonstrates how to use the <xref:System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle%2A> property to get a <xref:System.Threading.WaitHandle>, and how to wait for an asynchronous call on a delegate. The <xref:System.Threading.WaitHandle> is signaled when the asynchronous call completes, and you can wait for it by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.  \n  \n The example consists of two classes, the class that contains the method which is called asynchronously, and the class that contains the `Main` method that makes the call.  \n  \n For more information and more examples of calling methods asynchronously by using delegates, see [Calling Synchronous Methods Asynchronously](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AsyncDelegateExamples#1](~/add/codesnippet/visualbasic/t-system.runtime.remotin_18_1.vb)]\n [!code-cs[AsyncDelegateExamples#1](~/add/codesnippet/csharp/t-system.runtime.remotin_18_1.cs)]\n [!code-cpp[AsyncDelegateExamples#1](~/add/codesnippet/cpp/t-system.runtime.remotin_18_1.cpp)]  \n[!code-vb[AsyncDelegateExamples#3](~/add/codesnippet/visualbasic/t-system.runtime.remotin_18_2.vb)]\n[!code-cpp[AsyncDelegateExamples#3](~/add/codesnippet/cpp/t-system.runtime.remotin_18_2.cpp)]\n[!code-cs[AsyncDelegateExamples#3](~/add/codesnippet/csharp/t-system.runtime.remotin_18_2.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class AsyncResult : IAsyncResult, System.Runtime.Remoting.Messaging.IMessageSink
  inheritance:
  - System.Object
  implements:
  - System.IAsyncResult
  - System.Runtime.Remoting.Messaging.IMessageSink
  inheritedMembers: []
  platform:
  - net462
- uid: System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate
  id: AsyncDelegate
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  langs:
  - csharp
  name: AsyncDelegate
  nameWithType: AsyncResult.AsyncDelegate
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting.Messaging
  summary: "取得非同步呼叫已叫用的委派物件。"
  remarks: "AsyncDelegate 屬性可以轉換成實際的使用者定義委派類別。       例如，如果用來進行非同步呼叫的委派型別的`MyDelegate`，這個屬性所傳回的委派必須轉換成`MyDelegate`。 回呼方法接著便可以呼叫的委派`EndInvoke`具有正確的簽章，以取得結果的非同步方法呼叫的方法。"
  example:
  - "The following code example demonstrates how to use the AsyncDelegate property to get the delegate that was used to make the asynchronous call, in order to call `EndInvoke`. The example casts the <xref:System.IAsyncResult>, which is the only parameter of the callback method, to an <xref:System.Runtime.Remoting.Messaging.AsyncResult> object.  \n  \n The example consists of two classes, the class that contains the method which is called asynchronously, and the class that contains the `Main` method that makes the call.  \n  \n For more information on the way this callback example works, and more examples of calling methods asynchronously by using delegates, see [Calling Synchronous Methods Asynchronously](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AsyncDelegateExamples#1](~/add/codesnippet/visualbasic/p-system.runtime.remotin_95_1.vb)]\n [!code-cs[AsyncDelegateExamples#1](~/add/codesnippet/csharp/p-system.runtime.remotin_95_1.cs)]\n [!code-cpp[AsyncDelegateExamples#1](~/add/codesnippet/cpp/p-system.runtime.remotin_95_1.cpp)]  \n[!code-cs[AsyncDelegateExamples#5](~/add/codesnippet/csharp/p-system.runtime.remotin_95_2.cs)]\n[!code-cpp[AsyncDelegateExamples#5](~/add/codesnippet/cpp/p-system.runtime.remotin_95_2.cpp)]\n[!code-vb[AsyncDelegateExamples#5](~/add/codesnippet/visualbasic/p-system.runtime.remotin_95_2.vb)]"
  syntax:
    content: public virtual object AsyncDelegate { get; }
    return:
      type: System.Object
      description: "非同步呼叫已叫用委派物件。"
  overload: System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)
  id: AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  langs:
  - csharp
  name: AsyncProcessMessage(IMessage,IMessageSink)
  nameWithType: AsyncResult.AsyncProcessMessage(IMessage,IMessageSink)
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage(IMessage,IMessageSink)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting.Messaging
  summary: "實作<xref href=&quot;System.Runtime.Remoting.Messaging.IMessageSink&quot;></xref>介面。"
  remarks: "<xref:System.Runtime.Remoting.Messaging.IMessageSink>介面是不相關<xref:System.Runtime.Remoting.Messaging.AsyncResult>類別</xref:System.Runtime.Remoting.Messaging.AsyncResult></xref:System.Runtime.Remoting.Messaging.IMessageSink>AsyncProcessMessage 方法 實作<xref:System.Runtime.Remoting.Messaging.AsyncResult>會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Runtime.Remoting.Messaging.AsyncResult> 相反地，取得<xref:System.Runtime.Remoting.Messaging.AsyncResult>透過將轉型<xref:System.IAsyncResult>發出使用委派非同步呼叫所傳回的介面。</xref:System.IAsyncResult> </xref:System.Runtime.Remoting.Messaging.AsyncResult>"
  syntax:
    content: public virtual System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMessage
      description: "要求<xref href=&quot;System.Runtime.Remoting.Messaging.IMessage&quot;></xref>介面。"
    - id: replySink
      type: System.Runtime.Remoting.Messaging.IMessageSink
      description: "回應<xref href=&quot;System.Runtime.Remoting.Messaging.IMessageSink&quot;></xref>介面。"
    return:
      type: System.Runtime.Remoting.Messaging.IMessageCtrl
      description: "沒有傳回值。"
  overload: System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.Messaging.AsyncResult.AsyncState
  id: AsyncState
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  langs:
  - csharp
  name: AsyncState
  nameWithType: AsyncResult.AsyncState
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.AsyncState
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting.Messaging
  summary: "取得物件的最後一個參數當做提供<xref uid=&quot;langword_csharp_BeginInvoke&quot; name=&quot;BeginInvoke&quot; href=&quot;&quot;></xref>方法呼叫。"
  remarks: "如需有關`BeginInvoke`方法，請參閱[非同步程式設計使用委派](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates how the AsyncState property is used to pass information to a callback method. The last parameter of the `BeginInvoke` method call is a format string, which the callback method uses to format an output message.  \n  \n The example consists of two classes, the class that contains the method which is called asynchronously, and the class that contains the `Main` method that makes the call.  \n  \n For more information on the way this callback example works, and more examples of calling methods asynchronously by using delegates, see [Calling Synchronous Methods Asynchronously](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AsyncDelegateExamples#1](~/add/codesnippet/visualbasic/p-system.runtime.remotin_83_1.vb)]\n [!code-cs[AsyncDelegateExamples#1](~/add/codesnippet/csharp/p-system.runtime.remotin_83_1.cs)]\n [!code-cpp[AsyncDelegateExamples#1](~/add/codesnippet/cpp/p-system.runtime.remotin_83_1.cpp)]  \n[!code-cs[AsyncDelegateExamples#5](~/add/codesnippet/csharp/p-system.runtime.remotin_83_2.cs)]\n[!code-cpp[AsyncDelegateExamples#5](~/add/codesnippet/cpp/p-system.runtime.remotin_83_2.cpp)]\n[!code-vb[AsyncDelegateExamples#5](~/add/codesnippet/visualbasic/p-system.runtime.remotin_83_2.vb)]"
  syntax:
    content: public virtual object AsyncState { get; }
    return:
      type: System.Object
      description: "提供的最後一個參數為物件<xref uid=&quot;langword_csharp_BeginInvoke&quot; name=&quot;BeginInvoke&quot; href=&quot;&quot;></xref>方法呼叫。"
  overload: System.Runtime.Remoting.Messaging.AsyncResult.AsyncState*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle
  id: AsyncWaitHandle
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  langs:
  - csharp
  name: AsyncWaitHandle
  nameWithType: AsyncResult.AsyncWaitHandle
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting.Messaging
  summary: "取得<xref:System.Threading.WaitHandle>封裝 Win32 同步控制代碼，而且可讓各種同步處理的配置的實作。</xref:System.Threading.WaitHandle>"
  remarks: "<xref:System.Threading.WaitHandle>傳回此方法的非同步作業完成時自動收到信號。</xref:System.Threading.WaitHandle>       等候控制代碼不會自動關閉當您呼叫`EndInvoke`上用來進行非同步方法呼叫的委派。 如果您釋放所有等候控制代碼的參考，當記憶體回收收回等候控制代碼時，會釋放系統資源。 若要釋放系統資源，當您使用完等候控制代碼，呼叫<xref:System.Threading.WaitHandle.Close%2A?displayProperty=fullName>方法。</xref:System.Threading.WaitHandle.Close%2A?displayProperty=fullName> 明確地關閉或處置可處置的物件時，記憶體回收會更有效率。      > [!CAUTION] > <xref:System.Threading.WaitHandle>AsyncWaitHandle 屬性可用來非同步呼叫完成之前會封鎖目前執行緒中所包含。</xref:System.Threading.WaitHandle> 不過，<xref:System.Threading.WaitHandle>將會忽略<xref:System.AsyncCallback>，如果有指定期間`BeginInvoke`呼叫。</xref:System.AsyncCallback> </xref:System.Threading.WaitHandle> 因此，情況會發生在應用程式關閉之前<xref:System.AsyncCallback>已完成執行，即使<xref:System.Threading.WaitHandle>用來非同步呼叫完成的區塊。</xref:System.Threading.WaitHandle> </xref:System.AsyncCallback> 如需這種情況的範例，請參閱範例的<xref:System.Runtime.Remoting.Messaging.AsyncResult>類別，並移除<xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName>陳述式。</xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> </xref:System.Runtime.Remoting.Messaging.AsyncResult>"
  example:
  - "The following example demonstrates how to use the AsyncWaitHandle property to get a <xref:System.Threading.WaitHandle>, and how to wait for an asynchronous call on a delegate. The <xref:System.Threading.WaitHandle> is signaled when the asynchronous call completes, and you can wait for it by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.  \n  \n The example consists of two classes, the class that contains the method which is called asynchronously, and the class that contains the `Main` method that makes the call.  \n  \n For more information and more examples of calling methods asynchronously by using delegates, see [Calling Synchronous Methods Asynchronously](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AsyncDelegateExamples#1](~/add/codesnippet/visualbasic/p-system.runtime.remotin_47_1.vb)]\n [!code-cs[AsyncDelegateExamples#1](~/add/codesnippet/csharp/p-system.runtime.remotin_47_1.cs)]\n [!code-cpp[AsyncDelegateExamples#1](~/add/codesnippet/cpp/p-system.runtime.remotin_47_1.cpp)]  \n[!code-vb[AsyncDelegateExamples#3](~/add/codesnippet/visualbasic/p-system.runtime.remotin_47_2.vb)]\n[!code-cpp[AsyncDelegateExamples#3](~/add/codesnippet/cpp/p-system.runtime.remotin_47_2.cpp)]\n[!code-cs[AsyncDelegateExamples#3](~/add/codesnippet/csharp/p-system.runtime.remotin_47_2.cs)]"
  syntax:
    content: public virtual System.Threading.WaitHandle AsyncWaitHandle { get; }
    return:
      type: System.Threading.WaitHandle
      description: "A<xref:System.Threading.WaitHandle>封裝 Win32 同步控制代碼，而且可讓各種同步處理的配置的實作。</xref:System.Threading.WaitHandle>"
  overload: System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously
  id: CompletedSynchronously
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  langs:
  - csharp
  name: CompletedSynchronously
  nameWithType: AsyncResult.CompletedSynchronously
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting.Messaging
  summary: "取得值，指出是否<xref uid=&quot;langword_csharp_BeginInvoke&quot; name=&quot;BeginInvoke&quot; href=&quot;&quot;></xref>呼叫已同步完成。"
  remarks: "如果它偵測到的`BeginInvoke`呼叫已完成同步在<xref:System.AsyncCallback>委派，它是可能性呼叫 BeginInvoke 執行緒目前的執行緒。</xref:System.AsyncCallback> 大部分的提供者的<xref:System.IAsyncResult>介面不會使用的功能，而且會傳回預設值`false`。</xref:System.IAsyncResult>       目前實作的 CompletedSynchronously 一律會傳回`false`。"
  syntax:
    content: public virtual bool CompletedSynchronously { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref uid=&quot;langword_csharp_BeginInvoke&quot; name=&quot;BeginInvoke&quot; href=&quot;&quot;></xref>同步完成，否則呼叫<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.Messaging.AsyncResult.EndInvokeCalled
  id: EndInvokeCalled
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  langs:
  - csharp
  name: EndInvokeCalled
  nameWithType: AsyncResult.EndInvokeCalled
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.EndInvokeCalled
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting.Messaging
  summary: "取得或設定值，指出是否<xref uid=&quot;langword_csharp_EndInvoke&quot; name=&quot;EndInvoke&quot; href=&quot;&quot;></xref>已經在目前呼叫<xref href=&quot;System.Runtime.Remoting.Messaging.AsyncResult&quot;> </xref>。"
  syntax:
    content: public bool EndInvokeCalled { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref uid=&quot;langword_csharp_EndInvoke&quot; name=&quot;EndInvoke&quot; href=&quot;&quot;></xref>已經在目前呼叫<xref href=&quot;System.Runtime.Remoting.Messaging.AsyncResult&quot;> </xref>，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Runtime.Remoting.Messaging.AsyncResult.EndInvokeCalled*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage
  id: GetReplyMessage
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  langs:
  - csharp
  name: GetReplyMessage()
  nameWithType: AsyncResult.GetReplyMessage()
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting.Messaging
  summary: "取得非同步呼叫的回應訊息。"
  remarks: "GetReplyMessage 方法可以傳回的物件之後<xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A>方法呼叫。</xref:System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage%2A> <xref:System.Runtime.Remoting.Messaging.IMessage>傳回值可以轉換成<xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage>.</xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage> </xref:System.Runtime.Remoting.Messaging.IMessage>       不過，您不需要直接呼叫其中一種方法。 它們適用於.NET Framework 的遠端執行功能基礎結構。"
  syntax:
    content: public virtual System.Runtime.Remoting.Messaging.IMessage GetReplyMessage ();
    parameters: []
    return:
      type: System.Runtime.Remoting.Messaging.IMessage
      description: "遠端訊息應該代表遠端物件上的方法呼叫的回應。"
  overload: System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted
  id: IsCompleted
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  langs:
  - csharp
  name: IsCompleted
  nameWithType: AsyncResult.IsCompleted
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting.Messaging
  summary: "取得值，指出伺服器是否已完成呼叫。"
  remarks: "伺服器必須使用任何用戶端提供以外的資源所同意時它將 IsCompleted 屬性設定之後，共用語意`true`。 因此，它是安全的用戶端之後 IsCompleted 屬性會傳回終結資源`true`。"
  example:
  - "The following example shows how to use the <xref:System.IAsyncResult.IsCompleted%2A> property of the <xref:System.Runtime.Remoting.Messaging.AsyncResult> returned by `BeginInvoke` to discover when an asynchronous call completes. You might do this when making the asynchronous call from a thread that services the user interface. Polling for completion allows the calling thread to continue executing while the asynchronous call executes on a <xref:System.Threading.ThreadPool> thread.  \n  \n The example consists of two classes, the class that contains the method which is called asynchronously, and the class that contains the `Main` method that makes the call.  \n  \n For more information and more examples of calling methods asynchronously by using delegates, see [Calling Synchronous Methods Asynchronously](~/add/includes/ajax-current-ext-md.md).  \n  \n [!code-vb[AsyncDelegateExamples#1](~/add/codesnippet/visualbasic/p-system.runtime.remotin_39_1.vb)]\n [!code-cs[AsyncDelegateExamples#1](~/add/codesnippet/csharp/p-system.runtime.remotin_39_1.cs)]\n [!code-cpp[AsyncDelegateExamples#1](~/add/codesnippet/cpp/p-system.runtime.remotin_39_1.cpp)]  \n[!code-cpp[AsyncDelegateExamples#4](~/add/codesnippet/cpp/p-system.runtime.remotin_39_2.cpp)]\n[!code-cs[AsyncDelegateExamples#4](~/add/codesnippet/csharp/p-system.runtime.remotin_39_2.cs)]\n[!code-vb[AsyncDelegateExamples#4](~/add/codesnippet/visualbasic/p-system.runtime.remotin_39_2.vb)]"
  syntax:
    content: public virtual bool IsCompleted { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>伺服器完成呼叫; 之後否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.Messaging.AsyncResult.NextSink
  id: NextSink
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  langs:
  - csharp
  name: NextSink
  nameWithType: AsyncResult.NextSink
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.NextSink
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting.Messaging
  summary: "取得接收鏈結中的下一個訊息接收。"
  remarks: "傳回目前的 NextSink 實作`null`。"
  syntax:
    content: public System.Runtime.Remoting.Messaging.IMessageSink NextSink { get; }
    return:
      type: System.Runtime.Remoting.Messaging.IMessageSink
      description: "<xref href=&quot;System.Runtime.Remoting.Messaging.IMessageSink&quot;> </xref>接收鏈結中接收的介面，表示下一個訊息。"
  overload: System.Runtime.Remoting.Messaging.AsyncResult.NextSink*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl(System.Runtime.Remoting.Messaging.IMessageCtrl)
  id: SetMessageCtrl(System.Runtime.Remoting.Messaging.IMessageCtrl)
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  langs:
  - csharp
  name: SetMessageCtrl(IMessageCtrl)
  nameWithType: AsyncResult.SetMessageCtrl(IMessageCtrl)
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl(IMessageCtrl)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting.Messaging
  summary: "設定<xref href=&quot;System.Runtime.Remoting.Messaging.IMessageCtrl&quot;></xref>目前的遠端方法呼叫，這樣會提供方法來控制非同步訊息分派它們之後。"
  remarks: "您不需要呼叫 SetMessageCtrl 方法。"
  syntax:
    content: public virtual void SetMessageCtrl (System.Runtime.Remoting.Messaging.IMessageCtrl mc);
    parameters:
    - id: mc
      type: System.Runtime.Remoting.Messaging.IMessageCtrl
      description: "<xref href=&quot;System.Runtime.Remoting.Messaging.IMessageCtrl&quot;> </xref>目前的遠端方法呼叫。"
  overload: System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)
  id: SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  langs:
  - csharp
  name: SyncProcessMessage(IMessage)
  nameWithType: AsyncResult.SyncProcessMessage(IMessage)
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage(IMessage)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting.Messaging
  summary: "同步處理遠端物件上方法呼叫所傳回的回應訊息。"
  remarks: "SyncProcessMessage 方法會實作<xref:System.Runtime.Remoting.Messaging.IMessageSink>介面。</xref:System.Runtime.Remoting.Messaging.IMessageSink> 您不需要直接呼叫這個方法。 它適用於.NET Framework 的遠端執行功能基礎結構。       SyncProcessMessage 叫用的消費者程式碼<xref:System.AsyncCallback>委派。</xref:System.AsyncCallback> 它也會設定<xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage>所傳回的執行個體<xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A>方法。</xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A> </xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage> 如果`msg`參數是型別<xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage>、 <xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A>.</xref:System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage%2A>會傳回相同的物件</xref:System.Runtime.Remoting.Messaging.IMethodReturnMessage> 否則，會傳回回覆訊息，其中包含遠端處理的例外狀況。       SyncProcessMessage 也會修改所傳回的值<xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A>屬性。</xref:System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted%2A>"
  syntax:
    content: public virtual System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg);
    parameters:
    - id: msg
      type: System.Runtime.Remoting.Messaging.IMessage
      description: "遠端物件上呼叫方法的回應訊息。"
    return:
      type: System.Runtime.Remoting.Messaging.IMessage
      description: "Returns <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  overload: System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: AsyncDelegate
  nameWithType: AsyncResult.AsyncDelegate
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate
- uid: System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage,System.Runtime.Remoting.Messaging.IMessageSink)
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: AsyncProcessMessage(IMessage,IMessageSink)
  nameWithType: AsyncResult.AsyncProcessMessage(IMessage,IMessageSink)
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage(IMessage,IMessageSink)
- uid: System.Runtime.Remoting.Messaging.IMessageCtrl
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMessageCtrl
  nameWithType: IMessageCtrl
  fullName: System.Runtime.Remoting.Messaging.IMessageCtrl
- uid: System.Runtime.Remoting.Messaging.IMessage
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMessage
  nameWithType: IMessage
  fullName: System.Runtime.Remoting.Messaging.IMessage
- uid: System.Runtime.Remoting.Messaging.IMessageSink
  parent: System.Runtime.Remoting.Messaging
  isExternal: false
  name: IMessageSink
  nameWithType: IMessageSink
  fullName: System.Runtime.Remoting.Messaging.IMessageSink
- uid: System.Runtime.Remoting.Messaging.AsyncResult.AsyncState
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: AsyncState
  nameWithType: AsyncResult.AsyncState
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.AsyncState
- uid: System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: AsyncWaitHandle
  nameWithType: AsyncResult.AsyncWaitHandle
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: true
  name: WaitHandle
  nameWithType: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: CompletedSynchronously
  nameWithType: AsyncResult.CompletedSynchronously
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Runtime.Remoting.Messaging.AsyncResult.EndInvokeCalled
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: EndInvokeCalled
  nameWithType: AsyncResult.EndInvokeCalled
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.EndInvokeCalled
- uid: System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: GetReplyMessage()
  nameWithType: AsyncResult.GetReplyMessage()
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage()
- uid: System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: IsCompleted
  nameWithType: AsyncResult.IsCompleted
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted
- uid: System.Runtime.Remoting.Messaging.AsyncResult.NextSink
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: NextSink
  nameWithType: AsyncResult.NextSink
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.NextSink
- uid: System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl(System.Runtime.Remoting.Messaging.IMessageCtrl)
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: SetMessageCtrl(IMessageCtrl)
  nameWithType: AsyncResult.SetMessageCtrl(IMessageCtrl)
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl(IMessageCtrl)
- uid: System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage)
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: SyncProcessMessage(IMessage)
  nameWithType: AsyncResult.SyncProcessMessage(IMessage)
  fullName: System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage(IMessage)
- uid: System.Runtime.Remoting.Messaging.AsyncResult.AsyncDelegate*
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: AsyncDelegate
  nameWithType: AsyncResult.AsyncDelegate
- uid: System.Runtime.Remoting.Messaging.AsyncResult.AsyncProcessMessage*
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: AsyncProcessMessage
  nameWithType: AsyncResult.AsyncProcessMessage
- uid: System.Runtime.Remoting.Messaging.AsyncResult.AsyncState*
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: AsyncState
  nameWithType: AsyncResult.AsyncState
- uid: System.Runtime.Remoting.Messaging.AsyncResult.AsyncWaitHandle*
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: AsyncWaitHandle
  nameWithType: AsyncResult.AsyncWaitHandle
- uid: System.Runtime.Remoting.Messaging.AsyncResult.CompletedSynchronously*
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: CompletedSynchronously
  nameWithType: AsyncResult.CompletedSynchronously
- uid: System.Runtime.Remoting.Messaging.AsyncResult.EndInvokeCalled*
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: EndInvokeCalled
  nameWithType: AsyncResult.EndInvokeCalled
- uid: System.Runtime.Remoting.Messaging.AsyncResult.GetReplyMessage*
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: GetReplyMessage
  nameWithType: AsyncResult.GetReplyMessage
- uid: System.Runtime.Remoting.Messaging.AsyncResult.IsCompleted*
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: IsCompleted
  nameWithType: AsyncResult.IsCompleted
- uid: System.Runtime.Remoting.Messaging.AsyncResult.NextSink*
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: NextSink
  nameWithType: AsyncResult.NextSink
- uid: System.Runtime.Remoting.Messaging.AsyncResult.SetMessageCtrl*
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: SetMessageCtrl
  nameWithType: AsyncResult.SetMessageCtrl
- uid: System.Runtime.Remoting.Messaging.AsyncResult.SyncProcessMessage*
  parent: System.Runtime.Remoting.Messaging.AsyncResult
  isExternal: false
  name: SyncProcessMessage
  nameWithType: AsyncResult.SyncProcessMessage
