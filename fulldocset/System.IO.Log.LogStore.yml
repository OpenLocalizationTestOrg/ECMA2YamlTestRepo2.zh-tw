### YamlMime:ManagedReference
items:
- uid: System.IO.Log.LogStore
  id: LogStore
  children:
  - System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  - System.IO.Log.LogStore.Archivable
  - System.IO.Log.LogStore.BaseSequenceNumber
  - System.IO.Log.LogStore.CreateLogArchiveSnapshot
  - System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  - System.IO.Log.LogStore.Delete(System.String)
  - System.IO.Log.LogStore.Dispose
  - System.IO.Log.LogStore.Extents
  - System.IO.Log.LogStore.FreeBytes
  - System.IO.Log.LogStore.Handle
  - System.IO.Log.LogStore.LastSequenceNumber
  - System.IO.Log.LogStore.Length
  - System.IO.Log.LogStore.Policy
  - System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  - System.IO.Log.LogStore.StreamCount
  langs:
  - csharp
  name: LogStore
  nameWithType: LogStore
  fullName: System.IO.Log.LogStore
  type: Class
  summary: "代表記錄結構化儲存體。"
  remarks: "<xref:System.IO.Log.LogRecordSequence>類別提供的一般記錄檔系統 (CLFS) 記錄頂端的記錄順序介面實作</xref:System.IO.Log.LogRecordSequence> 它可搭配因為尚未類別，可提供直接操作和管理 CLFS 記錄檔的介面。 記錄存放區會提供一組延伸磁碟區的附加專用儲存體。 因為尚未類別代表這個儲存體，並提供方法來加入和移除容器、 設定原則，以及建立封存。 不提供方法的讀取和寫入儲存體。這些方法提供的<xref:System.IO.Log.LogRecordSequence>類別。</xref:System.IO.Log.LogRecordSequence>       因為尚未類別之間的關聯性和<xref:System.IO.Log.LogRecordSequence>類別是類似於磁碟檔案之間的關聯性和<xref:System.IO.FileStream>物件。</xref:System.IO.FileStream> </xref:System.IO.Log.LogRecordSequence> 磁碟檔案提供實際的儲存體，且具有 「 長度 」 和 「 上次存取時間時的<xref:System.IO.FileStream>物件提供的檢視，可以用來讀取和寫入該檔案</xref:System.IO.FileStream>等屬性 同樣地，因為尚未類別也具有原則和延伸磁碟區集合等屬性和<xref:System.IO.Log.LogRecordSequence>類別提供讀取和寫入資料的記錄導向機制。</xref:System.IO.Log.LogRecordSequence>       不同於所代表的檔案記錄順序<xref:System.IO.Log.FileRecordSequence>類別，因為尚未執行個體就會將其資料儲存集合中的延伸磁碟區，由<xref:System.IO.Log.LogExtent>執行個體。</xref:System.IO.Log.LogExtent> </xref:System.IO.Log.FileRecordSequence> 因為尚未指定執行個體中的延伸區大小均等，而加入和移除從因為尚未執行個體以範圍為增量單位空間時。 若要加入及移除延伸記錄區，使用<xref:System.IO.Log.LogExtentCollection.Add%2A>和<xref:System.IO.Log.LogExtentCollection.Remove%2A>方法<xref:System.IO.Log.LogExtentCollection>物件，可傳回<xref:System.IO.Log.LogStore.Extents%2A>屬性。</xref:System.IO.Log.LogStore.Extents%2A> </xref:System.IO.Log.LogExtentCollection> </xref:System.IO.Log.LogExtentCollection.Remove%2A> </xref:System.IO.Log.LogExtentCollection.Add%2A>       因為尚未執行個體可以有與其相關聯的原則。 這些都由<xref:System.IO.Log.LogPolicy>可傳回的執行個體<xref:System.IO.Log.LogStore.Policy%2A>屬性。</xref:System.IO.Log.LogStore.Policy%2A> </xref:System.IO.Log.LogPolicy> 原則會規定記錄檔將會嘗試依照，例如延伸區大小下限，並指示的最大數目的成長或壓縮因為尚未在某些情況下的規則。 此外，您可以指定是否可以封存因為尚未執行個體。 原則設定每個記錄，並為變動性，這表示一旦記錄檔的所有控制代碼關閉時，有這個原則不會再。"
  example:
  - "The following example shows how to archive a LogStore to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/t-system.io.log.logstore_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/t-system.io.log.logstore_1.cs)]"
  syntax:
    content: 'public sealed class LogStore : IDisposable'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(SafeFileHandle)
  nameWithType: LogStore.LogStore(SafeFileHandle)
  fullName: System.IO.Log.LogStore.LogStore(SafeFileHandle)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.LogStore&quot;></xref>類別指定的控制代碼。"
  syntax:
    content: public LogStore (Microsoft.Win32.SafeHandles.SafeFileHandle handle);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "檔案控制代碼的記錄檔目前<xref href=&quot;System.IO.Log.LogStore&quot;></xref>物件封裝。"
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>handle</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "記錄檔的控制代碼可能未繫結至執行緒集區。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄存放區遭作業系統拒絕。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode)
  nameWithType: LogStore.LogStore(String,FileMode)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.LogStore&quot;></xref>使用指定的路徑和模式的類別。"
  remarks: "使用這個建構函式來開啟記錄存放區使用指定的路徑和模式。 存放區會以讀取/寫入存取開啟，並且共用讀取權限。       `path`參數應使用下列語法︰`log:<physical log name>[::<log client name>]`其中`<physical log name>`是記錄檔的有效路徑和`<log client name>`是唯一的用戶端識別碼。 將記錄存放區應該是實體記錄存放區或虛擬記錄存放區中，但非兩者。 一旦將記錄存放區已建立實體或虛擬，該值保持不變的存留期間。 實體記錄存放區的建立方式指定實體記錄名稱。 指定實體記錄名稱和記錄用戶端名稱所建立的虛擬記錄存放區。       共用相同的實體記錄名稱的用戶端會共用同一個延伸區集合和原則。"
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "若要開啟的記錄存放區基底檔案的相對或絕對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值，決定如何開啟或建立存放區。"
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)。       -或-<code>path</code>只包含空格。       -或-<code>path</code>包含一或多個無效的字元。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含無效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到檔案。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟記錄存放區時發生 I/O 錯誤。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄存放區遭作業系統拒絕。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>無法使用，因為未安裝必要的通用記錄檔系統 (CLFS) 元件。 安裝 CLFS 元件適用於您的平台或使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>類別。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.LogStore&quot;></xref>與指定的路徑、 模式和存取的類別。"
  remarks: "使用指定的路徑、 模式和存取中開啟新的記錄存放區中使用這個建構函式。 共用讀取權限來開啟的存放區。       `path`參數應使用下列語法︰`log:<physical log name>[::<log client name>]`其中`<physical log name>`是記錄檔的有效路徑和`<log client name>`是唯一的用戶端識別碼。 將記錄存放區應該是實體記錄存放區或虛擬記錄存放區中，但非兩者。 一旦將記錄存放區已建立實體或虛擬，該值保持不變的存留期間。 實體記錄存放區的建立方式指定實體記錄名稱。 指定實體記錄名稱和記錄用戶端名稱所建立的虛擬記錄存放區。       共用相同的實體記錄名稱的用戶端會共用同一個延伸區集合和原則。"
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "若要開啟的記錄存放區基底檔案的相對或絕對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值，決定如何開啟或建立存放區。"
    - id: access
      type: System.IO.FileAccess
      description: "其中一個<xref href=&quot;System.IO.FileAccess&quot;></xref>值，決定如何存取檔案所<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)。       -或-<code>path</code>只包含空格。       -或-<code>path</code>包含一或多個無效的字元。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含無效的值。       -或<code>access</code>包含無效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到檔案。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟記錄存放區時發生 I/O 錯誤。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄存放區遭作業系統拒絕。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>無法使用，因為未安裝必要的通用記錄檔系統 (CLFS) 元件。 安裝 CLFS 元件適用於您的平台或使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>類別。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess,FileShare)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.LogStore&quot;></xref>類別。"
  remarks: "這個建構函式初始化新<xref:System.IO.Log.LogStore>以指定的路徑、 模式和存取所開啟的物件。</xref:System.IO.Log.LogStore> 共用指定的存取權限來開啟的存放區。       `path`參數應使用下列語法︰`log:<physical log name>[::<log client name>]`其中`<physical log name>`是記錄檔的有效路徑和`<log client name>`是唯一的用戶端識別碼。 將記錄存放區應該是實體記錄存放區或虛擬記錄存放區中，但非兩者。 一旦將記錄存放區已建立實體或虛擬，該值保持不變的存留期間。 實體記錄存放區的建立方式指定實體記錄名稱。 指定實體記錄名稱和記錄用戶端名稱所建立的虛擬記錄存放區。       共用相同的實體記錄名稱的用戶端會共用同一個延伸區集合和原則。"
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "若要開啟的記錄存放區基底檔案的相對或絕對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值，決定如何開啟或建立存放區。"
    - id: access
      type: System.IO.FileAccess
      description: "其中一個<xref href=&quot;System.IO.FileAccess&quot;></xref>值，決定如何存取檔案所<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
    - id: share
      type: System.IO.FileShare
      description: "其中一個<xref href=&quot;System.IO.FileShare&quot;></xref>值，決定如何在處理序之間共用記錄存放區。"
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)。       -或-<code>path</code>只包含空格。       -或-<code>path</code>包含一或多個無效的字元。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含無效的值。       -或<code>access</code>包含無效的值。       -或-<code>share</code>包含無效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到檔案。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟記錄存放區時發生 I/O 錯誤。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄存放區遭作業系統拒絕。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>無法使用，因為未安裝必要的通用記錄檔系統 (CLFS) 元件。 安裝 CLFS 元件適用於您的平台或使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>類別。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.LogStore&quot;></xref>類別。"
  remarks: "這個建構函式初始化新<xref:System.IO.Log.LogStore>以指定的路徑、 模式和存取所開啟的物件。</xref:System.IO.Log.LogStore> 共用指定的存取權限來開啟的存放區。 `path`參數應遵循下列語法︰`log:<physical log name>[::<log client name>]`其中`<physical log name>`是記錄檔的有效路徑和`<log client name>`是唯一的用戶端識別碼。 將記錄存放區應該是實體記錄存放區或虛擬記錄存放區中，但非兩者。 一旦將記錄存放區已建立實體或虛擬，該值保持不變的存留期間。 實體記錄存放區的建立方式指定實體記錄名稱。 指定實體記錄名稱和記錄用戶端名稱所建立的虛擬記錄存放區。       共用相同的實體記錄名稱的用戶端會共用同一個延伸區集合和原則。"
  syntax:
    content: public LogStore (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "若要開啟的記錄存放區基底檔案的相對或絕對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值，決定如何開啟或建立存放區。"
    - id: access
      type: System.IO.FileAccess
      description: "其中一個<xref href=&quot;System.IO.FileAccess&quot;></xref>值，決定如何存取檔案所<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
    - id: share
      type: System.IO.FileShare
      description: "其中一個<xref href=&quot;System.IO.FileShare&quot;></xref>值，決定如何在處理序之間共用記錄存放區。"
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "其中一個<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>值，指定要設定新建立的存放區上，如果必須建立存放區的安全性。"
  overload: System.IO.Log.LogStore.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "所指定的記錄存放區檔案名稱<code> path </code>不正確。       - <code> Mode </code>是<xref uid=&quot;langword_csharp_CreateNew&quot; name=&quot;CreateNew&quot; href=&quot;&quot;> </xref>，就無法使用沒有寫入存取權。       - <code> Mode </code>是<xref uid=&quot;langword_csharp_OpenOrCreate&quot; name=&quot;OpenOrCreate&quot; href=&quot;&quot;> </xref>，就無法使用沒有寫入存取權。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含無效的值。       -或<code>access</code>包含無效的值。       -或-<code>share</code>包含無效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到檔案。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟記錄存放區時發生 I/O 錯誤。       所指定的檔案<code> path </code>無法存取，因為它正在使用中另一個處理序。       -所指定的檔案<code> path </code>無法建立，因為檔案或目錄已存在。       -或者-記錄檔的控制代碼無法繫結至執行緒集區。       -或者-指定的記錄檔格式或版本無效。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "<xref href=&quot;System.IO.Log.LogStore&quot;></xref>無法使用，因為未安裝必要的通用記錄檔系統 (CLFS) 元件。 安裝 CLFS 元件適用於您的平台或使用<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>類別。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄存放區遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.Archivable
  id: Archivable
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Archivable
  nameWithType: LogStore.Archivable
  fullName: System.IO.Log.LogStore.Archivable
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得值，指出是否此<xref href=&quot;System.IO.Log.LogStore&quot;></xref>可保存執行個體。"
  remarks: "如果<xref:System.IO.Log.LogStore>不封存，呼叫<xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A>和<xref:System.IO.Log.LogStore.SetArchiveTail%2A>方法導致<xref:System.NotSupportedException>擲回。</xref:System.NotSupportedException> </xref:System.IO.Log.LogStore.SetArchiveTail%2A> </xref:System.IO.Log.LogStore.CreateLogArchiveSnapshot%2A> </xref:System.IO.Log.LogStore>"
  syntax:
    content: public bool Archivable { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果這個<xref href=&quot;System.IO.Log.LogStore&quot;></xref>執行個體可以是封存，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.Log.LogStore.Archivable*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
  fullName: System.IO.Log.LogStore.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "在此取得有效的記錄對應的最小序號<xref href=&quot;System.IO.Log.LogStore&quot;></xref>執行個體。"
  remarks: "有效的序號會大於或等於 BaseSequenceNumber，且小於<xref:System.IO.Log.LogStore.LastSequenceNumber%2A>.</xref:System.IO.Log.LogStore.LastSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "對應至這個有效記錄的最小序號<xref href=&quot;System.IO.Log.LogStore&quot;></xref>執行個體。"
  overload: System.IO.Log.LogStore.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot
  id: CreateLogArchiveSnapshot
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: CreateLogArchiveSnapshot()
  nameWithType: LogStore.CreateLogArchiveSnapshot()
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "以便製作備份的記錄存放區狀態的快照。"
  remarks: ''
  example:
  - "The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/m-system.io.log.logstore_1_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/m-system.io.log.logstore_1_1.cs)]"
  syntax:
    content: public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot ();
    parameters: []
    return:
      type: System.IO.Log.LogArchiveSnapshot
      description: "A <xref href=&quot;System.IO.Log.LogArchiveSnapshot&quot;> </xref>物件，其中包含製作封存檔所需的狀態。"
  overload: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "無法封存記錄存放區。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "建立封存快照時發生 I/O 錯誤。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "引數無效。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已執行無效的作業。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄存放區遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  id: CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  nameWithType: LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "指定的序列數字，以便製作備份之間的記錄存放區狀態的快照。"
  remarks: "從這個方法傳回的封存快照包含基底序號或封存序號的資訊，以較低，到最後一個序號。 不含最後一個序號，這表示，封存中僅包含但不是包括最後一個記錄。 此外，使用此方法時，起始的 SequenceNumber 必須等於 BaseSequenceNumber 中的封存保持一致的順序。"
  syntax:
    content: public System.IO.Log.LogArchiveSnapshot CreateLogArchiveSnapshot (System.IO.Log.SequenceNumber first, System.IO.Log.SequenceNumber last);
    parameters:
    - id: first
      type: System.IO.Log.SequenceNumber
      description: "起始範圍中要封存序號。"
    - id: last
      type: System.IO.Log.SequenceNumber
      description: "結束範圍中要封存序號。"
    return:
      type: System.IO.Log.LogArchiveSnapshot
      description: "A <xref href=&quot;System.IO.Log.LogArchiveSnapshot&quot;> </xref>物件，其中包含製作封存檔所需的狀態。"
  overload: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>first</code>或<code>last</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>first</code>大於<code>last</code>。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已執行無效的作業。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "建立封存快照時發生 I/O 錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "無法封存記錄存放區。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄存放區遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.Delete(System.String)
  id: Delete(System.String)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Delete(String)
  nameWithType: LogStore.Delete(String)
  fullName: System.IO.Log.LogStore.Delete(String)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "移除記錄存放區。"
  syntax:
    content: public static void Delete (string path);
    parameters:
    - id: path
      type: System.String
      description: "若要移除的記錄存放區基底檔案的相對或絕對路徑。"
  overload: System.IO.Log.LogStore.Delete*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)。       -或-<code>path</code>只包含空格。       -或-<code>path</code>包含一或多個無效的字元。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到檔案。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟記錄存放區時發生 I/O 錯誤。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄存放區遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.Dispose
  id: Dispose
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Dispose()
  nameWithType: LogStore.Dispose()
  fullName: System.IO.Log.LogStore.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "所使用的資源全部釋出<xref href=&quot;System.IO.Log.LogStore&quot;> </xref>。"
  remarks: "當您完成使用<xref:System.IO.Log.LogStore>.</xref:System.IO.Log.LogStore>呼叫 Dispose Dispose 方法會使<xref:System.IO.Log.LogStore>中無法使用的狀態。</xref:System.IO.Log.LogStore> 在呼叫 Dispose 之後，您必須釋放所有參考<xref:System.IO.Log.LogStore>讓記憶體回收行程可以回收記憶體的<xref:System.IO.Log.LogStore>所佔用。</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogStore>      > [!NOTE] > 永遠呼叫 Dispose 之後，再放開您的最後一個參考至<xref:System.IO.Log.LogStore>。</xref:System.IO.Log.LogStore> 否則，它所使用的資源將不會釋放直到記憶體回收行程呼叫<xref:System.IO.Log.LogStore>物件的`Finalize`方法。</xref:System.IO.Log.LogStore>"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.LogStore.Dispose*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.Extents
  id: Extents
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Extents
  nameWithType: LogStore.Extents
  fullName: System.IO.Log.LogStore.Extents
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得包含這個記錄存放區的資料延伸記錄區集合。"
  remarks: "A<xref:System.IO.Log.LogStore>執行個體會儲存其資料集合中的延伸磁碟區，由<xref:System.IO.Log.LogExtent>執行個體。</xref:System.IO.Log.LogExtent> </xref:System.IO.Log.LogStore> 中的範圍指定<xref:System.IO.Log.LogStore>執行個體大小均等，而加入及移除空間<xref:System.IO.Log.LogStore>以範圍為增量單位的執行個體。</xref:System.IO.Log.LogStore> </xref:System.IO.Log.LogStore> 若要加入及移除延伸記錄區，使用<xref:System.IO.Log.LogExtentCollection.Add%2A>和<xref:System.IO.Log.LogExtentCollection.Remove%2A>方法<xref:System.IO.Log.LogExtentCollection>物件，這個屬性由。</xref:System.IO.Log.LogExtentCollection> </xref:System.IO.Log.LogExtentCollection.Remove%2A> </xref:System.IO.Log.LogExtentCollection.Add%2A>"
  syntax:
    content: public System.IO.Log.LogExtentCollection Extents { get; }
    return:
      type: System.IO.Log.LogExtentCollection
      description: "A <xref href=&quot;System.IO.Log.LogExtentCollection&quot;> </xref>包含封裝這個記錄存放區資料的延伸記錄區集合的執行個體。"
  overload: System.IO.Log.LogStore.Extents*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.FreeBytes
  id: FreeBytes
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
  fullName: System.IO.Log.LogStore.FreeBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得記錄存放區的可用的位元組數目。"
  syntax:
    content: public long FreeBytes { get; }
    return:
      type: System.Int64
      description: "記錄存放區中可用的位元組數目。"
  overload: System.IO.Log.LogStore.FreeBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.Handle
  id: Handle
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Handle
  nameWithType: LogStore.Handle
  fullName: System.IO.Log.LogStore.Handle
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得作業系統檔案控制代碼之記錄檔的目前<xref href=&quot;System.IO.Log.LogStore&quot;></xref>執行個體所封裝。"
  syntax:
    content: public Microsoft.Win32.SafeHandles.SafeFileHandle Handle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "作業系統檔案控制代碼，記錄檔目前<xref href=&quot;System.IO.Log.LogStore&quot;></xref>執行個體所封裝。"
  overload: System.IO.Log.LogStore.Handle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
  fullName: System.IO.Log.LogStore.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "當在衍生類別中覆寫時，取得要附加至記錄存放區之下一筆記錄的序號。"
  remarks: "有效的序號會大於或等於<xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>且小於 LastSequenceNumber。</xref:System.IO.Log.LogStore.BaseSequenceNumber%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "要附加至記錄存放區之下一筆記錄的序號。"
  overload: System.IO.Log.LogStore.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.Length
  id: Length
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Length
  nameWithType: LogStore.Length
  fullName: System.IO.Log.LogStore.Length
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得記錄存放區，以位元組為單位的大小。"
  remarks: "記錄存放區的大小是延伸記錄區大小的總和。"
  syntax:
    content: public long Length { get; }
    return:
      type: System.Int64
      description: "記錄存放區，以位元組為單位的大小。"
  overload: System.IO.Log.LogStore.Length*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.Policy
  id: Policy
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: Policy
  nameWithType: LogStore.Policy
  fullName: System.IO.Log.LogStore.Policy
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得與這個記錄存放區相關聯的原則。"
  remarks: "您可以使用<xref:System.IO.Log.LogPolicy>與此<xref:System.IO.Log.LogStore>.</xref:System.IO.Log.LogStore>相關聯的執行個體來檢視和管理記錄原則的這個屬性所傳回</xref:System.IO.Log.LogPolicy>的"
  syntax:
    content: public System.IO.Log.LogPolicy Policy { get; }
    return:
      type: System.IO.Log.LogPolicy
      description: "A <xref href=&quot;System.IO.Log.LogPolicy&quot;> </xref>代表與這個記錄存放區相關聯的原則執行個體。"
  overload: System.IO.Log.LogStore.Policy*
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  id: SetArchiveTail(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: SetArchiveTail(SequenceNumber)
  nameWithType: LogStore.SetArchiveTail(SequenceNumber)
  fullName: System.IO.Log.LogStore.SetArchiveTail(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "設定封存結尾的序號。"
  remarks: "較小的基底序號和封存結尾決定記錄的結尾。"
  example:
  - "The following example shows how to archive a <xref:System.IO.Log.LogStore> to an XML document.  \n  \n [!code-vb[logarchievesnapshot#0](~/add/codesnippet/visualbasic/m-system.io.log.logstore_0_1.vb)]\n [!code-cs[logarchievesnapshot#0](~/add/codesnippet/csharp/m-system.io.log.logstore_0_1.cs)]"
  syntax:
    content: public void SetArchiveTail (System.IO.Log.SequenceNumber archiveTail);
    parameters:
    - id: archiveTail
      type: System.IO.Log.SequenceNumber
      description: "封存結尾的序號。"
  overload: System.IO.Log.LogStore.SetArchiveTail*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>archiveTail</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>archiveTail</code>無效，無法對此順序。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "已執行無效的作業。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "建立封存快照時發生 I/O 錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "無法封存記錄存放區。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄存放區遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.LogStore.StreamCount
  id: StreamCount
  parent: System.IO.Log.LogStore
  langs:
  - csharp
  name: StreamCount
  nameWithType: LogStore.StreamCount
  fullName: System.IO.Log.LogStore.StreamCount
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得這個記錄存放區中的記錄資料流數目。"
  syntax:
    content: public int StreamCount { get; }
    return:
      type: System.Int32
      description: "這個記錄存放區中的記錄資料流數目。"
  overload: System.IO.Log.LogStore.StreamCount*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.LogStore.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(SafeFileHandle)
  nameWithType: LogStore.LogStore(SafeFileHandle)
  fullName: System.IO.Log.LogStore.LogStore(SafeFileHandle)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode)
  nameWithType: LogStore.LogStore(String,FileMode)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess,FileShare)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.Log.LogStore.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Security.AccessControl.FileSecurity)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  nameWithType: LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
  fullName: System.IO.Log.LogStore.LogStore(String,FileMode,FileAccess,FileShare,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.Log.LogStore.Archivable
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Archivable
  nameWithType: LogStore.Archivable
  fullName: System.IO.Log.LogStore.Archivable
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.LogStore.BaseSequenceNumber
  parent: System.IO.Log.LogStore
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
  fullName: System.IO.Log.LogStore.BaseSequenceNumber
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot()
  nameWithType: LogStore.CreateLogArchiveSnapshot()
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot()
- uid: System.IO.Log.LogArchiveSnapshot
  parent: System.IO.Log
  isExternal: false
  name: LogArchiveSnapshot
  nameWithType: LogArchiveSnapshot
  fullName: System.IO.Log.LogArchiveSnapshot
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot(System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  nameWithType: LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
  fullName: System.IO.Log.LogStore.CreateLogArchiveSnapshot(SequenceNumber,SequenceNumber)
- uid: System.IO.Log.LogStore.Delete(System.String)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Delete(String)
  nameWithType: LogStore.Delete(String)
  fullName: System.IO.Log.LogStore.Delete(String)
- uid: System.IO.Log.LogStore.Dispose
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Dispose()
  nameWithType: LogStore.Dispose()
  fullName: System.IO.Log.LogStore.Dispose()
- uid: System.IO.Log.LogStore.Extents
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Extents
  nameWithType: LogStore.Extents
  fullName: System.IO.Log.LogStore.Extents
- uid: System.IO.Log.LogExtentCollection
  parent: System.IO.Log
  isExternal: false
  name: LogExtentCollection
  nameWithType: LogExtentCollection
  fullName: System.IO.Log.LogExtentCollection
- uid: System.IO.Log.LogStore.FreeBytes
  parent: System.IO.Log.LogStore
  isExternal: false
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
  fullName: System.IO.Log.LogStore.FreeBytes
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.LogStore.Handle
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Handle
  nameWithType: LogStore.Handle
  fullName: System.IO.Log.LogStore.Handle
- uid: System.IO.Log.LogStore.LastSequenceNumber
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
  fullName: System.IO.Log.LogStore.LastSequenceNumber
- uid: System.IO.Log.LogStore.Length
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Length
  nameWithType: LogStore.Length
  fullName: System.IO.Log.LogStore.Length
- uid: System.IO.Log.LogStore.Policy
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Policy
  nameWithType: LogStore.Policy
  fullName: System.IO.Log.LogStore.Policy
- uid: System.IO.Log.LogPolicy
  parent: System.IO.Log
  isExternal: false
  name: LogPolicy
  nameWithType: LogPolicy
  fullName: System.IO.Log.LogPolicy
- uid: System.IO.Log.LogStore.SetArchiveTail(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.LogStore
  isExternal: false
  name: SetArchiveTail(SequenceNumber)
  nameWithType: LogStore.SetArchiveTail(SequenceNumber)
  fullName: System.IO.Log.LogStore.SetArchiveTail(SequenceNumber)
- uid: System.IO.Log.LogStore.StreamCount
  parent: System.IO.Log.LogStore
  isExternal: false
  name: StreamCount
  nameWithType: LogStore.StreamCount
  fullName: System.IO.Log.LogStore.StreamCount
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.LogStore.#ctor*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LogStore
  nameWithType: LogStore.LogStore
- uid: System.IO.Log.LogStore.Archivable*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Archivable
  nameWithType: LogStore.Archivable
- uid: System.IO.Log.LogStore.BaseSequenceNumber*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: LogStore.BaseSequenceNumber
- uid: System.IO.Log.LogStore.CreateLogArchiveSnapshot*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: CreateLogArchiveSnapshot
  nameWithType: LogStore.CreateLogArchiveSnapshot
- uid: System.IO.Log.LogStore.Delete*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Delete
  nameWithType: LogStore.Delete
- uid: System.IO.Log.LogStore.Dispose*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Dispose
  nameWithType: LogStore.Dispose
- uid: System.IO.Log.LogStore.Extents*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Extents
  nameWithType: LogStore.Extents
- uid: System.IO.Log.LogStore.FreeBytes*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: FreeBytes
  nameWithType: LogStore.FreeBytes
- uid: System.IO.Log.LogStore.Handle*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Handle
  nameWithType: LogStore.Handle
- uid: System.IO.Log.LogStore.LastSequenceNumber*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: LastSequenceNumber
  nameWithType: LogStore.LastSequenceNumber
- uid: System.IO.Log.LogStore.Length*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Length
  nameWithType: LogStore.Length
- uid: System.IO.Log.LogStore.Policy*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: Policy
  nameWithType: LogStore.Policy
- uid: System.IO.Log.LogStore.SetArchiveTail*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: SetArchiveTail
  nameWithType: LogStore.SetArchiveTail
- uid: System.IO.Log.LogStore.StreamCount*
  parent: System.IO.Log.LogStore
  isExternal: false
  name: StreamCount
  nameWithType: LogStore.StreamCount
