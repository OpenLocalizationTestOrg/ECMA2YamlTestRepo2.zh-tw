### YamlMime:ManagedReference
items:
- uid: System.Security.CodeAccessPermission
  id: CodeAccessPermission
  children:
  - System.Security.CodeAccessPermission.#ctor
  - System.Security.CodeAccessPermission.Assert
  - System.Security.CodeAccessPermission.Copy
  - System.Security.CodeAccessPermission.Demand
  - System.Security.CodeAccessPermission.Deny
  - System.Security.CodeAccessPermission.Equals(System.Object)
  - System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)
  - System.Security.CodeAccessPermission.GetHashCode
  - System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)
  - System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)
  - System.Security.CodeAccessPermission.PermitOnly
  - System.Security.CodeAccessPermission.RevertAll
  - System.Security.CodeAccessPermission.RevertAssert
  - System.Security.CodeAccessPermission.RevertDeny
  - System.Security.CodeAccessPermission.RevertPermitOnly
  - System.Security.CodeAccessPermission.ToString
  - System.Security.CodeAccessPermission.ToXml
  - System.Security.CodeAccessPermission.Union(System.Security.IPermission)
  langs:
  - csharp
  name: CodeAccessPermission
  nameWithType: CodeAccessPermission
  fullName: System.Security.CodeAccessPermission
  type: Class
  summary: "定義所有程式碼存取權限的基礎結構。"
  remarks: "程式碼存取權限會使用堆疊查核行程，確認所有呼叫端程式碼的已被授與權限。 權限物件是否`null`，就會處理與<xref:System.Security.Permissions.PermissionState?displayProperty=fullName>.</xref:System.Security.Permissions.PermissionState?displayProperty=fullName>狀態的權限物件與相同       呼叫堆疊通常會表示向下成長，使方法呼叫堆疊中較高層呼叫的方法較低的呼叫堆疊中。       CodeAccessPermission 類別繼承者必須授與完全信任才能正確運作，做為安全性基礎結構延伸權限。 若要判斷，所以繼承者是完全受信任，CodeAccessPermission 發出<xref:System.Security.Permissions.SecurityAction>如<xref:System.Security.Permissions.SecurityPermissionFlag>=`true`和<xref:System.Security.Permissions.SecurityPermissionFlag>= `true`。</xref:System.Security.Permissions.SecurityPermissionFlag> </xref:System.Security.Permissions.SecurityPermissionFlag> </xref:System.Security.Permissions.SecurityAction>"
  example:
  - "The following code example shows a permission derived from the CodeAccessPermission class.  \n  \n [!code-cs[System.Security.Permissions.NameIdPermission#1](~/add/codesnippet/csharp/t-system.security.codeac_1.cs)]\n [!code-cpp[System.Security.Permissions.NameIdPermission#1](~/add/codesnippet/cpp/t-system.security.codeac_1.cpp)]\n [!code-vb[System.Security.Permissions.NameIdPermission#1](~/add/codesnippet/visualbasic/t-system.security.codeac_1.vb)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk
  inheritance:
  - System.Object
  implements:
  - System.Security.IPermission
  - System.Security.IStackWalk
  inheritedMembers: []
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.#ctor
  id: '#ctor'
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: CodeAccessPermission()
  nameWithType: CodeAccessPermission.CodeAccessPermission()
  fullName: System.Security.CodeAccessPermission.CodeAccessPermission()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "初始化的新執行個體<xref href=&quot;System.Security.CodeAccessPermission&quot;></xref>類別。"
  remarks: "這個建構函式會初始化型別中的狀態，每次建立衍生類別的執行個體時呼叫。 雖然您可以明確呼叫這個建構函式，在衍生的類別建構函式的建構函式宣告中，這通常不需要。大多數的編譯器會自動產生的呼叫。"
  syntax:
    content: protected CodeAccessPermission ();
    parameters: []
  overload: System.Security.CodeAccessPermission.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.Assert
  id: Assert
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: Assert()
  nameWithType: CodeAccessPermission.Assert()
  fullName: System.Security.CodeAccessPermission.Assert()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "宣告呼叫程式碼可以存取權限要求執行程式碼會呼叫這個方法，即使堆疊中較高層的呼叫端未獲得存取資源的權限受保護的資源。 使用判斷提示會造成安全性問題。"
  remarks: "呼叫堆疊通常會表示向下成長，使方法呼叫堆疊中較高層呼叫的方法較低的呼叫堆疊中。 呼叫判斷提示，可避免來自之外的程式碼會呼叫這個方法的呼叫堆疊向上繼續進行的呼叫堆疊中較低堆疊查核行程。 因此，即使在呼叫堆疊中較高的呼叫端沒有必要的使用權限來存取資源，他們還是可以存取它透過呼叫這個方法所需的權限的程式碼。 判斷提示就會生效，只有當呼叫判斷提示的程式碼通過安全性檢查，它會判斷提示之權限。       判斷提示的呼叫是有效，直到呼叫程式碼會傳回其呼叫端。 只有一個判斷提示可以是現用的框架。 嘗試呼叫判斷提示，使用中的判斷提示上的框架會導致<xref:System.Security.SecurityException>.</xref:System.Security.SecurityException>時 呼叫<xref:System.Security.CodeAccessPermission.RevertAssert%2A>或<xref:System.Security.CodeAccessPermission.RevertAll%2A>移除作用中的判斷提示。</xref:System.Security.CodeAccessPermission.RevertAll%2A> </xref:System.Security.CodeAccessPermission.RevertAssert%2A>       判斷提示該權限的要求將會失敗，因為未授與權限會被忽略。 不過，如果在呼叫堆疊中較低的程式碼呼叫<xref:System.Security.CodeAccessPermission.Demand%2A>該權限，<xref:System.Security.SecurityException>堆疊查核行程到達程式碼嘗試呼叫判斷提示時，會擲回。</xref:System.Security.SecurityException> </xref:System.Security.CodeAccessPermission.Demand%2A> 這不會因為呼叫判斷提示的程式碼無法獲得的權限，即使它嘗試將它判斷提示。      > [!CAUTION] > 呼叫 Assert 移除所有的程式碼呼叫鏈結中，必須授存取指定的資源的權限的需求，因為它可以開啟個安全性問題如果不正確或不當使用。 因此，應該使用小心謹慎。"
  syntax:
    content: public void Assert ();
    parameters: []
  overload: System.Security.CodeAccessPermission.Assert*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫程式碼並沒有<xref href=&quot;System.Security.Permissions.SecurityPermissionFlag&quot;> </xref>。       -或者-已經有使用中的判斷提示目前畫面格。"
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.Copy
  id: Copy
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: Copy()
  nameWithType: CodeAccessPermission.Copy()
  fullName: System.Security.CodeAccessPermission.Copy()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "由衍生類別實作時，會建立並傳回目前權限物件的相同複本。"
  remarks: "權限物件的複本以原始的權限物件的資源表示相同的存取權。"
  example:
  - "The following code example shows an override of the Copy method. This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.  \n  \n [!code-cs[System.Security.Permissions.NameIdPermission#2](~/add/codesnippet/csharp/m-system.security.codeac_0_1.cs)]\n [!code-cpp[System.Security.Permissions.NameIdPermission#2](~/add/codesnippet/cpp/m-system.security.codeac_0_1.cpp)]\n [!code-vb[System.Security.Permissions.NameIdPermission#2](~/add/codesnippet/visualbasic/m-system.security.codeac_0_1.vb)]"
  syntax:
    content: public abstract System.Security.IPermission Copy ();
    parameters: []
    return:
      type: System.Security.IPermission
      description: "目前的權限物件的複本。"
  overload: System.Security.CodeAccessPermission.Copy*
  exceptions: []
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.Demand
  id: Demand
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: Demand()
  nameWithType: CodeAccessPermission.Demand()
  fullName: System.Security.CodeAccessPermission.Demand()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "強制<xref:System.Security.SecurityException>所有呼叫堆疊中較高層的呼叫端未都獲得目前執行個體所指定的權限，如果在執行階段。</xref:System.Security.SecurityException>"
  remarks: "這個方法通常可由安全程式庫來確定呼叫端擁有存取資源的權限。 例如，檔案中的類別安全類別庫呼叫的必要需求<xref:System.Security.Permissions.FileIOPermission>之前執行檔案作業的呼叫端要求。</xref:System.Security.Permissions.FileIOPermission>       不會檢查呼叫這個方法的程式碼的權限;檢查該程式碼的立即呼叫端從開始，然後進行堆疊。 呼叫堆疊通常會表示向下成長，使方法呼叫堆疊中較高層呼叫的方法較低的呼叫堆疊中。 要求執行成功，只有當沒有<xref:System.Security.SecurityException>，就會引發。</xref:System.Security.SecurityException>"
  syntax:
    content: public void Demand ();
    parameters: []
  overload: System.Security.CodeAccessPermission.Demand*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫堆疊中較高層的呼叫端沒有目前的執行個體所指定的權限。       -或-呼叫堆疊中較高層的呼叫端已呼叫<xref:System.Security.CodeAccessPermission.Deny*>上目前的權限物件。</xref:System.Security.CodeAccessPermission.Deny*>"
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.Deny
  id: Deny
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: Deny()
  nameWithType: CodeAccessPermission.Deny()
  fullName: System.Security.CodeAccessPermission.Deny()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "防止呼叫堆疊中較高層的呼叫端使用程式碼呼叫此方法來存取目前的執行個體所指定的資源。"
  remarks: "> [!IMPORTANT]> Deny 方法應只有要保護資源的意外存取完全信任的程式碼。 它不應要保護資源的刻意誤用，而不受信任的程式碼。 例如，如果方法`A`發出的 Deny 權限，然後再呼叫方法`B`，方法`B`overtly 覆寫，可以拒絕發行<xref:System.Security.CodeAccessPermission.Assert%2A>.</xref:System.Security.CodeAccessPermission.Assert%2A> 所呼叫的方法一律是在堆疊中較高。 因此，如果方法`B`嘗試存取受保護的資源時，安全性系統會開始檢查它的權限，因為方法`B`是立即呼叫端，上下然後查核行程來確認是否有任何的 Deny 堆疊或<xref:System.Security.CodeAccessPermission.PermitOnly%2A>堆疊中較低。</xref:System.Security.CodeAccessPermission.PermitOnly%2A> 方法`B`，這嘗試存取資源，可以堆疊查核行程立即停止使用<xref:System.Security.CodeAccessPermission.Assert%2A>方法。</xref:System.Security.CodeAccessPermission.Assert%2A> 在此情況下，Deny 放置在堆疊上方法`A`永遠不會探索 （呼叫的方法）。       這個方法會防止呼叫堆疊中較高層的呼叫端程式碼呼叫此方法，透過存取受保護的資源，即使這些呼叫端必須被授與存取權限。 呼叫堆疊通常會表示向下成長，使方法呼叫堆疊中較高層呼叫的方法較低的呼叫堆疊中。       拒絕可以限制程式設計人員的責任，或協助避免意外安全性問題，因為它可協助防止拒絕會從用來存取拒絕的權限所保護的資源呼叫的方法。 如果方法呼叫拒絕權限，而且如果<xref:System.Security.CodeAccessPermission.Demand%2A>到達拒絕時，安全性檢查的呼叫堆疊中較低的呼叫端所叫用該權限時，將會失敗。</xref:System.Security.CodeAccessPermission.Demand%2A>       拒絕的呼叫是有效，直到呼叫程式碼會傳回其呼叫端。 只有一個拒絕可以是現用的框架。 嘗試在框架上的作用中的拒絕存在時，呼叫拒絕造成<xref:System.Security.SecurityException>.</xref:System.Security.SecurityException> 呼叫<xref:System.Security.CodeAccessPermission.RevertDeny%2A>或<xref:System.Security.CodeAccessPermission.RevertAll%2A>若要移除的使用中的拒絕。</xref:System.Security.CodeAccessPermission.RevertAll%2A> </xref:System.Security.CodeAccessPermission.RevertDeny%2A> 拒絕權限未授與該權限的要求將會失敗，因為已忽略。"
  syntax:
    content: public void Deny ();
    parameters: []
  overload: System.Security.CodeAccessPermission.Deny*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "已有作用中的拒絕，目前的框架。"
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.Equals(System.Object)
  id: Equals(System.Object)
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: Equals(Object)
  nameWithType: CodeAccessPermission.Equals(Object)
  fullName: System.Security.CodeAccessPermission.Equals(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "決定是否指定<xref href=&quot;System.Security.CodeAccessPermission&quot;></xref>物件是否等於目前<xref href=&quot;System.Security.CodeAccessPermission&quot;> </xref>。"
  remarks: "如需詳細資訊，請參閱<xref:System.Object.Equals%2A>.</xref:System.Object.Equals%2A>"
  syntax:
    content: public override bool Equals (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "<xref href=&quot;System.Security.CodeAccessPermission&quot;> </xref>物件要與目前比較<xref href=&quot;System.Security.CodeAccessPermission&quot;> </xref>。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果指定<xref href=&quot;System.Security.CodeAccessPermission&quot;></xref>物件是否等於目前<xref href=&quot;System.Security.CodeAccessPermission&quot;> </xref>，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Security.CodeAccessPermission.Equals*
  exceptions: []
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)
  id: FromXml(System.Security.SecurityElement)
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: FromXml(SecurityElement)
  nameWithType: CodeAccessPermission.FromXml(SecurityElement)
  fullName: System.Security.CodeAccessPermission.FromXml(SecurityElement)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "當在衍生類別中覆寫時，重新建構具有指定狀態的 XML 編碼方式的安全性物件。"
  remarks: "擴充安全性物件的自訂程式碼必須實作<xref:System.Security.CodeAccessPermission.ToXml%2A>和 FromXml 方法，使物件安全性 encodable。</xref:System.Security.CodeAccessPermission.ToXml%2A>"
  example:
  - "The following code example shows an override of the FromXml method. This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.  \n  \n [!code-cs[System.Security.Permissions.NameIdPermission#10](~/add/codesnippet/csharp/m-system.security.codeac_1_1.cs)]\n [!code-cpp[System.Security.Permissions.NameIdPermission#10](~/add/codesnippet/cpp/m-system.security.codeac_1_1.cpp)]\n [!code-vb[System.Security.Permissions.NameIdPermission#10](~/add/codesnippet/visualbasic/m-system.security.codeac_1_1.vb)]"
  syntax:
    content: public abstract void FromXml (System.Security.SecurityElement elem);
    parameters:
    - id: elem
      type: System.Security.SecurityElement
      description: "XML 編碼用來重新建構安全性物件。"
  overload: System.Security.CodeAccessPermission.FromXml*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>elem</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> elem </code>參數不包含目前執行個體與相同類型的執行個體的 XML 編碼方式。       -的版本號碼<code> elem </code>不支援參數。"
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.GetHashCode
  id: GetHashCode
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: CodeAccessPermission.GetHashCode()
  fullName: System.Security.CodeAccessPermission.GetHashCode()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "取得的雜湊碼<xref href=&quot;System.Security.CodeAccessPermission&quot;></xref>物件，其適合用於雜湊演算法和資料結構，例如雜湊表。"
  remarks: "相同的權限的兩個執行個體的雜湊程式碼可能會不同，因此雜湊程式碼不應比較兩個<xref:System.Security.CodeAccessPermission>物件。</xref:System.Security.CodeAccessPermission>"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "目前的雜湊碼<xref href=&quot;System.Security.CodeAccessPermission&quot;></xref>物件。"
  overload: System.Security.CodeAccessPermission.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)
  id: Intersect(System.Security.IPermission)
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: Intersect(IPermission)
  nameWithType: CodeAccessPermission.Intersect(IPermission)
  fullName: System.Security.CodeAccessPermission.Intersect(IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "由衍生類別實作時，會建立並傳回目前權限和指定的權限交集的權限。"
  remarks: "兩個權限的交集會描述一組共同兩者描述的作業的權限。 只有通過這兩個原始的使用權限的需求會通過交集。"
  example:
  - "The following code example shows an override of the Intersect method. This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.  \n  \n [!code-cs[System.Security.Permissions.NameIdPermission#5](~/add/codesnippet/csharp/m-system.security.codeac_3_1.cs)]\n [!code-cpp[System.Security.Permissions.NameIdPermission#5](~/add/codesnippet/cpp/m-system.security.codeac_3_1.cpp)]\n [!code-vb[System.Security.Permissions.NameIdPermission#5](~/add/codesnippet/visualbasic/m-system.security.codeac_3_1.vb)]"
  syntax:
    content: public abstract System.Security.IPermission Intersect (System.Security.IPermission target);
    parameters:
    - id: target
      type: System.Security.IPermission
      description: "要與目前權限產生交集的權限。 它必須是類型的相同與目前權限。"
    return:
      type: System.Security.IPermission
      description: "代表目前權限與指定權限交集的新權限。 這個新權限是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果交集是空的。"
  overload: System.Security.CodeAccessPermission.Intersect*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> target </code>參數不是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>並不是與目前權限具有相同類別的執行個體。"
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)
  id: IsSubsetOf(System.Security.IPermission)
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: IsSubsetOf(IPermission)
  nameWithType: CodeAccessPermission.IsSubsetOf(IPermission)
  fullName: System.Security.CodeAccessPermission.IsSubsetOf(IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "由衍生類別實作時，判斷目前權限是否為指定的權限的子集。"
  remarks: "The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission. For example, a permission that represents access to C:\\example.txt is a subset of a permission that represents access to C:\\\\. If this method returns `true`, the current permission represents no more access to the protected resource than does the specified permission.  \n  \n The following statements are required to be `true` for all overrides of the IsSubsetOf method. *X*, *Y*, and *Z* represent custom code access permission objects that are not null references, *U* represents an unrestricted code access permission, and *N* represents an empty permission with a <xref:System.Security.Permissions.PermissionState> of <xref:System.Security.Permissions.PermissionState>.  \n  \n-   *X*.IsSubsetOf(*X*) returns `true`.  \n  \n-   *X*.IsSubsetOf(*Y*) returns the same value as *Y*.IsSubsetOf(*X*) if and only if *X* and *Y* represent the same set of permissions.  \n  \n-   If *X*.IsSubsetOf(*Y*) and *Y*.IsSubsetOf(*Z*) both return `true`, *X*.IsSubsetOf(*Z*) returns `true`.  \n  \n-   *X*.IsSubsetOf(*U*) returns `true`.  \n  \n-   *X*.IsSubsetOf(*N*) returns `false`.  \n  \n-   *N*.IsSubsetOf(*X*) returns `true`.  \n  \n If *X* and *Y* represent custom code access permission objects that are null references, *X*.IsSubsetOf(*Y*) returns `true`. If *Z* is also null, the compound set operation *X*.Union(*Y*).IsSubsetOf(*Z*) also returns `true` because the union of two null permissions is a null permission."
  example:
  - "The following code example shows an override of the IsSubsetOf method. This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.  \n  \n [!code-cs[System.Security.Permissions.NameIdPermission#4](~/add/codesnippet/csharp/m-system.security.codeac_5_1.cs)]\n [!code-cpp[System.Security.Permissions.NameIdPermission#4](~/add/codesnippet/cpp/m-system.security.codeac_5_1.cpp)]\n [!code-vb[System.Security.Permissions.NameIdPermission#4](~/add/codesnippet/visualbasic/m-system.security.codeac_5_1.vb)]"
  syntax:
    content: public abstract bool IsSubsetOf (System.Security.IPermission target);
    parameters:
    - id: target
      type: System.Security.IPermission
      description: "要測試子集關聯性的權限。 此權限必須是類型的相同與目前權限。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果目前權限是指定的權限的子集否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Security.CodeAccessPermission.IsSubsetOf*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> target </code>參數不是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>而且不屬於相同的類型與目前權限。"
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.PermitOnly
  id: PermitOnly
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: PermitOnly()
  nameWithType: CodeAccessPermission.PermitOnly()
  fullName: System.Security.CodeAccessPermission.PermitOnly()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "防止呼叫堆疊中較高層的呼叫端使用程式碼呼叫此方法來存取目前的執行個體所指定之資源以外的所有資源。"
  remarks: "> [!IMPORTANT]> PermitOnly 方法應只有要保護資源的意外存取完全信任的程式碼。 它不應要保護資源的刻意誤用，而不受信任的程式碼。 例如，如果方法`A`發出 PermitOnly 權限，然後再呼叫方法`B`，方法`B`可以 overtly 覆寫 PermitOnly 發出<xref:System.Security.CodeAccessPermission.Assert%2A>.</xref:System.Security.CodeAccessPermission.Assert%2A> 所呼叫的方法一律是在堆疊中較高。 因此，如果方法`B`嘗試存取受保護的資源時，安全性系統會開始檢查它的權限，因為方法`B`是立即呼叫端，上下然後查核行程的堆疊可以確認是否有任何<xref:System.Security.CodeAccessPermission.Deny%2A>或 PermitOnly 堆疊中較低。</xref:System.Security.CodeAccessPermission.Deny%2A> 方法`B`，這嘗試存取資源，可以堆疊查核行程立即停止使用<xref:System.Security.CodeAccessPermission.Assert%2A>方法。</xref:System.Security.CodeAccessPermission.Assert%2A> 在此情況下，PermitOnly 放置在堆疊上方法`A`永遠不會探索 （呼叫的方法）。       PermitOnly 是類似於<xref:System.Security.CodeAccessPermission.Deny%2A>，在於兩者會導致堆疊查核行程符合則成功時失敗。</xref:System.Security.CodeAccessPermission.Deny%2A> 其差異在於，<xref:System.Security.CodeAccessPermission.Deny%2A>指定權限，會導致堆疊查核行程失敗，但 PermitOnly 指定不會導致堆疊查核行程失敗的唯一權限。</xref:System.Security.CodeAccessPermission.Deny%2A>       呼叫此方法，以確保您的程式碼，可用來存取指定的資源。 PermitOnly 的呼叫是有效的直到呼叫程式碼會傳回其呼叫端。 只有一個 PermitOnly 可以是現用的框架。 嘗試在框架上存在使用中的 PermitOnly 時呼叫 PermitOnly 造成<xref:System.Security.SecurityException>.</xref:System.Security.SecurityException> 呼叫<xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A>或<xref:System.Security.CodeAccessPermission.RevertAll%2A>移除作用中的 PermitOnly。</xref:System.Security.CodeAccessPermission.RevertAll%2A> </xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A>       PermitOnly 會忽略該權限的要求將會失敗，因為未授與的權限。 不過，如果程式碼呼叫較低堆疊稍後呼叫<xref:System.Security.CodeAccessPermission.Demand%2A>該權限，<xref:System.Security.SecurityException>堆疊查核行程到達程式碼嘗試呼叫 PermitOnly 時，會擲回。</xref:System.Security.SecurityException> </xref:System.Security.CodeAccessPermission.Demand%2A> 這是因為呼叫 PermitOnly 的程式碼無法獲得的權限，即使它針對該權限來呼叫 PermitOnly。 呼叫堆疊通常會表示向下成長，使方法呼叫堆疊中較高層呼叫的方法較低的呼叫堆疊中。"
  syntax:
    content: public void PermitOnly ();
    parameters: []
  overload: System.Security.CodeAccessPermission.PermitOnly*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "已針對目前的框架 active PermitOnly。"
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.RevertAll
  id: RevertAll
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: RevertAll()
  nameWithType: CodeAccessPermission.RevertAll()
  fullName: System.Security.CodeAccessPermission.RevertAll()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "會導致所有先前覆寫會移除目前畫面且不再有作用。"
  remarks: "如果沒有任何覆寫 (<xref:System.Security.CodeAccessPermission.Assert%2A>， <xref:System.Security.CodeAccessPermission.Deny%2A>，或<xref:System.Security.CodeAccessPermission.PermitOnly%2A>) 目前的框架，<xref:System.ExecutionEngineException>就會擲回。</xref:System.ExecutionEngineException> </xref:System.Security.CodeAccessPermission.PermitOnly%2A> </xref:System.Security.CodeAccessPermission.Deny%2A> </xref:System.Security.CodeAccessPermission.Assert%2A>"
  syntax:
    content: public static void RevertAll ();
    parameters: []
  overload: System.Security.CodeAccessPermission.RevertAll*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "沒有先前<> *>， <> </> *>，或<xref:System.Security.CodeAccessPermission.PermitOnly*>目前的框架。</xref:System.Security.CodeAccessPermission.PermitOnly*>"
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.RevertAssert
  id: RevertAssert
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: RevertAssert()
  nameWithType: CodeAccessPermission.RevertAssert()
  fullName: System.Security.CodeAccessPermission.RevertAssert()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "格之任何先前<xref:System.Security.CodeAccessPermission.Assert*>要移除目前畫面格，且不再有作用。</xref:System.Security.CodeAccessPermission.Assert*>"
  remarks: "如果沒有任何<xref:System.Security.CodeAccessPermission.Assert%2A>目前的框架，<xref:System.ExecutionEngineException>就會擲回。</xref:System.ExecutionEngineException> </xref:System.Security.CodeAccessPermission.Assert%2A>"
  syntax:
    content: public static void RevertAssert ();
    parameters: []
  overload: System.Security.CodeAccessPermission.RevertAssert*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "沒有先前<xref:System.Security.CodeAccessPermission.Assert*>目前的框架。</xref:System.Security.CodeAccessPermission.Assert*>"
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.RevertDeny
  id: RevertDeny
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: RevertDeny()
  nameWithType: CodeAccessPermission.RevertDeny()
  fullName: System.Security.CodeAccessPermission.RevertDeny()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "格之任何先前<xref:System.Security.CodeAccessPermission.Deny*>要移除目前畫面格，且不再有作用。</xref:System.Security.CodeAccessPermission.Deny*>"
  remarks: "如果沒有任何<xref:System.Security.CodeAccessPermission.Deny%2A>目前的框架，<xref:System.ExecutionEngineException>就會擲回。</xref:System.ExecutionEngineException> </xref:System.Security.CodeAccessPermission.Deny%2A>"
  syntax:
    content: public static void RevertDeny ();
    parameters: []
  overload: System.Security.CodeAccessPermission.RevertDeny*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "沒有先前<xref:System.Security.CodeAccessPermission.Deny*>目前的框架。</xref:System.Security.CodeAccessPermission.Deny*>"
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.RevertPermitOnly
  id: RevertPermitOnly
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: RevertPermitOnly()
  nameWithType: CodeAccessPermission.RevertPermitOnly()
  fullName: System.Security.CodeAccessPermission.RevertPermitOnly()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "格之任何先前<xref:System.Security.CodeAccessPermission.PermitOnly*>要移除目前畫面格，且不再有作用。</xref:System.Security.CodeAccessPermission.PermitOnly*>"
  remarks: "如果沒有任何<xref:System.Security.CodeAccessPermission.PermitOnly%2A>目前的框架，<xref:System.ExecutionEngineException>就會擲回。</xref:System.ExecutionEngineException> </xref:System.Security.CodeAccessPermission.PermitOnly%2A>"
  syntax:
    content: public static void RevertPermitOnly ();
    parameters: []
  overload: System.Security.CodeAccessPermission.RevertPermitOnly*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "沒有先前<xref:System.Security.CodeAccessPermission.PermitOnly*>目前的框架。</xref:System.Security.CodeAccessPermission.PermitOnly*>"
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.ToString
  id: ToString
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: ToString()
  nameWithType: CodeAccessPermission.ToString()
  fullName: System.Security.CodeAccessPermission.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "建立並傳回目前權限物件的字串表示。"
  remarks: "這個方法是用於偵錯時您需要以字串形式顯示權限。"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "目前的權限物件的字串表示。"
  overload: System.Security.CodeAccessPermission.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.ToXml
  id: ToXml
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: ToXml()
  nameWithType: CodeAccessPermission.ToXml()
  fullName: System.Security.CodeAccessPermission.ToXml()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "當在衍生類別中覆寫時，會建立安全性物件和其目前狀態的 XML 編碼方式。"
  remarks: "擴充安全性物件的自訂程式碼必須實作 ToXml 和<xref:System.Security.CodeAccessPermission.FromXml%2A>方法，以將物件變成安全性 encodable。</xref:System.Security.CodeAccessPermission.FromXml%2A>"
  example:
  - "The following code example shows an override of the ToXml method. This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.  \n  \n [!code-cs[System.Security.Permissions.NameIdPermission#11](~/add/codesnippet/csharp/m-system.security.codeac_4_1.cs)]\n [!code-cpp[System.Security.Permissions.NameIdPermission#11](~/add/codesnippet/cpp/m-system.security.codeac_4_1.cpp)]\n [!code-vb[System.Security.Permissions.NameIdPermission#11](~/add/codesnippet/visualbasic/m-system.security.codeac_4_1.vb)]"
  syntax:
    content: public abstract System.Security.SecurityElement ToXml ();
    parameters: []
    return:
      type: System.Security.SecurityElement
      description: "安全性物件，包含所有狀態資訊的 XML 編碼方式。"
  overload: System.Security.CodeAccessPermission.ToXml*
  exceptions: []
  platform:
  - net462
- uid: System.Security.CodeAccessPermission.Union(System.Security.IPermission)
  id: Union(System.Security.IPermission)
  parent: System.Security.CodeAccessPermission
  langs:
  - csharp
  name: Union(IPermission)
  nameWithType: CodeAccessPermission.Union(IPermission)
  fullName: System.Security.CodeAccessPermission.Union(IPermission)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security
  summary: "當在衍生類別中覆寫時，會建立目前的權限與指定權限的聯集的權限。"
  remarks: "要聯集呼叫的結果是權限，表示代表的所有作業目前的權限和指定的權限。 傳遞其中一個權限的任何要求會傳遞它們的聯集。"
  example:
  - "The following code example shows an override of the Union method. This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.  \n  \n [!code-cs[System.Security.Permissions.NameIdPermission#12](~/add/codesnippet/csharp/m-system.security.codeac_2_1.cs)]\n [!code-cpp[System.Security.Permissions.NameIdPermission#12](~/add/codesnippet/cpp/m-system.security.codeac_2_1.cpp)]\n [!code-vb[System.Security.Permissions.NameIdPermission#12](~/add/codesnippet/visualbasic/m-system.security.codeac_2_1.vb)]"
  syntax:
    content: public virtual System.Security.IPermission Union (System.Security.IPermission other);
    parameters:
    - id: other
      type: System.Security.IPermission
      description: "與目前權限結合的權限。 它必須是類型的相同與目前權限。"
    return:
      type: System.Security.IPermission
      description: "新的權限，表示目前的權限與指定權限的聯集。"
  overload: System.Security.CodeAccessPermission.Union*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "The <code>other</code> parameter is not <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>. 這個方法只支援在傳遞時，此層級<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Security.CodeAccessPermission.#ctor
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: CodeAccessPermission()
  nameWithType: CodeAccessPermission.CodeAccessPermission()
  fullName: System.Security.CodeAccessPermission.CodeAccessPermission()
- uid: System.Security.CodeAccessPermission.Assert
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: Assert()
  nameWithType: CodeAccessPermission.Assert()
  fullName: System.Security.CodeAccessPermission.Assert()
- uid: System.Security.CodeAccessPermission.Copy
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: Copy()
  nameWithType: CodeAccessPermission.Copy()
  fullName: System.Security.CodeAccessPermission.Copy()
- uid: System.Security.IPermission
  parent: System.Security
  isExternal: false
  name: IPermission
  nameWithType: IPermission
  fullName: System.Security.IPermission
- uid: System.Security.CodeAccessPermission.Demand
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: Demand()
  nameWithType: CodeAccessPermission.Demand()
  fullName: System.Security.CodeAccessPermission.Demand()
- uid: System.Security.CodeAccessPermission.Deny
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: Deny()
  nameWithType: CodeAccessPermission.Deny()
  fullName: System.Security.CodeAccessPermission.Deny()
- uid: System.Security.CodeAccessPermission.Equals(System.Object)
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: Equals(Object)
  nameWithType: CodeAccessPermission.Equals(Object)
  fullName: System.Security.CodeAccessPermission.Equals(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: FromXml(SecurityElement)
  nameWithType: CodeAccessPermission.FromXml(SecurityElement)
  fullName: System.Security.CodeAccessPermission.FromXml(SecurityElement)
- uid: System.Security.SecurityElement
  parent: System.Security
  isExternal: false
  name: SecurityElement
  nameWithType: SecurityElement
  fullName: System.Security.SecurityElement
- uid: System.Security.CodeAccessPermission.GetHashCode
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: GetHashCode()
  nameWithType: CodeAccessPermission.GetHashCode()
  fullName: System.Security.CodeAccessPermission.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: Intersect(IPermission)
  nameWithType: CodeAccessPermission.Intersect(IPermission)
  fullName: System.Security.CodeAccessPermission.Intersect(IPermission)
- uid: System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: IsSubsetOf(IPermission)
  nameWithType: CodeAccessPermission.IsSubsetOf(IPermission)
  fullName: System.Security.CodeAccessPermission.IsSubsetOf(IPermission)
- uid: System.Security.CodeAccessPermission.PermitOnly
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: PermitOnly()
  nameWithType: CodeAccessPermission.PermitOnly()
  fullName: System.Security.CodeAccessPermission.PermitOnly()
- uid: System.Security.CodeAccessPermission.RevertAll
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: RevertAll()
  nameWithType: CodeAccessPermission.RevertAll()
  fullName: System.Security.CodeAccessPermission.RevertAll()
- uid: System.Security.CodeAccessPermission.RevertAssert
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: RevertAssert()
  nameWithType: CodeAccessPermission.RevertAssert()
  fullName: System.Security.CodeAccessPermission.RevertAssert()
- uid: System.Security.CodeAccessPermission.RevertDeny
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: RevertDeny()
  nameWithType: CodeAccessPermission.RevertDeny()
  fullName: System.Security.CodeAccessPermission.RevertDeny()
- uid: System.Security.CodeAccessPermission.RevertPermitOnly
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: RevertPermitOnly()
  nameWithType: CodeAccessPermission.RevertPermitOnly()
  fullName: System.Security.CodeAccessPermission.RevertPermitOnly()
- uid: System.Security.CodeAccessPermission.ToString
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: ToString()
  nameWithType: CodeAccessPermission.ToString()
  fullName: System.Security.CodeAccessPermission.ToString()
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Security.CodeAccessPermission.ToXml
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: ToXml()
  nameWithType: CodeAccessPermission.ToXml()
  fullName: System.Security.CodeAccessPermission.ToXml()
- uid: System.Security.CodeAccessPermission.Union(System.Security.IPermission)
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: Union(IPermission)
  nameWithType: CodeAccessPermission.Union(IPermission)
  fullName: System.Security.CodeAccessPermission.Union(IPermission)
- uid: System.Security.CodeAccessPermission.#ctor*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: CodeAccessPermission
  nameWithType: CodeAccessPermission.CodeAccessPermission
- uid: System.Security.CodeAccessPermission.Assert*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: Assert
  nameWithType: CodeAccessPermission.Assert
- uid: System.Security.CodeAccessPermission.Copy*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: Copy
  nameWithType: CodeAccessPermission.Copy
- uid: System.Security.CodeAccessPermission.Demand*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: Demand
  nameWithType: CodeAccessPermission.Demand
- uid: System.Security.CodeAccessPermission.Deny*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: Deny
  nameWithType: CodeAccessPermission.Deny
- uid: System.Security.CodeAccessPermission.Equals*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: Equals
  nameWithType: CodeAccessPermission.Equals
- uid: System.Security.CodeAccessPermission.FromXml*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: FromXml
  nameWithType: CodeAccessPermission.FromXml
- uid: System.Security.CodeAccessPermission.GetHashCode*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: GetHashCode
  nameWithType: CodeAccessPermission.GetHashCode
- uid: System.Security.CodeAccessPermission.Intersect*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: Intersect
  nameWithType: CodeAccessPermission.Intersect
- uid: System.Security.CodeAccessPermission.IsSubsetOf*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: IsSubsetOf
  nameWithType: CodeAccessPermission.IsSubsetOf
- uid: System.Security.CodeAccessPermission.PermitOnly*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: PermitOnly
  nameWithType: CodeAccessPermission.PermitOnly
- uid: System.Security.CodeAccessPermission.RevertAll*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: RevertAll
  nameWithType: CodeAccessPermission.RevertAll
- uid: System.Security.CodeAccessPermission.RevertAssert*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: RevertAssert
  nameWithType: CodeAccessPermission.RevertAssert
- uid: System.Security.CodeAccessPermission.RevertDeny*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: RevertDeny
  nameWithType: CodeAccessPermission.RevertDeny
- uid: System.Security.CodeAccessPermission.RevertPermitOnly*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: RevertPermitOnly
  nameWithType: CodeAccessPermission.RevertPermitOnly
- uid: System.Security.CodeAccessPermission.ToString*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: ToString
  nameWithType: CodeAccessPermission.ToString
- uid: System.Security.CodeAccessPermission.ToXml*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: ToXml
  nameWithType: CodeAccessPermission.ToXml
- uid: System.Security.CodeAccessPermission.Union*
  parent: System.Security.CodeAccessPermission
  isExternal: false
  name: Union
  nameWithType: CodeAccessPermission.Union
