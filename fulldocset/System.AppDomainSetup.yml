### YamlMime:ManagedReference
items:
- uid: System.AppDomainSetup
  id: AppDomainSetup
  children:
  - System.AppDomainSetup.#ctor
  - System.AppDomainSetup.#ctor(System.ActivationContext)
  - System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)
  - System.AppDomainSetup.ActivationArguments
  - System.AppDomainSetup.AppDomainInitializer
  - System.AppDomainSetup.AppDomainInitializerArguments
  - System.AppDomainSetup.AppDomainManagerAssembly
  - System.AppDomainSetup.AppDomainManagerType
  - System.AppDomainSetup.ApplicationBase
  - System.AppDomainSetup.ApplicationName
  - System.AppDomainSetup.ApplicationTrust
  - System.AppDomainSetup.CachePath
  - System.AppDomainSetup.ConfigurationFile
  - System.AppDomainSetup.DisallowApplicationBaseProbing
  - System.AppDomainSetup.DisallowBindingRedirects
  - System.AppDomainSetup.DisallowCodeDownload
  - System.AppDomainSetup.DisallowPublisherPolicy
  - System.AppDomainSetup.DynamicBase
  - System.AppDomainSetup.GetConfigurationBytes
  - System.AppDomainSetup.LicenseFile
  - System.AppDomainSetup.LoaderOptimization
  - System.AppDomainSetup.PartialTrustVisibleAssemblies
  - System.AppDomainSetup.PrivateBinPath
  - System.AppDomainSetup.PrivateBinPathProbe
  - System.AppDomainSetup.SandboxInterop
  - System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})
  - System.AppDomainSetup.SetConfigurationBytes(System.Byte[])
  - System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)
  - System.AppDomainSetup.ShadowCopyDirectories
  - System.AppDomainSetup.ShadowCopyFiles
  - System.AppDomainSetup.TargetFrameworkName
  langs:
  - csharp
  name: AppDomainSetup
  nameWithType: AppDomainSetup
  fullName: System.AppDomainSetup
  type: Class
  summary: "表示可以加入至執行個體的組件繫結資訊<xref href=&quot;System.AppDomain&quot;> </xref>。"
  remarks: "變更 AppDomainSetup 執行個體的屬性不會影響任何現有的<xref:System.AppDomain>.</xref:System.AppDomain> 它可能會影響建立新的<xref:System.AppDomain>，當<xref:System.AppDomain.CreateDomain%2A>與 AppDomainSetup 執行個體做為參數呼叫方法。</xref:System.AppDomain.CreateDomain%2A> </xref:System.AppDomain>       這個類別會實作<xref:System.IAppDomainSetup>介面。</xref:System.IAppDomainSetup>      > [!CAUTION] > 的預設值為<xref:System.AppDomainSetup.DisallowCodeDownload%2A>屬性為 false。</xref:System.AppDomainSetup.DisallowCodeDownload%2A> 這項設定是不安全的服務。 為了避免服務下載部分信任程式碼，將此屬性設定為 true"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]

      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class AppDomainSetup : IAppDomainSetup
  inheritance:
  - System.Object
  implements:
  - System.IAppDomainSetup
  inheritedMembers: []
  platform:
  - net462
- uid: System.AppDomainSetup.#ctor
  id: '#ctor'
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: AppDomainSetup()
  nameWithType: AppDomainSetup.AppDomainSetup()
  fullName: System.AppDomainSetup.AppDomainSetup()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: "初始化的新執行個體<xref href=&quot;System.AppDomainSetup&quot;></xref>類別。"
  syntax:
    content: public AppDomainSetup ();
    parameters: []
  overload: System.AppDomainSetup.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.#ctor(System.ActivationContext)
  id: '#ctor(System.ActivationContext)'
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: AppDomainSetup(ActivationContext)
  nameWithType: AppDomainSetup.AppDomainSetup(ActivationContext)
  fullName: System.AppDomainSetup.AppDomainSetup(ActivationContext)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: "初始化的新執行個體<xref href=&quot;System.AppDomainSetup&quot;></xref>與要用於應用程式定義域的資訊清單型啟用指定的啟用內容的類別。"
  remarks: "<xref:System.ActivationContext>物件指定`activationContext`用來產生<xref:System.Runtime.Hosting.ActivationArguments>物件，其中包含啟動新的應用程式定義域所需的資訊。</xref:System.Runtime.Hosting.ActivationArguments> </xref:System.ActivationContext> 這<xref:System.Runtime.Hosting.ActivationArguments>物件可以使用來存取<xref:System.AppDomainSetup.ActivationArguments%2A>屬性。</xref:System.AppDomainSetup.ActivationArguments%2A> </xref:System.Runtime.Hosting.ActivationArguments>"
  syntax:
    content: public AppDomainSetup (ActivationContext activationContext);
    parameters:
    - id: activationContext
      type: System.ActivationContext
      description: "要用於應用程式定義域的啟動內容。"
  overload: System.AppDomainSetup.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>activationContext</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)
  id: '#ctor(System.Runtime.Hosting.ActivationArguments)'
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: AppDomainSetup(ActivationArguments)
  nameWithType: AppDomainSetup.AppDomainSetup(ActivationArguments)
  fullName: System.AppDomainSetup.AppDomainSetup(ActivationArguments)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System
  summary: "初始化的新執行個體<xref href=&quot;System.AppDomainSetup&quot;></xref>的應用程式定義域的資訊清單型啟用所需的指定的啟用引數的類別。"
  remarks: "指定的物件`activationArguments`可以使用來存取<xref:System.AppDomainSetup.ActivationArguments%2A>屬性。</xref:System.AppDomainSetup.ActivationArguments%2A>"
  syntax:
    content: public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);
    parameters:
    - id: activationArguments
      type: System.Runtime.Hosting.ActivationArguments
      description: "物件，指定所需的資訊清單為主的啟動新的應用程式定義域的資訊。"
  overload: System.AppDomainSetup.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>activationArguments</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.AppDomainSetup.ActivationArguments
  id: ActivationArguments
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: ActivationArguments
  nameWithType: AppDomainSetup.ActivationArguments
  fullName: System.AppDomainSetup.ActivationArguments
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定應用程式定義域的啟動有關的資料。"
  remarks: "如果這個屬性設定為將會擲回任何例外狀況`null`。       所提供的資訊<xref:System.Runtime.Hosting.ActivationArguments>物件支援資訊清單型啟用。</xref:System.Runtime.Hosting.ActivationArguments>"
  syntax:
    content: public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }
    return:
      type: System.Runtime.Hosting.ActivationArguments
      description: "物件，包含應用程式定義域的啟動有關的資料。"
  overload: System.AppDomainSetup.ActivationArguments*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "屬性設定為<xref href=&quot;System.Runtime.Hosting.ActivationArguments&quot;></xref>物件的應用程式識別不符合的應用程式識別<xref href=&quot;System.Security.Policy.ApplicationTrust&quot;></xref>所傳回物件<> *> 屬性。如果擲回任何例外狀況<> *> 屬性是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomainSetup.AppDomainInitializer
  id: AppDomainInitializer
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: AppDomainInitializer
  nameWithType: AppDomainSetup.AppDomainInitializer
  fullName: System.AppDomainSetup.AppDomainInitializer
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定<xref href=&quot;System.AppDomainInitializer&quot;></xref>委派，表示應用程式定義域初始化時會叫用的回呼方法。"
  remarks: "若要將資訊傳遞至回呼方法，將指定的字串陣列<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>屬性。</xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> 的陣列傳遞至回呼方法，每次<xref:System.AppDomain>已初始化。</xref:System.AppDomain>       新建立的應用程式定義域的內容中執行的回呼方法。"
  example:
  - "The following example creates a child application domain named `ChildDomain`, using an <xref:System.AppDomainSetup> object and evidence from the default application domain. The AppDomainInitializer property is set to the callback method `AppDomainInit`, which is invoked when the child domain is initialized. The arguments for the callback method are placed in an array of strings, which is assigned to the <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> property. When the child domain is created, the callback method simply prints the strings.  \n  \n [!code-cpp[AppDomainInitializer#1](~/add/codesnippet/cpp/p-system.appdomainsetup._4_1.cpp)]\n [!code-cs[AppDomainInitializer#1](~/add/codesnippet/csharp/p-system.appdomainsetup._4_1.cs)]\n [!code-vb[AppDomainInitializer#1](~/add/codesnippet/visualbasic/p-system.appdomainsetup._4_1.vb)]"
  syntax:
    content: public AppDomainInitializer AppDomainInitializer { get; set; }
    return:
      type: System.AppDomainInitializer
      description: "委派，代表應用程式定義域初始化時會叫用的回呼方法。"
  overload: System.AppDomainSetup.AppDomainInitializer*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.AppDomainInitializerArguments
  id: AppDomainInitializerArguments
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: AppDomainInitializerArguments
  nameWithType: AppDomainSetup.AppDomainInitializerArguments
  fullName: System.AppDomainSetup.AppDomainInitializerArguments
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定傳遞至所代表的回呼方法的引數<xref href=&quot;System.AppDomainInitializer&quot;></xref>委派。 應用程式定義域初始化時會叫用回呼方法。"
  remarks: "使用<xref:System.AppDomainSetup.AppDomainInitializer%2A>屬性來指定期間所叫用的回呼方法<xref:System.AppDomain>初始化。</xref:System.AppDomain> </xref:System.AppDomainSetup.AppDomainInitializer%2A> 如果<xref:System.AppDomainSetup.AppDomainInitializer%2A>屬性未設定，表示未使用指派給這個屬性的陣列。</xref:System.AppDomainSetup.AppDomainInitializer%2A>       新建立的應用程式定義域的內容中執行的回呼方法。"
  example:
  - "The following code example creates a child application domain named `ChildDomain`, using an <xref:System.AppDomainSetup> object and evidence from the default application domain. The <xref:System.AppDomainSetup.AppDomainInitializer%2A> property is set to the callback method `AppDomainInit`, which is invoked when the child domain is initialized. The arguments for the callback method are placed in an array of strings, which is assigned to the AppDomainInitializerArguments property. When the child domain is created, the callback method simply prints the strings.  \n  \n [!code-cpp[AppDomainInitializer#1](~/add/codesnippet/cpp/p-system.appdomainsetup._0_1.cpp)]\n [!code-cs[AppDomainInitializer#1](~/add/codesnippet/csharp/p-system.appdomainsetup._0_1.cs)]\n [!code-vb[AppDomainInitializer#1](~/add/codesnippet/visualbasic/p-system.appdomainsetup._0_1.vb)]"
  syntax:
    content: public string[] AppDomainInitializerArguments { get; set; }
    return:
      type: System.String[]
      description: "字串陣列傳遞至所代表之回呼方法<xref href=&quot;System.AppDomainInitializer&quot;></xref>委派時的回呼方法會叫用期間<xref href=&quot;System.AppDomain&quot;></xref>初始化。"
  overload: System.AppDomainSetup.AppDomainInitializerArguments*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.AppDomainManagerAssembly
  id: AppDomainManagerAssembly
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: AppDomainManagerAssembly
  nameWithType: AppDomainSetup.AppDomainManagerAssembly
  fullName: System.AppDomainSetup.AppDomainManagerAssembly
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定用於建立使用此應用程式定義域提供的應用程式定義域管理員類型的組件的顯示名稱<xref href=&quot;System.AppDomainSetup&quot;></xref>物件。"
  remarks: "To specify the type of the application domain manager, set both this property and the <xref:System.AppDomainSetup.AppDomainManagerType%2A> property. If either of these properties is not set, the other is ignored.  \n  \n If no type is provided, the application domain manager is created from the same type as the parent application domain (that is, the application domain from which the <xref:System.AppDomain.CreateDomain%2A?displayProperty=fullName> method is called).  \n  \n When the application domain is loaded, <xref:System.TypeLoadException> is thrown if the assembly does not exist, or if the assembly does not contain the type specified by the <xref:System.AppDomainSetup.AppDomainManagerType%2A> property. <xref:System.IO.FileLoadException> is thrown if the assembly is found but the version information does not match.  \n  \n To set the application domain manager for the default application domain, use the [\\<appDomainManagerAssembly>](../Topic/%3CappDomainManagerAssembly%3E%20Element.md) and [\\<appDomainManagerType>](../Topic/%3CappDomainManagerType%3E%20Element.md) elements in the [\\<runtime>](../Topic/%3Cruntime%3E%20Element.md) section of the application configuration file, or use the environment variables described in <xref:System.AppDomainManager>.  \n  \n This feature requires the application to have full trust. (For example, an application running on the desktop has full trust.) If the application does not have full trust, a <xref:System.TypeLoadException> is thrown.  \n  \n The format of the assembly display name is given by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> property."
  syntax:
    content: public string AppDomainManagerAssembly { get; set; }
    return:
      type: System.String
      description: "提供的組件的顯示名稱<xref:System.Type>的應用程式定義域管理員。</xref:System.Type>"
  overload: System.AppDomainSetup.AppDomainManagerAssembly*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.AppDomainManagerType
  id: AppDomainManagerType
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: AppDomainManagerType
  nameWithType: AppDomainSetup.AppDomainManagerType
  fullName: System.AppDomainSetup.AppDomainManagerType
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定建立使用此應用程式定義域提供應用程式定義域管理員類型的完整名稱<xref href=&quot;System.AppDomainSetup&quot;></xref>物件。"
  remarks: "To specify the type of the application domain manager, set both this property and the <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> property. If either of these properties is not set, the other is ignored.  \n  \n If no type is provided, the application domain manager is created from the same type as the parent application domain (that is, the application domain from which the <xref:System.AppDomain.CreateDomain%2A?displayProperty=fullName> method is called).  \n  \n When the application domain is loaded, <xref:System.TypeLoadException> is thrown if the assembly specified by the <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> property does not contain the type specified by this property.  \n  \n To set the application domain manager for the default application domain, use the [\\<appDomainManagerAssembly>](../Topic/%3CappDomainManagerAssembly%3E%20Element.md) and [\\<appDomainManagerType>](../Topic/%3CappDomainManagerType%3E%20Element.md) elements in the [\\<runtime>](../Topic/%3Cruntime%3E%20Element.md) section of the application configuration file, or use the environment variables described in <xref:System.AppDomainManager>.  \n  \n This feature requires the application to have full trust. (For example, an application running on the desktop has full trust.) If the application does not have full trust, a <xref:System.TypeLoadException> is thrown.  \n  \n The format of the full name of a type is given by the <xref:System.Type.FullName%2A?displayProperty=fullName> property."
  syntax:
    content: public string AppDomainManagerType { get; set; }
    return:
      type: System.String
      description: "類型，包括命名空間的完整名稱。"
  overload: System.AppDomainSetup.AppDomainManagerType*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.ApplicationBase
  id: ApplicationBase
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: ApplicationBase
  nameWithType: AppDomainSetup.ApplicationBase
  fullName: System.AppDomainSetup.ApplicationBase
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定包含應用程式的目錄名稱。"
  remarks: "應用程式基底目錄是組件管理員開始探查組件。       ApplicationBase 屬性可能會影響應用程式定義域授與的權限。 例如，通常來自本機電腦的應用程式定義域收到完全信任的來源的位置。 不過，如果該 ApplicationBase 屬性<xref:System.AppDomain>設為內部網路目錄中，設定會限制授與給 LocalIntranet 授與應用程式定義域，即使應用程式定義域確實來自本機電腦的權限 ApplicationBase 的完整名稱。</xref:System.AppDomain>"
  example:
  - "The following example demonstrates how to use the ApplicationBase property to set the location where the assembly loader begins probing for assemblies to load into a new application domain.  \n  \n> [!NOTE]\n>  You must ensure that the folder you specify exists.  \n  \n [!code-vb[ADApplicationBase#1](~/add/codesnippet/visualbasic/p-system.appdomainsetup._5_1.vb)]\n [!code-cpp[ADApplicationBase#1](~/add/codesnippet/cpp/p-system.appdomainsetup._5_1.cpp)]\n [!code-cs[ADApplicationBase#1](~/add/codesnippet/csharp/p-system.appdomainsetup._5_1.cs)]"
  syntax:
    content: public string ApplicationBase { get; set; }
    return:
      type: System.String
      description: "應用程式基底目錄的名稱。"
  overload: System.AppDomainSetup.ApplicationBase*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.ApplicationName
  id: ApplicationName
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: ApplicationName
  nameWithType: AppDomainSetup.ApplicationName
  fullName: System.AppDomainSetup.ApplicationName
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定應用程式的名稱。"
  remarks: ''
  example:
  - "The following example shows how to set the ApplicationName property when you create a new application domain.  \n  \n The example creates a new application domain, and then calls the <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=fullName> method to load the example assembly into the new application domain and create an instance of the `Worker` class. The `Worker` class inherits <xref:System.MarshalByRefObject>, so the example can use the proxy returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> to call the `TestLoad` method.  \n  \n The `TestLoad` method loads an assembly that you specify. You must either specify a valid, fully qualified assembly name, or comment out the <xref:System.Reflection.Assembly.Load%28System.String%29> method. The `TestLoad` method lists the assemblies that are loaded into the new application domain, showing that your specified assembly and the example assembly are loaded.  \n  \n The example uses the <xref:System.LoaderOptimizationAttribute> attribute to tell the assembly loader how the application will share code across application domains.  \n  \n [!code-cpp[ADMultiDomain#1](~/add/codesnippet/cpp/p-system.appdomainsetup._2_1.cpp)]\n [!code-cs[ADMultiDomain#1](~/add/codesnippet/csharp/p-system.appdomainsetup._2_1.cs)]\n [!code-vb[ADMultiDomain#1](~/add/codesnippet/visualbasic/p-system.appdomainsetup._2_1.vb)]"
  syntax:
    content: public string ApplicationName { get; set; }
    return:
      type: System.String
      description: "應用程式的名稱。"
  overload: System.AppDomainSetup.ApplicationName*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.ApplicationTrust
  id: ApplicationTrust
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: ApplicationTrust
  nameWithType: AppDomainSetup.ApplicationTrust
  fullName: System.AppDomainSetup.ApplicationTrust
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定包含安全性和信任資訊的物件。"
  remarks: "這個屬性是`null`時<xref:System.AppDomainSetup>建立。</xref:System.AppDomainSetup> 一旦變更，無法重設為 null 參考。"
  syntax:
    content: public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }
    return:
      type: System.Security.Policy.ApplicationTrust
      description: "物件，包含安全性和信任資訊。"
  overload: System.AppDomainSetup.ApplicationTrust*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "屬性設定為<xref href=&quot;System.Security.Policy.ApplicationTrust&quot;></xref>物件的應用程式識別不符合的應用程式識別<xref href=&quot;System.Runtime.Hosting.ActivationArguments&quot;></xref>所傳回物件<> *> 屬性。如果擲回任何例外狀況<> *> 屬性是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "屬性設定為<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomainSetup.CachePath
  id: CachePath
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: CachePath
  nameWithType: AppDomainSetup.CachePath
  fullName: System.AppDomainSetup.CachePath
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定其中的檔案已陰影複製的應用程式特定區域的名稱。"
  remarks: "為了讓此屬性，讓效果，請<xref:System.AppDomainSetup.ApplicationName%2A>也必須設定屬性。</xref:System.AppDomainSetup.ApplicationName%2A> 如果<xref:System.AppDomainSetup.ApplicationName%2A>屬性未設定，則會忽略 CachePath 屬性陰影複本快取位置預設為下載快取。</xref:System.AppDomainSetup.ApplicationName%2A>       如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public string CachePath { get; set; }
    return:
      type: System.String
      description: "其中的檔案已陰影複製的目錄路徑和檔案名稱的完整的名稱。"
  overload: System.AppDomainSetup.CachePath*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.ConfigurationFile
  id: ConfigurationFile
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: ConfigurationFile
  nameWithType: AppDomainSetup.ConfigurationFile
  fullName: System.AppDomainSetup.ConfigurationFile
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定應用程式定義域的組態檔的名稱。"
  remarks: "組態檔會描述應用程式定義域的組態資料與搜尋規則。 建立應用程式定義域的主機會負責提供這項資料，因為有意義的值不同的狀況。       例如，ASP.NET 應用程式的組態資料會儲存為每個應用程式、 網站和電腦，而可執行檔的組態資料會儲存每個應用程式、 使用者及電腦。 只有主機才會知道組態資料的詳細資訊，為特定狀況。"
  syntax:
    content: public string ConfigurationFile { get; set; }
    return:
      type: System.String
      description: "組態檔的名稱。"
  overload: System.AppDomainSetup.ConfigurationFile*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.DisallowApplicationBaseProbing
  id: DisallowApplicationBaseProbing
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: DisallowApplicationBaseProbing
  nameWithType: AppDomainSetup.DisallowApplicationBaseProbing
  fullName: System.AppDomainSetup.DisallowApplicationBaseProbing
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "指定當搜尋要載入的組件的應用程式基底路徑和私用二進位路徑是否要探查。"
  remarks: "如果 DisallowApplicationBaseProbing 屬性為`true`，值<xref:System.AppDomainSetup.ApplicationBase%2A>屬性會被忽略。</xref:System.AppDomainSetup.ApplicationBase%2A> 也就是任何組件會探查如中所指定目錄<xref:System.AppDomainSetup.ApplicationBase%2A>屬性。</xref:System.AppDomainSetup.ApplicationBase%2A> 此外，值<xref:System.AppDomainSetup.PrivateBinPath%2A>屬性和<xref:System.AppDomainSetup.PrivateBinPathProbe%2A>屬性會被忽略。</xref:System.AppDomainSetup.PrivateBinPathProbe%2A> </xref:System.AppDomainSetup.PrivateBinPath%2A> 所指定之目錄中任何組件探查的<xref:System.AppDomainSetup.PrivateBinPath%2A>屬性。</xref:System.AppDomainSetup.PrivateBinPath%2A>       DisallowApplicationBaseProbing 屬性會提供額外的控制載入程序。 標準的組件載入順序時，應用程式基底會探查之前<xref:System.AppDomain.AssemblyResolve?displayProperty=fullName>就會引發事件。</xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> 不過，某些應用程式可能需要從 OLE 複合檔案的文件，或從唯一的已知位置不在全域組件快取和所指定之目錄中載入的組件<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>屬性。</xref:System.AppDomainSetup.PrivateBinPath%2A> </xref:System.AppDomainSetup.ApplicationBase%2A> 這類應用程式可以使用 DisallowApplicationBaseProbing 屬性，以避免一般探查時，所造成的延遲，並避免載入必要可能位在一般的探查路徑中的組件的複本。"
  syntax:
    content: public bool DisallowApplicationBaseProbing { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果不允許探查，否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomainSetup.DisallowApplicationBaseProbing*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.DisallowBindingRedirects
  id: DisallowBindingRedirects
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: DisallowBindingRedirects
  nameWithType: AppDomainSetup.DisallowBindingRedirects
  fullName: System.AppDomainSetup.DisallowBindingRedirects
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定值，指出應用程式定義域是否允許組件繫結重新導向。"
  remarks: "DisallowBindingRedirects 屬性被設計用於服務和伺服器應用程式組件繫結重新導向不是屬於應用程式的情況。"
  syntax:
    content: public bool DisallowBindingRedirects { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果不允許組件重新導向，則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>被允許。"
  overload: System.AppDomainSetup.DisallowBindingRedirects*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.DisallowCodeDownload
  id: DisallowCodeDownload
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: DisallowCodeDownload
  nameWithType: AppDomainSetup.DisallowCodeDownload
  fullName: System.AppDomainSetup.DisallowCodeDownload
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定值，指出應用程式定義域是否允許以 HTTP 下載組件。"
  remarks: "DisallowCodeDownload 屬性被設計用於服務和伺服器應用程式從內部網路或網際網路下載的程式碼不是屬於應用程式的情況。      > [!CAUTION] > DisallowCodeDownload 屬性的預設值是`false`。 這項設定是不安全的服務。 為了避免服務下載部分信任程式碼，將此屬性設定為`true`。"
  syntax:
    content: public bool DisallowCodeDownload { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果 HTTP 下載組件不允許;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>被允許。"
  overload: System.AppDomainSetup.DisallowCodeDownload*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.DisallowPublisherPolicy
  id: DisallowPublisherPolicy
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: DisallowPublisherPolicy
  nameWithType: AppDomainSetup.DisallowPublisherPolicy
  fullName: System.AppDomainSetup.DisallowPublisherPolicy
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定值，指出是否[ &lt;p&gt; ](../Topic/%3CpublisherPolicy%3E%20Element.md)組態檔的區段是否套用至應用程式定義域。"
  remarks: "DisallowPublisherPolicy 屬性特別適用於在本機載入 Web 應用程式。 使用這個屬性來協助防止惡意嘗試在安全模式中執行不安全的 Web 應用程式。       如需略過發行者原則的詳細資訊，請參閱[重新導向組件版本](~/add/includes/ajax-current-ext-md.md)主題。 如需安全模式的詳細資訊，請參閱的 < 檢查組態檔案 > 一節[執行階段如何找出組件](~/add/includes/ajax-current-ext-md.md)主題。"
  syntax:
    content: public bool DisallowPublisherPolicy { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref uid=&quot;langword_csharp_&lt;publisherPolicy&gt;&quot; name=&quot;&lt;publisherPolicy&gt;&quot; href=&quot;&quot;></xref>應用程式定義域組態檔區段會被忽略;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果遵循所宣告的發行者原則，則為。"
  overload: System.AppDomainSetup.DisallowPublisherPolicy*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.DynamicBase
  id: DynamicBase
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: DynamicBase
  nameWithType: AppDomainSetup.DynamicBase
  fullName: System.AppDomainSetup.DynamicBase
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定基底目錄的動態產生檔案之目錄所在的位置。"
  remarks: "Use this property to set the base directory where the dynamic directory for the new application domain will be located. When code in the new application domain loads an assembly, assembly resolution looks first in the normal probing paths. If it does not find the assembly, it looks in the dynamic directory, which is returned by the <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=fullName> property. Dynamic assemblies that will be loaded and executed by the new application domain can be placed there.  \n  \n When you assign a path to the DynamicBase property, an additional subdirectory is added; the name of this subdirectory is the hash code of the value assigned to the <xref:System.AppDomainSetup.ApplicationName%2A> property. Thus, the base directory subsequently returned by this property is always different from the value assigned.  \n  \n> [!IMPORTANT]\n>  Assigning a value to this property does not create any directories. The directories must be created or verified by the code that uses them.  \n  \n The dynamic directory is a subdirectory of DynamicBase. Its simple name is the value returned by the <xref:System.AppDomainSetup.ApplicationName%2A> property, so its format is *original path*\\\\*hash code*\\\\*application name*."
  example:
  - "The following example demonstrates how to use the DynamicBase property to set the path an application domain probes when loading dynamic assemblies.  \n  \n The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to \"Example\" and its DynamicBase property to \"C:\\DynamicAssemblyDir\". The example then displays the DynamicBase property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.  \n  \n> [!NOTE]\n>  The base directory in this example is intended to be outside the probing path for the example application. Be sure to compile the example in a different location. Delete the base directory and all its subdirectories each time you run the example.  \n  \n The example creates a new application domain using the <xref:System.AppDomainSetup> object. The example then creates the dynamic directory if it does not already exist. Although the example uses the application domain's <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=fullName> property to get the name of the dynamic directory, it could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.  \n  \n The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory. The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`. Calling this method displays the name of the application domain.  \n  \n The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method. The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.  \n  \n You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example. The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`. This method does not have to have the same functionality as the one in the example; it can simply display a string to the console. The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0. When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.  \n  \n [!code-cpp[ADDynamicBase#1](~/add/codesnippet/cpp/p-system.appdomainsetup._1_1.cpp)]\n [!code-cs[ADDynamicBase#1](~/add/codesnippet/csharp/p-system.appdomainsetup._1_1.cs)]\n [!code-vb[ADDynamicBase#1](~/add/codesnippet/visualbasic/p-system.appdomainsetup._1_1.vb)]"
  syntax:
    content: public string DynamicBase { get; set; }
    return:
      type: System.String
      description: "目錄位置&lt;xref:System.AppDomain.DynamicDirectory%2A?displayProperty=fullName&gt;所在。       <div class=&quot;alert NOTE&quot;>    這個屬性的傳回值是不同於指派的值。 請參閱 < 備註 > 一節。      </div>"
  overload: System.AppDomainSetup.DynamicBase*
  exceptions:
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "無法設定這個屬性，因為應用程式定義域中的應用程式名稱是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.AppDomainSetup.GetConfigurationBytes
  id: GetConfigurationBytes
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: GetConfigurationBytes()
  nameWithType: AppDomainSetup.GetConfigurationBytes()
  fullName: System.AppDomainSetup.GetConfigurationBytes()
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "傳回所設定的 XML 組態資訊<xref:System.AppDomainSetup.SetConfigurationBytes*>方法，它會覆寫應用程式的 XML 組態資訊。</xref:System.AppDomainSetup.SetConfigurationBytes*>"
  remarks: "<xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法可用來建立新的應用程式定義域的應用程式的組態資訊會覆寫。</xref:System.AppDomainSetup.SetConfigurationBytes%2A> 中的設定檔資訊`value`覆寫應用程式的組態檔資訊。 例如，當 Example.exe 應用程式建立新的應用程式定義域時，它可以覆寫原先取自 Example.exe.config 檔案的組態資訊。      > [!IMPORTANT] > 部分的設定檔資訊的取用者不會使用儲存的資訊<xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法。</xref:System.AppDomainSetup.SetConfigurationBytes%2A> 執行階段不會強制這個屬性。 若要確保新的應用程式定義域中會覆寫所有的設定檔資訊，請使用<xref:System.AppDomainSetup.ConfigurationFile%2A>屬性來指定組態檔。</xref:System.AppDomainSetup.ConfigurationFile%2A> <xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法，並會影響組件繫結。</xref:System.AppDomainSetup.SetConfigurationBytes%2A>       中的 XML`value`等同於一般的組態檔中的 XML 之處在於它會儲存為<xref:System.Byte>陣列。</xref:System.Byte>       若要存取應用程式定義域的組態位元組，請使用<xref:System.AppDomain.SetupInformation%2A?displayProperty=fullName>屬性來取得<xref:System.AppDomainSetup>物件的應用程式定義域，然後使用 GetConfigurationBytes 方法。</xref:System.AppDomainSetup> </xref:System.AppDomain.SetupInformation%2A?displayProperty=fullName>"
  syntax:
    content: public byte[] GetConfigurationBytes ();
    parameters: []
    return:
      type: System.Byte[]
      description: "陣列，其中包含所設定的 XML 組態資訊<> *> 方法，或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>如果<> *> 尚未呼叫方法。"
  overload: System.AppDomainSetup.GetConfigurationBytes*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.LicenseFile
  id: LicenseFile
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: LicenseFile
  nameWithType: AppDomainSetup.LicenseFile
  fullName: System.AppDomainSetup.LicenseFile
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定與這個定義域相關聯的使用權檔案的位置。"
  syntax:
    content: public string LicenseFile { get; set; }
    return:
      type: System.String
      description: "位置和授權檔案的名稱。"
  overload: System.AppDomainSetup.LicenseFile*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.LoaderOptimization
  id: LoaderOptimization
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: LoaderOptimization
  nameWithType: AppDomainSetup.LoaderOptimization
  fullName: System.AppDomainSetup.LoaderOptimization
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "指定用來載入可執行檔的最佳化原則。"
  remarks: ''
  example:
  - "The following example creates a dynamic assembly and saves it to disk, and then uses the LoaderOptimization property to set the optimization policy used to load the assembly into an application domain.  \n  \n [!code-cpp[ADDyno#1](~/add/codesnippet/cpp/p-system.appdomainsetup._3_1.cpp)]\n [!code-cs[ADDyno#1](~/add/codesnippet/csharp/p-system.appdomainsetup._3_1.cs)]\n [!code-vb[ADDyno#1](~/add/codesnippet/visualbasic/p-system.appdomainsetup._3_1.vb)]"
  syntax:
    content: public LoaderOptimization LoaderOptimization { get; set; }
    return:
      type: System.LoaderOptimization
      description: "搭配使用的列舉的常數<xref href=&quot;System.LoaderOptimizationAttribute&quot;> </xref>。"
  overload: System.AppDomainSetup.LoaderOptimization*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.PartialTrustVisibleAssemblies
  id: PartialTrustVisibleAssemblies
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: PartialTrustVisibleAssemblies
  nameWithType: AppDomainSetup.PartialTrustVisibleAssemblies
  fullName: System.AppDomainSetup.PartialTrustVisibleAssemblies
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定標記的組件清單<xref href=&quot;System.Security.PartialTrustVisibilityLevel&quot;></xref>都已成為可見的沙箱化應用程式定義域中執行的部分信任程式碼的旗標。"
  remarks: "開頭為[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]，<xref:System.Security.AllowPartiallyTrustedCallersAttribute>藉由設定其<xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A>屬性至<xref:System.Security.PartialTrustVisibilityLevel>。</xref:System.Security.PartialTrustVisibilityLevel></xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A>條件進行 (APTCA) 屬性</xref:System.Security.AllowPartiallyTrustedCallersAttribute> <xref:System.Security.PartialTrustVisibilityLevel>除非主應用程式可讓它無法供部分信任程式碼</xref:System.Security.PartialTrustVisibilityLevel>已標記 APTCA 組件       沙箱化應用程式定義域的主機可允許使用條件式 APTCA 屬性中的組件，藉由建立陣列，其中包含的簡單名稱和公開金鑰的每個組件，並將陣列指派給這個屬性的應用程式定義域中的程式碼。 For example, an element of the array might look like the following: &quot;MyAssembly, PublicKey=0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9&quot;.      > [!IMPORTANT] > 如果您使用的子類別<xref:System.AppDomainManager>，並定義它的組件相依於以條件式 APTCA 屬性標記的組件時，您必須包含這些組件的清單中，您傳遞給 PartialTrustVisibleAssemblies 屬性<xref:System.AppDomainSetup>您用於建立應用程式定義域。</xref:System.AppDomainSetup> </xref:System.AppDomainManager> 否則會使用條件式 APTCA 屬性標示組件將會停用。      > [!NOTE] > 偵錯的應用程式，在沙箱化應用程式網域中，執行某些<xref:System.Security.SecurityException>訊息可能會產生誤導。</xref:System.Security.SecurityException> 比方說，訊息可能狀態，您完全信任組件的其中一個只具有有限的權限，當實際問題的原因是超過沙箱化應用程式網域的授權集的安全性要求有沙箱化應用程式定義域界限傳播時並失敗。"
  syntax:
    content: public string[] PartialTrustVisibleAssemblies { get; set; }
    return:
      type: System.String[]
      description: "部分組件名稱，其中每一個部分名稱所組成的簡單組件名稱和公開金鑰的陣列。"
  overload: System.AppDomainSetup.PartialTrustVisibleAssemblies*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.PrivateBinPath
  id: PrivateBinPath
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: PrivateBinPath
  nameWithType: AppDomainSetup.PrivateBinPath
  fullName: System.AppDomainSetup.PrivateBinPath
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定私用組件的應用程式基底目錄之下會探查的目錄清單。"
  remarks: "私用組件會部署在相同的目錄結構與應用程式。 如果 PrivateBinPath 為指定的目錄不在<xref:System.AppDomainSetup.ApplicationBase%2A>，便會予以忽略。</xref:System.AppDomainSetup.ApplicationBase%2A>"
  syntax:
    content: public string PrivateBinPath { get; set; }
    return:
      type: System.String
      description: "以分號分隔目錄名稱的清單。"
  overload: System.AppDomainSetup.PrivateBinPath*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.PrivateBinPathProbe
  id: PrivateBinPathProbe
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: PrivateBinPathProbe
  nameWithType: AppDomainSetup.PrivateBinPathProbe
  fullName: System.AppDomainSetup.PrivateBinPathProbe
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定字串值包含或排除<> *> 應用程式，並僅搜尋的搜尋路徑中<> *>。"
  remarks: "將此屬性設定為任何非 null 字串值，包括<xref:System.String?displayProperty=fullName>(&quot;&quot;)，若要排除的應用程式的目錄路徑，也就是<xref:System.AppDomainSetup.ApplicationBase%2A>— 應用程式，並搜尋<xref:System.AppDomainSetup.PrivateBinPath%2A>.</xref:System.AppDomainSetup.PrivateBinPath%2A>只能在組件的搜尋路徑中</xref:System.AppDomainSetup.ApplicationBase%2A></xref:System.String?displayProperty=fullName>"
  syntax:
    content: public string PrivateBinPathProbe { get; set; }
    return:
      type: System.String
      description: "Null 參考 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>在 Visual Basic 中) 包含搜尋組件時的應用程式基底路徑; 任何非 null 字串值的路徑排除。 預設值是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomainSetup.PrivateBinPathProbe*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.SandboxInterop
  id: SandboxInterop
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: SandboxInterop
  nameWithType: AppDomainSetup.SandboxInterop
  fullName: System.AppDomainSetup.SandboxInterop
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定值，指出是否介面快取已停用應用程式定義域中 interop 呼叫，讓`QueryInterface`每個呼叫上執行。"
  remarks: "停用介面快取 interop 呼叫的效能有重大影響。       這個成員在引進[!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]。"
  syntax:
    content: public bool SandboxInterop { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果與目前所建立的應用程式定義域中 interop 呼叫介面快取已停用<xref href=&quot;System.AppDomainSetup&quot;></xref>物件; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.AppDomainSetup.SandboxInterop*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})
  id: SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: SetCompatibilitySwitches(IEnumerable<String>)
  nameWithType: AppDomainSetup.SetCompatibilitySwitches(IEnumerable<String>)
  fullName: System.AppDomainSetup.SetCompatibilitySwitches(IEnumerable<String>)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "設定指定的參數，讓應用程式定義域與舊版的.NET Framework 針對指定的問題。"
  remarks: "Major versions of the .NET Framework sometimes introduce breaking changes from the previous version. For example, the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)] introduces a small number of breaking changes from the [!INCLUDE[net_v35_long](~/add/includes/ajax-current-ext-md.md)]. Use the SetCompatibilitySwitches method to specify that one or more of these breaking changes should be rolled back for the application domain, to make the behavior compatible with the previous version of the .NET Framework.  \n  \n Each time you call this method, it replaces the existing switch settings. To erase the settings, specify `null` for the `switches` parameter.  \n  \n The set of string values you provide for `switches` can be a simple string array, because arrays implement the <xref:System.Collections.IEnumerable> interface.  \n  \n The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.  \n  \n|Switch|Meaning|  \n|------------|-------------|  \n|\"NetFx40_LegacySecurityPolicy\"|Code access security (CAS) for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain. See [\\&lt;NetFx40_LegacySecurityPolicy\\&gt; Element](../Topic/%3CNetFx40_LegacySecurityPolicy%3E%20Element.md).|  \n|\"NetFx40_Legacy20SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] are enabled in this application domain. Successfully restoring legacy sorting behavior also requires the sort00001000.dll dynamic link library to be available on the local system. See [\\&lt;CompatSortNLSVersion\\&gt; Element](../Topic/%3CCompatSortNLSVersion%3E%20Element.md).|  \n|\"NetFx40_Legacy40SortingBehavior\"|String sorting defaults for the [!INCLUDE[net_v40_short](~/add/includes/net-v40-short-md.md)] and Unicode 5.0 are enabled in this application domain. Successfully restoring legacy sorting behavior also requires the sort00060101.dll dynamic link library to be available on the local system.|  \n|\"NetFx40_TimeSpanLegacyFormatMode\"|<xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/add/includes/net-v35-short-md.md)] is enabled in this application domain. See [\\&lt;TimeSpan_LegacyFormatMode\\&gt; Element](../Topic/%3CTimeSpan_LegacyFormatMode%3E%20Element.md) and the \"Restoring Legacy TimeSpan Formatting\" section of the <xref:System.TimeSpan> topic.|  \n|\"UseRandomizedStringHashAlgorithm\"|The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains. See [\\&lt;UseRandomizedStringHashAlgorithm\\&gt; Element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md).|"
  syntax:
    content: public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable<string> switches);
    parameters:
    - id: switches
      type: System.Collections.Generic.IEnumerable{System.String}
      description: "指定相容性參數的字串值的可列舉集或<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>清除現有的相容性參數。"
  overload: System.AppDomainSetup.SetCompatibilitySwitches*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.SetConfigurationBytes(System.Byte[])
  id: SetConfigurationBytes(System.Byte[])
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: SetConfigurationBytes(Byte[])
  nameWithType: AppDomainSetup.SetConfigurationBytes(Byte[])
  fullName: System.AppDomainSetup.SetConfigurationBytes(Byte[])
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "提供應用程式定義域，以取代應用程式的 XML 組態資訊的 XML 組態資訊。"
  remarks: "SetConfigurationBytes 方法可用來取代建立新的應用程式定義域的應用程式的組態資訊。 中的設定檔資訊`value`取代應用程式的設定檔資訊。 例如，當 Example.exe 應用程式建立新的應用程式定義域時，它可以取代原本取自 Example.exe.config 檔案的組態資訊。      > [!IMPORTANT] > 部分的設定檔資訊的取用者不會使用 SetConfigurationBytes 方法所儲存的資訊。 執行階段不會強制這個屬性。 若要確保所有的設定檔資訊會取代新的應用程式定義域中，使用<xref:System.AppDomainSetup.ConfigurationFile%2A>屬性來指定組態檔。</xref:System.AppDomainSetup.ConfigurationFile%2A> SetConfigurationBytes 方法，並會影響組件繫結。       中的 XML`value`等同於一般的組態檔中的 XML 之處在於它會儲存為<xref:System.Byte>陣列。</xref:System.Byte>"
  syntax:
    content: public void SetConfigurationBytes (byte[] value);
    parameters:
    - id: value
      type: System.Byte[]
      description: "陣列，其中包含要用於應用程式定義域的 XML 組態資訊。"
  overload: System.AppDomainSetup.SetConfigurationBytes*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)
  id: SetNativeFunction(System.String,System.Int32,System.IntPtr)
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: SetNativeFunction(String,Int32,IntPtr)
  nameWithType: AppDomainSetup.SetNativeFunction(String,Int32,IntPtr)
  fullName: System.AppDomainSetup.SetNativeFunction(String,Int32,IntPtr)
  type: Method
  assemblies:
  - mscorlib
  namespace: System
  summary: "Common language runtime 提供字串比較函式的替代實作。"
  remarks: "下列的字串比較和排序方法可以覆寫 SetNativeFunction 方法:- `IsNLSDefinedString`       -    `CompareStringEx`       -    `LCMapStringEx`       -    `FindNLSStringEx`       -    `CompareStringOrdinal`       -    `GetNLSVersion`這些函式的相關資訊，請參閱[國家語言支援函式](http://go.microsoft.com/fwlink/?LinkId=228134)。"
  syntax:
    content: public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);
    parameters:
    - id: functionName
      type: System.String
      description: "若要覆寫字串比較函式的名稱。"
    - id: functionVersion
      type: System.Int32
      description: "函式版本。 如[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]，其值必須大於或等於 1。"
    - id: functionPointer
      type: System.IntPtr
      description: "覆寫函式的指標`functionName`。"
  overload: System.AppDomainSetup.SetNativeFunction*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>functionName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>functionVersion</code>不大於或等於 1。       -<code>functionPointer</code>是&lt;xref:System.IntPtr?displayProperty=fullName&gt;。"
  platform:
  - net462
- uid: System.AppDomainSetup.ShadowCopyDirectories
  id: ShadowCopyDirectories
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: ShadowCopyDirectories
  nameWithType: AppDomainSetup.ShadowCopyDirectories
  fullName: System.AppDomainSetup.ShadowCopyDirectories
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定包含要陰影複製組件的目錄名稱。"
  remarks: "啟用陰影複製時，預設值是要透過探查; 找到的所有組件的陰影複製也就是所指定目錄中<xref:System.AppDomainSetup.PrivateBinPath%2A>和<xref:System.AppDomainSetup.ApplicationBase%2A>屬性。</xref:System.AppDomainSetup.ApplicationBase%2A> </xref:System.AppDomainSetup.PrivateBinPath%2A> ShadowCopyDirectories 屬性會限制 ShadowCopyDirectories 所指定目錄中的組件的陰影複製。       如果您不指派字串給 ShadowCopyDirectories 屬性，或如果您將此屬性設定為`null`，所指定目錄中的所有組件<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>屬性是陰影複製。</xref:System.AppDomainSetup.PrivateBinPath%2A> </xref:System.AppDomainSetup.ApplicationBase%2A>      > [!IMPORTANT] > 目錄路徑不可包含分號，因為分號是分隔符號字元。 分號沒有逸出字元。       作用時，陰影複製，組件檔會複製到另一個位置載入組件之前。 原始的組件檔未鎖定，因此可以更新。 如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public string ShadowCopyDirectories { get; set; }
    return:
      type: System.String
      description: "以分號分隔目錄名稱的清單。"
  overload: System.AppDomainSetup.ShadowCopyDirectories*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.ShadowCopyFiles
  id: ShadowCopyFiles
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: ShadowCopyFiles
  nameWithType: AppDomainSetup.ShadowCopyFiles
  fullName: System.AppDomainSetup.ShadowCopyFiles
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定指示陰影複製開啟或關閉的字串。"
  remarks: "如需有關陰影複製的詳細資訊，請參閱[陰影複製組件](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public string ShadowCopyFiles { get; set; }
    return:
      type: System.String
      description: "字串值&quot;true&quot;表示陰影複製為開啟，或者&quot;false&quot;表示陰影複製已關閉。"
  overload: System.AppDomainSetup.ShadowCopyFiles*
  exceptions: []
  platform:
  - net462
- uid: System.AppDomainSetup.TargetFrameworkName
  id: TargetFrameworkName
  parent: System.AppDomainSetup
  langs:
  - csharp
  name: TargetFrameworkName
  nameWithType: AppDomainSetup.TargetFrameworkName
  fullName: System.AppDomainSetup.TargetFrameworkName
  type: Property
  assemblies:
  - mscorlib
  namespace: System
  summary: "取得或設定字串，指定的目標版本和.NET Framework 應用程式定義域中，設定檔可剖析的格式&lt;xref:System.Runtime.Versioning.FrameworkName.%23ctor%28System.String%29?displayProperty=fullName&gt;建構函式。"
  remarks: "設定這個屬性，以判斷目前正在執行版本的.NET framework 應用程式定義域，可用來載入及執行的目標版本和設定檔的已編譯的組件。 如果目前執行的.NET framework 版本有選擇性的行為會影響相容性的目標版本編譯的程式碼，它可以啟用或停用這些行為，視需要以提高相容性。 當應用程式支援增益集由在個別的應用程式定義域中執行它們使用多個版本的.NET framework 編譯時，這非常有用。       用戶端應用程式，TargetFrameworkName 屬性的值由推斷<xref:System.Runtime.Versioning.TargetFrameworkAttribute>屬性。</xref:System.Runtime.Versioning.TargetFrameworkAttribute> 在[!INCLUDE[vs_dev10_long](~/add/includes/vs-dev10-long-md.md)]和更新版本中，這個屬性會加入至組件會自動根據專案設定**目標 Framework**屬性。"
  syntax:
    content: public string TargetFrameworkName { get; set; }
    return:
      type: System.String
      description: "目標版本和.NET Framework 的設定檔。"
  overload: System.AppDomainSetup.TargetFrameworkName*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.MemberAccessException
  isExternal: true
  name: System.MemberAccessException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.AppDomainSetup.#ctor
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainSetup()
  nameWithType: AppDomainSetup.AppDomainSetup()
  fullName: System.AppDomainSetup.AppDomainSetup()
- uid: System.AppDomainSetup.#ctor(System.ActivationContext)
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainSetup(ActivationContext)
  nameWithType: AppDomainSetup.AppDomainSetup(ActivationContext)
  fullName: System.AppDomainSetup.AppDomainSetup(ActivationContext)
- uid: System.ActivationContext
  parent: System
  isExternal: false
  name: ActivationContext
  nameWithType: ActivationContext
  fullName: System.ActivationContext
- uid: System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainSetup(ActivationArguments)
  nameWithType: AppDomainSetup.AppDomainSetup(ActivationArguments)
  fullName: System.AppDomainSetup.AppDomainSetup(ActivationArguments)
- uid: System.Runtime.Hosting.ActivationArguments
  parent: System.Runtime.Hosting
  isExternal: false
  name: ActivationArguments
  nameWithType: ActivationArguments
  fullName: System.Runtime.Hosting.ActivationArguments
- uid: System.AppDomainSetup.ActivationArguments
  parent: System.AppDomainSetup
  isExternal: false
  name: ActivationArguments
  nameWithType: AppDomainSetup.ActivationArguments
  fullName: System.AppDomainSetup.ActivationArguments
- uid: System.AppDomainSetup.AppDomainInitializer
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainSetup.AppDomainInitializer
  fullName: System.AppDomainSetup.AppDomainInitializer
- uid: System.AppDomainInitializer
  parent: System
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainInitializer
  fullName: System.AppDomainInitializer
- uid: System.AppDomainSetup.AppDomainInitializerArguments
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainInitializerArguments
  nameWithType: AppDomainSetup.AppDomainInitializerArguments
  fullName: System.AppDomainSetup.AppDomainInitializerArguments
- uid: System.String[]
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String[]
  spec.csharp:
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomainSetup.AppDomainManagerAssembly
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainManagerAssembly
  nameWithType: AppDomainSetup.AppDomainManagerAssembly
  fullName: System.AppDomainSetup.AppDomainManagerAssembly
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.AppDomainSetup.AppDomainManagerType
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainManagerType
  nameWithType: AppDomainSetup.AppDomainManagerType
  fullName: System.AppDomainSetup.AppDomainManagerType
- uid: System.AppDomainSetup.ApplicationBase
  parent: System.AppDomainSetup
  isExternal: false
  name: ApplicationBase
  nameWithType: AppDomainSetup.ApplicationBase
  fullName: System.AppDomainSetup.ApplicationBase
- uid: System.AppDomainSetup.ApplicationName
  parent: System.AppDomainSetup
  isExternal: false
  name: ApplicationName
  nameWithType: AppDomainSetup.ApplicationName
  fullName: System.AppDomainSetup.ApplicationName
- uid: System.AppDomainSetup.ApplicationTrust
  parent: System.AppDomainSetup
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomainSetup.ApplicationTrust
  fullName: System.AppDomainSetup.ApplicationTrust
- uid: System.Security.Policy.ApplicationTrust
  parent: System.Security.Policy
  isExternal: false
  name: ApplicationTrust
  nameWithType: ApplicationTrust
  fullName: System.Security.Policy.ApplicationTrust
- uid: System.AppDomainSetup.CachePath
  parent: System.AppDomainSetup
  isExternal: false
  name: CachePath
  nameWithType: AppDomainSetup.CachePath
  fullName: System.AppDomainSetup.CachePath
- uid: System.AppDomainSetup.ConfigurationFile
  parent: System.AppDomainSetup
  isExternal: false
  name: ConfigurationFile
  nameWithType: AppDomainSetup.ConfigurationFile
  fullName: System.AppDomainSetup.ConfigurationFile
- uid: System.AppDomainSetup.DisallowApplicationBaseProbing
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowApplicationBaseProbing
  nameWithType: AppDomainSetup.DisallowApplicationBaseProbing
  fullName: System.AppDomainSetup.DisallowApplicationBaseProbing
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.AppDomainSetup.DisallowBindingRedirects
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowBindingRedirects
  nameWithType: AppDomainSetup.DisallowBindingRedirects
  fullName: System.AppDomainSetup.DisallowBindingRedirects
- uid: System.AppDomainSetup.DisallowCodeDownload
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowCodeDownload
  nameWithType: AppDomainSetup.DisallowCodeDownload
  fullName: System.AppDomainSetup.DisallowCodeDownload
- uid: System.AppDomainSetup.DisallowPublisherPolicy
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowPublisherPolicy
  nameWithType: AppDomainSetup.DisallowPublisherPolicy
  fullName: System.AppDomainSetup.DisallowPublisherPolicy
- uid: System.AppDomainSetup.DynamicBase
  parent: System.AppDomainSetup
  isExternal: false
  name: DynamicBase
  nameWithType: AppDomainSetup.DynamicBase
  fullName: System.AppDomainSetup.DynamicBase
- uid: System.AppDomainSetup.GetConfigurationBytes
  parent: System.AppDomainSetup
  isExternal: false
  name: GetConfigurationBytes()
  nameWithType: AppDomainSetup.GetConfigurationBytes()
  fullName: System.AppDomainSetup.GetConfigurationBytes()
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AppDomainSetup.LicenseFile
  parent: System.AppDomainSetup
  isExternal: false
  name: LicenseFile
  nameWithType: AppDomainSetup.LicenseFile
  fullName: System.AppDomainSetup.LicenseFile
- uid: System.AppDomainSetup.LoaderOptimization
  parent: System.AppDomainSetup
  isExternal: false
  name: LoaderOptimization
  nameWithType: AppDomainSetup.LoaderOptimization
  fullName: System.AppDomainSetup.LoaderOptimization
- uid: System.LoaderOptimization
  parent: System
  isExternal: false
  name: LoaderOptimization
  nameWithType: LoaderOptimization
  fullName: System.LoaderOptimization
- uid: System.AppDomainSetup.PartialTrustVisibleAssemblies
  parent: System.AppDomainSetup
  isExternal: false
  name: PartialTrustVisibleAssemblies
  nameWithType: AppDomainSetup.PartialTrustVisibleAssemblies
  fullName: System.AppDomainSetup.PartialTrustVisibleAssemblies
- uid: System.AppDomainSetup.PrivateBinPath
  parent: System.AppDomainSetup
  isExternal: false
  name: PrivateBinPath
  nameWithType: AppDomainSetup.PrivateBinPath
  fullName: System.AppDomainSetup.PrivateBinPath
- uid: System.AppDomainSetup.PrivateBinPathProbe
  parent: System.AppDomainSetup
  isExternal: false
  name: PrivateBinPathProbe
  nameWithType: AppDomainSetup.PrivateBinPathProbe
  fullName: System.AppDomainSetup.PrivateBinPathProbe
- uid: System.AppDomainSetup.SandboxInterop
  parent: System.AppDomainSetup
  isExternal: false
  name: SandboxInterop
  nameWithType: AppDomainSetup.SandboxInterop
  fullName: System.AppDomainSetup.SandboxInterop
- uid: System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})
  parent: System.AppDomainSetup
  isExternal: false
  name: SetCompatibilitySwitches(IEnumerable<String>)
  nameWithType: AppDomainSetup.SetCompatibilitySwitches(IEnumerable<String>)
  fullName: System.AppDomainSetup.SetCompatibilitySwitches(IEnumerable<String>)
- uid: System.Collections.Generic.IEnumerable{System.String}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<String>
  nameWithType: IEnumerable<String>
  fullName: System.Collections.Generic.IEnumerable<System.String>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.String>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.String
    name: String
    nameWithType: String
    fullName: String
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.AppDomainSetup.SetConfigurationBytes(System.Byte[])
  parent: System.AppDomainSetup
  isExternal: false
  name: SetConfigurationBytes(Byte[])
  nameWithType: AppDomainSetup.SetConfigurationBytes(Byte[])
  fullName: System.AppDomainSetup.SetConfigurationBytes(Byte[])
- uid: System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)
  parent: System.AppDomainSetup
  isExternal: false
  name: SetNativeFunction(String,Int32,IntPtr)
  nameWithType: AppDomainSetup.SetNativeFunction(String,Int32,IntPtr)
  fullName: System.AppDomainSetup.SetNativeFunction(String,Int32,IntPtr)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.AppDomainSetup.ShadowCopyDirectories
  parent: System.AppDomainSetup
  isExternal: false
  name: ShadowCopyDirectories
  nameWithType: AppDomainSetup.ShadowCopyDirectories
  fullName: System.AppDomainSetup.ShadowCopyDirectories
- uid: System.AppDomainSetup.ShadowCopyFiles
  parent: System.AppDomainSetup
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomainSetup.ShadowCopyFiles
  fullName: System.AppDomainSetup.ShadowCopyFiles
- uid: System.AppDomainSetup.TargetFrameworkName
  parent: System.AppDomainSetup
  isExternal: false
  name: TargetFrameworkName
  nameWithType: AppDomainSetup.TargetFrameworkName
  fullName: System.AppDomainSetup.TargetFrameworkName
- uid: System.AppDomainSetup.#ctor*
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainSetup
  nameWithType: AppDomainSetup.AppDomainSetup
- uid: System.AppDomainSetup.ActivationArguments*
  parent: System.AppDomainSetup
  isExternal: false
  name: ActivationArguments
  nameWithType: AppDomainSetup.ActivationArguments
- uid: System.AppDomainSetup.AppDomainInitializer*
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainInitializer
  nameWithType: AppDomainSetup.AppDomainInitializer
- uid: System.AppDomainSetup.AppDomainInitializerArguments*
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainInitializerArguments
  nameWithType: AppDomainSetup.AppDomainInitializerArguments
- uid: System.AppDomainSetup.AppDomainManagerAssembly*
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainManagerAssembly
  nameWithType: AppDomainSetup.AppDomainManagerAssembly
- uid: System.AppDomainSetup.AppDomainManagerType*
  parent: System.AppDomainSetup
  isExternal: false
  name: AppDomainManagerType
  nameWithType: AppDomainSetup.AppDomainManagerType
- uid: System.AppDomainSetup.ApplicationBase*
  parent: System.AppDomainSetup
  isExternal: false
  name: ApplicationBase
  nameWithType: AppDomainSetup.ApplicationBase
- uid: System.AppDomainSetup.ApplicationName*
  parent: System.AppDomainSetup
  isExternal: false
  name: ApplicationName
  nameWithType: AppDomainSetup.ApplicationName
- uid: System.AppDomainSetup.ApplicationTrust*
  parent: System.AppDomainSetup
  isExternal: false
  name: ApplicationTrust
  nameWithType: AppDomainSetup.ApplicationTrust
- uid: System.AppDomainSetup.CachePath*
  parent: System.AppDomainSetup
  isExternal: false
  name: CachePath
  nameWithType: AppDomainSetup.CachePath
- uid: System.AppDomainSetup.ConfigurationFile*
  parent: System.AppDomainSetup
  isExternal: false
  name: ConfigurationFile
  nameWithType: AppDomainSetup.ConfigurationFile
- uid: System.AppDomainSetup.DisallowApplicationBaseProbing*
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowApplicationBaseProbing
  nameWithType: AppDomainSetup.DisallowApplicationBaseProbing
- uid: System.AppDomainSetup.DisallowBindingRedirects*
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowBindingRedirects
  nameWithType: AppDomainSetup.DisallowBindingRedirects
- uid: System.AppDomainSetup.DisallowCodeDownload*
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowCodeDownload
  nameWithType: AppDomainSetup.DisallowCodeDownload
- uid: System.AppDomainSetup.DisallowPublisherPolicy*
  parent: System.AppDomainSetup
  isExternal: false
  name: DisallowPublisherPolicy
  nameWithType: AppDomainSetup.DisallowPublisherPolicy
- uid: System.AppDomainSetup.DynamicBase*
  parent: System.AppDomainSetup
  isExternal: false
  name: DynamicBase
  nameWithType: AppDomainSetup.DynamicBase
- uid: System.AppDomainSetup.GetConfigurationBytes*
  parent: System.AppDomainSetup
  isExternal: false
  name: GetConfigurationBytes
  nameWithType: AppDomainSetup.GetConfigurationBytes
- uid: System.AppDomainSetup.LicenseFile*
  parent: System.AppDomainSetup
  isExternal: false
  name: LicenseFile
  nameWithType: AppDomainSetup.LicenseFile
- uid: System.AppDomainSetup.LoaderOptimization*
  parent: System.AppDomainSetup
  isExternal: false
  name: LoaderOptimization
  nameWithType: AppDomainSetup.LoaderOptimization
- uid: System.AppDomainSetup.PartialTrustVisibleAssemblies*
  parent: System.AppDomainSetup
  isExternal: false
  name: PartialTrustVisibleAssemblies
  nameWithType: AppDomainSetup.PartialTrustVisibleAssemblies
- uid: System.AppDomainSetup.PrivateBinPath*
  parent: System.AppDomainSetup
  isExternal: false
  name: PrivateBinPath
  nameWithType: AppDomainSetup.PrivateBinPath
- uid: System.AppDomainSetup.PrivateBinPathProbe*
  parent: System.AppDomainSetup
  isExternal: false
  name: PrivateBinPathProbe
  nameWithType: AppDomainSetup.PrivateBinPathProbe
- uid: System.AppDomainSetup.SandboxInterop*
  parent: System.AppDomainSetup
  isExternal: false
  name: SandboxInterop
  nameWithType: AppDomainSetup.SandboxInterop
- uid: System.AppDomainSetup.SetCompatibilitySwitches*
  parent: System.AppDomainSetup
  isExternal: false
  name: SetCompatibilitySwitches
  nameWithType: AppDomainSetup.SetCompatibilitySwitches
- uid: System.AppDomainSetup.SetConfigurationBytes*
  parent: System.AppDomainSetup
  isExternal: false
  name: SetConfigurationBytes
  nameWithType: AppDomainSetup.SetConfigurationBytes
- uid: System.AppDomainSetup.SetNativeFunction*
  parent: System.AppDomainSetup
  isExternal: false
  name: SetNativeFunction
  nameWithType: AppDomainSetup.SetNativeFunction
- uid: System.AppDomainSetup.ShadowCopyDirectories*
  parent: System.AppDomainSetup
  isExternal: false
  name: ShadowCopyDirectories
  nameWithType: AppDomainSetup.ShadowCopyDirectories
- uid: System.AppDomainSetup.ShadowCopyFiles*
  parent: System.AppDomainSetup
  isExternal: false
  name: ShadowCopyFiles
  nameWithType: AppDomainSetup.ShadowCopyFiles
- uid: System.AppDomainSetup.TargetFrameworkName*
  parent: System.AppDomainSetup
  isExternal: false
  name: TargetFrameworkName
  nameWithType: AppDomainSetup.TargetFrameworkName
