### YamlMime:ManagedReference
items:
- uid: System.IO.Log.FileRecordSequence
  id: FileRecordSequence
  children:
  - System.IO.Log.FileRecordSequence.#ctor(System.String)
  - System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)
  - System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)
  - System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  - System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  - System.IO.Log.FileRecordSequence.BaseSequenceNumber
  - System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  - System.IO.Log.FileRecordSequence.CreateReservationCollection
  - System.IO.Log.FileRecordSequence.Dispose
  - System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  - System.IO.Log.FileRecordSequence.Flush
  - System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.LastSequenceNumber
  - System.IO.Log.FileRecordSequence.MaximumRecordLength
  - System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  - System.IO.Log.FileRecordSequence.ReadRestartAreas
  - System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  - System.IO.Log.FileRecordSequence.ReservedBytes
  - System.IO.Log.FileRecordSequence.RestartSequenceNumber
  - System.IO.Log.FileRecordSequence.RetryAppend
  - System.IO.Log.FileRecordSequence.TailPinned
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  - System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  langs:
  - csharp
  name: FileRecordSequence
  nameWithType: FileRecordSequence
  fullName: System.IO.Log.FileRecordSequence
  type: Class
  summary: "實作<xref href=&quot;System.IO.Log.IRecordSequence&quot;></xref>檔案頂端。 這個類別無法被繼承。"
  remarks: "FileRecordSequence 是根據檔案系統中的單一記錄檔記錄順序。 它是簡單的實作的<xref:System.IO.Log.IRecordSequence>介面，在簡單的檔案式記錄檔。</xref:System.IO.Log.IRecordSequence>       若要管理以檔案為基礎的記錄檔，應用程式正在執行中的帳戶必須有足夠的權限，由檔案系統安全性規定 FileRecordSequence 建構時。 此外，在建構階段進行要求 fulltrust 權限。 為了保持 Windows 安全性模型權限驗證結果會快取。 您應該確定，您不小心公開未授權的使用者記錄順序的內容。"
  example:
  - "The following example creates a record sequence, appends record to it, and finally reads the records.  \n  \n [!code-vb[IRecordSequence#1](~/add/codesnippet/visualbasic/t-system.io.log.filereco_1.vb)]\n [!code-cs[IRecordSequence#1](~/add/codesnippet/csharp/t-system.io.log.filereco_1.cs)]"
  syntax:
    content: 'public sealed class FileRecordSequence : IDisposable, System.IO.Log.IRecordSequence'
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  - System.IO.Log.IRecordSequence
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: FileRecordSequence(String)
  nameWithType: FileRecordSequence.FileRecordSequence(String)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>類別使用指定的檔案。"
  remarks: "這個建構函式會建立檔案的讀取/寫入存取，並共用讀取權限來開啟檔案。 這表示這個或另一個處理序所開啟檔案進行寫入的要求會失敗，直到這<xref:System.IO.Log.FileRecordSequence>執行個體已經過處置，但嘗試讀取則會成功。</xref:System.IO.Log.FileRecordSequence> 如果`path`找不到，建立新的檔案大小為 0 個位元組。"
  example:
  - "The following example creates a record sequence, appends record to it, reads the records, and finally diposes the sequence.  \n  \n [!code-vb[IRecordSequence#1](~/add/codesnippet/visualbasic/m-system.io.log.filereco_1.vb)]\n [!code-cs[IRecordSequence#1](~/add/codesnippet/csharp/m-system.io.log.filereco_1.cs)]"
  syntax:
    content: public FileRecordSequence (string path);
    parameters:
    - id: path
      type: System.String
      description: "檔案的相對或絕對路徑這個<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>將會在封裝執行個體。"
  overload: System.IO.Log.FileRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "所指定的檔案<code> path </code>不正確。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "所指定的檔案<code> path </code>找不到。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄存放區遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileAccess)'
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: FileRecordSequence(String,FileAccess)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>與指定的檔案和存取模式的類別。"
  syntax:
    content: public FileRecordSequence (string path, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "檔案的相對或絕對路徑這個<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>將會在封裝執行個體。"
    - id: access
      type: System.IO.FileAccess
      description: "有效<xref href=&quot;System.IO.FileAccess&quot;></xref>值，控制存取使用者的類型有記錄檔。"
  overload: System.IO.Log.FileRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "所指定的檔案<code> path </code>不正確。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "所指定的檔案<code> path </code>找不到。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄存放區遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)
  id: '#ctor(System.String,System.IO.FileAccess,System.Int32)'
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: FileRecordSequence(String,FileAccess,Int32)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
  type: Constructor
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "初始化的新執行個體<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>類別指定的檔案、 存取模式，與檔案大小。"
  syntax:
    content: public FileRecordSequence (string path, System.IO.FileAccess access, int size);
    parameters:
    - id: path
      type: System.String
      description: "檔案的相對或絕對路徑這個<xref href=&quot;System.IO.Log.FileRecordSequence&quot;></xref>將會在封裝執行個體。"
    - id: access
      type: System.IO.FileAccess
      description: "有效<xref href=&quot;System.IO.FileAccess&quot;></xref>值，控制存取使用者的類型有記錄檔。"
    - id: size
      type: System.Int32
      description: "若要開啟記錄檔的大小。"
  overload: System.IO.Log.FileRecordSequence.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個參數超出有效範圍。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "所指定的檔案<code> path </code>不正確。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "所指定的檔案<code> path </code>找不到。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "存取指定的記錄存放區遭作業系統拒絕。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  id: AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "向前移的記錄檔的基底序號。 這個方法無法被繼承。"
  syntax:
    content: public void AdvanceBaseSequenceNumber (System.IO.Log.SequenceNumber newBaseSequenceNumber);
    parameters:
    - id: newBaseSequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "新基底序號的記錄順序。"
  overload: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSequenceNumber</code>不正確。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSequenceNumber</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "修改序列時發生 I/O 錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將記錄檔記錄寫入<xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>。 這個方法無法被繼承。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.FileRecordSequence.Flush%2A>方法。</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example creates a record sequence, appends record to it, and finally reads the records.  \n  \n [!code-cs[FileRecordSequence#0](~/add/codesnippet/csharp/10554b85-231e-4dbf-ad02-_1.cs)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個引數超出範圍。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將記錄檔記錄寫入<xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>。 這個方法無法被繼承。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.FileRecordSequence.Flush%2A>方法。</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  example:
  - "The following example shows how you can create a record sequence with this method.  \n  \n [!code-vb[IRecordSequence#3](~/add/codesnippet/visualbasic/5cdfd57c-5dff-4f9a-a7e0-_1.vb)]\n [!code-cs[IRecordSequence#3](~/add/codesnippet/csharp/5cdfd57c-5dff-4f9a-a7e0-_1.cs)]"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個引數超出範圍。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將記錄檔記錄寫入<xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>，使用先前在順序中保留的空間。 這個方法無法被繼承。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       附加的記錄將會取用先前所保留，使用所指定的保留區的空間`reservations`參數。 如果附加成功，便會取用的最小保留區域，其可保留資料，而且該保留區域將會從集合移除。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.FileRecordSequence.Flush%2A>方法。</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含應透過這個記錄的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個引數超出範圍。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>不是由此記錄順序所建立..."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  id: Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將記錄檔記錄寫入<xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>，使用先前在順序中保留的空間。 這個方法無法被繼承。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       附加的記錄將會取用先前所保留，使用所指定的保留區的空間`reservations`參數。 如果附加成功，便會取用的最小保留區域，其可保留資料，而且該保留區域將會從集合移除。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.FileRecordSequence.Flush%2A>方法。</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber Append (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含應透過這個記錄的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.FileRecordSequence.Append*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個引數超出範圍。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>不是由此記錄順序所建立..."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber
  id: BaseSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BaseSequenceNumber
  nameWithType: FileRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.BaseSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得在目前的第一個有效記錄的序號<xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>。"
  remarks: "有效的序號會大於或等於 BaseSequenceNumber，且小於<xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A>.</xref:System.IO.Log.FileRecordSequence.LastSequenceNumber%2A> 其他所有序號都全都無效。       可以變更這個屬性的值，藉由呼叫<xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>或<xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A>方法。</xref:System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber%2A> </xref:System.IO.Log.FileRecordSequence.WriteRestartArea%2A>"
  example:
  - "The following example shows using BaseSequenceNumber in a loop:  \n  \n [!code-vb[IRecordSequence#2](~/add/codesnippet/visualbasic/p-system.io.log.filereco_1.vb)]\n [!code-cs[IRecordSequence#2](~/add/codesnippet/csharp/p-system.io.log.filereco_1.cs)]"
  syntax:
    content: public System.IO.Log.SequenceNumber BaseSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "對應中的有效記錄的最小序號<xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>。"
  overload: System.IO.Log.FileRecordSequence.BaseSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始執行非同步的附加作業。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.FileRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.FileRecordSequence.Flush%2A>方法。</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步的附加，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個引數超出範圍。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始執行非同步的附加作業。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.FileRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.FileRecordSequence.Flush%2A>方法。</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步的附加，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個引數超出範圍。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始執行非同步的附加作業使用先前在順序中保留的空間。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.FileRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       附加的記錄將會取用先前所保留，使用所指定的保留區的空間`reservations`參數。 如果附加成功，便會取用的最小保留區域，其可保留資料，而且該保留區域將會從集合移除。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.FileRecordSequence.Flush%2A>方法。</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含應透過這個記錄的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步的附加，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個引數超出範圍。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>不是由此記錄順序所建立。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始執行非同步的附加作業使用先前在順序中保留的空間。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.FileRecordSequence.EndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.FileRecordSequence.EndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       附加的記錄將會取用先前所保留，使用所指定的保留區的空間`reservations`參數。 如果附加成功，便會取用的最小保留區域，其可保留資料，而且該保留區域將會從集合移除。       通常，這個方法已寫入記錄前完成。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.FileRecordSequence.Flush%2A>方法。</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public IAsyncResult BeginAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含應透過這個記錄的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步的附加，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個引數超出範圍。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>不是由此記錄順序所建立。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  id: BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始非同步的清除作業，使用先前在順序中保留的空間。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>目前的方法來傳回<xref:System.IO.Log.FileRecordSequence.EndFlush%2A>方法，以確保清除完成，並適當地釋放資源。</xref:System.IO.Log.FileRecordSequence.EndFlush%2A> </xref:System.IAsyncResult> 如果在非同步清除期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.FileRecordSequence.EndFlush%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndFlush%2A>       呼叫這個方法可確保所有記錄已附加至<xref:System.IO.Log.FileRecordSequence>永久寫入。</xref:System.IO.Log.FileRecordSequence>       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 非同步清除要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致擲回例外狀況時<xref:System.IO.Log.FileRecordSequence.EndFlush%2A>方法呼叫。</xref:System.IO.Log.FileRecordSequence.EndFlush%2A>"
  syntax:
    content: public IAsyncResult BeginFlush (System.IO.Log.SequenceNumber sequenceNumber, AsyncCallback callback, object state);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "必須寫入之最新記錄的序號。 如果<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>無效，則必須寫入所有的記錄。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，排清完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可從其他要求中辨別這個特定非同步清除要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，表示非同步排清作業可能還在擱置中。</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "一或多個引數無效。       <code>sequenceNumber</code>無效，無法對此順序。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "清除資料時發生 I/O 錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始非同步的保留和附加作業。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       指定的保留區會加入至提供的保留區集合中的不可部分完成的作業與記錄附加作業。 如果附加失敗，則會不保留任何空間。       一般來說，這個方法可能會完成之前已寫入記錄。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.FileRecordSequence.Flush%2A>方法。</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>方法呼叫。</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要建立保留項目中的保留項目集合。"
    - id: reservations
      type: System.Int64[]
      description: "要進行，以位元組為單位的保留區。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表這個非同步作業，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個引數超出範圍。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>不是由此記錄順序所建立。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  id: BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始非同步的保留和附加作業。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>方法，以確定附加作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A> </xref:System.IAsyncResult> 如果在非同步附加期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       指定的保留區會加入至提供的保留區集合中的不可部分完成的作業與記錄附加作業。 如果附加失敗，則會不保留任何空間。       一般來說，這個方法可能會完成之前已寫入記錄。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.FileRecordSequence.Flush%2A>方法。</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>方法呼叫。</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public IAsyncResult BeginReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要建立保留項目中的保留項目集合。"
    - id: reservations
      type: System.Int64[]
      description: "要進行，以位元組為單位的保留區。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，在附加完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步附加要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表這個非同步作業，可能還在暫止。</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個引數超出範圍。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>不是由此記錄順序所建立。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始執行非同步的重新啟動區域寫入作業，使用先前在順序中保留的空間。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>方法，以確定重新啟動區域寫入作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> 如果執行非同步的重新啟動區域寫入作業期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       當作業成功完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。       如果<xref:System.IO.Log.ReservationCollection>指定，則寫入重新啟動區域將會取用先前所保留，使用包含在集合中的保留區的空間。</xref:System.IO.Log.ReservationCollection> 如果此方法成功，便會取用的最小保留區，其可保留資料，而且該保留區將會從集合移除。       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>方法呼叫。</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含適用於此重新啟動區域的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，重新啟動區域寫入完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步重新啟動區域寫入要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表非同步重新啟動區域寫入作業，可能還在擱置中。</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>不是介於這個順序的基底序號和最後一個序號之間。       -或者-新的或現有封存結尾或作用中記錄的基底無效。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>不是由此記錄順序所建立。       -或-<code>newBaseSeqNum</code>對此順序無效。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  id: BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "開始執行非同步的重新啟動區域寫入作業，使用先前在順序中保留的空間。 這個方法無法被繼承。"
  remarks: "您應該傳遞<xref:System.IAsyncResult>由這個方法以傳回<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>方法，以確定重新啟動區域寫入作業已完成，而且可以適當地釋放資源。</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A> </xref:System.IAsyncResult> 如果執行非同步的重新啟動區域寫入作業期間發生錯誤，例外狀況才會擲回直到<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>方法呼叫<xref:System.IAsyncResult>這個方法所傳回。</xref:System.IAsyncResult> </xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>       中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       當作業成功完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。       如果<xref:System.IO.Log.ReservationCollection>指定，則寫入重新啟動區域將會取用先前所保留，使用包含在集合中的保留區的空間。</xref:System.IO.Log.ReservationCollection> 如果此方法成功，便會取用的最小保留區，其可保留資料，而且該保留區將會從集合移除。       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>方法呼叫。</xref:System.IO.Log.FileRecordSequence.EndWriteRestartArea%2A>"
  syntax:
    content: public IAsyncResult BeginWriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservation, AsyncCallback callback, object state);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    - id: reservation
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含適用於此重新啟動區域的保留。"
    - id: callback
      type: System.AsyncCallback
      description: "選擇性的非同步回呼，重新啟動區域寫入完成時呼叫。"
    - id: state
      type: System.Object
      description: "使用者提供的物件，可區別這個特定非同步重新啟動區域寫入要求與其他要求。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表非同步重新啟動區域寫入作業，可能還在擱置中。</xref:System.IAsyncResult>"
  overload: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>不是介於這個順序的基底序號和最後一個序號之間。       -或者-新的或現有封存結尾或作用中記錄的基底無效。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>不是由此記錄順序所建立。       -或-<code>newBaseSeqNum</code>對此順序無效。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection
  id: CreateReservationCollection
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: CreateReservationCollection()
  nameWithType: FileRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.FileRecordSequence.CreateReservationCollection()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "建立新<xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>。 這個方法無法被繼承。"
  syntax:
    content: public System.IO.Log.ReservationCollection CreateReservationCollection ();
    parameters: []
    return:
      type: System.IO.Log.ReservationCollection
      description: "新建立<xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>。"
  overload: System.IO.Log.FileRecordSequence.CreateReservationCollection*
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Dispose
  id: Dispose
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Dispose()
  nameWithType: FileRecordSequence.Dispose()
  fullName: System.IO.Log.FileRecordSequence.Dispose()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "立即釋放物件所使用的 unmanaged 的資源。"
  syntax:
    content: public void Dispose ();
    parameters: []
  overload: System.IO.Log.FileRecordSequence.Dispose*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "清除資料時發生 I/O 錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)
  id: EndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "結束執行非同步的附加作業。 這個方法無法被繼承。"
  remarks: "這個方法會封鎖，直到 I/O 作業完成為止。 EndAppend 呼叫時，就會顯示在非同步寫入要求，例如磁碟失敗期間，在 I/O 要求期間發生的錯誤。       必須正好一次呼叫此方法，在每個<xref:System.IAsyncResult>傳回<xref:System.IO.Log.FileRecordSequence.BeginAppend%2A>方法。</xref:System.IO.Log.FileRecordSequence.BeginAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未處理的非同步 I/O 要求的參考。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.FileRecordSequence.EndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>不正確。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>已經呼叫這項非同步作業。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)
  id: EndFlush(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndFlush(IAsyncResult)
  nameWithType: FileRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndFlush(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "結束非同步的清除作業。 這個方法無法被繼承。"
  remarks: "這個方法會封鎖，直到 I/O 作業完成為止。 EndFlush 呼叫時，就會顯示在非同步清除要求，例如磁碟失敗期間，在 I/O 要求期間發生的錯誤。       必須正好一次呼叫此方法，在每個<xref:System.IAsyncResult>傳回<xref:System.IO.Log.FileRecordSequence.BeginFlush%2A>方法。</xref:System.IO.Log.FileRecordSequence.BeginFlush%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndFlush (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未處理的非同步 I/O 要求的參考。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後一筆寫入之記錄序號。"
  overload: System.IO.Log.FileRecordSequence.EndFlush*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>不正確。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>已經呼叫這項非同步作業。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  id: EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndReserveAndAppend(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "結束執行非同步的保留和附加作業。 這個方法無法被繼承。"
  remarks: "這個方法會封鎖，直到 I/O 作業完成為止。 EndReserveAndAppend 呼叫時，就會顯示在非同步寫入要求，例如磁碟失敗期間，在 I/O 要求期間發生的錯誤。       必須正好一次呼叫此方法，在每個<xref:System.IAsyncResult>傳回<xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A>方法。</xref:System.IO.Log.FileRecordSequence.BeginReserveAndAppend%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndReserveAndAppend (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未處理的非同步 I/O 要求的參考。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.FileRecordSequence.EndReserveAndAppend*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>不正確。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>已經呼叫這項非同步作業。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  id: EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: FileRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndWriteRestartArea(IAsyncResult)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "結束執行非同步的重新啟動區域寫入作業。 這個方法無法被繼承。"
  remarks: "這個方法會封鎖，直到 I/O 作業完成為止。 EndWriteRestartArea 呼叫時，就會顯示在非同步寫入要求，例如磁碟失敗期間，在 I/O 要求期間發生的錯誤。       必須正好一次呼叫此方法，在每個<xref:System.IAsyncResult>傳回<xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A>方法。</xref:System.IO.Log.FileRecordSequence.BeginWriteRestartArea%2A> </xref:System.IAsyncResult>"
  syntax:
    content: public System.IO.Log.SequenceNumber EndWriteRestartArea (IAsyncResult result);
    parameters:
    - id: result
      type: System.IAsyncResult
      description: "未處理的非同步 I/O 要求的參考。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "寫入之記錄序號。"
  overload: System.IO.Log.FileRecordSequence.EndWriteRestartArea*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>result</code>不正確。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref uid=&quot;langword_csharp_End&quot; name=&quot;End&quot; href=&quot;&quot;></xref>已經呼叫這項非同步作業。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Flush
  id: Flush
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Flush()
  nameWithType: FileRecordSequence.Flush()
  fullName: System.IO.Log.FileRecordSequence.Flush()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "確定已寫入所有附加的記錄。 這個方法無法被繼承。"
  remarks: "呼叫這個方法可確保所有記錄已附加至<xref:System.IO.Log.FileRecordSequence>已永久寫入。</xref:System.IO.Log.FileRecordSequence>"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush ();
    parameters: []
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後一筆寫入之記錄序號。"
  overload: System.IO.Log.FileRecordSequence.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "清除資料時發生 I/O 錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)
  id: Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: Flush(SequenceNumber)
  nameWithType: FileRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.Flush(SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "確定已寫入所有附加的記錄。 這個方法無法被繼承。"
  remarks: "呼叫這個方法可以確保所有記錄最多內含指定的序號有已永久寫入。"
  syntax:
    content: public System.IO.Log.SequenceNumber Flush (System.IO.Log.SequenceNumber sequenceNumber);
    parameters:
    - id: sequenceNumber
      type: System.IO.Log.SequenceNumber
      description: "必須寫入之最新記錄的序號。 如果這個<xref href=&quot;System.IO.Log.SequenceNumber&quot;></xref>無效，則必須寫入所有的記錄。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "最後一筆寫入之記錄序號。"
  overload: System.IO.Log.FileRecordSequence.Flush*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>sequenceNumber</code>不是介於這個順序的基底序號和最後一個序號之間。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>sequenceNumber</code>無效，無法對此順序。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "清除資料時發生 I/O 錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber
  id: LastSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: LastSequenceNumber
  nameWithType: FileRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.LastSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得序號大於最後一筆附加的記錄。"
  remarks: "此屬性包含保證似乎較大序號的最後序號附加記錄。 有效的序號會大於或等於<xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A>且小於 LastSequenceNumber。</xref:System.IO.Log.FileRecordSequence.BaseSequenceNumber%2A> 其他所有序號都全都無效。"
  syntax:
    content: public System.IO.Log.SequenceNumber LastSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "大於最後一筆附加的記錄序號。"
  overload: System.IO.Log.FileRecordSequence.LastSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength
  id: MaximumRecordLength
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: MaximumRecordLength
  nameWithType: FileRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.FileRecordSequence.MaximumRecordLength
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得可以附加或讀取此順序，以位元組為單位的最大記錄大小。"
  syntax:
    content: public long MaximumRecordLength { get; }
    return:
      type: System.Int64
      description: "附加或讀取此順序，以位元組為單位的最大記錄大小。"
  overload: System.IO.Log.FileRecordSequence.MaximumRecordLength*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  id: ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "序列中傳回之記錄的可列舉集合。 這個方法無法被繼承。"
  remarks: "這個方法會傳回序列中之記錄的可列舉集合。 列舉的記錄順序取決於值`logRecordEnum`參數。"
  example:
  - "The following example shows how you can use this method to read the records in a log sequence.  \n  \n [!code-vb[IRecordSequence#2](~/add/codesnippet/visualbasic/5d31b2a4-d7cf-41cf-80bb-_1.vb)]\n [!code-cs[IRecordSequence#2](~/add/codesnippet/csharp/5d31b2a4-d7cf-41cf-80bb-_1.cs)]"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadLogRecords (System.IO.Log.SequenceNumber start, System.IO.Log.LogRecordEnumeratorType logRecordEnum);
    parameters:
    - id: start
      type: System.IO.Log.SequenceNumber
      description: "開始讀取的第一個記錄序號。"
    - id: logRecordEnum
      type: System.IO.Log.LogRecordEnumeratorType
      description: "有效<xref href=&quot;System.IO.Log.LogRecordEnumeratorType&quot;></xref>值，指定應該讀取哪一筆記錄中的方式 （也就是，向前或向後） <xref href=&quot;System.IO.Log.LogRecordSequence&quot;> </xref>。"
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "記錄順序中的可列舉集合。"
  overload: System.IO.Log.FileRecordSequence.ReadLogRecords*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個引數超出範圍。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯寫存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "記錄順序已損毀。       -或者-記錄已寫入的記錄順序版本不相容。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "列舉已經結束。       -或者-列舉尚未啟動。 呼叫<xref:System.Collections.IEnumerator.MoveNext*>必須設法。</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas
  id: ReadRestartAreas
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReadRestartAreas()
  nameWithType: FileRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.FileRecordSequence.ReadRestartAreas()
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "傳回序列中的重新啟動區域的可列舉集合。 這個方法無法被繼承。"
  remarks: "重新啟動區域會列舉在反向序列數字的順序，也就是從最低序號最高的序號。 只重新啟動區域的最後一個序號之間序號和要列舉的基底序號。"
  syntax:
    content: public System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord> ReadRestartAreas ();
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
      description: "序列中的重新啟動區域的可列舉集合。"
  overload: System.IO.Log.FileRecordSequence.ReadRestartAreas*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯寫存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "記錄順序已損毀。       -或者-記錄已寫入的記錄順序版本不相容。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "列舉已經結束。       -或者-列舉尚未啟動。 呼叫<xref:System.Collections.IEnumerator.MoveNext*>必須設法。</xref:System.Collections.IEnumerator.MoveNext*>"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "自動建立單一保留區，並將記錄附加至順序。 這個方法無法被繼承。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       指定的保留區會加入至提供的保留區集合中的不可部分完成的作業與記錄附加作業。 如果附加失敗，則會不保留任何空間。       一般來說，這個方法可能會完成之前已寫入記錄。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.FileRecordSequence.Flush%2A>方法。</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (ArraySegment<byte> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref> ，其中包含要建立保留項目中的集合。"
    - id: reservations
      type: System.Int64[]
      description: "要進行，以位元組為單位的保留區。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.FileRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個引數超出範圍。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>不是由此記錄順序所建立..."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  id: ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "自動建立單一保留區，並將記錄附加至順序。 這個方法無法被繼承。"
  remarks: "中所含資料`data`參數將串連至單一位元組陣列，以便附加成記錄。 不過，不會讀取記錄時，將資料分割回陣列區段。       指定的保留區會加入至提供的保留區集合中的不可部分完成的作業與記錄附加作業。 如果附加失敗，則會不保留任何空間。       一般來說，這個方法可能會完成之前已寫入記錄。 若要確定已寫入某筆記錄，也可以指定<xref:System.IO.Log.RecordAppendOptions>旗標使用`recordAppendOptions`參數或呼叫<xref:System.IO.Log.FileRecordSequence.Flush%2A>方法。</xref:System.IO.Log.FileRecordSequence.Flush%2A> </xref:System.IO.Log.RecordAppendOptions>"
  syntax:
    content: public System.IO.Log.SequenceNumber ReserveAndAppend (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber nextUndoRecord, System.IO.Log.SequenceNumber previousRecord, System.IO.Log.RecordAppendOptions recordAppendOptions, System.IO.Log.ReservationCollection reservationCollection, long[] reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: nextUndoRecord
      type: System.IO.Log.SequenceNumber
      description: "使用者指定的順序的下一個記錄序號。"
    - id: previousRecord
      type: System.IO.Log.SequenceNumber
      description: "之前的順序的下一個記錄序號。"
    - id: recordAppendOptions
      type: System.IO.Log.RecordAppendOptions
      description: "有效值<xref href=&quot;System.IO.Log.RecordAppendOptions&quot;></xref>指定寫入資料的方式。"
    - id: reservationCollection
      type: System.IO.Log.ReservationCollection
      description: "要建立保留項目中的保留項目集合。"
    - id: reservations
      type: System.Int64[]
      description: "要進行，以位元組為單位的保留區。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "附加之記錄序號。"
  overload: System.IO.Log.FileRecordSequence.ReserveAndAppend*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "有一或多個引數超出範圍。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>不是由此記錄順序所建立..."
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.ReservedBytes
  id: ReservedBytes
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: ReservedBytes
  nameWithType: FileRecordSequence.ReservedBytes
  fullName: System.IO.Log.FileRecordSequence.ReservedBytes
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得已保留的位元組總數。"
  syntax:
    content: public long ReservedBytes { get; }
    return:
      type: System.Int64
      description: "在這個記錄順序中所做的所有保留區的大小總計。"
  overload: System.IO.Log.FileRecordSequence.ReservedBytes*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber
  id: RestartSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: RestartSequenceNumber
  nameWithType: FileRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.RestartSequenceNumber
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得最近寫入的重新啟動區域的序號。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 常見的記錄檔系統 (CLFS) 會維護兩個重新啟動區域，以保證確定至少一個有效區域永遠可供使用。 當需要復原時，CLFS 會讀取其重新啟動區域和所有資料從最後一個檢查點作業。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。"
  syntax:
    content: public System.IO.Log.SequenceNumber RestartSequenceNumber { get; }
    return:
      type: System.IO.Log.SequenceNumber
      description: "重新啟動區域的最近寫入的序號。"
  overload: System.IO.Log.FileRecordSequence.RestartSequenceNumber*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.RetryAppend
  id: RetryAppend
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: RetryAppend
  nameWithType: FileRecordSequence.RetryAppend
  fullName: System.IO.Log.FileRecordSequence.RetryAppend
  type: Property
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "取得或設定值，指出是否將附加的記錄檔已滿時自動重試。"
  remarks: "如果這個屬性的值為`true`，和<xref:System.IO.Log.FileRecordSequence.Append%2A>呼叫失敗，因為在序列中沒有足夠的空間，記錄順序將會嘗試釋放空間，並重試附加。</xref:System.IO.Log.FileRecordSequence.Append%2A>"
  syntax:
    content: public bool RetryAppend { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果附加的記錄檔已滿; 自動重試否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.Log.FileRecordSequence.RetryAppend*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後存取此屬性。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.TailPinned
  id: TailPinned
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: TailPinned
  nameWithType: FileRecordSequence.TailPinned
  fullName: System.IO.Log.FileRecordSequence.TailPinned
  type: Event
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "發生於在記錄順序判斷必須向前移動結尾。 這個方法無法被繼承。"
  remarks: "您可以引發事件時，記錄順序已用盡空間。 這個事件一經引發，結尾順序 （也就是基底序號） 往前移動以釋放空間。"
  syntax:
    content: public event EventHandler<System.IO.Log.TailPinnedEventArgs> TailPinned;
    return:
      type: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  id: WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將重新啟動區域寫入<xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>。 這個方法無法被繼承。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 當需要復原時，您可以讀取重新啟動區域，並從最後一個檢查點作業擷取所有資料。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。       可以使用來讀取重新啟動區域<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       位元組陣列區段中的資料將串連至單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將重新啟動區域寫入<xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>。 這個方法無法被繼承。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 當需要復原時，您可以讀取重新啟動區域，並從最後一個檢查點作業擷取所有資料。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。       可以使用來讀取重新啟動區域<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       位元組陣列區段中的資料將串連至單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將重新啟動區域寫入<xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>。 這個方法無法被繼承。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 當需要復原時，您可以讀取重新啟動區域，並從最後一個檢查點作業擷取所有資料。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。       可以使用來讀取重新啟動區域<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       當寫入重新啟動區域時，位元組陣列區段中的資料會串連成單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。       這個方法順利完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>不是介於這個順序的基底序號和最後一個序號之間。       -或者-新的或現有封存結尾或作用中記錄的基底無效。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>無效，無法對此順序。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將重新啟動區域寫入<xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>。 這個方法無法被繼承。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 當需要復原時，您可以讀取重新啟動區域，並從最後一個檢查點作業擷取所有資料。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。       可以使用來讀取重新啟動區域<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       當寫入重新啟動區域時，位元組陣列區段中的資料會串連成單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。       這個方法順利完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>不是介於這個順序的基底序號和最後一個序號之間。       -或者-新的或現有封存結尾或作用中記錄的基底無效。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>newBaseSeqNum</code>無效，無法對此順序。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將重新啟動區域寫入<xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>。 這個方法無法被繼承。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 當需要復原時，您可以讀取重新啟動區域，並從最後一個檢查點作業擷取所有資料。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。       可以使用來讀取重新啟動區域<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       當寫入重新啟動區域時，位元組陣列區段中的資料會串連成單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。       如果已指定保留區，寫入的重新啟動區域將會取用先前所保留，使用包含在集合中的保留區的空間。 如果此方法成功，便會取用的最小保留區，可以包含的資料，而且該保留區將會從集合移除。       這個方法順利完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>方法呼叫。</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (ArraySegment<byte> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.ArraySegment{System.Byte}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含適用於此重新啟動區域的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>不是介於這個順序的基底序號和最後一個序號之間。       -或者-新的或現有封存結尾或作用中記錄的基底無效。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>不是由此記錄順序所建立。       -或-<code>newBaseSeqNum</code>對此順序無效。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  id: WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  langs:
  - csharp
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  type: Method
  assemblies:
  - System.IO.Log
  namespace: System.IO.Log
  summary: "將重新啟動區域寫入<xref href=&quot;System.IO.Log.FileRecordSequence&quot;> </xref>。 這個方法無法被繼承。"
  remarks: "重新啟動區域可用來暫時儲存包含用戶端的最後一個檢查點作業的資訊。 當需要復原時，您可以讀取重新啟動區域，並從最後一個檢查點作業擷取所有資料。 此資料會初始化異動資料表、 中途分頁資料表和開啟檔案資料表，好讓它們可用於復原程序。       可以使用來讀取重新啟動區域<xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>方法。</xref:System.IO.Log.FileRecordSequence.ReadRestartAreas%2A>       當寫入重新啟動區域時，位元組陣列區段中的資料會串連成單一位元組陣列，以便附加成記錄。 將資料分割回陣列區段中，在讀取重新啟動區域時，會不進行任何佈建。       如果已指定保留區，寫入的重新啟動區域將會取用先前所保留，使用包含在集合中的保留區的空間。 如果此方法成功，便會取用的最小保留區，可以包含的資料，而且該保留區將會從集合移除。       這個方法順利完成時，基底序號已經更新。 所有記錄的序號小於新基底序號都無法存取。       如果已經處置了記錄順序，或是您傳遞了無效的引數，會擲回例外狀況立即在此作業。 在非同步附加要求，例如，磁碟失敗期間，在 I/O 要求期間發生的錯誤會導致在時擲回的例外狀況<xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>方法呼叫。</xref:System.IO.Log.FileRecordSequence.EndReserveAndAppend%2A>"
  syntax:
    content: public System.IO.Log.SequenceNumber WriteRestartArea (System.Collections.Generic.IList<ArraySegment<byte>> data, System.IO.Log.SequenceNumber newBaseSeqNum, System.IO.Log.ReservationCollection reservations);
    parameters:
    - id: data
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "位元組陣列區段的即將串連並附加成記錄清單。"
    - id: newBaseSeqNum
      type: System.IO.Log.SequenceNumber
      description: "新基底序號。 指定的序號必須大於或等於目前基底序號。"
    - id: reservations
      type: System.IO.Log.ReservationCollection
      description: "A <xref href=&quot;System.IO.Log.ReservationCollection&quot;> </xref>其中包含適用於此重新啟動區域的保留。"
    return:
      type: System.IO.Log.SequenceNumber
      description: "序號寫入之重新啟動區域。"
  overload: System.IO.Log.FileRecordSequence.WriteRestartArea*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "一或多個引數的<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>newBaseSeqNum</code>不是介於這個順序的基底序號和最後一個序號之間。       -或者-新的或現有封存結尾或作用中記錄的基底無效。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>reservations</code>不是由此記錄順序所建立。       -或-<code>newBaseSeqNum</code>對此順序無效。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "記錄順序是以唯讀存取開啟，無法執行操作。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "無法執行要求，因為發生意外的 I/O 例外狀況。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "已在處置序列之後呼叫的方法。"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "沒有足夠的記憶體可以繼續執行程式。"
  - type: System.IO.Log.SequenceFullException
    commentId: T:System.IO.Log.SequenceFullException
    description: "記錄順序已滿。"
  - type: System.IO.Log.ReservationNotFoundException
    commentId: T:System.IO.Log.ReservationNotFoundException
    description: "沒有夠大，無法容納的保留區<code> data </code>位於<code> reservations </code>。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.OutOfMemoryException
  isExternal: true
  name: System.OutOfMemoryException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.IO.Log.SequenceFullException
  parent: System.IO.Log
  isExternal: false
  name: SequenceFullException
  nameWithType: SequenceFullException
  fullName: System.IO.Log.SequenceFullException
- uid: System.IO.Log.ReservationNotFoundException
  parent: System.IO.Log
  isExternal: false
  name: ReservationNotFoundException
  nameWithType: ReservationNotFoundException
  fullName: System.IO.Log.ReservationNotFoundException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence(String)
  nameWithType: FileRecordSequence.FileRecordSequence(String)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence(String,FileAccess)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.Log.FileRecordSequence.#ctor(System.String,System.IO.FileAccess,System.Int32)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence(String,FileAccess,Int32)
  nameWithType: FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
  fullName: System.IO.Log.FileRecordSequence.FileRecordSequence(String,FileAccess,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber(SequenceNumber)
  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber(SequenceNumber)
- uid: System.IO.Log.SequenceNumber
  parent: System.IO.Log
  isExternal: false
  name: SequenceNumber
  nameWithType: SequenceNumber
  fullName: System.IO.Log.SequenceNumber
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.ArraySegment{System.Byte}
  parent: System
  isExternal: true
  name: ArraySegment<Byte>
  nameWithType: ArraySegment<Byte>
  fullName: System.ArraySegment<System.Byte>
  spec.csharp:
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.RecordAppendOptions
  parent: System.IO.Log
  isExternal: false
  name: RecordAppendOptions
  nameWithType: RecordAppendOptions
  fullName: System.IO.Log.RecordAppendOptions
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions)
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  isExternal: true
  name: IList<ArraySegment<Byte>>
  nameWithType: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    nameWithType: IList
    fullName: IList<System.ArraySegment<System.Byte>>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    nameWithType: ArraySegment
    fullName: ArraySegment<System.Byte>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte
  - name: '>'
    nameWithType: '>'
    fullName: '>'
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.FileRecordSequence.Append(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.ReservationCollection
  parent: System.IO.Log
  isExternal: false
  name: ReservationCollection
  nameWithType: ReservationCollection
  fullName: System.IO.Log.ReservationCollection
- uid: System.IO.Log.FileRecordSequence.Append(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  nameWithType: FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.Append(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection)
- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: FileRecordSequence.BaseSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginFlush(System.IO.Log.SequenceNumber,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginFlush(SequenceNumber,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginFlush(SequenceNumber,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.Int64[]
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64[]
  spec.csharp:
  - uid: System.Int64
    name: Int64
    nameWithType: Int64
    fullName: Int64[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[],System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[],AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection,System.AsyncCallback,System.Object)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  nameWithType: FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
  fullName: System.IO.Log.FileRecordSequence.BeginWriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection,AsyncCallback,Object)
- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: CreateReservationCollection()
  nameWithType: FileRecordSequence.CreateReservationCollection()
  fullName: System.IO.Log.FileRecordSequence.CreateReservationCollection()
- uid: System.IO.Log.FileRecordSequence.Dispose
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Dispose()
  nameWithType: FileRecordSequence.Dispose()
  fullName: System.IO.Log.FileRecordSequence.Dispose()
- uid: System.IO.Log.FileRecordSequence.EndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndAppend(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.EndFlush(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndFlush(IAsyncResult)
  nameWithType: FileRecordSequence.EndFlush(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndFlush(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndReserveAndAppend(IAsyncResult)
  nameWithType: FileRecordSequence.EndReserveAndAppend(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndReserveAndAppend(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea(System.IAsyncResult)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndWriteRestartArea(IAsyncResult)
  nameWithType: FileRecordSequence.EndWriteRestartArea(IAsyncResult)
  fullName: System.IO.Log.FileRecordSequence.EndWriteRestartArea(IAsyncResult)
- uid: System.IO.Log.FileRecordSequence.Flush
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Flush()
  nameWithType: FileRecordSequence.Flush()
  fullName: System.IO.Log.FileRecordSequence.Flush()
- uid: System.IO.Log.FileRecordSequence.Flush(System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Flush(SequenceNumber)
  nameWithType: FileRecordSequence.Flush(SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.Flush(SequenceNumber)
- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: FileRecordSequence.LastSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.LastSequenceNumber
- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: FileRecordSequence.MaximumRecordLength
  fullName: System.IO.Log.FileRecordSequence.MaximumRecordLength
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.Log.FileRecordSequence.ReadLogRecords(System.IO.Log.SequenceNumber,System.IO.Log.LogRecordEnumeratorType)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  nameWithType: FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
  fullName: System.IO.Log.FileRecordSequence.ReadLogRecords(SequenceNumber,LogRecordEnumeratorType)
- uid: System.Collections.Generic.IEnumerable{System.IO.Log.LogRecord}
  parent: System.Collections.Generic
  isExternal: true
  name: IEnumerable<LogRecord>
  nameWithType: IEnumerable<LogRecord>
  fullName: System.Collections.Generic.IEnumerable<System.IO.Log.LogRecord>
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    nameWithType: IEnumerable
    fullName: IEnumerable<System.IO.Log.LogRecord>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.LogRecord
    name: LogRecord
    nameWithType: LogRecord
    fullName: LogRecord
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.LogRecordEnumeratorType
  parent: System.IO.Log
  isExternal: false
  name: LogRecordEnumeratorType
  nameWithType: LogRecordEnumeratorType
  fullName: System.IO.Log.LogRecordEnumeratorType
- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadRestartAreas()
  nameWithType: FileRecordSequence.ReadRestartAreas()
  fullName: System.IO.Log.FileRecordSequence.ReadRestartAreas()
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(ArraySegment<Byte>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.SequenceNumber,System.IO.Log.RecordAppendOptions,System.IO.Log.ReservationCollection,System.Int64[])
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  nameWithType: FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
  fullName: System.IO.Log.FileRecordSequence.ReserveAndAppend(IList<ArraySegment<Byte>>,SequenceNumber,SequenceNumber,RecordAppendOptions,ReservationCollection,Int64[])
- uid: System.IO.Log.FileRecordSequence.ReservedBytes
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: FileRecordSequence.ReservedBytes
  fullName: System.IO.Log.FileRecordSequence.ReservedBytes
- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: FileRecordSequence.RestartSequenceNumber
  fullName: System.IO.Log.FileRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.FileRecordSequence.RetryAppend
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: FileRecordSequence.RetryAppend
  fullName: System.IO.Log.FileRecordSequence.RetryAppend
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.Log.FileRecordSequence.TailPinned
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: TailPinned
  nameWithType: FileRecordSequence.TailPinned
  fullName: System.IO.Log.FileRecordSequence.TailPinned
- uid: System.EventHandler{System.IO.Log.TailPinnedEventArgs}
  parent: System
  isExternal: true
  name: EventHandler<TailPinnedEventArgs>
  nameWithType: EventHandler<TailPinnedEventArgs>
  fullName: System.EventHandler<System.IO.Log.TailPinnedEventArgs>
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    nameWithType: EventHandler
    fullName: EventHandler<System.IO.Log.TailPinnedEventArgs>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.IO.Log.TailPinnedEventArgs
    name: TailPinnedEventArgs
    nameWithType: TailPinnedEventArgs
    fullName: TailPinnedEventArgs
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte})
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.ArraySegment{System.Byte},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(ArraySegment<Byte>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.IO.Log.SequenceNumber,System.IO.Log.ReservationCollection)
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  nameWithType: FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
  fullName: System.IO.Log.FileRecordSequence.WriteRestartArea(IList<ArraySegment<Byte>>,SequenceNumber,ReservationCollection)
- uid: System.IO.Log.FileRecordSequence.#ctor*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: FileRecordSequence
  nameWithType: FileRecordSequence.FileRecordSequence
- uid: System.IO.Log.FileRecordSequence.AdvanceBaseSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: AdvanceBaseSequenceNumber
  nameWithType: FileRecordSequence.AdvanceBaseSequenceNumber
- uid: System.IO.Log.FileRecordSequence.Append*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Append
  nameWithType: FileRecordSequence.Append
- uid: System.IO.Log.FileRecordSequence.BaseSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BaseSequenceNumber
  nameWithType: FileRecordSequence.BaseSequenceNumber
- uid: System.IO.Log.FileRecordSequence.BeginAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginAppend
  nameWithType: FileRecordSequence.BeginAppend
- uid: System.IO.Log.FileRecordSequence.BeginFlush*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginFlush
  nameWithType: FileRecordSequence.BeginFlush
- uid: System.IO.Log.FileRecordSequence.BeginReserveAndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginReserveAndAppend
  nameWithType: FileRecordSequence.BeginReserveAndAppend
- uid: System.IO.Log.FileRecordSequence.BeginWriteRestartArea*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: BeginWriteRestartArea
  nameWithType: FileRecordSequence.BeginWriteRestartArea
- uid: System.IO.Log.FileRecordSequence.CreateReservationCollection*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: CreateReservationCollection
  nameWithType: FileRecordSequence.CreateReservationCollection
- uid: System.IO.Log.FileRecordSequence.Dispose*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Dispose
  nameWithType: FileRecordSequence.Dispose
- uid: System.IO.Log.FileRecordSequence.EndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndAppend
  nameWithType: FileRecordSequence.EndAppend
- uid: System.IO.Log.FileRecordSequence.EndFlush*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndFlush
  nameWithType: FileRecordSequence.EndFlush
- uid: System.IO.Log.FileRecordSequence.EndReserveAndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndReserveAndAppend
  nameWithType: FileRecordSequence.EndReserveAndAppend
- uid: System.IO.Log.FileRecordSequence.EndWriteRestartArea*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: EndWriteRestartArea
  nameWithType: FileRecordSequence.EndWriteRestartArea
- uid: System.IO.Log.FileRecordSequence.Flush*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: Flush
  nameWithType: FileRecordSequence.Flush
- uid: System.IO.Log.FileRecordSequence.LastSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: LastSequenceNumber
  nameWithType: FileRecordSequence.LastSequenceNumber
- uid: System.IO.Log.FileRecordSequence.MaximumRecordLength*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: MaximumRecordLength
  nameWithType: FileRecordSequence.MaximumRecordLength
- uid: System.IO.Log.FileRecordSequence.ReadLogRecords*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadLogRecords
  nameWithType: FileRecordSequence.ReadLogRecords
- uid: System.IO.Log.FileRecordSequence.ReadRestartAreas*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReadRestartAreas
  nameWithType: FileRecordSequence.ReadRestartAreas
- uid: System.IO.Log.FileRecordSequence.ReserveAndAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReserveAndAppend
  nameWithType: FileRecordSequence.ReserveAndAppend
- uid: System.IO.Log.FileRecordSequence.ReservedBytes*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: ReservedBytes
  nameWithType: FileRecordSequence.ReservedBytes
- uid: System.IO.Log.FileRecordSequence.RestartSequenceNumber*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RestartSequenceNumber
  nameWithType: FileRecordSequence.RestartSequenceNumber
- uid: System.IO.Log.FileRecordSequence.RetryAppend*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: RetryAppend
  nameWithType: FileRecordSequence.RetryAppend
- uid: System.IO.Log.FileRecordSequence.WriteRestartArea*
  parent: System.IO.Log.FileRecordSequence
  isExternal: false
  name: WriteRestartArea
  nameWithType: FileRecordSequence.WriteRestartArea
