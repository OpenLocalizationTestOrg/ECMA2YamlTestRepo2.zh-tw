### YamlMime:ManagedReference
items:
- uid: System.Security.AccessControl.RegistrySecurity
  id: RegistrySecurity
  children:
  - System.Security.AccessControl.RegistrySecurity.#ctor
  - System.Security.AccessControl.RegistrySecurity.AccessRightType
  - System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  - System.Security.AccessControl.RegistrySecurity.AccessRuleType
  - System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  - System.Security.AccessControl.RegistrySecurity.AuditRuleType
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  - System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  - System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  langs:
  - csharp
  name: RegistrySecurity
  nameWithType: RegistrySecurity
  fullName: System.Security.AccessControl.RegistrySecurity
  type: Class
  summary: "代表登錄機碼的 Windows 存取控制安全性。 這個類別無法被繼承。"
  remarks: "RegistrySecurity 物件指定的登錄機碼的存取權限，也會指定如何稽核存取嘗試。 登錄機碼的存取權限會由每個存取規則的規則，以表示<xref:System.Security.AccessControl.RegistryAccessRule>物件。</xref:System.Security.AccessControl.RegistryAccessRule> 每個稽核規則由<xref:System.Security.AccessControl.RegistryAuditRule>物件。</xref:System.Security.AccessControl.RegistryAuditRule>       這會反映基礎的 Windows 安全性系統，其中每個安全性實體物件都有最多一個判別存取控制清單 (DACL) 控制存取受保護的物件，並最多一個系統存取控制清單 (SACL)，指定稽核的存取嘗試。 DACL，SACL 會排序清單的指定存取和稽核使用者和群組的存取控制項目 (ACE)。 A<xref:System.Security.AccessControl.RegistryAccessRule>或<xref:System.Security.AccessControl.RegistryAuditRule>物件可能代表一個以上的 ACE。</xref:System.Security.AccessControl.RegistryAuditRule> </xref:System.Security.AccessControl.RegistryAccessRule>      > [!NOTE] > Windows 存取控制安全性只能套用到登錄機碼。 它無法套用至個別的索引鍵/值組儲存在索引鍵。       RegistrySecurity <xref:System.Security.AccessControl.RegistryAccessRule>，和<xref:System.Security.AccessControl.RegistryAuditRule>類別隱藏 Acl 和 Ace 的實作詳細資料。</xref:System.Security.AccessControl.RegistryAuditRule> </xref:System.Security.AccessControl.RegistryAccessRule> 它們可讓您忽略十七不同的 ACE 類型，並正確地維護繼承和存取權限傳播的複雜性。 這些物件也為了避免下列常見的存取控制項錯誤:-建立具有 null DACL 的安全性描述元。 DACL 的 null 參考可讓任何使用者新增到物件，也有可能產生的阻絕服務攻擊的存取規則。 此外，新的 RegistrySecurity 物件一律會以空的 DACL，它會拒絕所有使用者的所有存取開頭。      -違反 Ace 的標準順序。 如果 DACL 中的 ACE 清單不會保持在標準順序，使用者可能會不小心指定存取受保護的物件。 比方說，拒絕的存取權限必須永遠出現之前允許的存取權限。 RegistrySecurity 物件會在內部維護正確的順序。      -管理安全性描述元旗標，它應該只資源管理員的控制下。      -建立無效的 ACE 旗標組合。      -管理繼承的 Ace。 繼承和傳用是由資源管理員，以回應變更您對存取和稽核規則處理。      -無意義的 Ace 只插入 Acl。       不支援.NET 安全性物件的唯一功能是危險的活動，應該避免的大部分應用程式開發人員，如下所示:-通常由資源管理員執行的低階工作。      -新增或移除存取控制項目不會維護標準順序的方式。       若要修改 Windows 登錄機碼的存取控制安全性，請使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName>方法來取得 RegistrySecurity 物件。</xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> 修改安全性物件，透過加入和移除規則，然後再使用<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>方法來重新附加它。</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>      > [!IMPORTANT] > 對 RegistrySecurity 物件進行的變更不會影響登錄機碼的存取層級直到您呼叫<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>將登錄機碼變更後的安全性物件的方法。</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>       若要從一個登錄機碼的存取控制安全性複製到另一個中，使用<xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName>方法來取得 RegistrySecurity 物件，表示第一個登錄機碼的存取和稽核規則，然後使用<xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>方法，以將這些規則指派給第二個登錄機碼。</xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> 您也可以指派規則給第二個登錄機碼<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=fullName>或<xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=fullName>採用 RegistrySecurity 物件參數的方法。</xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=fullName> </xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=fullName>       中的安全性描述元定義語言 (SDDL) 投資的使用者可以使用<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>方法，以設定的登錄機碼的存取規則和<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>方法，以取得字串，代表 SDDL 格式中的存取規則。</xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> 建議您不要開發新項目。"
  example:
  - "This section contains two code examples. The first example shows how compatible rules merge when added and removed, and the second shows how inheritance and propagation flags affect the addition and deletion of rules.  \n  \n Example 1  \n  \n The following code example shows how the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method removes rights from a compatible rule, and how the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method merges rights with compatible rules.  \n  \n The example creates a RegistrySecurity object and adds a rule that allows the current user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName> rights. The example then creates a rule that grants the user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>, with the same inheritance and propagation rights as the first rule, and uses the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method to remove this new rule from the RegistrySecurity object. <xref:System.Security.AccessControl.RegistryRights> is a constituent of <xref:System.Security.AccessControl.RegistryRights>, so it is removed from the compatible rule. The rules in the RegistrySecurity object are displayed, showing the remaining constituents of <xref:System.Security.AccessControl.RegistryRights>.  \n  \n The example code then calls the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method to merge the <xref:System.Security.AccessControl.RegistryRights> right back into the rule in the RegistrySecurity object.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. The second example in this section attaches a security object, and so do the examples in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> and <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/visualbasic/t-system.security.access_15_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/csharp/t-system.security.access_15_1.cs)]  \n  \n Example 2  \n  \n The following code example demonstrates access rules with inheritance and propagation. The example creates a RegistrySecurity object, then creates and adds two rules that have the <xref:System.Security.AccessControl.InheritanceFlags> flag. The first rule has no propagation flags, while the second has <xref:System.Security.AccessControl.PropagationFlags> and <xref:System.Security.AccessControl.PropagationFlags>.  \n  \n The program displays the rules in the RegistrySecurity object, and then uses the RegistrySecurity object to create a subkey. The program creates a child subkey and a grandchild subkey, then displays the security for each subkey. Finally, the program deletes the test keys.  \n  \n [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/add/codesnippet/visualbasic/t-system.security.access_15_2.vb)]\n [!code-cs[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/add/codesnippet/csharp/t-system.security.access_15_2.cs)]"
  syntax:
    content: 'public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity'
  inheritance:
  - System.Object
  - System.Security.AccessControl.ObjectSecurity
  - System.Security.AccessControl.CommonObjectSecurity
  - System.Security.AccessControl.NativeObjectSecurity
  implements: []
  inheritedMembers:
  - System.Security.AccessControl.CommonObjectSecurity.AddAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.AddAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.GetAccessRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.GetAuditRules(System.Boolean,System.Boolean,System.Type)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAccess(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.ModifyAudit(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleAll(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleAll(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.CommonObjectSecurity.ResetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAccessRule(System.Security.AccessControl.AccessRule)
  - System.Security.AccessControl.CommonObjectSecurity.SetAuditRule(System.Security.AccessControl.AuditRule)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.Runtime.InteropServices.SafeHandle,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.NativeObjectSecurity.Persist(System.String,System.Security.AccessControl.AccessControlSections,System.Object)
  - System.Security.AccessControl.ObjectSecurity.AccessRulesModified
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAccessRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesCanonical
  - System.Security.AccessControl.ObjectSecurity.AreAuditRulesProtected
  - System.Security.AccessControl.ObjectSecurity.AuditRulesModified
  - System.Security.AccessControl.ObjectSecurity.GetGroup(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetOwner(System.Type)
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm
  - System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm(System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.GroupModified
  - System.Security.AccessControl.ObjectSecurity.IsContainer
  - System.Security.AccessControl.ObjectSecurity.IsDS
  - System.Security.AccessControl.ObjectSecurity.IsSddlConversionSupported
  - System.Security.AccessControl.ObjectSecurity.ModifyAccessRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AccessRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.ModifyAuditRule(System.Security.AccessControl.AccessControlModification,System.Security.AccessControl.AuditRule,System.Boolean@)
  - System.Security.AccessControl.ObjectSecurity.OwnerModified
  - System.Security.AccessControl.ObjectSecurity.Persist(System.Boolean,System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.PurgeAccessRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.PurgeAuditRules(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.ReadLock
  - System.Security.AccessControl.ObjectSecurity.ReadUnlock
  - System.Security.AccessControl.ObjectSecurity.SetAccessRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetAuditRuleProtection(System.Boolean,System.Boolean)
  - System.Security.AccessControl.ObjectSecurity.SetGroup(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetOwner(System.Security.Principal.IdentityReference)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[])
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm(System.Byte[],System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String)
  - System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm(System.String,System.Security.AccessControl.AccessControlSections)
  - System.Security.AccessControl.ObjectSecurity.WriteLock
  - System.Security.AccessControl.ObjectSecurity.WriteUnlock
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.#ctor
  id: '#ctor'
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RegistrySecurity()
  nameWithType: RegistrySecurity.RegistrySecurity()
  fullName: System.Security.AccessControl.RegistrySecurity.RegistrySecurity()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "初始化的新執行個體<xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;></xref>類別具有預設值。"
  remarks: "新<xref:System.Security.AccessControl.RegistrySecurity>物件一律開頭空白的判別存取清單 (DACL)，它會拒絕所有使用者的所有存取。</xref:System.Security.AccessControl.RegistrySecurity>"
  syntax:
    content: public RegistrySecurity ();
    parameters: []
  overload: System.Security.AccessControl.RegistrySecurity.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType
  id: AccessRightType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRightType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "取得列舉型別<xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;></xref>類別用來表示的存取權限。"
  remarks: "類別衍生自<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A>屬性，並傳回它們以表示的存取權限的類型。</xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> </xref:System.Security.AccessControl.ObjectSecurity> 當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷要用於每個安全性物件的正確的列舉類型。"
  syntax:
    content: public override Type AccessRightType { get; }
    return:
      type: System.Type
      description: "A<xref:System.Type>物件，代表<xref href=&quot;System.Security.AccessControl.RegistryRights&quot;></xref>列舉型別。</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AccessRightType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  id: AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "建立新的存取控制規則所指定的使用者，使用指定的存取權限、 存取控制和旗標。"
  remarks: "若要建立存取控制規則的建議的方式是使用<xref:System.Security.AccessControl.RegistryAccessRule>類別</xref:System.Security.AccessControl.RegistryAccessRule>的建構函式      > [!NOTE] > 雖然您可以指定的<xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>旗標，請在此情況下存取沒有點</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName> 存取控制項目的子機碼中的名稱/值組不是個別的物件。 名稱/值組的存取權限是由子機碼的權限控制。 此外，因為所有子機碼是容器 （也就是它們可以包含其他子機碼），它們不會影響<xref:System.Security.AccessControl.InheritanceFlags>旗標。</xref:System.Security.AccessControl.InheritanceFlags> 最後，指定<xref:System.Security.AccessControl.InheritanceFlags>旗標不必要地變得非常複雜的維護的規則，因為它會干擾一般相容規則的組合。</xref:System.Security.AccessControl.InheritanceFlags>"
  syntax:
    content: public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "<xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref>識別使用者或群組規則會套用至。"
    - id: accessMask
      type: System.Int32
      description: "位元組合<xref href=&quot;System.Security.AccessControl.RegistryRights&quot;></xref>轉換成整數的值，指定要允許或拒絕的存取權限。"
    - id: isInherited
      type: System.Boolean
      description: "布林值，指定是否要繼承規則。"
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "位元組合<xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;></xref>值，指定子機碼繼承規則的方式。"
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "位元組合<xref href=&quot;System.Security.AccessControl.PropagationFlags&quot;></xref>修改繼承規則的子機碼的方式的值。 如果沒有意義的值`inheritanceFlags`是<xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref>。"
    - id: type
      type: System.Security.AccessControl.AccessControlType
      description: "其中一個<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;></xref>值，指定是否允許或拒絕權限。"
    return:
      type: System.Security.AccessControl.AccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref>物件，代表指定之使用者的指定權限。"
  overload: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code><code>inheritanceFlags</code>， <code>propagationFlags</code>，或<code>type</code>指定無效的值。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或-<code>accessMask</code>為零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>既不是類型<xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>，或這類類型的<xref href=&quot;System.Security.Principal.NTAccount&quot;></xref>可以轉換為類型<xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>。"
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  id: AccessRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "取得型別<xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;></xref>類別用來代表存取規則。"
  remarks: "類別衍生自<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A>屬性，並傳回它們以表示存取規則的類型。</xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> 當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷用於每個安全性物件的正確的存取規則類型。"
  syntax:
    content: public override Type AccessRuleType { get; }
    return:
      type: System.Type
      description: "A<xref:System.Type>物件，代表<xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;></xref>類別</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AccessRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AddAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.AddAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "搜尋符合的存取控制，可以與合併新規則。 如果找不到，加入新的規則。"
  remarks: "AddAccessRule 方法會搜尋具有相同的使用者或群組及相同的規則<xref:System.Security.AccessControl.AccessControlType>為`rule`。</xref:System.Security.AccessControl.AccessControlType> 如果找不到，`rule`加入。 如果找到相符的規則是中的權限`rule`會合併與現有的規則。       如果它們有不同的繼承旗標，無法合併的規則。 例如，如果允許任何的繼承旗標的讀取權限的使用者，而且 AddAccessRule 用來新增規則，讓使用者撰寫繼承的子機碼的存取權 (<xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>)，無法合併兩個規則。</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>       使用不同的規則<xref:System.Security.AccessControl.AccessControlType>值永遠不會合併。</xref:System.Security.AccessControl.AccessControlType>       規則的最經濟的方式來表達權限。 例如，如果使用者具有<xref:System.Security.AccessControl.RegistryRights>，<xref:System.Security.AccessControl.RegistryRights>和<xref:System.Security.AccessControl.RegistryRights>權限，而且您將加入規則，允許<xref:System.Security.AccessControl.RegistryRights>權限，使用者擁有所有的構成部分<xref:System.Security.AccessControl.RegistryRights>權限。</xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights> 如果您查詢的使用者權限，您會看到一個規則，其中包含<xref:System.Security.AccessControl.RegistryRights>權限。</xref:System.Security.AccessControl.RegistryRights> 同樣地，如果您移除<xref:System.Security.AccessControl.RegistryRights>權限的其他結構成分<xref:System.Security.AccessControl.RegistryRights>權限將會重新顯示。</xref:System.Security.AccessControl.RegistryRights> </xref:System.Security.AccessControl.RegistryRights>"
  example:
  - "The following code example creates registry access rules and adds them to a <xref:System.Security.AccessControl.RegistrySecurity> object, showing how rules that allow and deny rights remain separate, while compatible rules of the same kind are merged.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. Examples that attach security objects can be found in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> and <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n A code example that demonstrates inheritance and propagation flags can be found in the <xref:System.Security.AccessControl.RegistryAccessRule> class.  \n  \n [!code-cs[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/add/codesnippet/csharp/0595520c-e456-4072-a959-_1.cs)]\n [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/add/codesnippet/visualbasic/0595520c-e456-4072-a959-_1.vb)]"
  syntax:
    content: public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "若要加入之存取控制規則。"
  overload: System.Security.AccessControl.RegistrySecurity.AddAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AddAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.AddAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "搜尋的稽核規則可以合併新規則。 如果找不到，加入新的規則。"
  remarks: "AddAuditRule 方法會搜尋具有相同的使用者或群組做為規則`rule`。 如果找不到，`rule`加入。 如果找到相符的規則是中的旗標`rule`會合併到現有的規則。       如果它們有不同的繼承旗標，無法合併的規則。 例如，如果寫入機碼的失敗的嘗試進行稽核特定的使用者，但沒有繼承旗標，而且 AddAuditRule 用來新增規則，指定失敗的嘗試變更權限是相同的使用者，但使用的子機碼的繼承稽核 (<xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>)，無法合併兩個規則。</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>"
  syntax:
    content: public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "要加入的稽核規則。 此規則所指定的使用者會決定搜尋。"
  overload: System.Security.AccessControl.RegistrySecurity.AddAuditRule*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  id: AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "建立新的稽核規則，指定將規則套用到稽核、 繼承和傳播規則的存取權限的使用者，並觸發此規則的結果。"
  remarks: "若要建立的稽核規則的建議的方式是使用<xref:System.Security.AccessControl.RegistryAuditRule>類別</xref:System.Security.AccessControl.RegistryAuditRule>的建構函式      > [!NOTE] > 雖然您可以指定的<xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName>旗標，請在此情況下存取沒有點</xref:System.Security.AccessControl.InheritanceFlags?displayProperty=fullName> 基於稽核控制，子機碼中的名稱/值組不是個別的物件。 名稱/值組的稽核權限是由子機碼的權限控制。 此外，因為所有子機碼是容器 （也就是它們可以包含其他子機碼），它們不會影響<xref:System.Security.AccessControl.InheritanceFlags>旗標。</xref:System.Security.AccessControl.InheritanceFlags> 最後，指定<xref:System.Security.AccessControl.InheritanceFlags>旗標不必要地變得非常複雜的維護的規則，因為它會干擾一般相容規則的組合。</xref:System.Security.AccessControl.InheritanceFlags>"
  syntax:
    content: public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
    parameters:
    - id: identityReference
      type: System.Security.Principal.IdentityReference
      description: "<xref href=&quot;System.Security.Principal.IdentityReference&quot;> </xref>識別使用者或群組規則會套用至。"
    - id: accessMask
      type: System.Int32
      description: "位元組合<xref href=&quot;System.Security.AccessControl.RegistryRights&quot;></xref>轉換成整數的值，指定要稽核的存取權限。"
    - id: isInherited
      type: System.Boolean
      description: "布林值，指定是否要繼承規則。"
    - id: inheritanceFlags
      type: System.Security.AccessControl.InheritanceFlags
      description: "位元組合<xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;></xref>值，指定子機碼繼承規則的方式。"
    - id: propagationFlags
      type: System.Security.AccessControl.PropagationFlags
      description: "位元組合<xref href=&quot;System.Security.AccessControl.PropagationFlags&quot;></xref>修改繼承規則的子機碼的方式的值。 如果沒有意義的值`inheritanceFlags`是<xref href=&quot;System.Security.AccessControl.InheritanceFlags&quot;> </xref>。"
    - id: flags
      type: System.Security.AccessControl.AuditFlags
      description: "位元組合<xref href=&quot;System.Security.AccessControl.AuditFlags&quot;></xref>指定是否要稽核成功的存取、 失敗的存取，或兩者的值。"
    return:
      type: System.Security.AccessControl.AuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref>物件，代表所指定的使用者，與指定的旗標指定的稽核規則。 方法的傳回型別是基底類別， <xref href=&quot;System.Security.AccessControl.AuditRule&quot;> </xref>，但傳回的值可以安全地轉換成衍生類別。"
  overload: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>accessMask</code><code>inheritanceFlags</code>， <code>propagationFlags</code>，或<code>flags</code>指定無效的值。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>identityReference</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>.       -或-<code>accessMask</code>為零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>identityReference</code>既不是類型<xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>，或這類類型的<xref href=&quot;System.Security.Principal.NTAccount&quot;></xref>可以轉換為類型<xref href=&quot;System.Security.Principal.SecurityIdentifier&quot;> </xref>。"
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  id: AuditRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "取得型別<xref href=&quot;System.Security.AccessControl.RegistrySecurity&quot;></xref>類別用來代表稽核規則。"
  remarks: "類別衍生自<xref:System.Security.AccessControl.ObjectSecurity>類別覆寫<xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A>屬性和傳回類型，用以代表稽核權限。</xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> </xref:System.Security.AccessControl.ObjectSecurity> 當您使用陣列或包含多個類型的安全性物件的集合時，使用這個屬性來判斷用於每個安全性物件的正確的稽核規則類型。"
  syntax:
    content: public override Type AuditRuleType { get; }
    return:
      type: System.Type
      description: "A<xref:System.Type>物件，代表<xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;></xref>類別</xref:System.Type>"
  overload: System.Security.AccessControl.RegistrySecurity.AuditRuleType*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "搜尋具有相同的使用者的存取控制規則及<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> （允許或拒絕） 所指定的存取規則，且具有相容的繼承和傳播旗標; 如果找到這類規則，指定的存取規則中所包含的權限會從中移除。"
  remarks: "目前<xref:System.Security.AccessControl.RegistrySecurity>擁有相同的使用者和相同的規則會搜尋<xref:System.Security.AccessControl.AccessControlType>視為`rule`。</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.RegistrySecurity> 如果找到任何這類規則，會採取任何動作，而且方法會傳回`false`。 如果找到比對規則，其繼承和相容性旗標會檢查在指定的旗標與相容性的`rule`。 如果找到不相容的規則，會採取任何動作，而且方法會傳回`false`。 如果找到具有相容的旗標的規則，在指定的權限`rule`移除了相容的規則，而且方法會傳回`true`。 如果`rule`指定不相容的規則中包含的權限，就會採取任何動作，與這些權限。 如果從相容的規則會移除所有的權限，整個規則會移除從目前<xref:System.Security.AccessControl.RegistrySecurity>物件。</xref:System.Security.AccessControl.RegistrySecurity>"
  example:
  - "The following code example shows how the RemoveAccessRule method removes rights from a compatible rule, and how the <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> method merges rights with compatible rules.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds a rule that allows the current user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName> rights. The example then creates a rule that grants the user <xref:System.Security.AccessControl.RegistryRights?displayProperty=fullName>, with the same inheritance and propagation rights as the first rule, and uses the RemoveAccessRule method to remove this new rule from the <xref:System.Security.AccessControl.RegistrySecurity> object. <xref:System.Security.AccessControl.RegistryRights> is a constituent of <xref:System.Security.AccessControl.RegistryRights>, so it is removed from the compatible rule. The rules in the <xref:System.Security.AccessControl.RegistrySecurity> object are displayed, showing the remaining constituents of <xref:System.Security.AccessControl.RegistryRights>.  \n  \n The example code then calls the RemoveAccessRule method to merge the <xref:System.Security.AccessControl.RegistryRights> right back into the rule in the <xref:System.Security.AccessControl.RegistrySecurity> object.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. The second example in this section attaches a security object, and so do the examples in <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName><xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName>.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/visualbasic/797f5ef0-d4da-43dd-bbe9-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/add/codesnippet/csharp/797f5ef0-d4da-43dd-bbe9-_1.cs)]"
  syntax:
    content: public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref>所指定的使用者和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;></xref>搜尋，和一組比對規則，如果的繼承和傳播旗標找到，就必須相容。 指定的權限移除相容的規則，如果找到。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果找到相容的規則否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRuleAll(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "搜尋所有存取控制規則具有相同的使用者和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> （允許或拒絕） 所指定規則，如果找到，則移除它們。"
  remarks: "目前<xref:System.Security.AccessControl.RegistrySecurity>具備相同的使用者和相同的規則會搜尋<xref:System.Security.AccessControl.AccessControlType>視為`rule`。</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.RegistrySecurity> 任何權限、 繼承旗標或所指定的傳播旗標`rule`時執行這項搜尋將會被忽略。 如果找不到任何對應的規則，會不採取任何動作。       例如，如果使用者有多個規則可讓具有不同的繼承和傳播旗標的各種權限，您可以移除所有這些規則建立<xref:System.Security.AccessControl.RegistryAccessRule>物件，指定使用者和<xref:System.Security.AccessControl.AccessControlType?displayProperty=fullName>、 具有任何任意的權限和旗標，且傳遞規則 RemoveAccessRuleAll 方法。</xref:System.Security.AccessControl.AccessControlType?displayProperty=fullName> </xref:System.Security.AccessControl.RegistryAccessRule>"
  example:
  - "The following code example shows that the RemoveAccessRuleAll method removes all rules that match user and <xref:System.Security.AccessControl.AccessControlType>, ignoring rights and flags.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user to take ownership, and passes that rule to the RemoveAccessRuleAll method to remove the two rules that allow access.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/add/codesnippet/visualbasic/2ba6e9de-1f41-4d05-af76-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/add/codesnippet/csharp/2ba6e9de-1f41-4d05-af76-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref>所指定的使用者和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;></xref>搜尋。 會忽略任何權限、 繼承旗標或此規則所指定的傳播旗標。"
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  id: RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAccessRuleSpecific(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "搜尋符合指定的存取控制規則的規則，如果找到，則移除它。"
  remarks: "此規則會移除它完全符合時，才`rule`中所有詳細資料，包括旗標。 其他規則具有相同的使用者和<xref:System.Security.AccessControl.AccessControlType>不會受到影響。</xref:System.Security.AccessControl.AccessControlType>      > [!IMPORTANT] > 規則表示一或多個基礎存取控制項目 (ACE)，以及分割或修改使用者存取安全性規則時，視需要結合這些項目。 因此，規則可能不再存在於特定的表單時加入，而在此情況下，不能移除該 RemoveAccessRuleSpecific 方法。"
  example:
  - "The following code example shows that the RemoveAccessRuleSpecific method removes a rule only if it matches exactly.  \n  \n The example creates two rules that allow different rights. The rules have compatible inheritance and propagation flags, so when the second rule is added it merges with the first. The example calls the RemoveAccessRuleSpecific method, specifying the first rule, but because the rules are merged there is no rule that matches. The example then calls the <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> method to the remove the second rule from the merged rule, and finally calls the RemoveAccessRuleSpecific method to remove the first rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/visualbasic/9819c0cd-2b26-4472-a333-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/add/codesnippet/csharp/9819c0cd-2b26-4472-a333-_1.cs)]"
  syntax:
    content: public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "<xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;> </xref>移除。"
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "搜尋的存取控制規則具有相同的使用者指定的規則，以及具有相容的繼承和傳播旗標。如果找到相容的規則，就會移除指定之規則中所包含的權限。"
  remarks: "目前<xref:System.Security.AccessControl.RegistrySecurity>搜尋具有相同的使用者的稽核規則`rule`。</xref:System.Security.AccessControl.RegistrySecurity> 如果找到任何這類規則，會採取任何動作，而且方法會傳回`false`。 如果找到比對規則，其繼承和相容性旗標會檢查在指定的旗標與相容性的`rule`。 如果找到不相容的規則，會採取任何動作，而且方法會傳回`false`。 如果找到具有相容的旗標的規則，在指定的權限`rule`移除了相容的規則，而且方法會傳回`true`。 如果`rule`指定不相容的規則中包含的權限，就會採取任何動作，與這些權限。 如果從相容的規則會移除所有的權限，整個規則會移除從目前<xref:System.Security.AccessControl.RegistrySecurity>物件。</xref:System.Security.AccessControl.RegistrySecurity>"
  syntax:
    content: public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref>指定要搜尋的使用者和一組比對規則的繼承和傳播旗標時發現，必須與相容。 指定的權限移除相容的規則，如果找到。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果找到相容的規則否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRuleAll(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "搜尋的所有稽核規則具有相同的使用者指定的規則，如果找到，會將它們移除。"
  remarks: "目前<xref:System.Security.AccessControl.RegistrySecurity>搜尋中是否有具有相同的使用者的稽核規則`rule`。</xref:System.Security.AccessControl.RegistrySecurity> 任何權限、 繼承旗標或所指定的傳播旗標`rule`時執行這項搜尋將會被忽略。 如果找不到任何對應的規則，會不採取任何動作。"
  syntax:
    content: public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "A <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref> ，指定要搜尋的使用者。 會忽略任何權限、 繼承旗標或此規則所指定的傳播旗標。"
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  id: RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: RemoveAuditRuleSpecific(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "搜尋符合指定的稽核規則的規則，如果找到，則移除它。"
  remarks: "此規則會移除它完全符合時，才`rule`中所有詳細資料，包括旗標。 不會影響同一個使用者的其他稽核規則。      > [!IMPORTANT] > 規則表示一或多個基礎存取控制項目 (ACE)，以及分割或修改使用者的安全性稽核規則時，視需要結合這些項目。 因此，規則可能不再存在於特定的表單時加入，而在此情況下，不能移除該 RemoveAuditRuleSpecific 方法。"
  syntax:
    content: public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "<xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;> </xref>移除。"
  overload: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: ResetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "移除具有所指定之規則的相同使用者的所有存取控制規則，不論<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref>，並將指定的規則。"
  remarks: "如果沒有使用者符合指定之規則的存取規則`rule`加入。"
  example:
  - "The following code example shows how the ResetAccessRule method replaces all rules for the matching user with the rule specified for the match.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user only to read the key, and uses the ResetAccessRule method to remove the all rules for the user and replace them with the new rule.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-cs[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/add/codesnippet/csharp/80c97a6c-33e0-43c8-8894-_1.cs)]\n [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/add/codesnippet/visualbasic/80c97a6c-33e0-43c8-8894-_1.vb)]"
  syntax:
    content: public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;></xref> to add. 此規則所指定的使用者可以決定之前加入這個規則所要移除的規則。"
  overload: System.Security.AccessControl.RegistrySecurity.ResetAccessRule*
  exceptions: []
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  id: SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: SetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.SetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAccessRule(RegistryAccessRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "移除所有的存取控制規則具有相同的使用者和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;> </xref> （允許或拒絕） 所指定的規則，並將指定的規則。"
  remarks: "如果指定的規則有<xref:System.Security.AccessControl.AccessControlType>，這個方法的效果是要移除所有<xref:System.Security.AccessControl.AccessControlType>規則所指定的使用者，將其取代為指定的規則。</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType> 如果指定的規則有<xref:System.Security.AccessControl.AccessControlType>，則所有<xref:System.Security.AccessControl.AccessControlType>規則指定的使用者都取代成指定的規則。</xref:System.Security.AccessControl.AccessControlType> </xref:System.Security.AccessControl.AccessControlType>       如果沒有規則的使用者和<xref:System.Security.AccessControl.AccessControlType>符合指定之規則`rule`加入。</xref:System.Security.AccessControl.AccessControlType>"
  example:
  - "The following code example shows that the SetAccessRule method removes all rules that match both the user and the <xref:System.Security.AccessControl.AccessControlType> of `rule`, ignoring rights and flags, and replaces them with `rule`.  \n  \n The example creates a <xref:System.Security.AccessControl.RegistrySecurity> object and adds rules that allow and deny various rights for the current user, with different inheritance and propagation flags. The example then creates a new rule that allows the current user only to read the key, and uses the SetAccessRule method to remove the two rules that allow access and to replace them with the new rule. The rule that denies access is not affected.  \n  \n> [!NOTE]\n>  This example does not attach the security object to a <xref:Microsoft.Win32.RegistryKey> object. See the <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=fullName> method and the <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=fullName> method.  \n  \n [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/add/codesnippet/visualbasic/908f14bb-fbc5-4e71-ac82-_1.vb)]\n [!code-cs[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/add/codesnippet/csharp/908f14bb-fbc5-4e71-ac82-_1.cs)]"
  syntax:
    content: public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAccessRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAccessRule&quot;></xref> to add. 使用者和<xref href=&quot;System.Security.AccessControl.AccessControlType&quot;></xref>的這項規則可以決定之前加入這個規則所要移除的規則。"
  overload: System.Security.AccessControl.RegistrySecurity.SetAccessRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  id: SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  langs:
  - csharp
  name: SetAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.SetAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAuditRule(RegistryAuditRule)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Security.AccessControl
  summary: "移除所有稽核規則具有相同的使用者所指定的規則，不論<xref href=&quot;System.Security.AccessControl.AuditFlags&quot;></xref>值，並將指定的規則。"
  remarks: "如果沒有使用者符合指定之規則的稽核規則`rule`加入。"
  syntax:
    content: public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);
    parameters:
    - id: rule
      type: System.Security.AccessControl.RegistryAuditRule
      description: "The <xref href=&quot;System.Security.AccessControl.RegistryAuditRule&quot;></xref> to add. 此規則所指定的使用者可以決定之前加入這個規則所要移除的規則。"
  overload: System.Security.AccessControl.RegistrySecurity.SetAuditRule*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>rule</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
references:
- uid: System.Security.AccessControl.NativeObjectSecurity
  isExternal: false
  name: System.Security.AccessControl.NativeObjectSecurity
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.AccessControl.RegistrySecurity.#ctor
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RegistrySecurity()
  nameWithType: RegistrySecurity.RegistrySecurity()
  fullName: System.Security.AccessControl.RegistrySecurity.RegistrySecurity()
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRightType
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  nameWithType: RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AccessControlType)
- uid: System.Security.AccessControl.AccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessRule
  nameWithType: AccessRule
  fullName: System.Security.AccessControl.AccessRule
- uid: System.Security.Principal.IdentityReference
  parent: System.Security.Principal
  isExternal: false
  name: IdentityReference
  nameWithType: IdentityReference
  fullName: System.Security.Principal.IdentityReference
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Security.AccessControl.InheritanceFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: InheritanceFlags
  nameWithType: InheritanceFlags
  fullName: System.Security.AccessControl.InheritanceFlags
- uid: System.Security.AccessControl.PropagationFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: PropagationFlags
  nameWithType: PropagationFlags
  fullName: System.Security.AccessControl.PropagationFlags
- uid: System.Security.AccessControl.AccessControlType
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlType
  nameWithType: AccessControlType
  fullName: System.Security.AccessControl.AccessControlType
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AccessRuleType
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.AddAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistryAccessRule
  parent: System.Security.AccessControl
  isExternal: false
  name: RegistryAccessRule
  nameWithType: RegistryAccessRule
  fullName: System.Security.AccessControl.RegistryAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.AddAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.AddAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistryAuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: RegistryAuditRule
  nameWithType: RegistryAuditRule
  fullName: System.Security.AccessControl.RegistryAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  nameWithType: RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(IdentityReference,Int32,Boolean,InheritanceFlags,PropagationFlags,AuditFlags)
- uid: System.Security.AccessControl.AuditRule
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditRule
  nameWithType: AuditRule
  fullName: System.Security.AccessControl.AuditRule
- uid: System.Security.AccessControl.AuditFlags
  parent: System.Security.AccessControl
  isExternal: false
  name: AuditFlags
  nameWithType: AuditFlags
  fullName: System.Security.AccessControl.AuditFlags
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
  fullName: System.Security.AccessControl.RegistrySecurity.AuditRuleType
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleAll(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleSpecific(RegistryAccessRule)
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleAll(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleSpecific(RegistryAuditRule)
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: ResetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.ResetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.ResetAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAccessRule(RegistryAccessRule)
  nameWithType: RegistrySecurity.SetAccessRule(RegistryAccessRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAccessRule(RegistryAccessRule)
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAuditRule(RegistryAuditRule)
  nameWithType: RegistrySecurity.SetAuditRule(RegistryAuditRule)
  fullName: System.Security.AccessControl.RegistrySecurity.SetAuditRule(RegistryAuditRule)
- uid: System.Security.AccessControl.RegistrySecurity.#ctor*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RegistrySecurity
  nameWithType: RegistrySecurity.RegistrySecurity
- uid: System.Security.AccessControl.RegistrySecurity.AccessRightType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRightType
  nameWithType: RegistrySecurity.AccessRightType
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleFactory*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleFactory
  nameWithType: RegistrySecurity.AccessRuleFactory
- uid: System.Security.AccessControl.RegistrySecurity.AccessRuleType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AccessRuleType
  nameWithType: RegistrySecurity.AccessRuleType
- uid: System.Security.AccessControl.RegistrySecurity.AddAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAccessRule
  nameWithType: RegistrySecurity.AddAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.AddAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AddAuditRule
  nameWithType: RegistrySecurity.AddAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleFactory*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleFactory
  nameWithType: RegistrySecurity.AuditRuleFactory
- uid: System.Security.AccessControl.RegistrySecurity.AuditRuleType*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: AuditRuleType
  nameWithType: RegistrySecurity.AuditRuleType
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRule
  nameWithType: RegistrySecurity.RemoveAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleAll
  nameWithType: RegistrySecurity.RemoveAccessRuleAll
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAccessRuleSpecific
  nameWithType: RegistrySecurity.RemoveAccessRuleSpecific
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRule
  nameWithType: RegistrySecurity.RemoveAuditRule
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleAll
  nameWithType: RegistrySecurity.RemoveAuditRuleAll
- uid: System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: RemoveAuditRuleSpecific
  nameWithType: RegistrySecurity.RemoveAuditRuleSpecific
- uid: System.Security.AccessControl.RegistrySecurity.ResetAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: ResetAccessRule
  nameWithType: RegistrySecurity.ResetAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.SetAccessRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAccessRule
  nameWithType: RegistrySecurity.SetAccessRule
- uid: System.Security.AccessControl.RegistrySecurity.SetAuditRule*
  parent: System.Security.AccessControl.RegistrySecurity
  isExternal: false
  name: SetAuditRule
  nameWithType: RegistrySecurity.SetAuditRule
