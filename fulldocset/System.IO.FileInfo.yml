### YamlMime:ManagedReference
items:
- uid: System.IO.FileInfo
  id: FileInfo
  children:
  - System.IO.FileInfo.#ctor(System.String)
  - System.IO.FileInfo.AppendText
  - System.IO.FileInfo.CopyTo(System.String)
  - System.IO.FileInfo.CopyTo(System.String,System.Boolean)
  - System.IO.FileInfo.Create
  - System.IO.FileInfo.CreateText
  - System.IO.FileInfo.Decrypt
  - System.IO.FileInfo.Delete
  - System.IO.FileInfo.Directory
  - System.IO.FileInfo.DirectoryName
  - System.IO.FileInfo.Encrypt
  - System.IO.FileInfo.Exists
  - System.IO.FileInfo.GetAccessControl
  - System.IO.FileInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)
  - System.IO.FileInfo.IsReadOnly
  - System.IO.FileInfo.Length
  - System.IO.FileInfo.MoveTo(System.String)
  - System.IO.FileInfo.Name
  - System.IO.FileInfo.Open(System.IO.FileMode)
  - System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess)
  - System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.FileInfo.OpenRead
  - System.IO.FileInfo.OpenText
  - System.IO.FileInfo.OpenWrite
  - System.IO.FileInfo.Replace(System.String,System.String)
  - System.IO.FileInfo.Replace(System.String,System.String,System.Boolean)
  - System.IO.FileInfo.SetAccessControl(System.Security.AccessControl.FileSecurity)
  - System.IO.FileInfo.ToString
  langs:
  - csharp
  name: FileInfo
  nameWithType: FileInfo
  fullName: System.IO.FileInfo
  type: Class
  summary: "提供屬性和執行個體方法，建立、 複製、 刪除、 移動和開啟檔案，並協助建立<xref href=&quot;System.IO.FileStream&quot;></xref>物件。 這個類別無法被繼承。       若要瀏覽此類型的.NET Framework 原始程式碼，請參閱[參考來源](http://referencesource.microsoft.com/#mscorlib/system/io/fileinfo.cs#4ee673c1a4ecad41)。"
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/fileinfo.cs#4ee673c1a4ecad41). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Use the FileInfo class for typical operations such as copying, moving, renaming, creating, opening, deleting, and appending to files.  \n  \n If you are performing multiple operations on the same file, it can be more efficient to use FileInfo instance methods instead of the corresponding static methods of the <xref:System.IO.File> class, because a security check will not always be necessary.  \n  \n Many of the FileInfo methods return other I/O types when you create or open files. You can use these other types to further manipulate a file. For more information, see specific FileInfo members such as <xref:System.IO.FileInfo.Open%2A>, <xref:System.IO.FileInfo.OpenRead%2A>, <xref:System.IO.FileInfo.OpenText%2A>, <xref:System.IO.FileInfo.CreateText%2A>, or <xref:System.IO.FileInfo.Create%2A>.  \n  \n By default, full read/write access to new files is granted to all users.  \n  \n The following table describes the enumerations that are used to customize the behavior of various FileInfo methods.  \n  \n|Enumeration|Description|  \n|-----------------|-----------------|  \n|<xref:System.IO.FileAccess>|Specifies read and write access to a file.|  \n|<xref:System.IO.FileShare>|Specifies the level of access permitted for a file that is already in use.|  \n|<xref:System.IO.FileMode>|Specifies whether the contents of an existing file are preserved or overwritten, and whether requests to create an existing file cause an exception.|  \n  \n> [!NOTE]\n>  In members that accept a path as an input string, that path must be well-formed or an exception is raised. For example, if a path is fully qualified but begins with a space, the path is not trimmed in methods of the class. Therefore, the path is malformed and an exception is raised. Similarly, a path or a combination of paths cannot be fully qualified twice. For example, \"c:\\temp c:\\windows\" also raises an exception in most cases. Ensure that your paths are well-formed when using methods that accept a path string.  \n  \n In members that accept a path, the path can refer to a file or just a directory. The specified path can also refer to a relative path or a Universal Naming Convention (UNC) path for a server and share name. For example, all the following are acceptable paths:  \n  \n-   \"c:\\\\\\MyDir\\\\\\MyFile.txt\" in C#, or \"c:\\MyDir\\MyFile.txt\" in Visual Basic.  \n  \n-   \"c:\\\\\\MyDir\" in C#, or \"c:\\MyDir\" in Visual Basic.  \n  \n-   \"MyDir\\\\\\MySubdir\" in C#, or \"MyDir\\MySubDir\" in Visual Basic.  \n  \n-   \"\\\\\\\\\\\\\\MyServer\\\\\\MyShare\" in C#, or \"\\\\\\MyServer\\MyShare\" in Visual Basic.  \n  \n The FileInfo class provides the following properties that enable you to retrieve information about a file. For an example of how to use each property, see the property pages.  \n  \n-   The <xref:System.IO.FileInfo.Directory%2A> property retrieves an object that represents the parent directory of a file.  \n  \n-   The <xref:System.IO.FileInfo.DirectoryName%2A> property retrieves the full path of the parent directory of a file.  \n  \n-   The <xref:System.IO.FileInfo.Exists%2A> property checks for the presence of a file before operating on it.  \n  \n-   The <xref:System.IO.FileInfo.IsReadOnly%2A> property retrieves or sets a value that specifies whether a file can be modified.  \n  \n-   The <xref:System.IO.FileInfo.Length%2A> retrieves the size of a file.  \n  \n-   The <xref:System.IO.FileInfo.Name%2A> retrieves the name of a file."
  example:
  - "The following example demonstrates some of the main members of the `FileInfo` class.  \n  \n When the properties are first retrieved, FileInfo calls the <xref:System.IO.FileSystemInfo.Refresh%2A> method and caches information about the file. On subsequent calls, you must call <xref:System.IO.FileSystemInfo.Refresh%2A> to get the latest copy of the information.  \n  \n [!code-cs[FInfo Class#1](~/add/codesnippet/csharp/t-system.io.fileinfo_1.cs)]\n [!code-cpp[FInfo Class#1](~/add/codesnippet/cpp/t-system.io.fileinfo_1.cpp)]\n [!code-vb[FInfo Class#1](~/add/codesnippet/visualbasic/t-system.io.fileinfo_1.vb)]  \n  \n This example produces output similar to the following.  \n  \n```  \nHello  \nAnd  \nWelcome  \nC:\\Users\\userName\\AppData\\Local\\Temp\\tmp70AB.tmp was copied to C:\\Users\\userName\\AppData\\Local\\Temp\\tmp70CB.tmp.  \nC:\\Users\\userName\\AppData\\Local\\Temp\\tmp70CB.tmp was successfully deleted.  \n```"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public sealed class FileInfo : System.IO.FileSystemInfo
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.IO.FileSystemInfo
  implements: []
  inheritedMembers:
  - System.IO.FileSystemInfo.Attributes
  - System.IO.FileSystemInfo.CreationTime
  - System.IO.FileSystemInfo.CreationTimeUtc
  - System.IO.FileSystemInfo.Extension
  - System.IO.FileSystemInfo.FullName
  - System.IO.FileSystemInfo.FullPath
  - System.IO.FileSystemInfo.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
  - System.IO.FileSystemInfo.LastAccessTime
  - System.IO.FileSystemInfo.LastAccessTimeUtc
  - System.IO.FileSystemInfo.LastWriteTime
  - System.IO.FileSystemInfo.LastWriteTimeUtc
  - System.IO.FileSystemInfo.OriginalPath
  - System.IO.FileSystemInfo.Refresh
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.IO.FileInfo.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: FileInfo(String)
  nameWithType: FileInfo.FileInfo(String)
  fullName: System.IO.FileInfo.FileInfo(String)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileInfo&quot;></xref>類別，做為檔案路徑的包裝函式。"
  remarks: "您可以指定完整或相對的檔名，但安全性檢查會取得完整限定的名稱。"
  example:
  - "The following example uses this constructor to create two files, which are then written to, read from, copied, and deleted.  \n  \n [!code-cpp[finfo ctor#1](~/add/codesnippet/cpp/m-system.io.fileinfo.sha_1.cpp)]\n [!code-cs[finfo ctor#1](~/add/codesnippet/csharp/m-system.io.fileinfo.sha_1.cs)]\n [!code-vb[finfo ctor#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.sha_1.vb)]  \n  \n The following example opens an existing file or creates a file, appends text to the file, and displays the results.  \n  \n [!code-cpp[fileinfomain#1](~/add/codesnippet/cpp/m-system.io.fileinfo.sha_2.cpp)]\n [!code-cs[fileinfomain#1](~/add/codesnippet/csharp/m-system.io.fileinfo.sha_2.cs)]\n [!code-vb[fileinfomain#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.sha_2.vb)]"
  syntax:
    content: public FileInfo (string fileName);
    parameters:
    - id: fileName
      type: System.String
      description: "新的檔案完整的名稱或相對的檔名。 未結束的路徑以目錄分隔符號字元。"
  overload: System.IO.FileInfo.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>fileName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "檔案名稱是空的、 只包含空格，或包含無效的字元。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "若要存取<code> fileName </code>遭到拒絕。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路徑、 檔案名稱，或兩者都超出系統定義的長度上限。 例如，windows 平台上，路徑必須少於 248 個字元，和檔案名稱必須少於 260 個字元。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>fileName</code>包含字串的中間的冒號 （:）。"
  platform:
  - net462
- uid: System.IO.FileInfo.AppendText
  id: AppendText
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: AppendText()
  nameWithType: FileInfo.AppendText()
  fullName: System.IO.FileInfo.AppendText()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "建立<xref:System.IO.StreamWriter>，將文字附加至這個執行個體所表示的檔案<xref href=&quot;System.IO.FileInfo&quot;> </xref>。</xref:System.IO.StreamWriter>"
  remarks: ''
  example:
  - "The following example appends text to a file and reads from the file.  \n  \n [!code-vb[finfo appendtext#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.app_1.vb)]\n [!code-cpp[finfo appendtext#1](~/add/codesnippet/cpp/m-system.io.fileinfo.app_1.cpp)]\n [!code-cs[finfo appendtext#1](~/add/codesnippet/csharp/m-system.io.fileinfo.app_1.cs)]  \n  \n The following example demonstrates appending text to the end of a file and also displays the result of the append operation to the console. The first time this routine is called, the file is created if it does not exist. After that, the specified text is appended to the file.  \n  \n [!code-vb[fileinfoappendtext#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.app_2.vb)]\n [!code-cpp[fileinfoappendtext#1](~/add/codesnippet/cpp/m-system.io.fileinfo.app_2.cpp)]\n [!code-cs[fileinfoappendtext#1](~/add/codesnippet/csharp/m-system.io.fileinfo.app_2.cs)]"
  syntax:
    content: public System.IO.StreamWriter AppendText ();
    parameters: []
    return:
      type: System.IO.StreamWriter
      description: "A new <xref uid=&quot;langword_csharp_StreamWriter&quot; name=&quot;StreamWriter&quot; href=&quot;&quot;></xref>."
  overload: System.IO.FileInfo.AppendText*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileInfo.CopyTo(System.String)
  id: CopyTo(System.String)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: CopyTo(String)
  nameWithType: FileInfo.CopyTo(String)
  fullName: System.IO.FileInfo.CopyTo(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "將現有的檔案複製到新的檔案，不允許覆寫現有的檔案。"
  remarks: "使用<xref:System.IO.FileInfo.CopyTo%2A>方法，以允許覆寫現有的檔案。</xref:System.IO.FileInfo.CopyTo%2A>      > [!CAUTION] > 盡可能避免使用這個方法的簡短檔案名稱 （例如 XXXXXX~1.XXX)。 如果兩個檔案有對等項目簡短檔案名稱，則這個方法可能會失敗並引發例外狀況和/或導致非預期的行為"
  example:
  - "The following example demonstrates both overloads of the `CopyTo` method.  \n  \n [!code-cpp[finfo copyto2#1](~/add/codesnippet/cpp/m-system.io.fileinfo.cop_1_1.cpp)]\n [!code-cs[finfo copyto2#1](~/add/codesnippet/csharp/m-system.io.fileinfo.cop_1_1.cs)]\n [!code-vb[finfo copyto2#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.cop_1_1.vb)]  \n  \n The following example demonstrates copying one file to another file, throwing an exception if the destination file already exists.  \n  \n [!code-cpp[FileInfoCopyTo1#1](~/add/codesnippet/cpp/m-system.io.fileinfo.cop_1_2.cpp)]\n [!code-cs[FileInfoCopyTo1#1](~/add/codesnippet/csharp/m-system.io.fileinfo.cop_1_2.cs)]\n [!code-vb[FileInfoCopyTo1#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.cop_1_2.vb)]"
  syntax:
    content: public System.IO.FileInfo CopyTo (string destFileName);
    parameters:
    - id: destFileName
      type: System.String
      description: "要複製到新的檔案名稱。"
    return:
      type: System.IO.FileInfo
      description: "具有完整路徑的新檔案。"
  overload: System.IO.FileInfo.CopyTo*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>destFileName</code>是空的、 只包含空格，或包含無效的字元。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生錯誤，或已存在目的地檔案。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>destFileName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "傳入目錄路徑，或者檔案正要移至不同的磁碟機。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "中指定的目錄<code> destFileName </code>不存在。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路徑、 檔案名稱，或兩者都超出系統定義的長度上限。 例如，windows 平台上，路徑必須少於 248 個字元，和檔案名稱必須少於 260 個字元。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>destFileName</code>包含在字串中的冒號 （:），但不是指定磁碟區。"
  platform:
  - net462
- uid: System.IO.FileInfo.CopyTo(System.String,System.Boolean)
  id: CopyTo(System.String,System.Boolean)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: CopyTo(String,Boolean)
  nameWithType: FileInfo.CopyTo(String,Boolean)
  fullName: System.IO.FileInfo.CopyTo(String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "將現有的檔案複製到新的檔案，允許覆寫現有的檔案。"
  remarks: "使用此方法以允許或防止覆寫現有的檔案。 使用<xref:System.IO.FileInfo.CopyTo%2A>以避免覆寫現有檔案的預設方法。</xref:System.IO.FileInfo.CopyTo%2A>      > [!CAUTION] > 盡可能避免使用這個方法的簡短檔案名稱 （例如 XXXXXX~1.XXX)。 如果兩個檔案有對等項目簡短檔案名稱，則這個方法可能會失敗並引發例外狀況和/或導致非預期的行為"
  example:
  - "The following example demonstrates both overloads of the `CopyTo` method.  \n  \n [!code-cpp[finfo copyto2#1](~/add/codesnippet/cpp/m-system.io.fileinfo.cop_0_1.cpp)]\n [!code-cs[finfo copyto2#1](~/add/codesnippet/csharp/m-system.io.fileinfo.cop_0_1.cs)]\n [!code-vb[finfo copyto2#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.cop_0_1.vb)]  \n  \n The following example demonstrates copying one file to another file, specifying whether to overwrite a file that already exists.  \n  \n [!code-cs[fileinfocopyto#1](~/add/codesnippet/csharp/m-system.io.fileinfo.cop_0_2.cs)]\n [!code-cpp[fileinfocopyto#1](~/add/codesnippet/cpp/m-system.io.fileinfo.cop_0_2.cpp)]\n [!code-vb[fileinfocopyto#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.cop_0_2.vb)]"
  syntax:
    content: public System.IO.FileInfo CopyTo (string destFileName, bool overwrite);
    parameters:
    - id: destFileName
      type: System.String
      description: "要複製到新的檔案名稱。"
    - id: overwrite
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要讓現有的檔案會覆寫;否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.IO.FileInfo
      description: "新的檔案或覆寫現有檔案如果<code> overwrite </code>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。 如果檔案存在和<code> overwrite </code>是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>、<xref:System.IO.IOException>就會擲回。</xref:System.IO.IOException>"
  overload: System.IO.FileInfo.CopyTo*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>destFileName</code>是空的、 只包含空格，或包含無效的字元。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生錯誤，或已存在目的地檔案和<code> overwrite </code>是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>destFileName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "中指定的目錄<code> destFileName </code>不存在。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "傳入目錄路徑，或者檔案正要移至不同的磁碟機。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路徑、 檔案名稱，或兩者都超出系統定義的長度上限。 例如，windows 平台上，路徑必須少於 248 個字元，和檔案名稱必須少於 260 個字元。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>destFileName</code>包含字串的中間的冒號 （:）。"
  platform:
  - net462
- uid: System.IO.FileInfo.Create
  id: Create
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Create()
  nameWithType: FileInfo.Create()
  fullName: System.IO.FileInfo.Create()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "建立檔案。"
  remarks: "根據預設，所有使用者已授都與至新的檔案的完整讀取/寫入存取。       這個方法是<xref:System.IO.File.Create%2A?displayProperty=fullName>.</xref:System.IO.File.Create%2A?displayProperty=fullName>所提供的功能的包裝函式"
  example:
  - "The following example creates a reference to a file, and then creates the file on disk using `FileInfo.Create()`.  \n  \n [!code-cpp[fileinfodelete#1](~/add/codesnippet/cpp/m-system.io.fileinfo.cre_0_1.cpp)]\n [!code-vb[fileinfodelete#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.cre_0_1.vb)]\n [!code-cs[fileinfodelete#1](~/add/codesnippet/csharp/m-system.io.fileinfo.cre_0_1.cs)]  \n  \n The following example creates a file, adds some text to it, and reads from the file.  \n  \n [!code-vb[finfo create#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.cre_0_2.vb)]\n [!code-cs[finfo create#1](~/add/codesnippet/csharp/m-system.io.fileinfo.cre_0_2.cs)]\n [!code-cpp[finfo create#1](~/add/codesnippet/cpp/m-system.io.fileinfo.cre_0_2.cpp)]"
  syntax:
    content: public System.IO.FileStream Create ();
    parameters: []
    return:
      type: System.IO.FileStream
      description: "新的檔案。"
  overload: System.IO.FileInfo.Create*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileInfo.CreateText
  id: CreateText
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: CreateText()
  nameWithType: FileInfo.CreateText()
  fullName: System.IO.FileInfo.CreateText()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "建立<xref:System.IO.StreamWriter>寫入新文字檔。</xref:System.IO.StreamWriter>"
  remarks: "根據預設，所有使用者已授都與至新的檔案的完整讀取/寫入存取。"
  example:
  - "The following example demonstrates the `CreateText` method.  \n  \n [!code-cpp[finfo createtext#1](~/add/codesnippet/cpp/m-system.io.fileinfo.cre_1_1.cpp)]\n [!code-vb[finfo createtext#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.cre_1_1.vb)]\n [!code-cs[finfo createtext#1](~/add/codesnippet/csharp/m-system.io.fileinfo.cre_1_1.cs)]"
  syntax:
    content: public System.IO.StreamWriter CreateText ();
    parameters: []
    return:
      type: System.IO.StreamWriter
      description: "A new <xref uid=&quot;langword_csharp_StreamWriter&quot; name=&quot;StreamWriter&quot; href=&quot;&quot;></xref>."
  overload: System.IO.FileInfo.CreateText*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "檔案名稱是一個目錄。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "磁碟處於唯讀狀態。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.IO.FileInfo.Decrypt
  id: Decrypt
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Decrypt()
  nameWithType: FileInfo.Decrypt()
  fullName: System.IO.FileInfo.Decrypt()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "解密目前帳戶使用加密檔案<xref:System.IO.FileInfo.Encrypt*>方法。</xref:System.IO.FileInfo.Encrypt*>"
  remarks: "解密方法可讓您將使用加密檔案解密<xref:System.IO.FileInfo.Encrypt%2A>方法。</xref:System.IO.FileInfo.Encrypt%2A>  解密方法可以解密使用目前的使用者帳戶已加密的檔案。       同時<xref:System.IO.FileInfo.Encrypt%2A>和解密方法使用電腦上安裝並呼叫方法的程序的檔案加密金鑰的密碼編譯服務提供者 (CSP)。</xref:System.IO.FileInfo.Encrypt%2A>       目前的檔案系統必須格式化為 NTFS，且目前的作業系統必須 Microsoft Windows NT 或更新版本。"
  example:
  - "The following code example uses the <xref:System.IO.FileInfo.Encrypt%2A> method and the Decrypt method to encrypt and then decrypt a file.  \n  \n [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/add/codesnippet/cpp/m-system.io.fileinfo.dec_1.cpp)]\n [!code-cs[IO.FileInfo.Encrypt-Decrypt#1](~/add/codesnippet/csharp/m-system.io.fileinfo.dec_1.cs)]\n [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.dec_1.vb)]"
  syntax:
    content: public void Decrypt ();
    parameters: []
  overload: System.IO.FileInfo.Decrypt*
  exceptions:
  - type: System.IO.DriveNotFoundException
    commentId: T:System.IO.DriveNotFoundException
    description: "指定了無效的磁碟機。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "目前所描述的檔案<xref href=&quot;System.IO.FileInfo&quot;></xref>找不到物件。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟檔案時發生 I/O 錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "檔案系統不是 NTFS。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "目前的作業系統不是 Microsoft Windows NT 或更新版本。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "目前所描述的檔案<xref href=&quot;System.IO.FileInfo&quot;></xref>物件是唯讀的。       -或者-目前的平台不支援此作業。       -或者-呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.IO.FileInfo.Delete
  id: Delete
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Delete()
  nameWithType: FileInfo.Delete()
  fullName: System.IO.FileInfo.Delete()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "永久刪除的檔案。"
  remarks: "如果檔案不存在，這個方法沒有任何作用。"
  example:
  - "The following example demonstrates the `Delete` method.  \n  \n [!code-cpp[finfo delete#1](~/add/codesnippet/cpp/m-system.io.fileinfo.del_1.cpp)]\n [!code-cs[finfo delete#1](~/add/codesnippet/csharp/m-system.io.fileinfo.del_1.cs)]\n [!code-vb[finfo delete#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.del_1.vb)]  \n  \n The following example creates, closes, and deletes a file.  \n  \n [!code-cpp[fileinfodelete#1](~/add/codesnippet/cpp/m-system.io.fileinfo.del_2.cpp)]\n [!code-vb[fileinfodelete#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.del_2.vb)]\n [!code-cs[fileinfodelete#1](~/add/codesnippet/csharp/m-system.io.fileinfo.del_2.cs)]"
  syntax:
    content: public override void Delete ();
    parameters: []
  overload: System.IO.FileInfo.Delete*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟或執行 Microsoft Windows NT 的電腦上記憶體對應檔案。       -或-開啟的控制代碼上的檔案，而且作業系統是 Windows XP 或更早版本。 這個開啟控制代碼可能是因為列舉目錄和檔案。 如需詳細資訊，請參閱[如何︰ 列舉目錄和檔案](~/add/includes/ajax-current-ext-md.md)。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "路徑是目錄。"
  platform:
  - net462
- uid: System.IO.FileInfo.Directory
  id: Directory
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Directory
  nameWithType: FileInfo.Directory
  fullName: System.IO.FileInfo.Directory
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得父目錄的執行個體。"
  remarks: "若要取得以字串形式的父目錄，請使用<xref:System.IO.FileInfo.DirectoryName%2A>屬性。</xref:System.IO.FileInfo.DirectoryName%2A>"
  example:
  - "The following example opens or creates a file, determines its full path, and determines and displays the full contents of the directory.  \n  \n [!code-cs[fileinfodirectory#1](~/add/codesnippet/csharp/p-system.io.fileinfo.dir_0_1.cs)]\n [!code-vb[fileinfodirectory#1](~/add/codesnippet/visualbasic/p-system.io.fileinfo.dir_0_1.vb)]\n [!code-cpp[fileinfodirectory#1](~/add/codesnippet/cpp/p-system.io.fileinfo.dir_0_1.cpp)]"
  syntax:
    content: public System.IO.DirectoryInfo Directory { get; }
    return:
      type: System.IO.DirectoryInfo
      description: "A <xref href=&quot;System.IO.DirectoryInfo&quot;> </xref>物件，代表這個檔案的上層目錄。"
  overload: System.IO.FileInfo.Directory*
  exceptions:
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.IO.FileInfo.DirectoryName
  id: DirectoryName
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: DirectoryName
  nameWithType: FileInfo.DirectoryName
  fullName: System.IO.FileInfo.DirectoryName
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得表示目錄的完整路徑的字串。"
  remarks: "若要取得的父目錄<xref:System.IO.DirectoryInfo>物件，請使用<xref:System.IO.FileInfo.Directory%2A>屬性。</xref:System.IO.FileInfo.Directory%2A> </xref:System.IO.DirectoryInfo>       第一次呼叫時，<xref:System.IO.FileInfo>呼叫<xref:System.IO.FileSystemInfo.Refresh%2A>和快取檔案的相關資訊。</xref:System.IO.FileSystemInfo.Refresh%2A> </xref:System.IO.FileInfo> 在後續呼叫中，您必須呼叫<xref:System.IO.FileSystemInfo.Refresh%2A>取得資訊的最新的複本。</xref:System.IO.FileSystemInfo.Refresh%2A>"
  example:
  - "The following example retrieves the full path of the specified file.  \n  \n [!code-cs[System.IO.FileInfo members#3](~/add/codesnippet/csharp/p-system.io.fileinfo.dir_1_1.cs)]\n [!code-cpp[System.IO.FileInfo members#3](~/add/codesnippet/cpp/p-system.io.fileinfo.dir_1_1.cpp)]\n [!code-vb[System.IO.FileInfo members#3](~/add/codesnippet/visualbasic/p-system.io.fileinfo.dir_1_1.vb)]"
  syntax:
    content: public string DirectoryName { get; }
    return:
      type: System.String
      description: "字串，表示目錄的完整路徑。"
  overload: System.IO.FileInfo.DirectoryName*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>傳入的目錄名稱。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "完整的路徑為 260 或多個字元。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.IO.FileInfo.Encrypt
  id: Encrypt
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Encrypt()
  nameWithType: FileInfo.Encrypt()
  fullName: System.IO.FileInfo.Encrypt()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "加密檔案，只有使用加密檔案的帳戶才能將其解密。"
  remarks: "加密方法可讓您加密檔案，以便只有呼叫這個方法所使用的帳戶才能將其解密。  使用<xref:System.IO.FileInfo.Decrypt%2A>方法來解密加密的加密方法的檔案。</xref:System.IO.FileInfo.Decrypt%2A>       這兩種加密方法和<xref:System.IO.FileInfo.Decrypt%2A>方法使用的電腦上安裝並呼叫方法的程序的檔案加密金鑰的密碼編譯服務提供者 (CSP)。</xref:System.IO.FileInfo.Decrypt%2A>       目前的檔案系統必須格式化為 NTFS，且目前的作業系統必須 Microsoft Windows NT 或更新版本。"
  example:
  - "The following code example uses the Encrypt method and the <xref:System.IO.FileInfo.Decrypt%2A> method to encrypt a file and then decrypt it.  \n  \n [!code-cpp[IO.FileInfo.Encrypt-Decrypt#1](~/add/codesnippet/cpp/m-system.io.fileinfo.enc_1.cpp)]\n [!code-cs[IO.FileInfo.Encrypt-Decrypt#1](~/add/codesnippet/csharp/m-system.io.fileinfo.enc_1.cs)]\n [!code-vb[IO.FileInfo.Encrypt-Decrypt#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.enc_1.vb)]"
  syntax:
    content: public void Encrypt ();
    parameters: []
  overload: System.IO.FileInfo.Encrypt*
  exceptions:
  - type: System.IO.DriveNotFoundException
    commentId: T:System.IO.DriveNotFoundException
    description: "指定了無效的磁碟機。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "目前所描述的檔案<xref href=&quot;System.IO.FileInfo&quot;></xref>找不到物件。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟檔案時發生 I/O 錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "檔案系統不是 NTFS。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "目前的作業系統不是 Microsoft Windows NT 或更新版本。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "目前所描述的檔案<xref href=&quot;System.IO.FileInfo&quot;></xref>物件是唯讀的。       -或者-目前的平台不支援此作業。       -或者-呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.IO.FileInfo.Exists
  id: Exists
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Exists
  nameWithType: FileInfo.Exists
  fullName: System.IO.FileInfo.Exists
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得值，指出檔案是否存在。"
  remarks: "第一次呼叫時，<xref:System.IO.FileInfo>呼叫<xref:System.IO.FileSystemInfo.Refresh%2A>和快取檔案的相關資訊。</xref:System.IO.FileSystemInfo.Refresh%2A> </xref:System.IO.FileInfo> 在後續呼叫中，您必須呼叫<xref:System.IO.FileSystemInfo.Refresh%2A>取得資訊的最新的複本。</xref:System.IO.FileSystemInfo.Refresh%2A>       Exists 屬性會傳回`false`如果發生任何錯誤時嘗試判斷指定的檔案是否存在。 可能發生這種情況下，會引發例外狀況，例如傳遞檔名無效的字元或太多的字元，失敗或遺失的磁碟，或如果呼叫端沒有讀取檔案的權限。"
  example:
  - "The following code example uses the Exists property ensure a file exists before opening it.  You can use this technique to throw a custom exception when the file is not found.  \n  \n [!code-cpp[IO.FileInfo.Exists#1](~/add/codesnippet/cpp/p-system.io.fileinfo.exi_1.cpp)]\n [!code-cs[IO.FileInfo.Exists#1](~/add/codesnippet/csharp/p-system.io.fileinfo.exi_1.cs)]\n [!code-vb[IO.FileInfo.Exists#1](~/add/codesnippet/visualbasic/p-system.io.fileinfo.exi_1.vb)]"
  syntax:
    content: public override bool Exists { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果檔案存在。<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果檔案不存在，或如果檔案是目錄。"
  overload: System.IO.FileInfo.Exists*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileInfo.GetAccessControl
  id: GetAccessControl
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: GetAccessControl()
  nameWithType: FileInfo.GetAccessControl()
  fullName: System.IO.FileInfo.GetAccessControl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>物件會封裝目前所描述的檔案存取控制清單 (ACL) 項目<xref href=&quot;System.IO.FileInfo&quot;></xref>物件。"
  remarks: "您可以使用 GetAccessControl 方法來擷取目前的檔案之存取控制清單 (ACL) 項目。       ACL 描述個人及/或群組，讓他們已經有或沒有，在指定的檔案上採取特定動作的權限。 如需詳細資訊，請參閱[如何︰ 加入或移除存取控制清單項目](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example uses the GetAccessControl method and the <xref:System.IO.FileInfo.SetAccessControl%2A> method to add and then remove an access control list (ACL) entry from a file.  You must supply a valid user or group account to run this example.  \n  \n [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/cpp/m-system.io.fileinfo.get_1.cpp)]\n [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.get_1.vb)]\n [!code-cs[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/csharp/m-system.io.fileinfo.get_1.cs)]"
  syntax:
    content: public System.Security.AccessControl.FileSecurity GetAccessControl ();
    parameters: []
    return:
      type: System.Security.AccessControl.FileSecurity
      description: "A <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref>封裝目前檔案的存取控制規則的物件。"
  overload: System.IO.FileInfo.GetAccessControl*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟檔案時發生 I/O 錯誤。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "目前的作業系統不是 Microsoft Windows 2000 或更新版本。"
  - type: System.Security.AccessControl.PrivilegeNotHeldException
    commentId: T:System.Security.AccessControl.PrivilegeNotHeldException
    description: "目前的系統帳戶沒有系統管理權限。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "找不到檔案。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "目前的平台不支援此作業。       -或者-呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.IO.FileInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)
  id: GetAccessControl(System.Security.AccessControl.AccessControlSections)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: GetAccessControl(AccessControlSections)
  nameWithType: FileInfo.GetAccessControl(AccessControlSections)
  fullName: System.IO.FileInfo.GetAccessControl(AccessControlSections)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>封裝的目前所描述之檔案的存取控制清單 (ACL) 項目之指定的類型的物件<xref href=&quot;System.IO.FileInfo&quot;></xref>物件。"
  remarks: "您可以使用 GetAccessControl 方法來擷取目前的檔案之存取控制清單 (ACL) 項目。       ACL 描述個人及/或群組，讓他們已經有或沒有，在指定的檔案上採取特定動作的權限。 如需詳細資訊，請參閱[如何︰ 加入或移除存取控制清單項目](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public System.Security.AccessControl.FileSecurity GetAccessControl (System.Security.AccessControl.AccessControlSections includeSections);
    parameters:
    - id: includeSections
      type: System.Security.AccessControl.AccessControlSections
      description: "其中一個<xref href=&quot;System.Security.AccessControl.AccessControlSections&quot;></xref>值，指定哪些群組的存取控制擷取的項目。"
    return:
      type: System.Security.AccessControl.FileSecurity
      description: "A <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref>封裝目前檔案的存取控制規則的物件。"
  overload: System.IO.FileInfo.GetAccessControl*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟檔案時發生 I/O 錯誤。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "目前的作業系統不是 Microsoft Windows 2000 或更新版本。"
  - type: System.Security.AccessControl.PrivilegeNotHeldException
    commentId: T:System.Security.AccessControl.PrivilegeNotHeldException
    description: "目前的系統帳戶沒有系統管理權限。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "找不到檔案。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "目前的平台不支援此作業。       -或者-呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.IO.FileInfo.IsReadOnly
  id: IsReadOnly
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: IsReadOnly
  nameWithType: FileInfo.IsReadOnly
  fullName: System.IO.FileInfo.IsReadOnly
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得或設定值，判斷目前檔案是否為唯讀。"
  remarks: "IsReadOnly 屬性用於快速判斷或變更是否目前檔案為唯讀。       第一次呼叫時，<xref:System.IO.FileInfo>呼叫<xref:System.IO.FileSystemInfo.Refresh%2A>和快取檔案的相關資訊。</xref:System.IO.FileSystemInfo.Refresh%2A> </xref:System.IO.FileInfo> 在後續呼叫中，您必須呼叫<xref:System.IO.FileSystemInfo.Refresh%2A>取得資訊的最新的複本。</xref:System.IO.FileSystemInfo.Refresh%2A>"
  example:
  - "The following example uses the IsReadOnly property to mark a file as read only and then mark it as read-write.  \n  \n [!code-cs[IO.FileInfo.IsReadOnly#1](~/add/codesnippet/csharp/p-system.io.fileinfo.isr_1.cs)]\n [!code-vb[IO.FileInfo.IsReadOnly#1](~/add/codesnippet/visualbasic/p-system.io.fileinfo.isr_1.vb)]\n [!code-cpp[IO.FileInfo.IsReadOnly#1](~/add/codesnippet/cpp/p-system.io.fileinfo.isr_1.cpp)]"
  syntax:
    content: public bool IsReadOnly { get; set; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果目前檔案為唯讀。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.FileInfo.IsReadOnly*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "目前所描述的檔案<xref href=&quot;System.IO.FileInfo&quot;></xref>找不到物件。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟檔案時發生 I/O 錯誤。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "目前的平台不支援此作業。       -或者-呼叫端沒有必要的權限。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "使用者沒有寫入權限，但嘗試將此屬性設定為<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  platform:
  - net462
- uid: System.IO.FileInfo.Length
  id: Length
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Length
  nameWithType: FileInfo.Length
  fullName: System.IO.FileInfo.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得大小，以位元組為單位，目前的檔案。"
  remarks: "Length 屬性的值時，預先快取的目前執行個體<xref:System.IO.FileInfo>物件已從下列任何一個傳回<xref:System.IO.DirectoryInfo>方法:- <xref:System.IO.DirectoryInfo.GetDirectories%2A>- <xref:System.IO.DirectoryInfo.GetFiles%2A>- <xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A>- <xref:System.IO.DirectoryInfo.EnumerateDirectories%2A>- <xref:System.IO.DirectoryInfo.EnumerateFiles%2A>-<xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A>若要取得最新的值，呼叫<xref:System.IO.FileSystemInfo.Refresh%2A>方法。</xref:System.IO.FileSystemInfo.Refresh%2A> </xref:System.IO.DirectoryInfo.EnumerateFileSystemInfos%2A> </xref:System.IO.DirectoryInfo.EnumerateFiles%2A> </xref:System.IO.DirectoryInfo.EnumerateDirectories%2A> </xref:System.IO.DirectoryInfo.GetFileSystemInfos%2A> </xref:System.IO.DirectoryInfo.GetFiles%2A> </xref:System.IO.DirectoryInfo.GetDirectories%2A> </xref:System.IO.DirectoryInfo> </xref:System.IO.FileInfo>"
  example:
  - "The following example displays the size of the specified files.  \n  \n [!code-cpp[FileLength#1](~/add/codesnippet/cpp/p-system.io.fileinfo.len_1.cpp)]\n [!code-cs[FileLength#1](~/add/codesnippet/csharp/p-system.io.fileinfo.len_1.cs)]\n [!code-vb[FileLength#1](~/add/codesnippet/visualbasic/p-system.io.fileinfo.len_1.vb)]"
  syntax:
    content: public long Length { get; }
    return:
      type: System.Int64
      description: "目前的檔案，以位元組為單位的大小。"
  overload: System.IO.FileInfo.Length*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "<xref:System.IO.FileSystemInfo.Refresh*>無法更新檔案或目錄的狀態。</xref:System.IO.FileSystemInfo.Refresh*>"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "檔案不存在。       -或- <xref uid=&quot;langword_csharp_Length&quot; name=&quot;Length&quot; href=&quot;&quot;> </xref>屬性稱為目錄。"
  platform:
  - net462
- uid: System.IO.FileInfo.MoveTo(System.String)
  id: MoveTo(System.String)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: MoveTo(String)
  nameWithType: FileInfo.MoveTo(String)
  fullName: System.IO.FileInfo.MoveTo(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "將指定的檔案移至新的位置，並提供指定新的檔案名稱的選項。"
  remarks: "這個方法適用於跨磁碟區。 例如，檔案 c:\\MyFile.txt 可以移至 d:\\public 和重新命名 NewFile.txt。"
  example:
  - "The following example demonstrates moving a file to a different location and renaming the file.  \n  \n [!code-cs[IO.FileInfo.MoveTo#1](~/add/codesnippet/csharp/m-system.io.fileinfo.mov_1.cs)]\n [!code-vb[IO.FileInfo.MoveTo#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.mov_1.vb)]"
  syntax:
    content: public void MoveTo (string destFileName);
    parameters:
    - id: destFileName
      type: System.String
      description: "路徑移動檔案，可以指定不同的檔案名稱。"
  overload: System.IO.FileInfo.MoveTo*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如目的檔案已經存在，或目的地裝置尚未就緒。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>destFileName</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>destFileName</code>是空的、 只包含空格，或包含無效的字元。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code>destFileName</code>是唯讀或為目錄。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到檔案。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路徑、 檔案名稱，或兩者都超出系統定義的長度上限。 例如，windows 平台上，路徑必須少於 248 個字元，和檔案名稱必須少於 260 個字元。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>destFileName</code>包含字串的中間的冒號 （:）。"
  platform:
  - net462
- uid: System.IO.FileInfo.Name
  id: Name
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Name
  nameWithType: FileInfo.Name
  fullName: System.IO.FileInfo.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得檔案的名稱。"
  remarks: "第一次呼叫時，<xref:System.IO.FileInfo>呼叫<xref:System.IO.FileSystemInfo.Refresh%2A>和快取檔案的相關資訊。</xref:System.IO.FileSystemInfo.Refresh%2A> </xref:System.IO.FileInfo> 在後續呼叫中，您必須呼叫<xref:System.IO.FileSystemInfo.Refresh%2A>取得資訊的最新的複本。</xref:System.IO.FileSystemInfo.Refresh%2A>       檔案名稱包含副檔名。"
  example:
  - "The following example uses the `Name` property to display the names of files in the current directory.  \n  \n [!code-cs[fileinfoname#1](~/add/codesnippet/csharp/p-system.io.fileinfo.name_1.cs)]\n [!code-cpp[fileinfoname#1](~/add/codesnippet/cpp/p-system.io.fileinfo.name_1.cpp)]\n [!code-vb[fileinfoname#1](~/add/codesnippet/visualbasic/p-system.io.fileinfo.name_1.vb)]"
  syntax:
    content: public override string Name { get; }
    return:
      type: System.String
      description: "檔案的名稱。"
  overload: System.IO.FileInfo.Name*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileInfo.Open(System.IO.FileMode)
  id: Open(System.IO.FileMode)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Open(FileMode)
  nameWithType: FileInfo.Open(FileMode)
  fullName: System.IO.FileInfo.Open(FileMode)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "以指定模式開啟檔案。"
  remarks: ''
  example:
  - "The following example opens a file, adds some information to the file, and reads the file.  \n  \n [!code-cs[finfo open1#1](~/add/codesnippet/csharp/m-system.io.fileinfo.ope_0_1.cs)]\n [!code-cpp[finfo open1#1](~/add/codesnippet/cpp/m-system.io.fileinfo.ope_0_1.cpp)]\n [!code-vb[finfo open1#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.ope_0_1.vb)]"
  syntax:
    content: public System.IO.FileStream Open (System.IO.FileMode mode);
    parameters:
    - id: mode
      type: System.IO.FileMode
      description: "A <xref href=&quot;System.IO.FileMode&quot;> </xref>常數，指定的模式 (例如， <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref>或<xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;> </xref>)，以開啟檔案。"
    return:
      type: System.IO.FileStream
      description: "一個檔案中指定的模式，以讀取/寫入存取開啟，且不共用。"
  overload: System.IO.FileInfo.Open*
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到檔案。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "檔案是唯讀，或為目錄。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案已經開啟。"
  platform:
  - net462
- uid: System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess)
  id: Open(System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Open(FileMode,FileAccess)
  nameWithType: FileInfo.Open(FileMode,FileAccess)
  fullName: System.IO.FileInfo.Open(FileMode,FileAccess)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "開啟檔案中指定的模式和讀取、 寫入或讀取/寫入存取。"
  remarks: ''
  example:
  - "The following example opens a file as read-only and reads from the file.  \n  \n [!code-vb[finfo open2#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.ope_2_1.vb)]\n [!code-cpp[finfo open2#1](~/add/codesnippet/cpp/m-system.io.fileinfo.ope_2_1.cpp)]\n [!code-cs[finfo open2#1](~/add/codesnippet/csharp/m-system.io.fileinfo.ope_2_1.cs)]"
  syntax:
    content: public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: mode
      type: System.IO.FileMode
      description: "A <xref href=&quot;System.IO.FileMode&quot;> </xref>常數，指定的模式 (例如， <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref>或<xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;> </xref>)，以開啟檔案。"
    - id: access
      type: System.IO.FileAccess
      description: "A <xref href=&quot;System.IO.FileAccess&quot;> </xref>常數，指定是否要開啟副檔名為<xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>， <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>，或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>檔案存取。"
    return:
      type: System.IO.FileStream
      description: "A <xref href=&quot;System.IO.FileStream&quot;> </xref>開啟於指定的模式和存取，且為不共用的物件。"
  overload: System.IO.FileInfo.Open*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到檔案。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code>path</code>是唯讀或為目錄。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案已經開啟。"
  platform:
  - net462
- uid: System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Open(FileMode,FileAccess,FileShare)
  nameWithType: FileInfo.Open(FileMode,FileAccess,FileShare)
  fullName: System.IO.FileInfo.Open(FileMode,FileAccess,FileShare)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "讀取、 寫入或讀取/寫入存取和指定的共用選項與指定的模式中開啟檔案。"
  remarks: ''
  example:
  - "The following example demonstrates opening a file for reading and writing, but disallowing access to other users or processes.  \n  \n [!code-cpp[fileinfoopen#1](~/add/codesnippet/cpp/8bd38f9d-a8ac-4cea-8fda-_1.cpp)]\n [!code-cs[fileinfoopen#1](~/add/codesnippet/csharp/8bd38f9d-a8ac-4cea-8fda-_1.cs)]\n [!code-vb[fileinfoopen#1](~/add/codesnippet/visualbasic/8bd38f9d-a8ac-4cea-8fda-_1.vb)]"
  syntax:
    content: public System.IO.FileStream Open (System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: mode
      type: System.IO.FileMode
      description: "A <xref href=&quot;System.IO.FileMode&quot;> </xref>常數，指定的模式 (例如， <xref uid=&quot;langword_csharp_Open&quot; name=&quot;Open&quot; href=&quot;&quot;> </xref>或<xref uid=&quot;langword_csharp_Append&quot; name=&quot;Append&quot; href=&quot;&quot;> </xref>)，以開啟檔案。"
    - id: access
      type: System.IO.FileAccess
      description: "A <xref href=&quot;System.IO.FileAccess&quot;> </xref>常數，指定是否要開啟副檔名為<xref uid=&quot;langword_csharp_Read&quot; name=&quot;Read&quot; href=&quot;&quot;> </xref>， <xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;> </xref>，或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>檔案存取。"
    - id: share
      type: System.IO.FileShare
      description: "A <xref href=&quot;System.IO.FileShare&quot;> </xref>常數，指定的型別存取其他<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件對這個檔案。"
    return:
      type: System.IO.FileStream
      description: "A <xref href=&quot;System.IO.FileStream&quot;> </xref>物件開啟與指定的模式、 存取和共用選項。"
  overload: System.IO.FileInfo.Open*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到檔案。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code>path</code>是唯讀或為目錄。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案已經開啟。"
  platform:
  - net462
- uid: System.IO.FileInfo.OpenRead
  id: OpenRead
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: OpenRead()
  nameWithType: FileInfo.OpenRead()
  fullName: System.IO.FileInfo.OpenRead()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "建立唯讀<xref href=&quot;System.IO.FileStream&quot;> </xref>。"
  remarks: "這個方法會傳回唯讀<xref:System.IO.FileStream><xref:System.IO.FileShare>模式設定為<xref:System.IO.FileShare>.</xref:System.IO.FileShare></xref:System.IO.FileShare>物件</xref:System.IO.FileStream>"
  example:
  - "The following example opens a file as read-only and reads from it.  \n  \n [!code-vb[finfo openread#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.ope_4_1.vb)]\n [!code-cs[finfo openread#1](~/add/codesnippet/csharp/m-system.io.fileinfo.ope_4_1.cs)]\n [!code-cpp[finfo openread#1](~/add/codesnippet/cpp/m-system.io.fileinfo.ope_4_1.cpp)]"
  syntax:
    content: public System.IO.FileStream OpenRead ();
    parameters: []
    return:
      type: System.IO.FileStream
      description: "新唯讀<xref href=&quot;System.IO.FileStream&quot;></xref>物件。"
  overload: System.IO.FileInfo.OpenRead*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code>path</code>是唯讀或為目錄。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "檔案已經開啟。"
  platform:
  - net462
- uid: System.IO.FileInfo.OpenText
  id: OpenText
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: OpenText()
  nameWithType: FileInfo.OpenText()
  fullName: System.IO.FileInfo.OpenText()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "建立<xref:System.IO.StreamReader>具有 UTF8 編碼方式，可從現有文字檔讀取。</xref:System.IO.StreamReader>"
  remarks: ''
  example:
  - "The following example reads text from a file.  \n  \n [!code-cpp[finfo opentext#1](~/add/codesnippet/cpp/m-system.io.fileinfo.ope_1_1.cpp)]\n [!code-cs[finfo opentext#1](~/add/codesnippet/csharp/m-system.io.fileinfo.ope_1_1.cs)]\n [!code-vb[finfo opentext#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.ope_1_1.vb)]"
  syntax:
    content: public System.IO.StreamReader OpenText ();
    parameters: []
    return:
      type: System.IO.StreamReader
      description: "新<xref uid=&quot;langword_csharp_StreamReader&quot; name=&quot;StreamReader&quot; href=&quot;&quot;></xref>具有 UTF8 編碼方式。"
  overload: System.IO.FileInfo.OpenText*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到檔案。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code>path</code>是唯讀或為目錄。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  platform:
  - net462
- uid: System.IO.FileInfo.OpenWrite
  id: OpenWrite
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: OpenWrite()
  nameWithType: FileInfo.OpenWrite()
  fullName: System.IO.FileInfo.OpenWrite()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "建立唯寫<xref href=&quot;System.IO.FileStream&quot;> </xref>。"
  remarks: "OpenWrite 方法開啟的檔案，其中一個已存在的檔案路徑，或如果不存在的話，會建立新的檔案。 現有的檔案，它不會將新的文字附加至現有的文字。 相反地，它會覆寫現有的字元與新的字元。 如果您覆寫較長的字串 （例如，&quot;This is OpenWrite 方法的測試)&quot;使用較短的字串 （例如 [第二個執行]），檔案會包含字串的混合 (「 第二個 runtest OpenWrite 方法的&quot;)。"
  example:
  - "The following example opens a file for writing and then reads from the file.  \n  \n [!code-cs[finfo openwrite#1](~/add/codesnippet/csharp/m-system.io.fileinfo.ope_3_1.cs)]\n [!code-vb[finfo openwrite#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.ope_3_1.vb)]\n [!code-cpp[finfo openwrite#1](~/add/codesnippet/cpp/m-system.io.fileinfo.ope_3_1.cpp)]"
  syntax:
    content: public System.IO.FileStream OpenWrite ();
    parameters: []
    return:
      type: System.IO.FileStream
      description: "唯寫非共用<xref href=&quot;System.IO.FileStream&quot;></xref>新的或現有的檔案物件。"
  overload: System.IO.FileInfo.OpenWrite*
  exceptions:
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "建立的執行個體時指定的路徑<xref href=&quot;System.IO.FileInfo&quot;></xref>物件是唯讀或為目錄。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "建立的執行個體時指定的路徑<xref href=&quot;System.IO.FileInfo&quot;></xref>物件無效，例如位於未對應的磁碟機上。"
  platform:
  - net462
- uid: System.IO.FileInfo.Replace(System.String,System.String)
  id: Replace(System.String,System.String)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Replace(String,String)
  nameWithType: FileInfo.Replace(String,String)
  fullName: System.IO.FileInfo.Replace(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "目前所描述的檔案，取代指定檔案的內容<xref href=&quot;System.IO.FileInfo&quot;></xref>物件，刪除原始檔案，並建立已取代檔案的備份。"
  remarks: "Replace 方法目前所描述之檔案的內容，取代指定檔案的內容<xref:System.IO.FileInfo>物件。</xref:System.IO.FileInfo>  它也會建立已取代檔案的備份。  最後，它會傳回新<xref:System.IO.FileInfo>描述覆寫的檔案的物件。</xref:System.IO.FileInfo>      > [!CAUTION] > 如果，這個方法會在 Windows 2000 環境中成功`destFileName`處於唯讀狀態，並將不會引發例外狀況。 使用<xref:System.IO.FileInfo.IsReadOnly%2A>屬性來檢查目的地檔案是否為唯讀，然後再嘗試將取代它。</xref:System.IO.FileInfo.IsReadOnly%2A>       傳遞`null`至`destBackupFileName`參數，如果您不想建立已取代檔案的備份。"
  example:
  - "The following example uses the <xref:System.IO.File.Replace%2A> method to replace a file with another file and create a backup of the replaced file.  \n  \n [!code-cs[IO.FileInfo.Replace#1](~/add/codesnippet/csharp/m-system.io.fileinfo.rep_0_1.cs)]\n [!code-vb[IO.FileInfo.Replace#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.rep_0_1.vb)]\n [!code-cpp[IO.FileInfo.Replace#1](~/add/codesnippet/cpp/m-system.io.fileinfo.rep_0_1.cpp)]"
  syntax:
    content: public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName);
    parameters:
    - id: destinationFileName
      type: System.String
      description: "要使用目前檔案取代之檔案的名稱。"
    - id: destinationBackupFileName
      type: System.String
      description: "用來建立所描述之檔案的備份檔案的名稱`destFileName`參數。"
    return:
      type: System.IO.FileInfo
      description: "A <xref href=&quot;System.IO.FileInfo&quot;> </xref>封裝所描述之檔案的相關資訊的物件<code> destFileName </code>參數。"
  overload: System.IO.FileInfo.Replace*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "描述的路徑<code> destFileName </code>參數不是合法的表單。       -描述的路徑<code> destBackupFileName </code>參數不是合法的表單。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>destFileName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "目前所描述的檔案<xref href=&quot;System.IO.FileInfo&quot;></xref>找不到物件。       -所描述的檔案<code> destinationFileName </code>找不到參數。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "目前的作業系統不是 Microsoft Windows NT 或更新版本。"
  platform:
  - net462
- uid: System.IO.FileInfo.Replace(System.String,System.String,System.Boolean)
  id: Replace(System.String,System.String,System.Boolean)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: Replace(String,String,Boolean)
  nameWithType: FileInfo.Replace(String,String,Boolean)
  fullName: System.IO.FileInfo.Replace(String,String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "目前所描述的檔案，取代指定檔案的內容<xref href=&quot;System.IO.FileInfo&quot;></xref>物件，刪除原始檔案，並建立已取代檔案的備份。  也會指定是否忽略合併錯誤。"
  remarks: "Replace 方法目前所描述之檔案的內容，取代指定檔案的內容<xref:System.IO.FileInfo>物件。</xref:System.IO.FileInfo>  它也會建立已取代檔案的備份。  最後，它會傳回新<xref:System.IO.FileInfo>描述覆寫的檔案的物件。</xref:System.IO.FileInfo>      > [!CAUTION] > 如果，這個方法會在 Windows 2000 環境中成功`destFileName`處於唯讀狀態，並將不會引發例外狀況。 使用<xref:System.IO.FileInfo.IsReadOnly%2A>屬性來檢查目的地檔案是否為唯讀，然後再嘗試將取代它。</xref:System.IO.FileInfo.IsReadOnly%2A>       傳遞`null`至`destBackupFileName`參數，如果您不想建立已取代檔案的備份。"
  example:
  - "The following example uses the <xref:System.IO.File.Replace%2A> method to replace a file with another file and create a backup of the replaced file.  \n  \n [!code-cs[IO.FileInfo.Replace#1](~/add/codesnippet/csharp/m-system.io.fileinfo.rep_1_1.cs)]\n [!code-vb[IO.FileInfo.Replace#1](~/add/codesnippet/visualbasic/m-system.io.fileinfo.rep_1_1.vb)]\n [!code-cpp[IO.FileInfo.Replace#1](~/add/codesnippet/cpp/m-system.io.fileinfo.rep_1_1.cpp)]"
  syntax:
    content: public System.IO.FileInfo Replace (string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    parameters:
    - id: destinationFileName
      type: System.String
      description: "要使用目前檔案取代之檔案的名稱。"
    - id: destinationBackupFileName
      type: System.String
      description: "用來建立所描述之檔案的備份檔案的名稱`destFileName`參數。"
    - id: ignoreMetadataErrors
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要取代檔案忽略合併錯誤 （例如屬性和 Acl），取代檔案否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.IO.FileInfo
      description: "A <xref href=&quot;System.IO.FileInfo&quot;> </xref>封裝所描述之檔案的相關資訊的物件<code> destFileName </code>參數。"
  overload: System.IO.FileInfo.Replace*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "描述的路徑<code> destFileName </code>參數不是合法的表單。       -描述的路徑<code> destBackupFileName </code>參數不是合法的表單。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>destFileName</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "目前所描述的檔案<xref href=&quot;System.IO.FileInfo&quot;></xref>找不到物件。       -所描述的檔案<code> destinationFileName </code>找不到參數。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "目前的作業系統不是 Microsoft Windows NT 或更新版本。"
  platform:
  - net462
- uid: System.IO.FileInfo.SetAccessControl(System.Security.AccessControl.FileSecurity)
  id: SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: SetAccessControl(FileSecurity)
  nameWithType: FileInfo.SetAccessControl(FileSecurity)
  fullName: System.IO.FileInfo.SetAccessControl(FileSecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "適用於所描述的存取控制清單 (ACL) 項目<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>目前所描述之檔案的物件<xref href=&quot;System.IO.FileInfo&quot;></xref>物件。"
  remarks: "SetAccessControl 方法套用至目前的檔案，表示 noninherited 的 ACL 清單的存取控制清單 (ACL) 項目。       每當您需要新增或移除檔案的 ACL 項目，請使用 SetAccessControl 方法。      > [!CAUTION] > ACL 指定`fileSecurity`參數已取代現有檔案的 ACL。 若要加入之新使用者的權限，請使用<xref:System.IO.Directory.GetAccessControl%2A>方法來取得現有的 ACL、 修改它，然後使用 SetAccessControl 來套用該備份檔案。</xref:System.IO.Directory.GetAccessControl%2A>       ACL 描述個人及/或群組，讓他們已經有或沒有，在指定的檔案上採取特定動作的權限。 如需詳細資訊，請參閱[如何︰ 加入或移除存取控制清單項目](~/add/includes/ajax-current-ext-md.md)。       只保存 SetAccessControl 方法<xref:System.Security.AccessControl.FileSecurity>物件建立後已修改的物件。</xref:System.Security.AccessControl.FileSecurity>  如果<xref:System.Security.AccessControl.FileSecurity>不修改物件，不會保存至檔案。</xref:System.Security.AccessControl.FileSecurity>  因此，不可以擷取<xref:System.Security.AccessControl.FileSecurity>物件從一個檔案，並重新套用到另一個檔案的相同物件。</xref:System.Security.AccessControl.FileSecurity>       若要將 ACL 資訊從一個檔案複製到另一個︰ 1。  使用<xref:System.IO.FileInfo.GetAccessControl%2A>方法來擷取<xref:System.Security.AccessControl.FileSecurity>從原始程式檔的物件。</xref:System.Security.AccessControl.FileSecurity> </xref:System.IO.FileInfo.GetAccessControl%2A>      2.  建立新<xref:System.Security.AccessControl.FileSecurity>目的地檔案的物件。</xref:System.Security.AccessControl.FileSecurity>      3.  使用<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>或<xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A>來源方法<xref:System.Security.AccessControl.FileSecurity>擷取 ACL 資訊的物件。</xref:System.Security.AccessControl.FileSecurity> </xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A>      4.  使用<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A>或<xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A>方法可複製的資訊擷取到目的地的步驟 3 中<xref:System.Security.AccessControl.FileSecurity>物件。</xref:System.Security.AccessControl.FileSecurity> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> </xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A>      5.  設定目的地<xref:System.Security.AccessControl.FileSecurity>使用 SetAccessControl 方法的目的檔案的物件。</xref:System.Security.AccessControl.FileSecurity>"
  example:
  - "The following code example uses the <xref:System.IO.FileInfo.GetAccessControl%2A> method and the SetAccessControl method to add and then remove an ACL entry from a file.  You must supply a valid user or group account to run this example.  \n  \n [!code-cpp[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/cpp/c24a4717-31ac-4834-901c-_1.cpp)]\n [!code-vb[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/visualbasic/c24a4717-31ac-4834-901c-_1.vb)]\n [!code-cs[IO.FileInfo.GetAccessControl-SetAccessControl#1](~/add/codesnippet/csharp/c24a4717-31ac-4834-901c-_1.cs)]"
  syntax:
    content: public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "A <xref href=&quot;System.Security.AccessControl.FileSecurity&quot;> </xref>物件，描述要套用至目前檔案的存取控制清單 (ACL) 項目。"
  overload: System.IO.FileInfo.SetAccessControl*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>fileSecurity</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "找不到或無法修改檔案。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "目前的處理序沒有開啟檔案的存取權。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "目前的作業系統不是 Microsoft Windows 2000 或更新版本。"
  platform:
  - net462
- uid: System.IO.FileInfo.ToString
  id: ToString
  parent: System.IO.FileInfo
  langs:
  - csharp
  name: ToString()
  nameWithType: FileInfo.ToString()
  fullName: System.IO.FileInfo.ToString()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "將路徑當做字串傳回。"
  remarks: "ToString 方法所傳回的字串表示傳遞給建構函式的路徑。  當您建立<xref:System.IO.FileInfo>物件使用建構函式，ToString 方法會傳回完整路徑。</xref:System.IO.FileInfo>  不過，有些情況是 ToString 方法所傳回的字串不是完整的路徑。  例如，當您建立的<xref:System.IO.FileInfo>物件使用的<xref:System.IO.DirectoryInfo.GetFiles%2A>方法，ToString 方法不是完整路徑。</xref:System.IO.DirectoryInfo.GetFiles%2A> </xref:System.IO.FileInfo>"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: "表示路徑的字串。"
  overload: System.IO.FileInfo.ToString*
  exceptions: []
  platform:
  - net462
references:
- uid: System.IO.FileSystemInfo
  isExternal: false
  name: System.IO.FileSystemInfo
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.DriveNotFoundException
  parent: System.IO
  isExternal: false
  name: DriveNotFoundException
  nameWithType: DriveNotFoundException
  fullName: System.IO.DriveNotFoundException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.Security.AccessControl.PrivilegeNotHeldException
  parent: System.Security.AccessControl
  isExternal: false
  name: PrivilegeNotHeldException
  nameWithType: PrivilegeNotHeldException
  fullName: System.Security.AccessControl.PrivilegeNotHeldException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.IO.FileInfo.#ctor(System.String)
  parent: System.IO.FileInfo
  isExternal: false
  name: FileInfo(String)
  nameWithType: FileInfo.FileInfo(String)
  fullName: System.IO.FileInfo.FileInfo(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileInfo.AppendText
  parent: System.IO.FileInfo
  isExternal: false
  name: AppendText()
  nameWithType: FileInfo.AppendText()
  fullName: System.IO.FileInfo.AppendText()
- uid: System.IO.StreamWriter
  parent: System.IO
  isExternal: true
  name: StreamWriter
  nameWithType: StreamWriter
  fullName: System.IO.StreamWriter
- uid: System.IO.FileInfo.CopyTo(System.String)
  parent: System.IO.FileInfo
  isExternal: false
  name: CopyTo(String)
  nameWithType: FileInfo.CopyTo(String)
  fullName: System.IO.FileInfo.CopyTo(String)
- uid: System.IO.FileInfo
  parent: System.IO
  isExternal: false
  name: FileInfo
  nameWithType: FileInfo
  fullName: System.IO.FileInfo
- uid: System.IO.FileInfo.CopyTo(System.String,System.Boolean)
  parent: System.IO.FileInfo
  isExternal: false
  name: CopyTo(String,Boolean)
  nameWithType: FileInfo.CopyTo(String,Boolean)
  fullName: System.IO.FileInfo.CopyTo(String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.FileInfo.Create
  parent: System.IO.FileInfo
  isExternal: false
  name: Create()
  nameWithType: FileInfo.Create()
  fullName: System.IO.FileInfo.Create()
- uid: System.IO.FileStream
  parent: System.IO
  isExternal: false
  name: FileStream
  nameWithType: FileStream
  fullName: System.IO.FileStream
- uid: System.IO.FileInfo.CreateText
  parent: System.IO.FileInfo
  isExternal: false
  name: CreateText()
  nameWithType: FileInfo.CreateText()
  fullName: System.IO.FileInfo.CreateText()
- uid: System.IO.FileInfo.Decrypt
  parent: System.IO.FileInfo
  isExternal: false
  name: Decrypt()
  nameWithType: FileInfo.Decrypt()
  fullName: System.IO.FileInfo.Decrypt()
- uid: System.IO.FileInfo.Delete
  parent: System.IO.FileInfo
  isExternal: false
  name: Delete()
  nameWithType: FileInfo.Delete()
  fullName: System.IO.FileInfo.Delete()
- uid: System.IO.FileInfo.Directory
  parent: System.IO.FileInfo
  isExternal: false
  name: Directory
  nameWithType: FileInfo.Directory
  fullName: System.IO.FileInfo.Directory
- uid: System.IO.DirectoryInfo
  parent: System.IO
  isExternal: false
  name: DirectoryInfo
  nameWithType: DirectoryInfo
  fullName: System.IO.DirectoryInfo
- uid: System.IO.FileInfo.DirectoryName
  parent: System.IO.FileInfo
  isExternal: false
  name: DirectoryName
  nameWithType: FileInfo.DirectoryName
  fullName: System.IO.FileInfo.DirectoryName
- uid: System.IO.FileInfo.Encrypt
  parent: System.IO.FileInfo
  isExternal: false
  name: Encrypt()
  nameWithType: FileInfo.Encrypt()
  fullName: System.IO.FileInfo.Encrypt()
- uid: System.IO.FileInfo.Exists
  parent: System.IO.FileInfo
  isExternal: false
  name: Exists
  nameWithType: FileInfo.Exists
  fullName: System.IO.FileInfo.Exists
- uid: System.IO.FileInfo.GetAccessControl
  parent: System.IO.FileInfo
  isExternal: false
  name: GetAccessControl()
  nameWithType: FileInfo.GetAccessControl()
  fullName: System.IO.FileInfo.GetAccessControl()
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.FileInfo.GetAccessControl(System.Security.AccessControl.AccessControlSections)
  parent: System.IO.FileInfo
  isExternal: false
  name: GetAccessControl(AccessControlSections)
  nameWithType: FileInfo.GetAccessControl(AccessControlSections)
  fullName: System.IO.FileInfo.GetAccessControl(AccessControlSections)
- uid: System.Security.AccessControl.AccessControlSections
  parent: System.Security.AccessControl
  isExternal: false
  name: AccessControlSections
  nameWithType: AccessControlSections
  fullName: System.Security.AccessControl.AccessControlSections
- uid: System.IO.FileInfo.IsReadOnly
  parent: System.IO.FileInfo
  isExternal: false
  name: IsReadOnly
  nameWithType: FileInfo.IsReadOnly
  fullName: System.IO.FileInfo.IsReadOnly
- uid: System.IO.FileInfo.Length
  parent: System.IO.FileInfo
  isExternal: false
  name: Length
  nameWithType: FileInfo.Length
  fullName: System.IO.FileInfo.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.FileInfo.MoveTo(System.String)
  parent: System.IO.FileInfo
  isExternal: false
  name: MoveTo(String)
  nameWithType: FileInfo.MoveTo(String)
  fullName: System.IO.FileInfo.MoveTo(String)
- uid: System.IO.FileInfo.Name
  parent: System.IO.FileInfo
  isExternal: false
  name: Name
  nameWithType: FileInfo.Name
  fullName: System.IO.FileInfo.Name
- uid: System.IO.FileInfo.Open(System.IO.FileMode)
  parent: System.IO.FileInfo
  isExternal: false
  name: Open(FileMode)
  nameWithType: FileInfo.Open(FileMode)
  fullName: System.IO.FileInfo.Open(FileMode)
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.FileInfo
  isExternal: false
  name: Open(FileMode,FileAccess)
  nameWithType: FileInfo.Open(FileMode,FileAccess)
  fullName: System.IO.FileInfo.Open(FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.FileInfo
  isExternal: false
  name: Open(FileMode,FileAccess,FileShare)
  nameWithType: FileInfo.Open(FileMode,FileAccess,FileShare)
  fullName: System.IO.FileInfo.Open(FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.FileInfo.OpenRead
  parent: System.IO.FileInfo
  isExternal: false
  name: OpenRead()
  nameWithType: FileInfo.OpenRead()
  fullName: System.IO.FileInfo.OpenRead()
- uid: System.IO.FileInfo.OpenText
  parent: System.IO.FileInfo
  isExternal: false
  name: OpenText()
  nameWithType: FileInfo.OpenText()
  fullName: System.IO.FileInfo.OpenText()
- uid: System.IO.StreamReader
  parent: System.IO
  isExternal: true
  name: StreamReader
  nameWithType: StreamReader
  fullName: System.IO.StreamReader
- uid: System.IO.FileInfo.OpenWrite
  parent: System.IO.FileInfo
  isExternal: false
  name: OpenWrite()
  nameWithType: FileInfo.OpenWrite()
  fullName: System.IO.FileInfo.OpenWrite()
- uid: System.IO.FileInfo.Replace(System.String,System.String)
  parent: System.IO.FileInfo
  isExternal: false
  name: Replace(String,String)
  nameWithType: FileInfo.Replace(String,String)
  fullName: System.IO.FileInfo.Replace(String,String)
- uid: System.IO.FileInfo.Replace(System.String,System.String,System.Boolean)
  parent: System.IO.FileInfo
  isExternal: false
  name: Replace(String,String,Boolean)
  nameWithType: FileInfo.Replace(String,String,Boolean)
  fullName: System.IO.FileInfo.Replace(String,String,Boolean)
- uid: System.IO.FileInfo.SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileInfo
  isExternal: false
  name: SetAccessControl(FileSecurity)
  nameWithType: FileInfo.SetAccessControl(FileSecurity)
  fullName: System.IO.FileInfo.SetAccessControl(FileSecurity)
- uid: System.IO.FileInfo.ToString
  parent: System.IO.FileInfo
  isExternal: false
  name: ToString()
  nameWithType: FileInfo.ToString()
  fullName: System.IO.FileInfo.ToString()
- uid: System.IO.FileInfo.#ctor*
  parent: System.IO.FileInfo
  isExternal: false
  name: FileInfo
  nameWithType: FileInfo.FileInfo
- uid: System.IO.FileInfo.AppendText*
  parent: System.IO.FileInfo
  isExternal: false
  name: AppendText
  nameWithType: FileInfo.AppendText
- uid: System.IO.FileInfo.CopyTo*
  parent: System.IO.FileInfo
  isExternal: false
  name: CopyTo
  nameWithType: FileInfo.CopyTo
- uid: System.IO.FileInfo.Create*
  parent: System.IO.FileInfo
  isExternal: false
  name: Create
  nameWithType: FileInfo.Create
- uid: System.IO.FileInfo.CreateText*
  parent: System.IO.FileInfo
  isExternal: false
  name: CreateText
  nameWithType: FileInfo.CreateText
- uid: System.IO.FileInfo.Decrypt*
  parent: System.IO.FileInfo
  isExternal: false
  name: Decrypt
  nameWithType: FileInfo.Decrypt
- uid: System.IO.FileInfo.Delete*
  parent: System.IO.FileInfo
  isExternal: false
  name: Delete
  nameWithType: FileInfo.Delete
- uid: System.IO.FileInfo.Directory*
  parent: System.IO.FileInfo
  isExternal: false
  name: Directory
  nameWithType: FileInfo.Directory
- uid: System.IO.FileInfo.DirectoryName*
  parent: System.IO.FileInfo
  isExternal: false
  name: DirectoryName
  nameWithType: FileInfo.DirectoryName
- uid: System.IO.FileInfo.Encrypt*
  parent: System.IO.FileInfo
  isExternal: false
  name: Encrypt
  nameWithType: FileInfo.Encrypt
- uid: System.IO.FileInfo.Exists*
  parent: System.IO.FileInfo
  isExternal: false
  name: Exists
  nameWithType: FileInfo.Exists
- uid: System.IO.FileInfo.GetAccessControl*
  parent: System.IO.FileInfo
  isExternal: false
  name: GetAccessControl
  nameWithType: FileInfo.GetAccessControl
- uid: System.IO.FileInfo.IsReadOnly*
  parent: System.IO.FileInfo
  isExternal: false
  name: IsReadOnly
  nameWithType: FileInfo.IsReadOnly
- uid: System.IO.FileInfo.Length*
  parent: System.IO.FileInfo
  isExternal: false
  name: Length
  nameWithType: FileInfo.Length
- uid: System.IO.FileInfo.MoveTo*
  parent: System.IO.FileInfo
  isExternal: false
  name: MoveTo
  nameWithType: FileInfo.MoveTo
- uid: System.IO.FileInfo.Name*
  parent: System.IO.FileInfo
  isExternal: false
  name: Name
  nameWithType: FileInfo.Name
- uid: System.IO.FileInfo.Open*
  parent: System.IO.FileInfo
  isExternal: false
  name: Open
  nameWithType: FileInfo.Open
- uid: System.IO.FileInfo.OpenRead*
  parent: System.IO.FileInfo
  isExternal: false
  name: OpenRead
  nameWithType: FileInfo.OpenRead
- uid: System.IO.FileInfo.OpenText*
  parent: System.IO.FileInfo
  isExternal: false
  name: OpenText
  nameWithType: FileInfo.OpenText
- uid: System.IO.FileInfo.OpenWrite*
  parent: System.IO.FileInfo
  isExternal: false
  name: OpenWrite
  nameWithType: FileInfo.OpenWrite
- uid: System.IO.FileInfo.Replace*
  parent: System.IO.FileInfo
  isExternal: false
  name: Replace
  nameWithType: FileInfo.Replace
- uid: System.IO.FileInfo.SetAccessControl*
  parent: System.IO.FileInfo
  isExternal: false
  name: SetAccessControl
  nameWithType: FileInfo.SetAccessControl
- uid: System.IO.FileInfo.ToString*
  parent: System.IO.FileInfo
  isExternal: false
  name: ToString
  nameWithType: FileInfo.ToString
