### YamlMime:ManagedReference
items:
- uid: System.IO.FileStream
  id: FileStream
  children:
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  - System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.FileStream.CanRead
  - System.IO.FileStream.CanSeek
  - System.IO.FileStream.CanWrite
  - System.IO.FileStream.Dispose(System.Boolean)
  - System.IO.FileStream.EndRead(System.IAsyncResult)
  - System.IO.FileStream.EndWrite(System.IAsyncResult)
  - System.IO.FileStream.Finalize
  - System.IO.FileStream.Flush
  - System.IO.FileStream.Flush(System.Boolean)
  - System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.FileStream.GetAccessControl
  - System.IO.FileStream.Handle
  - System.IO.FileStream.IsAsync
  - System.IO.FileStream.Length
  - System.IO.FileStream.Lock(System.Int64,System.Int64)
  - System.IO.FileStream.Name
  - System.IO.FileStream.Position
  - System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.ReadByte
  - System.IO.FileStream.SafeFileHandle
  - System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.SetLength(System.Int64)
  - System.IO.FileStream.Unlock(System.Int64,System.Int64)
  - System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: FileStream
  nameWithType: FileStream
  fullName: System.IO.FileStream
  type: Class
  summary: "提供<xref:System.IO.Stream>檔案，同時支援同步與非同步讀取和寫入作業。</xref:System.IO.Stream>       若要瀏覽此類型的.NET Framework 原始程式碼，請參閱[參考來源](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3)。"
  remarks: "> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n Use the FileStream class to read from, write to, open, and close files on a file system, and to manipulate other file-related operating system handles, including pipes, standard input, and standard output. You can use the [Read(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), [Write(Byte\\[\\], Int32, Int32)](assetId:///M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=True), <xref:System.IO.Stream.CopyTo%2A>, and <xref:System.IO.FileStream.Flush%2A> methods to perform synchronous operations, or the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, and <xref:System.IO.FileStream.FlushAsync%2A> methods to perform asynchronous operations. Use the asynchronous methods to perform resource-intensive file operations without blocking the main thread. This performance consideration is particularly important in a [!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)] app or [!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)] app where a time-consuming stream operation can block the UI thread and make your app appear as if it is not working. FileStream buffers input and output for better performance.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref:System.IDisposable> interface topic.  \n  \n The <xref:System.IO.FileStream.IsAsync%2A> property detects whether the file handle was opened asynchronously. You specify this value when you create an instance of the FileStream class using a constructor that has an `isAsync`, `useAsync`, or `options` parameter. When the property is `true`, the stream utilizes overlapped I/O to perform file operations asynchronously. However, the <xref:System.IO.FileStream.IsAsync%2A> property does not have to be `true` to call the <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, or <xref:System.IO.Stream.CopyToAsync%2A> method. When the <xref:System.IO.FileStream.IsAsync%2A> property is `false` and you call the asynchronous read and write operations, the UI thread is still not blocked, but the actual I/O operation is performed synchronously.  \n  \n The <xref:System.IO.FileStream.Seek%2A> method supports random access to files. <xref:System.IO.FileStream.Seek%2A> allows the read/write position to be moved to any position within the file. This is done with byte offset reference point parameters. The byte offset is relative to the seek reference point, which can be the beginning, the current position, or the end of the underlying file, as represented by the three members of the <xref:System.IO.SeekOrigin> enumeration.  \n  \n> [!NOTE]\n>  Disk files always support random access. At the time of construction, the <xref:System.IO.FileStream.CanSeek%2A> property value is set to `true` or `false` depending on the underlying file type.If the underlying file type is FILE_TYPE_DISK, as defined in winbase.h, the <xref:System.IO.FileStream.CanSeek%2A> property value is `true`. Otherwise, the <xref:System.IO.FileStream.CanSeek%2A> property value is `false`.  \n  \n If a process terminates with part of a file locked or closes a file that has outstanding locks, the behavior is undefined.  \n  \n For directory operations and other file operations, see the <xref:System.IO.File>, <xref:System.IO.Directory>, and <xref:System.IO.Path> classes. The <xref:System.IO.File> class is a utility class that has static methods primarily for the creation of FileStream objects based on file paths. The <xref:System.IO.MemoryStream> class creates a stream from a byte array and is similar to the FileStream class.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md).  \n  \n## Detection of Stream Position Changes  \n When a FileStream object does not have an exclusive hold on its handle, another thread could access the file handle concurrently and change the position of the operating system's file pointer that is associated with the file handle. In this case, the cached position in the FileStream object and the cached data in the buffer could be compromised. The FileStream object routinely performs checks on methods that access the cached buffer to ensure that the operating system's handle position is the same as the cached position used by the FileStream object.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Read%2A> method, the .NET Framework discards the contents of the buffer and reads the stream from the file again. This can affect performance, depending on the size of the file and any other processes that could affect the position of the file stream.  \n  \n If an unexpected change in the handle position is detected in a call to the <xref:System.IO.FileStream.Write%2A> method, the contents of the buffer are discarded and an <xref:System.IO.IOException> exception is thrown.  \n  \n A FileStream object will not have an exclusive hold on its handle when either the <xref:System.IO.FileStream.SafeFileHandle%2A> property is accessed to expose the handle or the FileStream object is given the <xref:System.IO.FileStream.SafeFileHandle%2A> property in its constructor."
  example:
  - "The following example demonstrates some of the FileStream constructors.  \n  \n [!code-cs[fstream class#1](~/add/codesnippet/csharp/t-system.io.filestream_1.cs)]\n [!code-vb[fstream class#1](~/add/codesnippet/visualbasic/t-system.io.filestream_1.vb)]\n [!code-cpp[fstream class#1](~/add/codesnippet/cpp/t-system.io.filestream_1.cpp)]  \n  \n The following example shows how to write to a file asynchronously. This code runs in a WPF app that has a TextBlock named UserInput and a button hooked up to a Click event handler that is named Button_Click. The file path needs to be changed to a file than exits on the computer.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/t-system.io.filestream_2.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/t-system.io.filestream_2.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class FileStream : System.IO.Stream
  inheritance:
  - System.IO.Stream
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>類別指定的檔案控制代碼，以指定的讀取/寫入權限。"
  remarks: "當<xref:System.IO.Stream.Close%2A>是呼叫，此控制代碼，也會關閉和檔案的控制碼計數會遞減。</xref:System.IO.Stream.Close%2A>       `FileStream`假設它有控制代碼的專有控制權。 讀取、 寫入，或搜尋時`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全呼叫<xref:System.IO.FileStream.Flush%2A>之前使用此控制代碼，並避免呼叫任何方法以外`Close`完成之後使用此控制代碼。</xref:System.IO.FileStream.Flush%2A>      > [!CAUTION] > 字元當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，可能會無法解譯，並可能會導致擲回例外狀況。       `FileShare.Read`這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。</xref:System.IO.FileStream>       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "檔案的檔案控制代碼的目前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件將會封裝。"
    - id: access
      type: System.IO.FileAccess
      description: "常數，設定<> *> 和<> *> 的內容<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>不是欄位的<xref href=&quot;System.IO.FileAccess&quot;> </xref>。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如磁碟錯誤。       -或者-資料流已關閉。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求所指定的檔案控制代碼，例如當作業系統不允許<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和檔案控制代碼設為唯讀存取。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  id: '#ctor(System.IntPtr,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>類別指定的檔案控制代碼，以指定的讀取/寫入權限。"
  remarks: "當<xref:System.IO.Stream.Close%2A>是呼叫，此控制代碼，也會關閉和檔案的控制碼計數會遞減。</xref:System.IO.Stream.Close%2A>       `FileStream`假設它有控制代碼的專有控制權。 讀取、 寫入，或搜尋時`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全呼叫<xref:System.IO.FileStream.Flush%2A>之前使用此控制代碼，並避免呼叫任何方法以外`Close`完成之後使用此控制代碼。</xref:System.IO.FileStream.Flush%2A>      > [!CAUTION] > 字元當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，可能會無法解譯，並可能會導致擲回例外狀況。       `FileShare.Read`這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。</xref:System.IO.FileStream>       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "檔案的檔案控制代碼的目前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件將會封裝。"
    - id: access
      type: System.IO.FileAccess
      description: "常數，設定<> *> 和<> *> 的內容<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>不是欄位的<xref href=&quot;System.IO.FileAccess&quot;> </xref>。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如磁碟錯誤。       -或者-資料流已關閉。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求所指定的檔案控制代碼，例如當作業系統不允許<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和檔案控制代碼設為唯讀存取。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>使用指定的路徑和建立模式的類別。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed).  \n  \n You cannot use this constructor to open read-only files; instead, you must use a constructor that accepts a `FileAccess` parameter with the value set to `FileAccess.Read`.  \n  \n The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n For constructors without a <xref:System.IO.FileAccess> parameter, if the `mode` parameter is set to <xref:System.IO.FileMode>, <xref:System.IO.FileAccess> is the default access. Otherwise, the access is set to <xref:System.IO.FileAccess>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_0_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "檔案的相對或絕對路徑的目前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件將會封裝。"
    - id: mode
      type: System.IO.FileMode
      description: "常數，決定如何開啟或建立檔案。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)、 只包含空格，或包含一或多個無效的字元。       -或-<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;，&quot;lpt1:&quot;，等 NTFS 環境中的。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 環境中的。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不檔案，例如當<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，所指定的檔案和<code> path </code>不存在。 檔案必須存在於這些模式。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>時所指定的檔案<code> path </code>已經存在，發生。       -或者-資料流已關閉。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路徑、 檔案名稱，或兩者都超出系統定義的長度上限。 例如，windows 平台上，路徑必須少於 248 個字元，和檔案名稱必須少於 260 個字元。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含無效的值。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>類別指定的檔案控制代碼，以指定的讀取/寫入權限和緩衝區大小。"
  remarks: "`FileStream`假設它有控制代碼的專有控制權。 讀取、 寫入，或搜尋時`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全呼叫<xref:System.IO.FileStream.Flush%2A>之前使用此控制代碼，並避免呼叫任何方法以外`Close`完成之後使用此控制代碼。</xref:System.IO.FileStream.Flush%2A> 或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。       `FileShare.Read`這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。</xref:System.IO.FileStream>      > [!CAUTION] > 字元當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，可能會無法解譯，並可能會導致擲回例外狀況。       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "檔案的檔案控制代碼的目前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件將會封裝。"
    - id: access
      type: System.IO.FileAccess
      description: "A <xref href=&quot;System.IO.FileAccess&quot;> </xref>常數，設定<> *> 和<> *> 的內容<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>值大於 0，指出緩衝區大小。</xref:System.Int32> 預設緩衝區大小為 4096。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> handle </code>參數是無效的控制代碼。       -或- <code> handle </code>參數是同步的控制代碼，且曾以非同步方式使用。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> bufferSize </code>參數是負值。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如磁碟錯誤。       -或者-資料流已關閉。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求所指定的檔案控制代碼，例如當作業系統不允許<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和檔案控制代碼設為唯讀存取。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>指定的檔案控制代碼，以指定的讀取/寫入權限的類別和<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>執行個體擁有權。"
  remarks: "`FileStream`物件會得到的指定的存取檔案。 控制代碼的擁有權會依指定。 如果此程序擁有的控制代碼呼叫<xref:System.IO.Stream.Close%2A>方法也會關閉此控制代碼，而檔案控制碼計數會遞減。</xref:System.IO.Stream.Close%2A> `FileStream`物件會得到預設緩衝區大小為 4096 位元組。       `FileStream`假設它有控制代碼的專有控制權。 讀取、 寫入，或搜尋時`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全呼叫<xref:System.IO.FileStream.Flush%2A>之前使用此控制代碼，並避免呼叫的方法以外`Close`完成之後使用此控制代碼。</xref:System.IO.FileStream.Flush%2A>       `FileShare.Read`這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。</xref:System.IO.FileStream>      > [!CAUTION] > 字元當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，可能會無法解譯，並可能會導致擲回例外狀況。       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "檔案的檔案控制代碼的目前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件將會封裝。"
    - id: access
      type: System.IO.FileAccess
      description: "常數，設定<> *> 和<> *> 的內容<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。"
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果將擁有檔案控制代碼，由此<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>執行個體; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>access</code>不是欄位的<xref href=&quot;System.IO.FileAccess&quot;> </xref>。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如磁碟錯誤。       -或者-資料流已關閉。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求所指定的檔案控制代碼，例如當作業系統不允許<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和檔案控制代碼設為唯讀存取。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>類別指定的路徑、 建立模式和讀取/寫入權限。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n `FileShare.Read` is the default for those <xref:System.IO.FileStream> constructors without a `FileShare` parameter.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "檔案的相對或絕對路徑的目前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件將會封裝。"
    - id: mode
      type: System.IO.FileMode
      description: "常數，決定如何開啟或建立檔案。"
    - id: access
      type: System.IO.FileAccess
      description: "常數，決定如何存取檔案所<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。 這也會決定所傳回的值<> *> 和<> *> 的內容<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。 <xref:System.IO.FileStream.CanSeek*>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果`path`指定了磁碟檔案。</xref:System.IO.FileStream.CanSeek*>"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)、 只包含空格，或包含一或多個無效的字元。       -或-<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;，&quot;lpt1:&quot;，等 NTFS 環境中的。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 環境中的。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不檔案，例如當<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，所指定的檔案和<code> path </code>不存在。 檔案必須存在於這些模式。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>時所指定的檔案<code> path </code>已經存在，發生。       -或者-資料流已關閉。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求所指定的作業系統不允許<code> path </code>，例如當<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和檔案或目錄設為唯讀存取。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路徑、 檔案名稱，或兩者都超出系統定義的長度上限。 例如，windows 平台上，路徑必須少於 248 個字元，和檔案名稱必須少於 260 個字元。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含無效的值。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  id: '#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>類別指定的檔案控制代碼，使用指定的讀取/寫入權限、 緩衝區大小和同步或非同步狀態。"
  remarks: "您設定`isAsync`參數`true`以非同步方式開啟檔案控制代碼。 當參數是`true`，資料流使用重疊的 I/O，以非同步方式執行檔案作業。 不過，有參數不是`true`呼叫<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> 當`isAsync`參數是`false`和呼叫的非同步讀取和寫入作業，仍不封鎖 UI 執行緒，但實際的 I/O 作業會以同步方式執行。       `FileStream`假設它有控制代碼的專有控制權。 讀取、 寫入，或搜尋時`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全呼叫<xref:System.IO.FileStream.Flush%2A>之前使用此控制代碼，並避免呼叫任何方法以外`Close`完成之後使用此控制代碼。</xref:System.IO.FileStream.Flush%2A> 或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。       `FileShare.Read`這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。</xref:System.IO.FileStream>      > [!CAUTION] > 字元當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，可能會無法解譯，並可能會導致擲回例外狀況。       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "檔案之檔案控制代碼這個<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件將會封裝。"
    - id: access
      type: System.IO.FileAccess
      description: "常數，設定<> *> 和<> *> 的內容<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>值大於 0，指出緩衝區大小。</xref:System.Int32> 預設緩衝區大小為 4096。"
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果控制代碼為非同步開啟 （也就是說，在重疊 I/O 模式）。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> handle </code>參數是無效的控制代碼。       -或- <code> handle </code>參數是同步的控制代碼，且曾以非同步方式使用。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code> bufferSize </code>參數是負值。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如磁碟錯誤。       -或者-資料流已關閉。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求所指定的檔案控制代碼，例如當作業系統不允許<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和檔案控制代碼設為唯讀存取。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>類別指定的檔案控制代碼，使用指定的讀取/寫入權限、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>執行個體擁有權和緩衝區大小。"
  remarks: "`FileStream`物件會得到的指定的存取檔案。 控制代碼的擁有權會依指定。 如果這個`FileStream`擁有的控制代碼呼叫<xref:System.IO.Stream.Close%2A>方法也會關閉此控制代碼。</xref:System.IO.Stream.Close%2A> 特別是，檔案的控制碼計數會遞減。 `FileStream`物件會得到在指定的緩衝區大小。       `FileStream`假設它有控制代碼的專有控制權。 讀取、 寫入，或搜尋時`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全呼叫<xref:System.IO.FileStream.Flush%2A>之前使用此控制代碼，並避免呼叫任何方法以外`Close`完成之後使用此控制代碼。</xref:System.IO.FileStream.Flush%2A> 或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。       `FileShare.Read`這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。</xref:System.IO.FileStream>      > [!CAUTION] > 字元當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，可能會無法解譯，並可能會導致擲回例外狀況。       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "檔案之檔案控制代碼這個<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件將會封裝。"
    - id: access
      type: System.IO.FileAccess
      description: "常數，設定<> *> 和<> *> 的內容<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。"
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果將擁有檔案控制代碼，由此<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>執行個體; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>值大於 0，指出緩衝區大小。</xref:System.Int32> 預設緩衝區大小為 4096。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>為負。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如磁碟錯誤。       -或者-資料流已關閉。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求所指定的檔案控制代碼，例如當作業系統不允許<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和檔案控制代碼設為唯讀存取。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>類別指定的路徑、 建立模式、 讀取/寫入權限和共用權限。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n The constructor is given read/write access to the file, and it is opened sharing Read access (that is, requests to open the file for writing by this or another process will fail until the `FileStream` object has been closed, but read attempts will succeed). The buffer size is set to the default size of 4096 bytes (4 KB).  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#2](~/add/codesnippet/csharp/904a8302-b9b6-44f1-89c4-_1.cs)]\n [!code-cpp[System.IO.FileStream3#2](~/add/codesnippet/cpp/904a8302-b9b6-44f1-89c4-_1.cpp)]\n [!code-vb[System.IO.FileStream3#2](~/add/codesnippet/visualbasic/904a8302-b9b6-44f1-89c4-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "檔案的相對或絕對路徑的目前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件將會封裝。"
    - id: mode
      type: System.IO.FileMode
      description: "常數，決定如何開啟或建立檔案。"
    - id: access
      type: System.IO.FileAccess
      description: "常數，決定如何存取檔案所<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。 這也會決定所傳回的值<> *> 和<> *> 的內容<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。 <xref:System.IO.FileStream.CanSeek*>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果`path`指定了磁碟檔案。</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "常數，決定處理程序如何共用檔案。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)、 只包含空格，或包含一或多個無效的字元。       -或-<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;，&quot;lpt1:&quot;，等 NTFS 環境中的。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 環境中的。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不檔案，例如當<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，所指定的檔案和<code> path </code>不存在。 檔案必須存在於這些模式。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>時所指定的檔案<code> path </code>已經存在，發生。       -或-系統正在執行 Windows 98 或 Windows 98 Second Edition 和<code> share </code>設<xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>。       -或者-資料流已關閉。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求所指定的作業系統不允許<code> path </code>，例如當<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和檔案或目錄設為唯讀存取。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路徑、 檔案名稱，或兩者都超出系統定義的長度上限。 例如，windows 平台上，路徑必須少於 248 個字元，和檔案名稱必須少於 260 個字元。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>mode</code>包含無效的值。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  id: '#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>類別指定的檔案控制代碼，使用指定的讀取/寫入權限、 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>執行個體擁有權、 緩衝區大小和同步或非同步狀態。"
  remarks: "`FileStream`物件會得到的指定的存取檔案。 控制代碼的擁有權會依指定。 如果這個`FileStream`擁有的控制代碼呼叫<xref:System.IO.Stream.Close%2A>方法也會關閉此控制代碼。</xref:System.IO.Stream.Close%2A> 特別是，檔案的控制碼計數會遞減。 `FileStream`物件會得到在指定的緩衝區大小。       `FileStream`假設它有控制代碼的專有控制權。 讀取、 寫入，或搜尋時`FileStream`也持有控制代碼可能會導致資料損毀。 針對資料安全呼叫<xref:System.IO.FileStream.Flush%2A>之前使用此控制代碼，並避免呼叫任何方法以外`Close`完成之後使用此控制代碼。</xref:System.IO.FileStream.Flush%2A> 或者，讀取和寫入至控制代碼之前呼叫此`FileStream`建構函式。       `FileShare.Read`這些是預設值<xref:System.IO.FileStream>建構函式不含`FileShare`參數。</xref:System.IO.FileStream>      > [!CAUTION] > 字元當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，可能會無法解譯，並可能會導致擲回例外狀況。       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    parameters:
    - id: handle
      type: System.IntPtr
      description: "檔案之檔案控制代碼這個<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件將會封裝。"
    - id: access
      type: System.IO.FileAccess
      description: "常數，設定<> *> 和<> *> 的內容<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。"
    - id: ownsHandle
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果將擁有檔案控制代碼，由此<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>執行個體; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>值大於 0，指出緩衝區大小。</xref:System.Int32> 預設緩衝區大小為 4096。"
    - id: isAsync
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果控制代碼為非同步開啟 （也就是說，在重疊 I/O 模式）。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>access</code>是小於<xref uid=&quot;langword_csharp_FileAccess.Read&quot; name=&quot;FileAccess.Read&quot; href=&quot;&quot;></xref>或大於<xref uid=&quot;langword_csharp_FileAccess.ReadWrite&quot; name=&quot;FileAccess.ReadWrite&quot; href=&quot;&quot;></xref>或<code>bufferSize</code>小於或等於 0。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "控制代碼無效。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如磁碟錯誤。       -或者-資料流已關閉。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求所指定的檔案控制代碼，例如當作業系統不允許<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和檔案控制代碼設為唯讀存取。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>類別指定的路徑、 建立模式、 讀取/寫入與共用權限與緩衝區大小。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
    parameters:
    - id: path
      type: System.String
      description: "檔案的相對或絕對路徑的目前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件將會封裝。"
    - id: mode
      type: System.IO.FileMode
      description: "常數，決定如何開啟或建立檔案。"
    - id: access
      type: System.IO.FileAccess
      description: "常數，決定如何存取檔案所<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。 這也會決定所傳回的值<> *> 和<> *> 的內容<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。 <xref:System.IO.FileStream.CanSeek*>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果`path`指定了磁碟檔案。</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "常數，決定處理程序如何共用檔案。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>值大於 0，指出緩衝區大小。</xref:System.Int32> 預設緩衝區大小為 4096。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)、 只包含空格，或包含一或多個無效的字元。       -或-<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;，&quot;lpt1:&quot;，等 NTFS 環境中的。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 環境中的。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>是負值或零。       - <code>mode</code>， <code>access</code>，或<code>share</code>包含無效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不檔案，例如當<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，所指定的檔案和<code> path </code>不存在。 檔案必須存在於這些模式。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>時所指定的檔案<code> path </code>已經存在，發生。       -或-系統正在執行 Windows 98 或 Windows 98 Second Edition 和<code> share </code>設<xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>。       -或者-資料流已關閉。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求所指定的作業系統不允許<code> path </code>，例如當<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和檔案或目錄設為唯讀存取。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路徑、 檔案名稱，或兩者都超出系統定義的長度上限。 例如，windows 平台上，路徑必須少於 248 個字元，和檔案名稱必須少於 260 個字元。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>類別指定的路徑、 建立模式、 讀取/寫入與共用權限、 緩衝大小與同步或非同步狀態。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following code example shows how to asynchronously write data to a file and then verify that the data was written correctly. A `State` object is created to pass information from the main thread to the `EndReadCallback` and `EndWriteCallback` methods.  \n  \n [!code-cs[System.IO.FileStream2#1](~/add/codesnippet/csharp/ff94fabb-a26d-4ac2-a74e-_1.cs)]\n [!code-vb[System.IO.FileStream2#1](~/add/codesnippet/visualbasic/ff94fabb-a26d-4ac2-a74e-_1.vb)]\n [!code-cpp[System.IO.FileStream2#1](~/add/codesnippet/cpp/ff94fabb-a26d-4ac2-a74e-_1.cpp)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);
    parameters:
    - id: path
      type: System.String
      description: "檔案的相對或絕對路徑的目前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件將會封裝。"
    - id: mode
      type: System.IO.FileMode
      description: "常數，決定如何開啟或建立檔案。"
    - id: access
      type: System.IO.FileAccess
      description: "常數，決定如何存取檔案所<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。 這也會決定所傳回的值<> *> 和<> *> 的內容<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。 <xref:System.IO.FileStream.CanSeek*>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果`path`指定了磁碟檔案。</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "常數，決定處理程序如何共用檔案。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>值大於 0，指出緩衝區大小。</xref:System.Int32> 預設緩衝區大小為 4096..."
    - id: useAsync
      type: System.Boolean
      description: "指定是否要使用非同步 I/O 或同步 I/O。 不過，請注意基礎作業系統可能不支援非同步 I/O，所以在指定<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>，可能會以同步方式開啟控制代碼，視平台。 以非同步方式開啟時<> *> 和<> *> 方法對更大的讀取或寫入，但是可能會變得很慢很小的讀取或寫入。 如果應用程式設計成使用非同步 I/O，設定`useAsync`參數<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。 正確地使用非同步 I/O 可以加快應用程式如往常般 10，但使用而不必重新設計非同步 I/O 的應用程式可能降低效能最多 10 倍。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)、 只包含空格，或包含一或多個無效的字元。       -或-<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;，&quot;lpt1:&quot;，等 NTFS 環境中的。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 環境中的。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>是負值或零。       - <code>mode</code>， <code>access</code>，或<code>share</code>包含無效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不檔案，例如當<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，所指定的檔案和<code> path </code>不存在。 檔案必須存在於這些模式。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>時所指定的檔案<code> path </code>已經存在，發生。       -或-系統正在執行 Windows 98 或 Windows 98 Second Edition 和<code> share </code>設<xref uid=&quot;langword_csharp_FileShare.Delete&quot; name=&quot;FileShare.Delete&quot; href=&quot;&quot;> </xref>。       -或者-資料流已關閉。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求所指定的作業系統不允許<code> path </code>，例如當<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和檔案或目錄設為唯讀存取。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路徑、 檔案名稱，或兩者都超出系統定義的長度上限。 例如，windows 平台上，路徑必須少於 248 個字元，和檔案名稱必須少於 260 個字元。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>類別指定的路徑、 建立模式、 讀取/寫入與共用權限、 存取其他 Filestream 對相同的檔案、 緩衝區大小和其他檔案選項。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor1#1](~/add/codesnippet/cpp/53f739ba-7c4d-43ff-a387-_1.cpp)]\n [!code-vb[IO.FileStream.ctor1#1](~/add/codesnippet/visualbasic/53f739ba-7c4d-43ff-a387-_1.vb)]\n [!code-cs[IO.FileStream.ctor1#1](~/add/codesnippet/csharp/53f739ba-7c4d-43ff-a387-_1.cs)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "檔案的相對或絕對路徑的目前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件將會封裝。"
    - id: mode
      type: System.IO.FileMode
      description: "常數，決定如何開啟或建立檔案。"
    - id: access
      type: System.IO.FileAccess
      description: "常數，決定如何存取檔案所<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。 這也會決定所傳回的值<> *> 和<> *> 的內容<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件。 <xref:System.IO.FileStream.CanSeek*>是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果`path`指定了磁碟檔案。</xref:System.IO.FileStream.CanSeek*>"
    - id: share
      type: System.IO.FileShare
      description: "常數，決定處理程序如何共用檔案。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>值大於 0，指出緩衝區大小。</xref:System.Int32> 預設緩衝區大小為 4096。"
    - id: options
      type: System.IO.FileOptions
      description: "值，指定其他檔案選項。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)、 只包含空格，或包含一或多個無效的字元。       -或-<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;，&quot;lpt1:&quot;，等 NTFS 環境中的。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 環境中的。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>是負值或零。       - <code>mode</code>， <code>access</code>，或<code>share</code>包含無效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不檔案，例如當<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，所指定的檔案和<code> path </code>不存在。 檔案必須存在於這些模式。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>時所指定的檔案<code> path </code>已經存在，發生。       -或者-資料流已關閉。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求所指定的作業系統不允許<code> path </code>，例如當<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和檔案或目錄設為唯讀存取。       - <xref href=&quot;System.IO.FileOptions&quot;> </xref>指定<code> options </code>，但目前平台不支援檔案加密。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定的路徑、 檔案名稱，或兩者都超出系統定義的長度上限。 例如，windows 平台上，路徑必須少於 248 個字元，和檔案名稱必須少於 260 個字元。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>類別具有指定的路徑、 建立模式、 存取權限和共用權限、 緩衝區大小和其他檔案選項。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
    parameters:
    - id: path
      type: System.String
      description: "檔案的相對或絕對路徑的目前<xref href=&quot;System.IO.FileStream&quot;></xref>物件將會封裝。"
    - id: mode
      type: System.IO.FileMode
      description: "常數，決定如何開啟或建立檔案。"
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "常數，決定建立檔案的存取和稽核規則時要使用的存取權限。"
    - id: share
      type: System.IO.FileShare
      description: "常數，決定處理程序如何共用檔案。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>值大於 0，指出緩衝區大小。</xref:System.Int32> 預設緩衝區大小為 4096。"
    - id: options
      type: System.IO.FileOptions
      description: "常數，指定其他檔案選項。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)、 只包含空格，或包含一或多個無效的字元。       -或-<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;，&quot;lpt1:&quot;，等 NTFS 環境中的。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 環境中的。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>是負值或零。       - <code>mode</code>， <code>access</code>，或<code>share</code>包含無效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不檔案，例如當<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，所指定的檔案和<code> path </code>不存在。 檔案必須存在於這些模式。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "目前的作業系統不是 Windows NT 或更新版本。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>時所指定的檔案<code> path </code>已經存在，發生。       -或者-資料流已關閉。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求所指定的作業系統不允許<code> path </code>，例如當<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和檔案或目錄設為唯讀存取。       - <xref href=&quot;System.IO.FileOptions&quot;> </xref>指定<code> options </code>，但目前平台不支援檔案加密。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定<code> path </code>，檔案名稱，或兩者都超出系統定義的長度上限。 例如，windows 平台上，路徑必須少於 248 個字元，和檔案名稱必須少於 260 個字元。"
  platform:
  - net462
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  id: '#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)'
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "初始化的新執行個體<xref href=&quot;System.IO.FileStream&quot;></xref>類別指定的路徑、 建立模式、 存取權與共用權限、 緩衝區大小、 其他檔案選項、 存取控制和稽核安全性。"
  remarks: "The .NET Framework does not support direct access to physical disks through paths that are device names, such as \"\\\\\\\\.\\PHYSICALDRIVE0 \".  \n  \n Use this FileStream constructor to apply access rights at the point of creation of a file. To access or modify rights on an existing file, consider using the <xref:System.IO.File.GetAccessControl%2A> and <xref:System.IO.File.SetAccessControl%2A> methods.  \n  \n The `fileOptions` parameter is used to provide access to more advanced operations that can be leveraged when creating a <xref:System.IO.FileStream> object.  \n  \n The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.  \n  \n> [!NOTE]\n>  `path` is not required to be a file stored on disk; it can be any part of a system that supports access through streams. For example, depending on the system, this class can access a physical device.  \n  \n <xref:System.IO.Stream.CanSeek%2A> is `true` for all <xref:System.IO.FileStream> objects that encapsulate files. If `path` indicates a device that does not support seeking, the <xref:System.IO.FileStream.CanSeek%2A> property on the resulting <xref:System.IO.FileStream> is `false`. For additional information, see <xref:System.IO.Stream.CanSeek%2A>.  \n  \n> [!CAUTION]\n>  When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.  \n  \n For a list of common file and directory operations, see [Common I/O Tasks](~/add/includes/ajax-current-ext-md.md)."
  example:
  - "The following example writes data to a file and then reads the data using the <xref:System.IO.FileStream> object.  \n  \n [!code-cpp[IO.FileStream.ctor2#1](~/add/codesnippet/cpp/7f323125-1dac-495a-a4ee-_1.cpp)]\n [!code-cs[IO.FileStream.ctor2#1](~/add/codesnippet/csharp/7f323125-1dac-495a-a4ee-_1.cs)]\n [!code-vb[IO.FileStream.ctor2#1](~/add/codesnippet/visualbasic/7f323125-1dac-495a-a4ee-_1.vb)]"
  syntax:
    content: public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: path
      type: System.String
      description: "檔案的相對或絕對路徑的目前<xref href=&quot;System.IO.FileStream&quot;></xref>物件將會封裝。"
    - id: mode
      type: System.IO.FileMode
      description: "常數，決定如何開啟或建立檔案。"
    - id: rights
      type: System.Security.AccessControl.FileSystemRights
      description: "常數，決定建立檔案的存取和稽核規則時要使用的存取權限。"
    - id: share
      type: System.IO.FileShare
      description: "常數，決定處理程序如何共用檔案。"
    - id: bufferSize
      type: System.Int32
      description: "正<xref:System.Int32>值大於 0，指出緩衝區大小。</xref:System.Int32> 預設緩衝區大小為 4096。"
    - id: options
      type: System.IO.FileOptions
      description: "常數，指定其他檔案選項。"
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "常數，決定的存取控制和稽核安全性檔案。"
  overload: System.IO.FileStream.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>path</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>path</code>為空字串 (&quot;&quot;)、 只包含空格，或包含一或多個無效的字元。       -或-<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;，&quot;lpt1:&quot;，等 NTFS 環境中的。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<code>path</code>指非檔案裝置，例如&quot;con:&quot;，&quot;com1:&quot;、&quot;lpt1:&quot;，等非 NTFS 環境中的。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>bufferSize</code>是負值或零。       - <code>mode</code>， <code>access</code>，或<code>share</code>包含無效的值。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不檔案，例如當<code> mode </code>是<xref uid=&quot;langword_csharp_FileMode.Truncate&quot; name=&quot;FileMode.Truncate&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_FileMode.Open&quot; name=&quot;FileMode.Open&quot; href=&quot;&quot;> </xref>，所指定的檔案和<code> path </code>不存在。 檔案必須存在於這些模式。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如指定<xref uid=&quot;langword_csharp_FileMode.CreateNew&quot; name=&quot;FileMode.CreateNew&quot; href=&quot;&quot;></xref>時所指定的檔案<code> path </code>已經存在，發生。       -或者-資料流已關閉。"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "指定的路徑無效，例如位於未對應的磁碟機上。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "<code> access </code>要求所指定的作業系統不允許<code> path </code>，例如當<code> access </code>是<xref uid=&quot;langword_csharp_Write&quot; name=&quot;Write&quot; href=&quot;&quot;></xref>或<xref uid=&quot;langword_csharp_ReadWrite&quot; name=&quot;ReadWrite&quot; href=&quot;&quot;></xref>和檔案或目錄設為唯讀存取。       - <xref href=&quot;System.IO.FileOptions&quot;> </xref>指定<code> options </code>，但目前平台不支援檔案加密。"
  - type: System.IO.PathTooLongException
    commentId: T:System.IO.PathTooLongException
    description: "指定<code> path </code>，檔案名稱，或兩者都超出系統定義的長度上限。 例如，windows 平台上，路徑必須少於 248 個字元，和檔案名稱必須少於 260 個字元。"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "目前的作業系統不是 Windows NT 或更新版本。"
  platform:
  - net462
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "開始非同步的讀取的作業。 (請考慮使用<xref:System.IO.FileStream.ReadAsync*>代替; 請參閱 < 備註 > 一節。)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "在.NET Framework 4 和舊版中，您必須使用例如 BeginRead 方法和<xref:System.IO.FileStream.EndRead%2A>實作非同步檔案作業。</xref:System.IO.FileStream.EndRead%2A> 這些方法都仍有[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]以支援舊版的程式碼; 不過，新的非同步方法，例如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，協助您更輕鬆地實作非同步檔案作業。</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndRead%2A>必須呼叫一次的 BeginRead 每次呼叫。</xref:System.IO.FileStream.EndRead%2A> 若要開始另一次讀取之前結束讀取的處理序失敗，可能會導致非預期的行為，例如死結。       <xref:System.IO.FileStream>提供兩個不同的作業模式︰ I/O 同步和非同步 I/O。</xref:System.IO.FileStream> 雖然可以用來，基礎作業系統資源可能只有其中一個這些模式中允許存取。 根據預設，<xref:System.IO.FileStream>以同步方式開啟的作業系統控制代碼。</xref:System.IO.FileStream> 在 Windows 中，這會略微減慢非同步方法。 如果使用非同步方法，使用<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>      > [!NOTE] > 使用<xref:System.IO.FileStream.CanRead%2A>屬性來判斷目前的執行個體是否支援讀取。</xref:System.IO.FileStream.CanRead%2A> 如需詳細資訊，請參閱<xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A>       如果資料流已關閉，或是您傳遞了無效的引數，會擲回例外狀況立即從 BeginRead。 非同步讀取要求，例如磁碟失敗期間的 IO 要求期間發生的錯誤發生在執行緒集區執行緒，並且<xref:System.IO.FileStream.EndRead%2A>.</xref:System.IO.FileStream.EndRead%2A>呼叫時變成可見       <xref:System.IO.Stream.EndRead%2A>必須先呼叫與這個<xref:System.IAsyncResult>找出多少位元組被讀取。</xref:System.IAsyncResult></xref:System.IO.Stream.EndRead%2A>       多個同時進行非同步要求轉譯要求完成順序不確定。       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/82be2bd0-0603-4287-b351-_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/82be2bd0-0603-4287-b351-_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/82be2bd0-0603-4287-b351-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "要讀取資料的緩衝區。"
    - id: offset
      type: System.Int32
      description: "中的位元組位移`array`中要開始讀取。"
    - id: numBytes
      type: System.Int32
      description: "要讀取的位元組數目上限。"
    - id: userCallback
      type: System.AsyncCallback
      description: "在完成非同步讀取作業時所要呼叫的方法。"
    - id: stateObject
      type: System.Object
      description: "從其他要求使用者提供的物件，可區別這個特定非同步讀取的要求。"
    return:
      type: System.IAsyncResult
      description: "物件，參考非同步讀取。"
  overload: System.IO.FileStream.BeginRead*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "陣列長度減去<code> offset </code>是小於<code> numBytes </code>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>numBytes</code>是負數。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "超過檔案結尾處嘗試了非同步讀取。"
  platform:
  - net462
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "開始非同步的寫入作業。 (請考慮使用<xref:System.IO.FileStream.WriteAsync*>代替; 請參閱 < 備註 > 一節。)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "在.NET Framework 4 和舊版中，您必須使用例如 BeginWrite 方法和<xref:System.IO.FileStream.EndWrite%2A>實作非同步檔案作業。</xref:System.IO.FileStream.EndWrite%2A> 這些方法都仍有[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]以支援舊版的程式碼; 不過，新的非同步方法，例如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，協助您更輕鬆地實作非同步檔案作業。</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       <xref:System.IO.FileStream.EndWrite%2A>必須正好一次上呼叫每個<xref:System.IAsyncResult>從 BeginWrite。</xref:System.IAsyncResult></xref:System.IO.FileStream.EndWrite%2A> <xref:System.IO.FileStream.EndWrite%2A>將會封鎖，直到 I/O 作業完成為止。</xref:System.IO.FileStream.EndWrite%2A>       這個方法會覆寫<xref:System.IO.Stream.BeginWrite%2A>.</xref:System.IO.Stream.BeginWrite%2A>       <xref:System.IO.FileStream>提供兩個不同的作業模式︰ I/O 同步和非同步 I/O。</xref:System.IO.FileStream> 雖然可以用來，基礎作業系統資源可能只有其中一個這些模式中允許存取。 根據預設，<xref:System.IO.FileStream>以同步方式開啟的作業系統控制代碼。</xref:System.IO.FileStream> 在 Windows 中，這會略微減慢非同步方法。 如果使用非同步方法，使用<xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>建構函式。</xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29>       如果資料流已關閉，或是您傳遞了無效的引數，會擲回例外狀況立即從 BeginWrite。 非同步寫入要求，例如磁碟失敗期間的 IO 要求期間發生的錯誤發生在執行緒集區執行緒，並且<xref:System.IO.FileStream.EndWrite%2A>.</xref:System.IO.FileStream.EndWrite%2A>呼叫時變成可見       多個同時進行非同步要求轉譯要求完成順序不確定。       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/439bdb1f-5241-4046-a4ad-_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/439bdb1f-5241-4046-a4ad-_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/439bdb1f-5241-4046-a4ad-_1.cpp)]"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: array
      type: System.Byte[]
      description: "包含要寫入目前資料流資料的緩衝區。"
    - id: offset
      type: System.Int32
      description: "中以零為起始的位元組位移`array`中要開始複製位元組到目前資料流。"
    - id: numBytes
      type: System.Int32
      description: "要寫入的位元組數目上限。"
    - id: userCallback
      type: System.AsyncCallback
      description: "在非同步寫入作業完成時要呼叫方法。"
    - id: stateObject
      type: System.Object
      description: "使用者提供的物件，可從其他要求中辨別這個特定非同步寫入要求。"
    return:
      type: System.IAsyncResult
      description: "物件，參考非同步寫入。"
  overload: System.IO.FileStream.BeginWrite*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>長度減去<code>offset</code>是小於<code>numBytes</code>。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>numBytes</code>是負數。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "資料流不支援寫入。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "資料流已關閉。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤。"
  platform:
  - net462
- uid: System.IO.FileStream.CanRead
  id: CanRead
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得值，指出目前資料流是否支援讀取。"
  remarks: "如果類別衍生自<xref:System.IO.Stream>不支援讀取，但呼叫<xref:System.IO.FileStream.Read%2A>， <xref:System.IO.FileStream.ReadByte%2A>，而且<xref:System.IO.FileStream.BeginRead%2A>方法會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.BeginRead%2A> </xref:System.IO.FileStream.ReadByte%2A> </xref:System.IO.FileStream.Read%2A> </xref:System.IO.Stream>       如果資料流已關閉，則這個屬性會傳回`false`。"
  example:
  - "The following example demonstrates a use of the `CanRead` property. The output of this code is \"MyFile.txt is not writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanRead Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_1_1.cs)]\n [!code-cpp[Classic FileStream.CanRead Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_1_1.cpp)]\n [!code-vb[Classic FileStream.CanRead Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_1_1.vb)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果資料流支援讀取，<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果資料流已關閉或以唯寫存取開啟。"
  overload: System.IO.FileStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanSeek
  id: CanSeek
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得值，指出目前資料流是否支援搜尋。"
  remarks: "如果類別衍生自<xref:System.IO.Stream>不支援搜尋，但呼叫<xref:System.IO.FileStream.Length%2A>， <xref:System.IO.FileStream.SetLength%2A>， <xref:System.IO.FileStream.Position%2A>，而且<xref:System.IO.FileStream.Seek%2A>會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.Seek%2A> </xref:System.IO.FileStream.Position%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.FileStream.Length%2A> </xref:System.IO.Stream>       如果資料流已關閉，則這個屬性會傳回`false`。"
  example:
  - "The following example uses the `CanSeek` property to check whether a stream supports seeking.  \n  \n [!code-cpp[fstream canseek#1](~/add/codesnippet/cpp/p-system.io.filestream.c_0_1.cpp)]\n [!code-vb[fstream canseek#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_0_1.vb)]\n [!code-cs[fstream canseek#1](~/add/codesnippet/csharp/p-system.io.filestream.c_0_1.cs)]"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果資料流支援搜尋。，<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果資料流已關閉，或如果<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>建構從作業系統控制代碼，例如管道或輸出至主控台。"
  overload: System.IO.FileStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.CanWrite
  id: CanWrite
  parent: System.IO.FileStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得值，指出目前資料流是否支援寫入。"
  remarks: "如果類別衍生自<xref:System.IO.Stream>不支援寫入，呼叫<xref:System.IO.FileStream.SetLength%2A>， <xref:System.IO.FileStream.Write%2A>， <xref:System.IO.FileStream.BeginWrite%2A>，或<xref:System.IO.FileStream.WriteByte%2A>擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.IO.FileStream.WriteByte%2A> </xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IO.FileStream.Write%2A> </xref:System.IO.FileStream.SetLength%2A> </xref:System.IO.Stream>       如果資料流已關閉，則這個屬性會傳回`false`。"
  example:
  - "The following example uses the `CanWrite` property to check whether a stream supports writing.  \n  \n [!code-cs[fstream canwrite#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_1.cs)]\n [!code-cpp[fstream canwrite#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_1.cpp)]\n [!code-vb[fstream canwrite#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_1.vb)]  \n  \n The following is an example using the `CanWrite` property. The output of this code is \"MyFile.txt is writable.\" To get the output message \"MyFile.txt can be both written to and read from.\", change the `FileAccess` parameter to `ReadWrite` in the `FileStream` constructor.  \n  \n [!code-cs[Classic FileStream.CanWrite Example#1](~/add/codesnippet/csharp/p-system.io.filestream.c_2_2.cs)]\n [!code-vb[Classic FileStream.CanWrite Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.c_2_2.vb)]\n [!code-cpp[Classic FileStream.CanWrite Example#1](~/add/codesnippet/cpp/p-system.io.filestream.c_2_2.cpp)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果資料流支援寫入;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果資料流已關閉或以唯讀存取開啟。"
  overload: System.IO.FileStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "所使用的 unmanaged 的資源釋出<xref href=&quot;System.IO.FileStream&quot;></xref>並選擇性釋放 managed 的資源。"
  remarks: "這個方法會呼叫公用<xref:System.ComponentModel.Component.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。</xref:System.Object.Finalize%2A> </xref:System.ComponentModel.Component.Dispose%2A> <xref:System.ComponentModel.Component.Dispose%2A>與受保護的 Dispose 方法會叫用`disposing`參數設定為`true`。</xref:System.ComponentModel.Component.Dispose%2A> <xref:System.Object.Finalize%2A>叫用 Dispose 以`disposing`設`false`。</xref:System.Object.Finalize%2A>       當`disposing`參數是`true`，這個方法的任何 managed 物件所持有的資源全部釋出這個<xref:System.IO.FileStream>參考。</xref:System.IO.FileStream> 這個方法會叫用<xref:System.ComponentModel.Component.Dispose%2A>每個參考物件的方法。</xref:System.ComponentModel.Component.Dispose%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示釋放 managed 和 unmanaged 資源，<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示只釋放 unmanaged 的資源。"
  overload: System.IO.FileStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "等候暫止非同步讀取作業完成。 (請考慮使用<xref:System.IO.FileStream.ReadAsync*>代替; 請參閱 < 備註 > 一節。)</xref:System.IO.FileStream.ReadAsync*>"
  remarks: "在.NET Framework 4 和舊版中，您必須使用下列方法<xref:System.IO.FileStream.BeginRead%2A>和實作非同步檔案作業的 EndRead。</xref:System.IO.FileStream.BeginRead%2A> 這些方法都仍有[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]以支援舊版的程式碼; 不過，新的非同步方法，例如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，協助您更輕鬆地實作非同步檔案作業。</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       必須完全個<xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A>每次呼叫呼叫 EndRead 若要開始另一次讀取之前結束讀取的處理序失敗，可能會導致非預期的行為，例如死結。       這個方法會覆寫<xref:System.IO.Stream.EndRead%2A>.</xref:System.IO.Stream.EndRead%2A>       每個<xref:System.IAsyncResult>從<xref:System.IO.FileStream.BeginRead%2A>.</xref:System.IO.FileStream.BeginRead%2A></xref:System.IAsyncResult>上可呼叫 EndRead 呼叫 EndRead 會告訴您多少位元組被讀取從資料流。 EndRead 會阻擋，直到 I/O 作業完成為止。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/m-system.io.filestream.e_0_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/m-system.io.filestream.e_0_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/m-system.io.filestream.e_0_1.cpp)]"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "等候暫止的非同步要求的參考。"
    return:
      type: System.Int32
      description: "從資料流，介於 0 到您要求的位元組數，讀取的位元組數。 資料流只傳回 0 的資料流結尾，否則它們應該封鎖直到至少 1 位元組可用為止。"
  overload: System.IO.FileStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "此<xref:System.IAsyncResult>物件不是藉由呼叫<xref:System.IO.FileStream.BeginRead*>在這個類別。</xref:System.IO.FileStream.BeginRead*> </xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "多次呼叫 EndRead。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "資料流已關閉或發生內部錯誤。"
  platform:
  - net462
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "結束非同步寫入作業並封鎖，直到 I/O 作業完成為止。 (請考慮使用<xref:System.IO.FileStream.WriteAsync*>代替; 請參閱 < 備註 > 一節。)</xref:System.IO.FileStream.WriteAsync*>"
  remarks: "在.NET Framework 4 和舊版中，您必須使用下列方法<xref:System.IO.FileStream.BeginWrite%2A>和實作非同步檔案作業的 EndWrite。</xref:System.IO.FileStream.BeginWrite%2A> 這些方法都仍有[!INCLUDE[net_v45](~/add/includes/ajax-current-ext-md.md)]以支援舊版的程式碼; 不過，新的非同步方法，例如<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>， <xref:System.IO.Stream.CopyToAsync%2A>，和<xref:System.IO.FileStream.FlushAsync%2A>，協助您更輕鬆地實作非同步檔案作業。</xref:System.IO.FileStream.FlushAsync%2A> </xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A>       這個方法會覆寫<xref:System.IO.Stream.EndWrite%2A>.</xref:System.IO.Stream.EndWrite%2A>       EndWrite 必須正好一次上呼叫每個<xref:System.IAsyncResult>從<xref:System.IO.FileStream.BeginWrite%2A>.</xref:System.IO.FileStream.BeginWrite%2A> </xref:System.IAsyncResult> EndWrite 會阻擋，直到 I/O 作業完成為止。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#3](~/add/codesnippet/csharp/m-system.io.filestream.e_1_1.cs)]\n [!code-vb[System.IO.FileStream2#3](~/add/codesnippet/visualbasic/m-system.io.filestream.e_1_1.vb)]\n [!code-cpp[System.IO.FileStream2#3](~/add/codesnippet/cpp/m-system.io.filestream.e_1_1.cpp)]"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "暫止的非同步 I/O 要求。"
  overload: System.IO.FileStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>asyncResult</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "此<xref:System.IAsyncResult>物件不是藉由呼叫<xref:System.IO.Stream.BeginWrite*>在這個類別。</xref:System.IO.Stream.BeginWrite*> </xref:System.IAsyncResult>"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "EndWrite 會呼叫多次。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "資料流已關閉或發生內部錯誤。"
  platform:
  - net462
- uid: System.IO.FileStream.Finalize
  id: Finalize
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "確認釋出資源，並在記憶體回收行程回收時執行其他清除作業<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>。"
  remarks: "記憶體回收行程呼叫`Finalize`準備最終處理而將目前的物件時。 `Finalize`關閉`FileStream`。"
  syntax:
    content: ~FileStream ();
    parameters: []
  overload: System.IO.FileStream.Finalize*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Flush
  id: Flush
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "清除這個資料流的緩衝區，並造成任何緩衝的資料全部寫入檔案。"
  remarks: "這個方法會覆寫<xref:System.IO.Stream.Flush%2A?displayProperty=fullName>.</xref:System.IO.Stream.Flush%2A?displayProperty=fullName>       當您呼叫 Flush 方法時，也會排清作業系統 I/O 緩衝區。       除非您明確地呼叫排清或處置物件，不會排清資料流編碼器。 設定<xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName>至`true`表示從緩衝區資料流，清除資料，但並不會清除編碼器狀態。</xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=fullName> 這可讓編碼器將保存其狀態 （部分字元），讓它可以正確編碼字元的下一個區塊。 這種情況下會影響 UTF8 及 UTF7 其中某些字元可以只編碼的編碼器接收或多個相鄰的字元之後。       排清緩衝區可以用來讀取或寫入，因為可執行下列兩個功能:-任何之前寫入緩衝區的資料複製到檔案，並清除緩衝區其編碼器狀態除外。      -如果<xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName>是`true`資料先前已從檔案複製到讀取的緩衝區，檔案中目前的位置也會減少在緩衝區中讀取的位元組數目。</xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=fullName> 然後會清除緩衝區。       使用<xref:System.IO.FileStream.Flush%28System.Boolean%29>方法多載，當您想要確保所有中繼檔案緩衝區中緩衝資料寫入至磁碟。</xref:System.IO.FileStream.Flush%28System.Boolean%29>"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#4](~/add/codesnippet/csharp/m-system.io.filestream.f_1.cs)]\n [!code-cpp[System.IO.FileStream3#4](~/add/codesnippet/cpp/m-system.io.filestream.f_1.cpp)]\n [!code-vb[System.IO.FileStream3#4](~/add/codesnippet/visualbasic/m-system.io.filestream.f_1.vb)]"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.FileStream.Flush*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "資料流已關閉。"
  platform:
  - net462
- uid: System.IO.FileStream.Flush(System.Boolean)
  id: Flush(System.Boolean)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "清除這個資料流的緩衝區，造成任何緩衝的資料全部寫入檔案，並也會清除所有中繼檔案緩衝區。"
  remarks: "使用這個多載，當您想要確保所有中繼檔案緩衝區中緩衝資料寫入至磁碟。       當您呼叫 Flush 方法時，也會排清作業系統 I/O 緩衝區。"
  syntax:
    content: public virtual void Flush (bool flushToDisk);
    parameters:
    - id: flushToDisk
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要排清所有中繼檔案緩衝區;否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.FileStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  id: FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "以非同步的方式清除這個資料流的所有緩衝區，造成任何緩衝的資料都寫入基礎裝置，並且監視取消要求。"
  remarks: "當您呼叫 FlushAsync 方法時，也會排清作業系統 I/O 緩衝區。       如果在作業完成之前將其取消，則傳回的工作包含<xref:System.Threading.Tasks.TaskStatus>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> 如果已處置的檔案控制代碼，則傳回的工作包含<xref:System.ObjectDisposedException>中的例外狀況<xref:System.Threading.Tasks.Task.Exception%2A>屬性。</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  syntax:
    content: public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要用於監控取消要求的語彙基元。"
    return:
      type: System.Threading.Tasks.Task
      description: "表示非同步排清作業的工作。"
  overload: System.IO.FileStream.FlushAsync*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "資料流已經處置。"
  platform:
  - net462
- uid: System.IO.FileStream.GetAccessControl
  id: GetAccessControl
  parent: System.IO.FileStream
  langs:
  - csharp
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>物件會封裝目前所描述的檔案存取控制清單 (ACL) 項目<xref href=&quot;System.IO.FileStream&quot;></xref>物件。"
  remarks: "雖然<xref:System.IO.FileStream>可用來擷取現有檔案的存取控制清單 (ACL) 項目，請考慮使用類別和 GetAccessControl<xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName>方法，因為它比較容易使用。</xref:System.IO.File.GetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       您可以使用 GetAccessControl 方法來擷取檔案的 ACL 項目。       ACL 描述個人及/或群組，讓他們已經有或沒有，在指定的檔案上採取特定動作的權限。 如需詳細資訊，請參閱[如何︰ 加入或移除存取控制清單項目](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public System.Security.AccessControl.FileSecurity GetAccessControl ();
    parameters: []
    return:
      type: System.Security.AccessControl.FileSecurity
      description: "物件會封裝目前所描述之檔案的存取控制設定<xref href=&quot;System.IO.FileStream&quot;></xref>物件。"
  overload: System.IO.FileStream.GetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "關閉檔案。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "開啟檔案時發生 I/O 錯誤。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "找不到檔案。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "目前的平台不支援此作業。       -或者-呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.IO.FileStream.Handle
  id: Handle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得作業系統檔案控制代碼的檔案目前<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件封裝。"
  remarks: "這個屬性是用於操作-系統提供的系統呼叫作業系統的控制代碼 (例如`ReadFile`Windows 上)。 它不適用於 C 程式庫函式預期的檔案描述項，例如`fread`。       作業系統控制代碼可能已經開啟同步或非同步方式，依據`FileStream`建構函式呼叫。 使用<xref:System.IO.FileStream.IsAsync%2A>屬性以探索此控制代碼是否以非同步方式開啟。</xref:System.IO.FileStream.IsAsync%2A> 在 Win32 中，這表示控制代碼已開啟重疊的 io，而且它需要不同的參數`ReadFile`和`WriteFile`。      > [!CAUTION] > 如果，可能會發生資料損毀`FileStream`已建立，其控制代碼傳遞時，某些作業移動控制代碼的檔案指標，然後`FileStream`會再次使用。 多個執行緒安全地無法同時寫入相同的檔案和`FileStream`緩衝處理程式碼會假設它以獨佔方式控制控制代碼。 `FileStream`可能會擲回<xref:System.IO.IOException>如果`FileStream`偵測到某些其他處理序已移動檔案指標。</xref:System.IO.IOException> 若要避免這個問題，請勿不寫入任何資料檔案的一部分，`FileStream`可能必須緩衝處理，並在上次呼叫了方法時發生的位置還原的檔案指標`FileStream`。"
  syntax:
    content: public virtual IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "這個封裝的檔案之作業系統檔案控制代碼<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>物件，或是-1 <xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>已關閉。"
  overload: System.IO.FileStream.Handle*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "呼叫端沒有必要的權限。"
  platform:
  - net462
- uid: System.IO.FileStream.IsAsync
  id: IsAsync
  parent: System.IO.FileStream
  langs:
  - csharp
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得值，指出是否<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>為非同步或同步開啟。"
  remarks: "`IsAsync`屬性會偵測是否`FileStream`控制代碼開啟時以非同步的方式，讓您的程式碼使用<xref:System.IO.FileStream.Handle%2A>屬性正確。</xref:System.IO.FileStream.Handle%2A> 在 Win32 中，`IsAsync`正在 true 表示控制代碼的重疊 I/O，已開啟，並因此而需要不同的參數來`ReadFile`和`WriteFile`。       當您建立的執行個體時，指定這個值<xref:System.IO.FileStream>類別使用的建構函式`isAsync`， `useAsync`，或`options`參數。</xref:System.IO.FileStream> 若屬性是`true`，資料流使用重疊的 I/O，以非同步方式執行檔案作業。 不過，IsAsync 屬性並沒有要`true`呼叫<xref:System.IO.FileStream.ReadAsync%2A>， <xref:System.IO.FileStream.WriteAsync%2A>，或<xref:System.IO.Stream.CopyToAsync%2A>方法。</xref:System.IO.Stream.CopyToAsync%2A> </xref:System.IO.FileStream.WriteAsync%2A> </xref:System.IO.FileStream.ReadAsync%2A> 當 IsAsync 屬性是`false`和呼叫的非同步讀取和寫入作業，仍不封鎖 UI 執行緒，但實際的 I/O 作業會以同步方式執行。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#2](~/add/codesnippet/csharp/p-system.io.filestream.i_1.cs)]\n [!code-vb[System.IO.FileStream2#2](~/add/codesnippet/visualbasic/p-system.io.filestream.i_1.vb)]\n [!code-cpp[System.IO.FileStream2#2](~/add/codesnippet/cpp/p-system.io.filestream.i_1.cpp)]"
  syntax:
    content: public virtual bool IsAsync { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>為非同步開啟; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.FileStream.IsAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Length
  id: Length
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得以位元組為單位的資料流的長度。"
  remarks: "如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.l_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.l_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.l_1.vb)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "代表以位元組為單位的資料流長度的長數值。"
  overload: System.IO.FileStream.Length*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref:System.IO.FileStream.CanSeek*>這個資料流是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.IO.FileStream.CanSeek*>"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤，例如檔案已關閉。"
  platform:
  - net462
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  id: Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "防止其他處理程序讀取或寫入<xref href=&quot;System.IO.FileStream&quot;> </xref>。"
  remarks: "鎖定某個範圍的檔案資料流可讓執行緒的鎖定的處理序獨佔存取該範圍的檔案資料流。       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file. Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.l_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.l_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.l_1.vb)]"
  syntax:
    content: public virtual void Lock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "要鎖定之範圍的開頭。 此參數的值必須等於或大於零 (0)。"
    - id: length
      type: System.Int64
      description: "要鎖定的範圍。"
  overload: System.IO.FileStream.Lock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>或<code>length</code>是負數。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "關閉檔案。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "處理程序無法存取檔案，因為另一個處理序鎖定檔案的一部分。"
  platform:
  - net462
- uid: System.IO.FileStream.Name
  id: Name
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得名稱<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>傳遞給建構函式。"
  remarks: "如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> constructor.  \n  \n [!code-cs[System.IO.FileStream2#4](~/add/codesnippet/csharp/p-system.io.filestream.n_1.cs)]\n [!code-vb[System.IO.FileStream2#4](~/add/codesnippet/visualbasic/p-system.io.filestream.n_1.vb)]\n [!code-cpp[System.IO.FileStream2#4](~/add/codesnippet/cpp/p-system.io.filestream.n_1.cpp)]"
  syntax:
    content: public string Name { get; }
    return:
      type: System.String
      description: "字串名稱<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.FileStream.Name*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Position
  id: Position
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得或設定此資料流的目前位置。"
  remarks: "支援搜尋到的任何位置超出資料流的長度。  當您搜尋檔案的長度超過檔案大小會成長。  在 Microsoft Windows NT 及更新版本，新增至檔案結尾的所有資料都設為零。  在 Microsoft Windows 98 或更早版本，新增至檔案結尾的所有資料未設定為零，表示先前已刪除的資料會顯示資料流。 將資料流的位置設定為較大的值，在 Windows 98 或更早版本的資料流的結尾之外，可能會導致引發例外狀況。       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example uses the `Length` and `Position` properties to check for an end-of-file condition.  \n  \n [!code-cpp[Classic FileStream.Length Example#1](~/add/codesnippet/cpp/p-system.io.filestream.p_1.cpp)]\n [!code-cs[Classic FileStream.Length Example#1](~/add/codesnippet/csharp/p-system.io.filestream.p_1.cs)]\n [!code-vb[Classic FileStream.Length Example#1](~/add/codesnippet/visualbasic/p-system.io.filestream.p_1.vb)]"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "這個資料流目前位置。"
  overload: System.IO.FileStream.Position*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "資料流不支援搜尋。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n The position was set to a very large value beyond the end of the stream in Windows 98 or earlier."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "嘗試將位置設定為負數值。"
  - type: System.IO.EndOfStreamException
    commentId: T:System.IO.EndOfStreamException
    description: "嘗試搜尋超過不支援此資料流的結尾。"
  platform:
  - net462
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "從資料流讀取位元組區塊，並將資料寫入指定緩衝區。"
  remarks: "這個方法會覆寫<xref:System.IO.Stream.Read%2A>.</xref:System.IO.Stream.Read%2A>       `offset`參數會提供中的位元組位移`array`（緩衝區索引） 中要開始閱讀，而`count`參數指定要從這個資料流讀取的位元組數目上限。 如果已到達資料流結尾，傳回的值會是個位元組，則為零的實際數目。 如果在讀取的作業成功，讀取的位元組數目進階資料流的目前位置。 如果發生例外狀況，目前資料流的位置不變。       Read 方法傳回後才到達資料流結尾的零。 否則，讀取一定會讀取至少一個位元組資料流中傳回之前。 如果沒有資料可從資料流讀取呼叫時，方法會封鎖直到至少一個位元組的資料可能會傳回。 實作可以自由地傳回比要求的位元組更少，即使尚未達到資料流結尾。       使用<xref:System.IO.BinaryReader>讀取基本資料型別。</xref:System.IO.BinaryReader>       不會中斷正在執行讀取的作業的執行緒。 雖然應用程式或許可以順利執行之後，執行緒會封鎖，您的應用程式效能和可靠性，就可能會降低發生中斷。       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example reads the contents from a <xref:System.IO.FileStream> and writes it into another <xref:System.IO.FileStream>.  \n  \n [!code-vb[FSRead#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_1_1.vb)]\n [!code-cs[FSRead#1](~/add/codesnippet/csharp/m-system.io.filestream.r_1_1.cs)]"
  syntax:
    content: public override int Read (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "當這個方法會傳回包含指定的位元組陣列，其值介於`offset`和 (`offset`  +  `count` -1`)`由讀取自目前來源的位元組所取代。"
    - id: offset
      type: System.Int32
      description: "中的位元組位移`array`在將放置讀取的位元組。"
    - id: count
      type: System.Int32
      description: "要讀取的位元組數目上限。"
    return:
      type: System.Int32
      description: "緩衝區所讀取的位元組總數。 這可能會小於所要求的數目位元組如果位元組數目目前沒有提供，或如果資料流結尾為止。"
  overload: System.IO.FileStream.Read*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>是負數。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "資料流不支援讀取。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>和<code>count</code>說明中的無效範圍<code>array</code>。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "關閉資料流後呼叫了方法。"
  platform:
  - net462
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "以非同步方式從目前的資料流讀取一連串的位元組資料流位置推進讀取位元組數，並且監視取消要求。"
  remarks: "ReadAsync 方法可讓您執行需要大量資源的檔案作業，而不會封鎖主執行緒。 這項效能考量是特別重要，尤其[!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)]應用程式或[!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)]耗時的資料流作業可以封鎖 UI 執行緒，使起來像是停止運作的應用程式的應用程式。 非同步方法會用於搭配`async`和`await`Visual Basic 和 C# 中的關鍵字。       使用<xref:System.IO.FileStream.CanRead%2A>屬性來判斷目前的執行個體是否支援讀取。</xref:System.IO.FileStream.CanRead%2A>       如果在作業完成之前將其取消，則傳回的工作包含<xref:System.Threading.Tasks.TaskStatus>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> 如果已處置的檔案控制代碼，則傳回的工作包含<xref:System.ObjectDisposedException>中的例外狀況<xref:System.Threading.Tasks.Task.Exception%2A>屬性。</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to read from a file asynchronously.  \n  \n [!code-vb[Asynchronous_File_IO_async#4](~/add/codesnippet/visualbasic/9c5ba435-5f90-4f89-b415-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#4](~/add/codesnippet/csharp/9c5ba435-5f90-4f89-b415-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task<int> ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要寫入資料的緩衝區。"
    - id: offset
      type: System.Int32
      description: "中的位元組位移`buffer`中要開始寫入資料流的資料。"
    - id: count
      type: System.Int32
      description: "要讀取的位元組數目上限。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要用於監控取消要求的語彙基元。"
    return:
      type: System.Threading.Tasks.Task{System.Int32}
      description: "工作表示非同步讀取作業。 值<code> TResult </code>參數會包含讀取至緩衝區的位元組總數。 結果值可能會小於要求的位元組數; 如果目前可用的位元組數目少於所要求的數目，或如果已經到達資料流末端，則可能為 0 （零）。"
  overload: System.IO.FileStream.ReadAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>是負數。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "總和<code> offset </code>和<code> count </code>大於緩衝區長度。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "資料流不支援讀取。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "資料流已經處置。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "資料流目前正在使用先前的讀取作業。"
  platform:
  - net462
- uid: System.IO.FileStream.ReadByte
  id: ReadByte
  parent: System.IO.FileStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "從檔案讀取一個位元組，並往前移讀取的位置一個位元組。"
  remarks: "這個方法會覆寫<xref:System.IO.Stream.ReadByte%2A>.</xref:System.IO.Stream.ReadByte%2A>      > [!NOTE] > 使用<xref:System.IO.FileStream.CanRead%2A>屬性來判斷目前的執行個體是否支援讀取。</xref:System.IO.FileStream.CanRead%2A> 如需詳細資訊，請參閱<xref:System.IO.Stream.CanRead%2A>.</xref:System.IO.Stream.CanRead%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.r_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.r_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.r_0_1.cpp)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "Byte、 轉型為<xref:System.Int32>，則為-1，如果已經到達資料流結尾。</xref:System.Int32>"
  overload: System.IO.FileStream.ReadByte*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "目前資料流不支援讀取。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "目前資料流已關閉。"
  platform:
  - net462
- uid: System.IO.FileStream.SafeFileHandle
  id: SafeFileHandle
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "取得<xref href=&quot;Microsoft.Win32.SafeHandles.SafeFileHandle&quot;></xref>物件，代表檔案之作業系統檔案控制代碼的目前<xref href=&quot;System.IO.FileStream&quot;></xref>物件封裝。"
  remarks: "SafeFileHandle 屬性自動排清資料流，並將目前資料流位置設定為 0。  這可讓要移動檔案或要使用這個屬性所傳回的 SafeFileHandle 的另一個資料流來重設之資料流的位置。"
  syntax:
    content: public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "物件，代表檔案之作業系統檔案控制代碼的目前<xref href=&quot;System.IO.FileStream&quot;></xref>物件封裝。"
  overload: System.IO.FileStream.SafeFileHandle*
  exceptions: []
  platform:
  - net462
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "將此資料流的目前位置設定指定的值。"
  remarks: "這個方法會覆寫<xref:System.IO.Stream.Seek%2A?displayProperty=fullName>.</xref:System.IO.Stream.Seek%2A?displayProperty=fullName>      > [!NOTE] > 使用<xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName>屬性來判斷目前的執行個體是否支援搜尋。</xref:System.IO.FileStream.CanSeek%2A?displayProperty=fullName> 如需詳細資訊，請參閱<xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>.</xref:System.IO.Stream.CanSeek%2A?displayProperty=fullName>       您可以搜尋到的任何位置超出資料流的長度。 當您搜尋檔案的長度超過檔案大小會成長。 在 Windows NT 和更新版本中，資料檔案的結尾處加入設為零。 在 Windows 98 或更早版本中，新增到檔案結尾的資料未設定為零，表示先前已刪除的資料會顯示資料流。       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.s_1_1.cpp)]  \n  \n The following example reads text in the reverse direction, from the end of file to the beginning of the file, by using the various <xref:System.IO.SeekOrigin> values with the Seek method.  \n  \n [!code-vb[System.IO.FileStream.Seek#1](~/add/codesnippet/visualbasic/m-system.io.filestream.s_1_2.vb)]\n [!code-cs[System.IO.FileStream.Seek#1](~/add/codesnippet/csharp/m-system.io.filestream.s_1_2.cs)]"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "相對於`origin`要從其中開始搜尋。"
    - id: origin
      type: System.IO.SeekOrigin
      description: "指定開頭、 結尾或目前位置做為參考點`offset`，使用型別<xref:System.IO.SeekOrigin>.</xref:System.IO.SeekOrigin>值"
    return:
      type: System.Int64
      description: "資料流中的新位置。"
  overload: System.IO.FileStream.Seek*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "資料流不支援搜尋，例如，如果<xref uid=&quot;langword_csharp_FileStream&quot; name=&quot;FileStream&quot; href=&quot;&quot;></xref>建構從管道或主控台輸出。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "資料流開頭之前嘗試搜尋。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "關閉資料流後呼叫了方法。"
  platform:
  - net462
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  id: SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "適用於所描述的存取控制清單 (ACL) 項目<xref href=&quot;System.Security.AccessControl.FileSecurity&quot;></xref>目前所描述之檔案的物件<xref href=&quot;System.IO.FileStream&quot;></xref>物件。"
  remarks: "雖然<xref:System.IO.FileStream>類別和 SetAccessControl 可以用於現有的檔案，請考慮使用<xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName>方法，因為它比較容易使用。</xref:System.IO.File.SetAccessControl%2A?displayProperty=fullName> </xref:System.IO.FileStream>       SetAccessControl 方法適用於存取控制清單 (ACL) 項目代表 noninherited 的 ACL 清單的檔案。      > [!CAUTION] > ACL 指定`fileSecurity`參數已取代現有檔案的 ACL。 若要加入之新使用者的權限，請使用<xref:System.IO.FileStream.GetAccessControl%2A>方法來取得現有的 ACL、 修改它，然後使用 SetAccessControl 來套用該備份檔案。</xref:System.IO.FileStream.GetAccessControl%2A>       ACL 描述個人及/或群組，讓他們已經有或沒有，在指定的檔案上採取特定動作的權限。 如需詳細資訊，請參閱[如何︰ 加入或移除存取控制清單項目](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);
    parameters:
    - id: fileSecurity
      type: System.Security.AccessControl.FileSecurity
      description: "物件，描述要套用至目前檔案的 ACL 項目。"
  overload: System.IO.FileStream.SetAccessControl*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "關閉檔案。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>fileSecurity</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "找不到或無法修改檔案。"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "目前的處理序沒有開啟檔案的存取權。"
  platform:
  - net462
- uid: System.IO.FileStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "設定此資料流的長度為指定值。"
  remarks: "這個方法會覆寫<xref:System.IO.Stream.SetLength%2A>.</xref:System.IO.Stream.SetLength%2A>       如果指定的值小於目前資料流的長度，則會截斷資料流。 在此案例中，如果目前的位置是新的長度大於目前的位置會移至最後一個資料流的位元組。 如果目前資料流的長度大於指定的值，擴充的資料流，及目前的位置維持不變。 如果展開資料流時，舊之間的新長度的資料流的內容會是未定義。       資料流必須支援寫入和搜尋的`SetLength`運作。      > [!NOTE] > 使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入，而<xref:System.IO.FileStream.CanSeek%2A>屬性來判斷是否支援搜尋。</xref:System.IO.FileStream.CanSeek%2A> </xref:System.IO.FileStream.CanWrite%2A> 如需詳細資訊，請參閱<xref:System.IO.Stream.CanWrite%2A>和<xref:System.IO.Stream.CanSeek%2A>。</xref:System.IO.Stream.CanSeek%2A> </xref:System.IO.Stream.CanWrite%2A>       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "資料流的新長度。"
  overload: System.IO.FileStream.SetLength*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "發生 I/O 錯誤。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "資料流不支援寫入和搜尋。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "嘗試設定<code> value </code>參數小於 0。"
  platform:
  - net462
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  id: Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "允許存取其他處理程序全部或部分先前鎖定的檔案。"
  remarks: "如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "The following code example demonstrates how to lock part of a file so another process cannot access that part of the file even though it has read/write access to the file, and then unlock the specified part of the file . Run the program simultaneously in different command windows and investigate using the different console input options.  \n  \n [!code-cs[System.IO.FileStream3#1](~/add/codesnippet/csharp/m-system.io.filestream.u_1.cs)]\n [!code-cpp[System.IO.FileStream3#1](~/add/codesnippet/cpp/m-system.io.filestream.u_1.cpp)]\n [!code-vb[System.IO.FileStream3#1](~/add/codesnippet/visualbasic/m-system.io.filestream.u_1.vb)]"
  syntax:
    content: public virtual void Unlock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "若要解除鎖定範圍的開頭。"
    - id: length
      type: System.Int64
      description: "要解除鎖定範圍。"
  overload: System.IO.FileStream.Unlock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>或<code>length</code>是負數。"
  platform:
  - net462
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "將位元組區塊寫入至檔案資料流。"
  remarks: "這個方法會覆寫<xref:System.IO.Stream.Write%2A>.</xref:System.IO.Stream.Write%2A>       `offset`參數會提供中的位元組位移`array`（緩衝區索引） 中要開始複製，而`count`參數指定將寫入資料流的位元組數目。 如果作業成功時，寫入的位元組數目進階資料流的目前位置。 如果發生例外狀況，目前資料流的位置不變。      > [!NOTE] > 使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入。</xref:System.IO.FileStream.CanWrite%2A> 如需詳細資訊，請參閱<xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A>       不會中斷正在執行寫入作業的執行緒。 雖然應用程式或許可以順利執行之後，執行緒會封鎖，您的應用程式效能和可靠性，就可能會降低發生中斷。       如需常見的檔案和目錄作業的清單，請參閱[一般 I/O 工作](~/add/includes/ajax-current-ext-md.md)。"
  example:
  - "This code example is part of a larger example provided for the <xref:System.IO.FileStream.Lock%2A> method.  \n  \n [!code-cs[System.IO.FileStream3#3](~/add/codesnippet/csharp/m-system.io.filestream.w_1_1.cs)]\n [!code-cpp[System.IO.FileStream3#3](~/add/codesnippet/cpp/m-system.io.filestream.w_1_1.cpp)]\n [!code-vb[System.IO.FileStream3#3](~/add/codesnippet/visualbasic/m-system.io.filestream.w_1_1.vb)]"
  syntax:
    content: public override void Write (byte[] array, int offset, int count);
    parameters:
    - id: array
      type: System.Byte[]
      description: "包含要寫入資料流資料的緩衝區。"
    - id: offset
      type: System.Int32
      description: "中以零為起始的位元組位移`array`要從其中開始將位元組複製至資料流。"
    - id: count
      type: System.Int32
      description: "要寫入的位元組數目上限。"
  overload: System.IO.FileStream.Write*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>offset</code>和<code>count</code>說明中的無效範圍<code>array</code>。"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>是負數。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "An I/O error occurred.  \n  \n \\- or -  \n  \n Another thread may have caused an unexpected change in the position of the operating system's file handle."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "資料流已關閉。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "目前資料流執行個體不支援寫入。"
  platform:
  - net462
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  id: WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "以非同步方式將一連串的位元組寫入目前資料流，這個資料流中的目前位置前移寫入的位元組數目，以及監視取消要求。"
  remarks: "WriteAsync 方法可讓您執行需要大量資源的檔案作業，而不會封鎖主執行緒。 這項效能考量是特別重要，尤其[!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)]應用程式或[!INCLUDE[desktop_appname](~/add/includes/desktop-appname-md.md)]耗時的資料流作業可以封鎖 UI 執行緒，使起來像是停止運作的應用程式的應用程式。 非同步方法會用於搭配`async`和`await`Visual Basic 和 C# 中的關鍵字。       使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援讀取。</xref:System.IO.FileStream.CanWrite%2A>       如果在作業完成之前將其取消，則傳回的工作包含<xref:System.Threading.Tasks.TaskStatus>值<xref:System.Threading.Tasks.Task.Status%2A>屬性。</xref:System.Threading.Tasks.Task.Status%2A> </xref:System.Threading.Tasks.TaskStatus> 如果已處置的檔案控制代碼，則傳回的工作包含<xref:System.ObjectDisposedException>中的例外狀況<xref:System.Threading.Tasks.Task.Exception%2A>屬性。</xref:System.Threading.Tasks.Task.Exception%2A> </xref:System.ObjectDisposedException>"
  example:
  - "The following example shows how to write asynchronously to a file.  \n  \n [!code-vb[Asynchronous_File_IO_async#3](~/add/codesnippet/visualbasic/7726d527-d678-42ba-9864-_1.vb)]\n [!code-cs[Asynchronous_File_IO_async#3](~/add/codesnippet/csharp/7726d527-d678-42ba-9864-_1.cs)]"
  syntax:
    content: public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "資料寫入來源緩衝區。"
    - id: offset
      type: System.Int32
      description: "中以零為起始的位元組位移`buffer`要從其中開始將位元組複製至資料流。"
    - id: count
      type: System.Int32
      description: "要寫入的位元組數目上限。"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "要用於監控取消要求的語彙基元。"
    return:
      type: System.Threading.Tasks.Task
      description: "表示非同步寫入作業的工作。"
  overload: System.IO.FileStream.WriteAsync*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>buffer</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>offset</code>或<code>count</code>是負數。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "總和<code> offset </code>和<code> count </code>大於緩衝區長度。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "資料流不支援寫入。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "資料流已經處置。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "資料流目前正在使用先前的寫入作業。"
  platform:
  - net462
- uid: System.IO.FileStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.FileStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO
  summary: "將位元組寫入檔案資料流中目前的位置。"
  remarks: "這個方法會覆寫<xref:System.IO.Stream.WriteByte%2A>.</xref:System.IO.Stream.WriteByte%2A>       使用`WriteByte`寫入一個位元組至`FileStream`有效率。 如果資料流已關閉或沒有可寫入，就會擲回例外狀況。      > [!NOTE] > 使用<xref:System.IO.FileStream.CanWrite%2A>屬性來判斷目前的執行個體是否支援寫入。</xref:System.IO.FileStream.CanWrite%2A> 如需詳細資訊，請參閱<xref:System.IO.Stream.CanWrite%2A>.</xref:System.IO.Stream.CanWrite%2A>"
  example:
  - "The following code example shows how to write data to a file, byte by byte, and then verify that the data was written correctly.  \n  \n [!code-vb[System.IO.FileStream1#1](~/add/codesnippet/visualbasic/m-system.io.filestream.w_0_1.vb)]\n [!code-cs[System.IO.FileStream1#1](~/add/codesnippet/csharp/m-system.io.filestream.w_0_1.cs)]\n [!code-cpp[System.IO.FileStream1#1](~/add/codesnippet/cpp/m-system.io.filestream.w_0_1.cpp)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "要寫入資料流的位元組。"
  overload: System.IO.FileStream.WriteByte*
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "資料流已關閉。"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "資料流不支援寫入。"
  platform:
  - net462
references:
- uid: System.IO.Stream
  isExternal: false
  name: System.IO.Stream
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: true
  name: System.UnauthorizedAccessException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.PathTooLongException
  isExternal: true
  name: System.IO.PathTooLongException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.PlatformNotSupportedException
  isExternal: true
  name: System.PlatformNotSupportedException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.IO.EndOfStreamException
  isExternal: true
  name: System.IO.EndOfStreamException
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess)
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess)
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode)
  nameWithType: FileStream.FileStream(String,FileMode)
  fullName: System.IO.FileStream.FileStream(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess)
- uid: System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  nameWithType: FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(SafeFileHandle,FileAccess,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  nameWithType: FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(IntPtr,FileAccess,Boolean,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,Boolean)
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileAccess,FileShare,Int32,FileOptions)
- uid: System.IO.FileOptions
  parent: System.IO
  isExternal: false
  name: FileOptions
  nameWithType: FileOptions
  fullName: System.IO.FileOptions
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions)
- uid: System.Security.AccessControl.FileSystemRights
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSystemRights
  nameWithType: FileSystemRights
  fullName: System.Security.AccessControl.FileSystemRights
- uid: System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  nameWithType: FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
  fullName: System.IO.FileStream.FileStream(String,FileMode,FileSystemRights,FileShare,Int32,FileOptions,FileSecurity)
- uid: System.Security.AccessControl.FileSecurity
  parent: System.Security.AccessControl
  isExternal: false
  name: FileSecurity
  nameWithType: FileSecurity
  fullName: System.Security.AccessControl.FileSecurity
- uid: System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.FileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.FileStream.CanRead
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
  fullName: System.IO.FileStream.CanRead
- uid: System.IO.FileStream.CanSeek
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
  fullName: System.IO.FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
  fullName: System.IO.FileStream.CanWrite
- uid: System.IO.FileStream.Dispose(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: FileStream.Dispose(Boolean)
  fullName: System.IO.FileStream.Dispose(Boolean)
- uid: System.IO.FileStream.EndRead(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: FileStream.EndRead(IAsyncResult)
  fullName: System.IO.FileStream.EndRead(IAsyncResult)
- uid: System.IO.FileStream.EndWrite(System.IAsyncResult)
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: FileStream.EndWrite(IAsyncResult)
  fullName: System.IO.FileStream.EndWrite(IAsyncResult)
- uid: System.IO.FileStream.Finalize
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize()
  nameWithType: FileStream.Finalize()
  fullName: System.IO.FileStream.Finalize()
- uid: System.IO.FileStream.Flush
  parent: System.IO.FileStream
  isExternal: false
  name: Flush()
  nameWithType: FileStream.Flush()
  fullName: System.IO.FileStream.Flush()
- uid: System.IO.FileStream.Flush(System.Boolean)
  parent: System.IO.FileStream
  isExternal: false
  name: Flush(Boolean)
  nameWithType: FileStream.Flush(Boolean)
  fullName: System.IO.FileStream.Flush(Boolean)
- uid: System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync(CancellationToken)
  nameWithType: FileStream.FlushAsync(CancellationToken)
  fullName: System.IO.FileStream.FlushAsync(CancellationToken)
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: true
  name: Task
  nameWithType: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: true
  name: CancellationToken
  nameWithType: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.IO.FileStream.GetAccessControl
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl()
  nameWithType: FileStream.GetAccessControl()
  fullName: System.IO.FileStream.GetAccessControl()
- uid: System.IO.FileStream.Handle
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
  fullName: System.IO.FileStream.Handle
- uid: System.IO.FileStream.IsAsync
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
  fullName: System.IO.FileStream.IsAsync
- uid: System.IO.FileStream.Length
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
  fullName: System.IO.FileStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.FileStream.Lock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Lock(Int64,Int64)
  nameWithType: FileStream.Lock(Int64,Int64)
  fullName: System.IO.FileStream.Lock(Int64,Int64)
- uid: System.IO.FileStream.Name
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
  fullName: System.IO.FileStream.Name
- uid: System.IO.FileStream.Position
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
  fullName: System.IO.FileStream.Position
- uid: System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: FileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Read(Byte[],Int32,Int32)
- uid: System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.ReadAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  isExternal: true
  name: Task<Int32>
  nameWithType: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    nameWithType: Task
    fullName: Task<System.Int32>
  - name: <
    nameWithType: <
    fullName: <
  - uid: System.Int32
    name: Int32
    nameWithType: Int32
    fullName: Int32
  - name: '>'
    nameWithType: '>'
    fullName: '>'
- uid: System.IO.FileStream.ReadByte
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte()
  nameWithType: FileStream.ReadByte()
  fullName: System.IO.FileStream.ReadByte()
- uid: System.IO.FileStream.SafeFileHandle
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
  fullName: System.IO.FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.FileStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: FileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.FileStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl(FileSecurity)
  nameWithType: FileStream.SetAccessControl(FileSecurity)
  fullName: System.IO.FileStream.SetAccessControl(FileSecurity)
- uid: System.IO.FileStream.SetLength(System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: FileStream.SetLength(Int64)
  fullName: System.IO.FileStream.SetLength(Int64)
- uid: System.IO.FileStream.Unlock(System.Int64,System.Int64)
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock(Int64,Int64)
  nameWithType: FileStream.Unlock(Int64,Int64)
  fullName: System.IO.FileStream.Unlock(Int64,Int64)
- uid: System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.FileStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: FileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.FileStream.Write(Byte[],Int32,Int32)
- uid: System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync(Byte[],Int32,Int32,CancellationToken)
  nameWithType: FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
  fullName: System.IO.FileStream.WriteAsync(Byte[],Int32,Int32,CancellationToken)
- uid: System.IO.FileStream.WriteByte(System.Byte)
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: FileStream.WriteByte(Byte)
  fullName: System.IO.FileStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.FileStream.#ctor*
  parent: System.IO.FileStream
  isExternal: false
  name: FileStream
  nameWithType: FileStream.FileStream
- uid: System.IO.FileStream.BeginRead*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginRead
  nameWithType: FileStream.BeginRead
- uid: System.IO.FileStream.BeginWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: BeginWrite
  nameWithType: FileStream.BeginWrite
- uid: System.IO.FileStream.CanRead*
  parent: System.IO.FileStream
  isExternal: false
  name: CanRead
  nameWithType: FileStream.CanRead
- uid: System.IO.FileStream.CanSeek*
  parent: System.IO.FileStream
  isExternal: false
  name: CanSeek
  nameWithType: FileStream.CanSeek
- uid: System.IO.FileStream.CanWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: CanWrite
  nameWithType: FileStream.CanWrite
- uid: System.IO.FileStream.Dispose*
  parent: System.IO.FileStream
  isExternal: false
  name: Dispose
  nameWithType: FileStream.Dispose
- uid: System.IO.FileStream.EndRead*
  parent: System.IO.FileStream
  isExternal: false
  name: EndRead
  nameWithType: FileStream.EndRead
- uid: System.IO.FileStream.EndWrite*
  parent: System.IO.FileStream
  isExternal: false
  name: EndWrite
  nameWithType: FileStream.EndWrite
- uid: System.IO.FileStream.Finalize*
  parent: System.IO.FileStream
  isExternal: false
  name: Finalize
  nameWithType: FileStream.Finalize
- uid: System.IO.FileStream.Flush*
  parent: System.IO.FileStream
  isExternal: false
  name: Flush
  nameWithType: FileStream.Flush
- uid: System.IO.FileStream.FlushAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: FlushAsync
  nameWithType: FileStream.FlushAsync
- uid: System.IO.FileStream.GetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: GetAccessControl
  nameWithType: FileStream.GetAccessControl
- uid: System.IO.FileStream.Handle*
  parent: System.IO.FileStream
  isExternal: false
  name: Handle
  nameWithType: FileStream.Handle
- uid: System.IO.FileStream.IsAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: IsAsync
  nameWithType: FileStream.IsAsync
- uid: System.IO.FileStream.Length*
  parent: System.IO.FileStream
  isExternal: false
  name: Length
  nameWithType: FileStream.Length
- uid: System.IO.FileStream.Lock*
  parent: System.IO.FileStream
  isExternal: false
  name: Lock
  nameWithType: FileStream.Lock
- uid: System.IO.FileStream.Name*
  parent: System.IO.FileStream
  isExternal: false
  name: Name
  nameWithType: FileStream.Name
- uid: System.IO.FileStream.Position*
  parent: System.IO.FileStream
  isExternal: false
  name: Position
  nameWithType: FileStream.Position
- uid: System.IO.FileStream.Read*
  parent: System.IO.FileStream
  isExternal: false
  name: Read
  nameWithType: FileStream.Read
- uid: System.IO.FileStream.ReadAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadAsync
  nameWithType: FileStream.ReadAsync
- uid: System.IO.FileStream.ReadByte*
  parent: System.IO.FileStream
  isExternal: false
  name: ReadByte
  nameWithType: FileStream.ReadByte
- uid: System.IO.FileStream.SafeFileHandle*
  parent: System.IO.FileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: FileStream.SafeFileHandle
- uid: System.IO.FileStream.Seek*
  parent: System.IO.FileStream
  isExternal: false
  name: Seek
  nameWithType: FileStream.Seek
- uid: System.IO.FileStream.SetAccessControl*
  parent: System.IO.FileStream
  isExternal: false
  name: SetAccessControl
  nameWithType: FileStream.SetAccessControl
- uid: System.IO.FileStream.SetLength*
  parent: System.IO.FileStream
  isExternal: false
  name: SetLength
  nameWithType: FileStream.SetLength
- uid: System.IO.FileStream.Unlock*
  parent: System.IO.FileStream
  isExternal: false
  name: Unlock
  nameWithType: FileStream.Unlock
- uid: System.IO.FileStream.Write*
  parent: System.IO.FileStream
  isExternal: false
  name: Write
  nameWithType: FileStream.Write
- uid: System.IO.FileStream.WriteAsync*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteAsync
  nameWithType: FileStream.WriteAsync
- uid: System.IO.FileStream.WriteByte*
  parent: System.IO.FileStream
  isExternal: false
  name: WriteByte
  nameWithType: FileStream.WriteByte
