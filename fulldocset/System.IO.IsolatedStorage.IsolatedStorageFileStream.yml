### YamlMime:ManagedReference
items:
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream
  id: IsolatedStorageFileStream
  children:
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(System.IAsyncResult)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Length
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(System.Int64,System.Int64)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Position
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(System.Int64)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(System.Int64,System.Int64)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(System.Byte)
  langs:
  - csharp
  name: IsolatedStorageFileStream
  nameWithType: IsolatedStorageFileStream
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream
  type: Class
  summary: "公開隔離儲存區中的檔案。"
  remarks: "您可以使用這個類別來讀取、 寫入和建立隔離儲存區中的檔案。       由於此類別會擴充<xref:System.IO.FileStream>，您可以使用 IsolatedStorageFileStream 的執行個體，在大部分情況下其中<xref:System.IO.FileStream>可能用，例如建構<xref:System.IO.StreamReader>或<xref:System.IO.StreamWriter>.</xref:System.IO.StreamWriter> </xref:System.IO.StreamReader> </xref:System.IO.FileStream> </xref:System.IO.FileStream>       此類型會實作<xref:System.IDisposable>介面。</xref:System.IDisposable> 當您完成使用類型時，您應該會處置它直接或間接。 若要直接處置的類型，呼叫其<xref:System.IDisposable.Dispose%2A>方法中的`try` / `catch`區塊。</xref:System.IDisposable.Dispose%2A> 若要為其配置間接，使用語言建構例如`using`（C# 中） 或`Using`（在 Visual Basic)。 如需詳細資訊，請參閱中的 「 使用物件的實作 IDisposable 」 一節<xref:System.IDisposable>介面 > 主題。</xref:System.IDisposable>      > [!IMPORTANT] > 隔離儲存區不適用於[!INCLUDE[win8_appname_long](~/add/includes/win8-appname-long-md.md)]應用程式。 相反地，使用中的應用程式資料類別`Windows.Storage`中包含的命名空間[!INCLUDE[wrt](~/add/includes/wrt-md.md)]來儲存本機資料和檔案 API。 如需詳細資訊，請參閱[應用程式資料](http://go.microsoft.com/fwlink/?LinkId=229175)Windows 開發人員中心。"
  example:
  - "The following console application demonstrates how you can use <xref:System.IO.IsolatedStorage.IsolatedStorageFile> and IsolatedStorageFileStream to write data to an Isolated Storage file. The user is requested to log in. If the user is a new user, a News URL and a Sports URL are recorded as personal preferences in Isolated Storage. If the user is a returning user, the user's current preferences are displayed. The code examples used throughout this namespace are presented in the context of this sample application. You can use the [Storeadm.exe (Isolated Storage Tool)](~/add/includes/ajax-current-ext-md.md) utility to list and remove the Isolated Storage files that are created with this console application.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#1](~/add/codesnippet/visualbasic/t-system.io.isolatedstor_2_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#1](~/add/codesnippet/cpp/t-system.io.isolatedstor_2_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#1](~/add/codesnippet/csharp/t-system.io.isolatedstor_2_1.cs)]"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public class IsolatedStorageFileStream : System.IO.FileStream
  inheritance:
  - System.IO.Stream
  - System.IO.FileStream
  implements: []
  inheritedMembers:
  - System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)
  - System.IO.FileStream.GetAccessControl
  - System.IO.FileStream.Name
  - System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  - System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)
  - System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode)
  id: '#ctor(System.String,System.IO.FileMode)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新執行個體<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>授予存取權所指定的檔案物件<code> path </code>指定<code> mode </code>。"
  remarks: "使用隔離儲存區的範圍是由目前執行組件的識別，以及正在執行的應用程式定義域。 此存放區會保持開啟狀態的存留期只針對<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 若要指定不同的隔離儲存區的範圍，或允許保持開啟存放區 (因此多個<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件可以從它開啟)，使用建構函式可接受的形式<xref:System.IO.IsolatedStorage.IsolatedStorageFile>物件。</xref:System.IO.IsolatedStorage.IsolatedStorageFile> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>       `mode`參數會指出是否應該建立新的檔案、 使用現有的等等。      > [!CAUTION] > 當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，而且可能會導致擲回例外狀況。"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode);
    parameters:
    - id: path
      type: System.String
      description: "隔離儲存區中的檔案相對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式不正確。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.DirectoryNotFoundException
    commentId: T:System.IO.DirectoryNotFoundException
    description: "中的目錄<code> path </code>不存在。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到任何檔案和<code> mode </code>設為<xref href=&quot;System.IO.FileMode&quot;></xref>"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode,FileAccess)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新執行個體<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>類別存取所指定的檔案<code> path </code>，在指定<code> mode </code>，使用種類的<code> access </code>要求。"
  remarks: "使用隔離儲存區的範圍是由目前執行組件的識別，以及正在執行的應用程式定義域。 此存放區會保持開啟狀態的存留期只針對<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 若要指定不同的隔離儲存區的範圍，或允許保持開啟存放區 (因此多個<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件可以從它開啟)，使用建構函式可接受的形式<xref:System.IO.IsolatedStorage.IsolatedStorageFile>物件。</xref:System.IO.IsolatedStorage.IsolatedStorageFile> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>       `mode`參數會指出是否應該建立新的檔案或使用現有的。 `access`參數包含唯讀的讀取/寫入，和唯寫。      > [!CAUTION] > 當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會導致擲回例外狀況。"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);
    parameters:
    - id: path
      type: System.String
      description: "隔離儲存區中的檔案相對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
    - id: access
      type: System.IO.FileAccess
      description: "位元組合<xref href=&quot;System.IO.FileAccess&quot;></xref>值。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式不正確。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到任何檔案和<code> mode </code>設<xref href=&quot;System.IO.FileMode&quot;> </xref>。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,IsolatedStorageFile)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新執行個體<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>類別存取所指定的檔案<code> path </code>，在指定<code> mode </code>，內容中<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;></xref>所指定<code> isf </code>。"
  remarks: "`mode`參數會指出是否應該建立新的檔案、 使用現有的等等。      > [!CAUTION] > 當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會導致擲回例外狀況。"
  example:
  - "The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/visualbasic/ed0ff8fa-778f-4b06-9af8-_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/cpp/ed0ff8fa-778f-4b06-9af8-_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/csharp/ed0ff8fa-778f-4b06-9af8-_1.cs)]"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.IsolatedStorage.IsolatedStorageFile isf);
    parameters:
    - id: path
      type: System.String
      description: "隔離儲存區中的檔案相對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
    - id: isf
      type: System.IO.IsolatedStorage.IsolatedStorageFile
      description: "<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;> </xref>開啟<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式不正確。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到任何檔案和<code> mode </code>設<xref href=&quot;System.IO.FileMode&quot;> </xref>。"
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "<code>isf</code>沒有配額。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新執行個體<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>類別存取所指定的檔案<code> path </code>，在指定<code> mode </code>，使用指定的檔案<code> access </code>，使用的檔案共用模式所指定<code> share </code>。"
  remarks: "使用隔離儲存區的範圍是由目前執行組件的識別，以及正在執行的應用程式定義域。 此存放區會保持開啟狀態的存留期只針對<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 若要指定不同的隔離儲存區的範圍，或允許保持開啟存放區 (因此多個<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件可以從它開啟)，使用建構函式可接受的形式<xref:System.IO.IsolatedStorage.IsolatedStorageFile>物件。</xref:System.IO.IsolatedStorage.IsolatedStorageFile> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>      > [!CAUTION] > 當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，而且可能會導致擲回例外狀況。"
  example:
  - "The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#15](~/add/codesnippet/visualbasic/16e66ff6-8db3-485d-ac06-_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#15](~/add/codesnippet/cpp/16e66ff6-8db3-485d-ac06-_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#15](~/add/codesnippet/csharp/16e66ff6-8db3-485d-ac06-_1.cs)]"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
    parameters:
    - id: path
      type: System.String
      description: "隔離儲存區中的檔案相對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
    - id: access
      type: System.IO.FileAccess
      description: "位元組合<xref href=&quot;System.IO.FileAccess&quot;></xref>值。"
    - id: share
      type: System.IO.FileShare
      description: "位元組合<xref href=&quot;System.IO.FileShare&quot;></xref>值。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式不正確。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到任何檔案和<code> mode </code>設<xref href=&quot;System.IO.FileMode&quot;> </xref>。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,IsolatedStorageFile)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新執行個體<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>類別存取所指定的檔案<code> path </code>指定<code> mode </code>，使用指定的檔案<code> access </code>，內容中<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;></xref>所指定<code> isf </code>。"
  remarks: "`mode`參數會指出是否應該建立新的檔案或使用現有的。 `access`參數包含唯讀的讀取/寫入，和唯寫。      > [!CAUTION] > 當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會導致擲回例外狀況。"
  example:
  - "The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/add/codesnippet/visualbasic/404bef15-453e-4818-ab5f-_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/add/codesnippet/cpp/404bef15-453e-4818-ab5f-_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#10](~/add/codesnippet/csharp/404bef15-453e-4818-ab5f-_1.cs)]"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.IsolatedStorage.IsolatedStorageFile isf);
    parameters:
    - id: path
      type: System.String
      description: "隔離儲存區中的檔案相對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
    - id: access
      type: System.IO.FileAccess
      description: "位元組合<xref href=&quot;System.IO.FileAccess&quot;></xref>值。"
    - id: isf
      type: System.IO.IsolatedStorage.IsolatedStorageFile
      description: "<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;> </xref>開啟<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式不正確。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "隔離儲存區已關閉。"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到任何檔案和<code> mode </code>設<xref href=&quot;System.IO.FileMode&quot;> </xref>。"
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "<code>isf</code>沒有配額。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新執行個體<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>類別存取所指定的檔案<code> path </code>，在指定<code> mode </code>，使用指定的檔案<code> access </code>，使用的檔案共用模式所指定<code> share </code>，與<code> buffersize </code>指定。"
  remarks: "使用隔離儲存區的範圍是由目前執行組件的識別，以及正在執行的應用程式定義域。 此存放區會保持開啟狀態的存留期只針對<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 若要指定不同的隔離儲存區的範圍，或允許保持開啟存放區 (因此多個<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件可以從它開啟)，使用建構函式可接受的形式<xref:System.IO.IsolatedStorage.IsolatedStorageFile>物件。</xref:System.IO.IsolatedStorage.IsolatedStorageFile> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>       `mode`參數會指出是否應該建立新的檔案或使用現有的。 `access`參數包含唯讀的讀取/寫入，和唯寫。      > [!CAUTION] > 當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會導致擲回例外狀況。"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
    parameters:
    - id: path
      type: System.String
      description: "隔離儲存區中的檔案相對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
    - id: access
      type: System.IO.FileAccess
      description: "位元組合<xref href=&quot;System.IO.FileAccess&quot;></xref>值。"
    - id: share
      type: System.IO.FileShare
      description: "位元組合<xref href=&quot;System.IO.FileShare&quot;></xref>值。"
    - id: bufferSize
      type: System.Int32
      description: "<xref href=&quot;System.IO.FileStream&quot;> </xref>緩衝區大小。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式不正確。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到任何檔案和<code> mode </code>設<xref href=&quot;System.IO.FileMode&quot;> </xref>。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,IsolatedStorageFile)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新執行個體<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>類別存取所指定的檔案<code> path </code>，在指定<code> mode </code>，使用指定的檔案<code> access </code>，使用的檔案共用模式所指定<code> share </code>，內容中<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;></xref>所指定<code> isf </code>。"
  remarks: "`mode`參數會指出是否應該建立新的檔案或使用現有的。 `access`參數包含唯讀的讀取/寫入，和唯寫。      > [!CAUTION] > 當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會導致擲回例外狀況。"
  example:
  - "The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/visualbasic/d6e9d0e2-c3f3-4d3d-941f-_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/cpp/d6e9d0e2-c3f3-4d3d-941f-_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/csharp/d6e9d0e2-c3f3-4d3d-941f-_1.cs)]"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.IsolatedStorage.IsolatedStorageFile isf);
    parameters:
    - id: path
      type: System.String
      description: "隔離儲存區中的檔案相對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
    - id: access
      type: System.IO.FileAccess
      description: "位元組合<xref href=&quot;System.IO.FileAccess&quot;></xref>值。"
    - id: share
      type: System.IO.FileShare
      description: "位元組合<xref href=&quot;System.IO.FileShare&quot;></xref>值。"
    - id: isf
      type: System.IO.IsolatedStorage.IsolatedStorageFile
      description: "<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;> </xref>開啟<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式不正確。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到任何檔案和<code> mode </code>設<xref href=&quot;System.IO.FileMode&quot;> </xref>。"
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "<code>isf</code>沒有配額。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)
  id: '#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)'
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32,IsolatedStorageFile)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "初始化的新執行個體<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>類別存取所指定的檔案<code> path </code>，在指定<code> mode </code>，使用指定的檔案<code> access </code>，使用的檔案共用模式所指定<code> share </code>，與<code> buffersize </code>指定，並在內容中<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;></xref>所指定<code> isf </code>。"
  remarks: "`mode`參數會指出是否應該建立新的檔案或使用現有的。 `access`參數包含唯讀的讀取/寫入，和唯寫。      > [!CAUTION] > 當您使用特定文化特性設定進行編譯的一組字元，並擷取相同的字元具有不同的文化特性設定時，這些字元可能會無法解譯，，而且可能會導致擲回例外狀況。"
  example:
  - "The following code example demonstrates the use of this constructor. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#12](~/add/codesnippet/visualbasic/992df1ce-aff0-4ca4-9ce4-_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#12](~/add/codesnippet/cpp/992df1ce-aff0-4ca4-9ce4-_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#12](~/add/codesnippet/csharp/992df1ce-aff0-4ca4-9ce4-_1.cs)]"
  syntax:
    content: public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.IsolatedStorage.IsolatedStorageFile isf);
    parameters:
    - id: path
      type: System.String
      description: "隔離儲存區中的檔案相對路徑。"
    - id: mode
      type: System.IO.FileMode
      description: "其中一個<xref href=&quot;System.IO.FileMode&quot;></xref>值。"
    - id: access
      type: System.IO.FileAccess
      description: "位元組合<xref href=&quot;System.IO.FileAccess&quot;></xref>值。"
    - id: share
      type: System.IO.FileShare
      description: "位元組合<xref href=&quot;System.IO.FileShare&quot;></xref>值"
    - id: bufferSize
      type: System.Int32
      description: "<xref href=&quot;System.IO.FileStream&quot;> </xref>緩衝區大小。"
    - id: isf
      type: System.IO.IsolatedStorage.IsolatedStorageFile
      description: "<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFile&quot;> </xref>開啟<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> path </code>格式不正確。"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>path</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "找不到任何檔案和<code> mode </code>設<xref href=&quot;System.IO.FileMode&quot;> </xref>。"
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "<code>isf</code>沒有配額。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: IsolatedStorageFileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "開始非同步讀取。"
  remarks: "當您發出非同步的讀取或寫入 I/O 作業完成時，不更新資料流中目前的位置。       您必須呼叫<xref:System.IO.Stream.EndRead%2A>與這個<xref:System.IAsyncResult>找出多少位元組被讀取。</xref:System.IAsyncResult> </xref:System.IO.Stream.EndRead%2A>"
  syntax:
    content: public override IAsyncResult BeginRead (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要讀取資料的緩衝區。"
    - id: offset
      type: System.Int32
      description: "中的位元組位移`buffer`中要開始讀取。"
    - id: numBytes
      type: System.Int32
      description: "要讀取的位元組數目上限。"
    - id: userCallback
      type: System.AsyncCallback
      description: "在完成非同步讀取作業時要呼叫的方法。 這個參數是選擇性的。"
    - id: stateObject
      type: System.Object
      description: "讀取的非同步狀態。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>物件，表示非同步讀取，可能還在暫止中。</xref:System.IAsyncResult> 這<xref:System.IAsyncResult>必須傳遞給這個資料流<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead*>方法來判斷有多少位元組被讀取。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead*> </xref:System.IAsyncResult> 這可以完成相同的程式碼呼叫 BeginRead 或在傳遞至 BeginRead 的回呼中。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "超過檔案結尾處嘗試了非同步讀取。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  id: BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: IsolatedStorageFileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "開始非同步寫入。"
  remarks: "如果<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件是可寫入，寫入資料流的結尾會展開的資料流。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>       當您發出非同步的讀取或寫入 I/O 作業完成時，不更新資料流中目前的位置。       您必須呼叫<xref:System.IO.Stream.EndWrite%2A>與<xref:System.IAsyncResult>這個方法會傳回以找出多少個位元組所撰寫的物件。</xref:System.IAsyncResult> </xref:System.IO.Stream.EndWrite%2A>"
  syntax:
    content: public override IAsyncResult BeginWrite (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "若要將資料寫入緩衝區。"
    - id: offset
      type: System.Int32
      description: "中的位元組位移`buffer`中要開始寫入。"
    - id: numBytes
      type: System.Int32
      description: "要寫入的位元組數目上限。"
    - id: userCallback
      type: System.AsyncCallback
      description: "要在完成非同步寫入作業時呼叫的方法。 這個參數是選擇性的。"
    - id: stateObject
      type: System.Object
      description: "非同步寫入的狀態。"
    return:
      type: System.IAsyncResult
      description: "<xref:System.IAsyncResult>，代表可能還在暫止的非同步寫入。</xref:System.IAsyncResult> 這<xref:System.IAsyncResult>必須傳遞給這個資料流<> *> 方法，以確保寫入完成，然後適當地釋放資源。</xref:System.IAsyncResult>作法是由相同的程式碼呼叫<> *> 或傳遞至<xref:System.IO.Stream.BeginWrite*>。</xref:System.IO.Stream.BeginWrite*>回呼"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite*
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "非同步寫入嘗試超過檔案結尾。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead
  id: CanRead
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: CanRead
  nameWithType: IsolatedStorageFileStream.CanRead
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "取得布林值，指出是否可以讀取檔案。"
  remarks: "使用這個屬性來判斷是否<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>可以讀取物件。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>"
  example:
  - "The following code example demonstrates how you could use the CanRead property, as a check to see whether a stream can be read before calling the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> or <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A> methods. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/visualbasic/p-system.io.isolatedstor_1_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/cpp/p-system.io.isolatedstor_1_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#11](~/add/codesnippet/csharp/p-system.io.isolatedstor_1_1.cs)]"
  syntax:
    content: public override bool CanRead { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件可以讀取，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek
  id: CanSeek
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: CanSeek
  nameWithType: IsolatedStorageFileStream.CanSeek
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "取得布林值，指出是否搜尋支援作業。"
  remarks: "使用這個屬性來判斷是否<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件支援搜尋作業。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>"
  syntax:
    content: public override bool CanSeek { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件支援搜尋作業，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite
  id: CanWrite
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: CanWrite
  nameWithType: IsolatedStorageFileStream.CanWrite
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "取得布林值，指出是否可以寫入檔案。"
  remarks: "使用這個屬性來判斷是否<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件只能被寫入。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>"
  example:
  - "The following code example demonstrates how you could use the CanWrite property, as a check to see whether a stream can be read before calling the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write%2A> or <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A> methods. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#13](~/add/codesnippet/visualbasic/p-system.io.isolatedstor_3_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#13](~/add/codesnippet/cpp/p-system.io.isolatedstor_3_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#13](~/add/codesnippet/csharp/p-system.io.isolatedstor_3_1.cs)]"
  syntax:
    content: public override bool CanWrite { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件可以寫入，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: IsolatedStorageFileStream.Dispose(Boolean)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "所使用的 unmanaged 的資源釋出<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>並選擇性釋放 managed 的資源。"
  remarks: "這個方法會呼叫公用<xref:System.IDisposable.Dispose%2A>方法和<xref:System.Object.Finalize%2A>方法。</xref:System.Object.Finalize%2A> </xref:System.IDisposable.Dispose%2A> <xref:System.IDisposable.Dispose%2A>與受保護的 Dispose 方法會叫用`disposing`參數設為 true。</xref:System.IDisposable.Dispose%2A> <xref:System.Object.Finalize%2A>叫用 Dispose 以`disposing`設為 false。</xref:System.Object.Finalize%2A>       當`disposing`參數為 true，這個方法的任何 managed 物件所持有的資源全部釋出這個<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>參考。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 這個方法會叫用<xref:System.IDisposable.Dispose%2A>每個參考物件的方法。</xref:System.IDisposable.Dispose%2A>"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示釋放 managed 和 unmanaged 資源，<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示只釋放 unmanaged 的資源"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)
  id: EndRead(System.IAsyncResult)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: EndRead(IAsyncResult)
  nameWithType: IsolatedStorageFileStream.EndRead(IAsyncResult)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "結束暫止的非同步讀取的要求。"
  remarks: "EndRead 必須正好一次上呼叫每個<xref:System.IAsyncResult>物件從<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>，和呼叫 EndRead 是唯一能知道多少位元組被讀取從<xref:System.IO.Stream>.</xref:System.IO.Stream> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A> </xref:System.IAsyncResult> EndRead 會阻擋，直到 I/O 作業完成為止。"
  syntax:
    content: public override int EndRead (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "暫止的非同步要求。"
    return:
      type: System.Int32
      description: "從零之間所要求的位元組數目的資料流讀取的位元組數目。 資料流只會傳回資料流結尾的零。 否則，它們會阻擋，直到至少一個位元組可用為止。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(System.IAsyncResult)
  id: EndWrite(System.IAsyncResult)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: EndWrite(IAsyncResult)
  nameWithType: IsolatedStorageFileStream.EndWrite(IAsyncResult)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(IAsyncResult)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "結束非同步寫入。"
  remarks: "EndWrite 必須正好一次上呼叫每個<xref:System.IAsyncResult>從<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>.</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A> </xref:System.IAsyncResult>       EndWrite 會阻擋，直到 I/O 作業完成為止。"
  syntax:
    content: public override void EndWrite (IAsyncResult asyncResult);
    parameters:
    - id: asyncResult
      type: System.IAsyncResult
      description: "暫止非同步 I/O 要求結束。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>asyncResult</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush
  id: Flush
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Flush()
  nameWithType: IsolatedStorageFileStream.Flush()
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "清除這個資料流的緩衝區，並造成任何緩衝的資料全部寫入檔案。"
  remarks: "因為緩衝區可用來讀取或寫入，但不可兩者同時排清會執行兩個函式。 首先，任何之前寫入緩衝區的資料複製到檔案，並清除緩衝區。 第二個，如果<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A>是`true`資料先前已從檔案複製到讀取的緩衝區，檔案中目前的位置也會減少在緩衝區中讀取的位元組數目。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> 然後會清除緩衝區。       使用<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%28System.Boolean%29>方法多載，當您想要確保所有中繼檔案緩衝區中緩衝資料寫入至磁碟。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%28System.Boolean%29>"
  syntax:
    content: public override void Flush ();
    parameters: []
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)
  id: Flush(System.Boolean)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Flush(Boolean)
  nameWithType: IsolatedStorageFileStream.Flush(Boolean)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "清除這個資料流的緩衝區，造成任何緩衝的資料全部寫入檔案，並也會清除所有中繼檔案緩衝區。"
  remarks: "使用這個多載，當您想要確保所有中繼檔案緩衝區中緩衝資料寫入至磁碟。"
  syntax:
    content: public override void Flush (bool flushToDisk);
    parameters:
    - id: flushToDisk
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要排清所有中繼檔案緩衝區;否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle
  id: Handle
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Handle
  nameWithType: IsolatedStorageFileStream.Handle
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "取得檔案控制代碼的檔案目前<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件封裝。 存取這個屬性上不得有<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件，並擲回<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageException&quot;> </xref>。"
  remarks: "如需詳細資訊，請參閱<xref:System.IO.FileStream.Handle%2A>.</xref:System.IO.FileStream.Handle%2A>"
  example:
  - "The following code example demonstrates the Handle property.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#4](~/add/codesnippet/visualbasic/p-system.io.isolatedstor_4_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#4](~/add/codesnippet/cpp/p-system.io.isolatedstor_4_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#4](~/add/codesnippet/csharp/p-system.io.isolatedstor_4_1.cs)]"
  syntax:
    content: public override IntPtr Handle { get; }
    return:
      type: System.IntPtr
      description: "檔案的檔案控制代碼的目前<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件封裝。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle*
  exceptions:
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "控制代碼屬性一律會產生這個例外狀況。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync
  id: IsAsync
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: IsAsync
  nameWithType: IsolatedStorageFileStream.IsAsync
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "取得布林值，指出是否<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件以非同步方式或同步開啟。"
  remarks: "<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>無法建立物件，不像<xref:System.IO.FileStream>.</xref:System.IO.FileStream></xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>非同步 不過， <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>， <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>， <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A>，和<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A>具有一些效能的負面影響的同步執行個體上支援的方法。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A> </xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>"
  example:
  - "The following code example demonstrates how you can use the IsAsync property to verify that an <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> is synchronous. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#7](~/add/codesnippet/visualbasic/p-system.io.isolatedstor_7_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#7](~/add/codesnippet/cpp/p-system.io.isolatedstor_7_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#7](~/add/codesnippet/csharp/p-system.io.isolatedstor_7_1.cs)]"
  syntax:
    content: public override bool IsAsync { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件支援非同步存取，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Length
  id: Length
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Length
  nameWithType: IsolatedStorageFileStream.Length
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Length
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "取得長度<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件。"
  remarks: "長度代表目前在檔案中的位元組數目。 它不會受到隔離儲存區配額。"
  example:
  - "The following code example demonstrates the Length property.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/visualbasic/p-system.io.isolatedstor_6_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/cpp/p-system.io.isolatedstor_6_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/csharp/p-system.io.isolatedstor_6_1.cs)]"
  syntax:
    content: public override long Length { get; }
    return:
      type: System.Int64
      description: "長度<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>以位元組為單位的物件。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Length*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(System.Int64,System.Int64)
  id: Lock(System.Int64,System.Int64)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Lock(Int64,Int64)
  nameWithType: IsolatedStorageFileStream.Lock(Int64,Int64)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "防止其他處理程序讀取或寫入資料流。"
  remarks: "鎖定某個範圍的檔案資料流可讓執行緒的鎖定的處理程序的獨佔存取該範圍的檔案資料流。"
  syntax:
    content: public override void Lock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "要鎖定之範圍的開始位置。 此參數的值必須等於或大於 0 （零）。"
    - id: length
      type: System.Int64
      description: "要鎖定的位元組數目。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>或<code>length</code>是負數。"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "關閉檔案。"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "處理程序無法存取檔案，因為另一個處理序鎖定檔案的一部分。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Position
  id: Position
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Position
  nameWithType: IsolatedStorageFileStream.Position
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Position
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "取得或設定目前的目前位置<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件。"
  remarks: "設定這個屬性的運作<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A>屬性是`true`。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A>"
  example:
  - "The following code example uses the Position property to write data to a file.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/visualbasic/p-system.io.isolatedstor_0_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/cpp/p-system.io.isolatedstor_0_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/csharp/p-system.io.isolatedstor_0_1.cs)]"
  syntax:
    content: public override long Position { get; set; }
    return:
      type: System.Int64
      description: "目前的位置<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Position*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "位置不能設為負數。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Read(Byte[],Int32,Int32)
  nameWithType: IsolatedStorageFileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "從目前緩衝會將位元組複製<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件陣列。"
  remarks: "`buffer`參數可以是的執行個體<xref:System.Buffer>類別或其中一個下列類型的陣列︰ <xref:System.Byte>， <xref:System.SByte>， <xref:System.Char>， <xref:System.Int16>， <xref:System.Int32>， <xref:System.Int64>， <xref:System.UInt16>， <xref:System.UInt32>， <xref:System.UInt64>， <xref:System.Single>，或<xref:System.Double>.</xref:System.Double> </xref:System.Single> </xref:System.UInt64> </xref:System.UInt32> </xref:System.UInt16> </xref:System.Int64> </xref:System.Int32> </xref:System.Int16> </xref:System.Char> </xref:System.SByte> </xref:System.Byte> </xref:System.Buffer> `offset`參數緩衝區中要開始寫入 （索引緩衝區中） 中指定的位元組位移，`count`參數會提供將會從這個資料流讀取的位元組數目上限。 如果已到達資料流結尾，傳回的值會是個位元組，則為零的實際數目。 如果在讀取的作業成功，讀取的位元組數目進階資料流的目前位置。 如果發生例外狀況，目前資料流的位置不變。       Read 方法會將`buffer`做為區塊的位元組，不論其實際型別參數。 同樣地，`offset`和`count`參數一律會以位元組為單位指定。 如`buffer`這以外的位元組陣列的參數，表示曲線索引必須乘以項目大小，以位元組為單位來形成的正確值`offset`或`count`。       Read 方法會傳回零，只有當資料流結尾為止。 在其他情況下，讀取一定會讀取至少一個位元組資料流中傳回之前。 如果沒有資料可從<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>方法將會封鎖直到至少一個位元組的資料可能會傳回物件時呼叫 Read。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>"
  syntax:
    content: public override int Read (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要讀取的緩衝區。"
    - id: offset
      type: System.Int32
      description: "中要開始寫入緩衝區的位移。"
    - id: count
      type: System.Int32
      description: "要讀取的位元組數目上限。"
    return:
      type: System.Int32
      description: "總位元組數讀入<code> buffer </code>。 這可以是小於如果許多位元組目前沒有提供，或如果資料流結尾為止，要求的位元組數目。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Read*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte
  id: ReadByte
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: ReadByte()
  nameWithType: IsolatedStorageFileStream.ReadByte()
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "讀取單一位元組從<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>隔離儲存區中的物件。"
  remarks: ''
  example:
  - "The following code example demonstrates how the ReadByte method can be used to read data from an <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/visualbasic/m-system.io.isolatedstor_13_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/cpp/m-system.io.isolatedstor_13_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/csharp/m-system.io.isolatedstor_13_1.cs)]"
  syntax:
    content: public override int ReadByte ();
    parameters: []
    return:
      type: System.Int32
      description: "從隔離儲存區檔案讀取的 8 位元不帶正負號的整數值。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte*
  exceptions: []
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle
  id: SafeFileHandle
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: SafeFileHandle
  nameWithType: IsolatedStorageFileStream.SafeFileHandle
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle
  type: Property
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "取得<xref href=&quot;Microsoft.Win32.SafeHandles.SafeFileHandle&quot;></xref>物件，代表檔案之作業系統檔案控制代碼的目前<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件封裝。"
  remarks: "SafeFileHandle 屬性不支援，且一律會產生<xref:System.IO.IsolatedStorage.IsolatedStorageException>例外狀況。</xref:System.IO.IsolatedStorage.IsolatedStorageException>"
  syntax:
    content: public override Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }
    return:
      type: Microsoft.Win32.SafeHandles.SafeFileHandle
      description: "A <xref href=&quot;Microsoft.Win32.SafeHandles.SafeFileHandle&quot;> </xref>物件，代表檔案之作業系統檔案控制代碼的目前<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件封裝。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle*
  exceptions:
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "SafeFileHandle 屬性一律會產生這個例外狀況。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Seek(Int64,SeekOrigin)
  nameWithType: IsolatedStorageFileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(Int64,SeekOrigin)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "設定目前的位置<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件為指定的值。"
  remarks: "某些<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件支援的位置超出資料流的長度，其他人將會在此情況下擲回例外狀況。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>"
  syntax:
    content: public override long Seek (long offset, System.IO.SeekOrigin origin);
    parameters:
    - id: offset
      type: System.Int64
      description: "新位置<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件。"
    - id: origin
      type: System.IO.SeekOrigin
      description: "其中一個<xref:System.IO.SeekOrigin>值。</xref:System.IO.SeekOrigin>"
    return:
      type: System.Int64
      description: "中的新位置<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> origin </code>必須是其中一個<xref:System.IO.SeekOrigin>值。</xref:System.IO.SeekOrigin>"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: SetLength(Int64)
  nameWithType: IsolatedStorageFileStream.SetLength(Int64)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "設定這個長度<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>到指定的物件<code> value </code>。"
  remarks: "如果指定`value`小於目前的長度<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件、 資料流遭截斷。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 如果指定`value`大於目前長度的資料流，擴充的資料流。 如果展開資料流時，舊之間的新長度的資料流的內容會是未定義。 若要使用這個方法，<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件必須支援寫入和搜尋。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>"
  syntax:
    content: public override void SetLength (long value);
    parameters:
    - id: value
      type: System.Int64
      description: "新長度<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>value</code>為負數。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(System.Int64,System.Int64)
  id: Unlock(System.Int64,System.Int64)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Unlock(Int64,Int64)
  nameWithType: IsolatedStorageFileStream.Unlock(Int64,Int64)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(Int64,Int64)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "允許其他處理程序存取全部或部分先前鎖定的檔案。"
  syntax:
    content: public override void Unlock (long position, long length);
    parameters:
    - id: position
      type: System.Int64
      description: "若要解除鎖定範圍的開始位置。 此參數的值必須等於或大於 0 （零）。"
    - id: length
      type: System.Int64
      description: "若要解除鎖定的位元組數目。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>position</code>或<code>length</code>是負數。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: Write(Byte[],Int32,Int32)
  nameWithType: IsolatedStorageFileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(Byte[],Int32,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "將位元組區塊寫入<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件使用讀取自位元組陣列的資料。"
  remarks: "`offset`參數會提供中的位元組位移`buffer`開始閱讀，而`count`參數會提供這將寫入的位元組數目<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 如果作業成功時，目前位置<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件前移寫入的位元組數目。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> 如果發生例外狀況，目前的位置<xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>物件並未變更。</xref:System.IO.IsolatedStorage.IsolatedStorageFileStream>"
  syntax:
    content: public override void Write (byte[] buffer, int offset, int count);
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "要寫入的緩衝區。"
    - id: offset
      type: System.Int32
      description: "從其開始的緩衝區位元組位移。"
    - id: count
      type: System.Int32
      description: "要寫入的位元組數目上限。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.Write*
  exceptions:
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "寫入嘗試超過配額<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件。"
  platform:
  - net462
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(System.Byte)
  id: WriteByte(System.Byte)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  langs:
  - csharp
  name: WriteByte(Byte)
  nameWithType: IsolatedStorageFileStream.WriteByte(Byte)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(Byte)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.IO.IsolatedStorage
  summary: "將單一位元組寫入<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件。"
  remarks: ''
  example:
  - "The following code example demonstrates how the WriteByte method can be used to read data from an <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> object. For the complete context of this example, see the <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> overview.  \n  \n [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/visualbasic/m-system.io.isolatedstor_8_1.vb)]\n [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/cpp/m-system.io.isolatedstor_8_1.cpp)]\n [!code-cs[System.IO.IsolatedStorage.IsolatedStorage#14](~/add/codesnippet/csharp/m-system.io.isolatedstor_8_1.cs)]"
  syntax:
    content: public override void WriteByte (byte value);
    parameters:
    - id: value
      type: System.Byte
      description: "要寫入隔離儲存區檔案的位元組值。"
  overload: System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte*
  exceptions:
  - type: System.IO.IsolatedStorage.IsolatedStorageException
    commentId: T:System.IO.IsolatedStorage.IsolatedStorageException
    description: "寫入嘗試超過配額<xref href=&quot;System.IO.IsolatedStorage.IsolatedStorageFileStream&quot;></xref>物件。"
  platform:
  - net462
references:
- uid: System.IO.FileStream
  isExternal: false
  name: System.IO.FileStream
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.IO.DirectoryNotFoundException
  isExternal: true
  name: System.IO.DirectoryNotFoundException
- uid: System.IO.FileNotFoundException
  isExternal: true
  name: System.IO.FileNotFoundException
- uid: System.IO.IsolatedStorage.IsolatedStorageException
  parent: System.IO.IsolatedStorage
  isExternal: false
  name: IsolatedStorageException
  nameWithType: IsolatedStorageException
  fullName: System.IO.IsolatedStorage.IsolatedStorageException
- uid: System.ObjectDisposedException
  isExternal: true
  name: System.ObjectDisposedException
- uid: System.IO.IOException
  isExternal: true
  name: System.IO.IOException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.IO.FileMode
  parent: System.IO
  isExternal: false
  name: FileMode
  nameWithType: FileMode
  fullName: System.IO.FileMode
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode,FileAccess)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess)
- uid: System.IO.FileAccess
  parent: System.IO
  isExternal: false
  name: FileAccess
  nameWithType: FileAccess
  fullName: System.IO.FileAccess
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,IsolatedStorageFile)
- uid: System.IO.IsolatedStorage.IsolatedStorageFile
  parent: System.IO.IsolatedStorage
  isExternal: false
  name: IsolatedStorageFile
  nameWithType: IsolatedStorageFile
  fullName: System.IO.IsolatedStorage.IsolatedStorageFile
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare)
- uid: System.IO.FileShare
  parent: System.IO
  isExternal: false
  name: FileShare
  nameWithType: FileShare
  fullName: System.IO.FileShare
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,IsolatedStorageFile)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,IsolatedStorageFile)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32,IsolatedStorageFile)
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32,IsolatedStorageFile)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsolatedStorageFileStream(String,FileMode,FileAccess,FileShare,Int32,IsolatedStorageFile)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: IsolatedStorageFileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IAsyncResult
  parent: System
  isExternal: true
  name: IAsyncResult
  nameWithType: IAsyncResult
  fullName: System.IAsyncResult
- uid: System.Byte[]
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte[]
  spec.csharp:
  - uid: System.Byte
    name: Byte
    nameWithType: Byte
    fullName: Byte[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.AsyncCallback
  parent: System
  isExternal: true
  name: AsyncCallback
  nameWithType: AsyncCallback
  fullName: System.AsyncCallback
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  nameWithType: IsolatedStorageFileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(Byte[],Int32,Int32,AsyncCallback,Object)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: CanRead
  nameWithType: IsolatedStorageFileStream.CanRead
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: CanSeek
  nameWithType: IsolatedStorageFileStream.CanSeek
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: CanWrite
  nameWithType: IsolatedStorageFileStream.CanWrite
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: IsolatedStorageFileStream.Dispose(Boolean)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(Boolean)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: EndRead(IAsyncResult)
  nameWithType: IsolatedStorageFileStream.EndRead(IAsyncResult)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(IAsyncResult)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(System.IAsyncResult)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: EndWrite(IAsyncResult)
  nameWithType: IsolatedStorageFileStream.EndWrite(IAsyncResult)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(IAsyncResult)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Flush()
  nameWithType: IsolatedStorageFileStream.Flush()
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush()
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Flush(Boolean)
  nameWithType: IsolatedStorageFileStream.Flush(Boolean)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(Boolean)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Handle
  nameWithType: IsolatedStorageFileStream.Handle
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle
- uid: System.IntPtr
  parent: System
  isExternal: true
  name: IntPtr
  nameWithType: IntPtr
  fullName: System.IntPtr
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsAsync
  nameWithType: IsolatedStorageFileStream.IsAsync
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Length
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Length
  nameWithType: IsolatedStorageFileStream.Length
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Length
- uid: System.Int64
  parent: System
  isExternal: true
  name: Int64
  nameWithType: Int64
  fullName: System.Int64
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(System.Int64,System.Int64)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Lock(Int64,Int64)
  nameWithType: IsolatedStorageFileStream.Lock(Int64,Int64)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(Int64,Int64)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Position
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Position
  nameWithType: IsolatedStorageFileStream.Position
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Position
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Read(Byte[],Int32,Int32)
  nameWithType: IsolatedStorageFileStream.Read(Byte[],Int32,Int32)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(Byte[],Int32,Int32)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: ReadByte()
  nameWithType: IsolatedStorageFileStream.ReadByte()
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte()
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: IsolatedStorageFileStream.SafeFileHandle
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle
- uid: Microsoft.Win32.SafeHandles.SafeFileHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeFileHandle
  nameWithType: SafeFileHandle
  fullName: Microsoft.Win32.SafeHandles.SafeFileHandle
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Seek(Int64,SeekOrigin)
  nameWithType: IsolatedStorageFileStream.Seek(Int64,SeekOrigin)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(Int64,SeekOrigin)
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: true
  name: SeekOrigin
  nameWithType: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(System.Int64)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: SetLength(Int64)
  nameWithType: IsolatedStorageFileStream.SetLength(Int64)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(Int64)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(System.Int64,System.Int64)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Unlock(Int64,Int64)
  nameWithType: IsolatedStorageFileStream.Unlock(Int64,Int64)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(Int64,Int64)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(System.Byte[],System.Int32,System.Int32)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Write(Byte[],Int32,Int32)
  nameWithType: IsolatedStorageFileStream.Write(Byte[],Int32,Int32)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(Byte[],Int32,Int32)
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(System.Byte)
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: WriteByte(Byte)
  nameWithType: IsolatedStorageFileStream.WriteByte(Byte)
  fullName: System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(Byte)
- uid: System.Byte
  parent: System
  isExternal: true
  name: Byte
  nameWithType: Byte
  fullName: System.Byte
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsolatedStorageFileStream
  nameWithType: IsolatedStorageFileStream.IsolatedStorageFileStream
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: BeginRead
  nameWithType: IsolatedStorageFileStream.BeginRead
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: BeginWrite
  nameWithType: IsolatedStorageFileStream.BeginWrite
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: CanRead
  nameWithType: IsolatedStorageFileStream.CanRead
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: CanSeek
  nameWithType: IsolatedStorageFileStream.CanSeek
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: CanWrite
  nameWithType: IsolatedStorageFileStream.CanWrite
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Dispose
  nameWithType: IsolatedStorageFileStream.Dispose
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: EndRead
  nameWithType: IsolatedStorageFileStream.EndRead
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: EndWrite
  nameWithType: IsolatedStorageFileStream.EndWrite
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Flush
  nameWithType: IsolatedStorageFileStream.Flush
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Handle
  nameWithType: IsolatedStorageFileStream.Handle
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: IsAsync
  nameWithType: IsolatedStorageFileStream.IsAsync
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Length*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Length
  nameWithType: IsolatedStorageFileStream.Length
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Lock
  nameWithType: IsolatedStorageFileStream.Lock
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Position*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Position
  nameWithType: IsolatedStorageFileStream.Position
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Read*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Read
  nameWithType: IsolatedStorageFileStream.Read
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: ReadByte
  nameWithType: IsolatedStorageFileStream.ReadByte
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: SafeFileHandle
  nameWithType: IsolatedStorageFileStream.SafeFileHandle
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Seek
  nameWithType: IsolatedStorageFileStream.Seek
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: SetLength
  nameWithType: IsolatedStorageFileStream.SetLength
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Unlock
  nameWithType: IsolatedStorageFileStream.Unlock
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.Write*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: Write
  nameWithType: IsolatedStorageFileStream.Write
- uid: System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte*
  parent: System.IO.IsolatedStorage.IsolatedStorageFileStream
  isExternal: false
  name: WriteByte
  nameWithType: IsolatedStorageFileStream.WriteByte
