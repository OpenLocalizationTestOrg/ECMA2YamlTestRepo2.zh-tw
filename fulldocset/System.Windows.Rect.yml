### YamlMime:ManagedReference
items:
- uid: System.Windows.Rect
  id: Rect
  children:
  - System.Windows.Rect.#ctor(System.Windows.Size)
  - System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Point)
  - System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Size)
  - System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Vector)
  - System.Windows.Rect.#ctor(System.Double,System.Double,System.Double,System.Double)
  - System.Windows.Rect.Bottom
  - System.Windows.Rect.BottomLeft
  - System.Windows.Rect.BottomRight
  - System.Windows.Rect.Contains(System.Windows.Point)
  - System.Windows.Rect.Contains(System.Windows.Rect)
  - System.Windows.Rect.Contains(System.Double,System.Double)
  - System.Windows.Rect.Empty
  - System.Windows.Rect.Equals(System.Object)
  - System.Windows.Rect.Equals(System.Windows.Rect)
  - System.Windows.Rect.Equals(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.GetHashCode
  - System.Windows.Rect.Height
  - System.Windows.Rect.Inflate(System.Windows.Size)
  - System.Windows.Rect.Inflate(System.Double,System.Double)
  - System.Windows.Rect.Inflate(System.Windows.Rect,System.Windows.Size)
  - System.Windows.Rect.Inflate(System.Windows.Rect,System.Double,System.Double)
  - System.Windows.Rect.Intersect(System.Windows.Rect)
  - System.Windows.Rect.Intersect(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.IntersectsWith(System.Windows.Rect)
  - System.Windows.Rect.IsEmpty
  - System.Windows.Rect.Left
  - System.Windows.Rect.Location
  - System.Windows.Rect.Offset(System.Windows.Vector)
  - System.Windows.Rect.Offset(System.Double,System.Double)
  - System.Windows.Rect.Offset(System.Windows.Rect,System.Windows.Vector)
  - System.Windows.Rect.Offset(System.Windows.Rect,System.Double,System.Double)
  - System.Windows.Rect.op_Equality(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.op_Inequality(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.Parse(System.String)
  - System.Windows.Rect.Right
  - System.Windows.Rect.Scale(System.Double,System.Double)
  - System.Windows.Rect.Size
  - System.Windows.Rect.System#IFormattable#ToString(System.String,System.IFormatProvider)
  - System.Windows.Rect.Top
  - System.Windows.Rect.TopLeft
  - System.Windows.Rect.TopRight
  - System.Windows.Rect.ToString
  - System.Windows.Rect.ToString(System.IFormatProvider)
  - System.Windows.Rect.Transform(System.Windows.Media.Matrix)
  - System.Windows.Rect.Transform(System.Windows.Rect,System.Windows.Media.Matrix)
  - System.Windows.Rect.Union(System.Windows.Point)
  - System.Windows.Rect.Union(System.Windows.Rect)
  - System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Point)
  - System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Rect)
  - System.Windows.Rect.Width
  - System.Windows.Rect.X
  - System.Windows.Rect.Y
  langs:
  - csharp
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
  type: Struct
  summary: "描述寬度、 高度和矩形的位置。"
  remarks: "<a name=&quot;xamlAttributeUsage_Duration&quot;></a># # XAML 屬性使用方式```   <object property=&quot;x,y,width,height&quot;/>   ``` <a name=&quot;xamlValues_MinWidth&quot;> </a> # # XAML 值*x* <xref:System.Double?displayProperty=fullName>框左邊的 x 座標位置。</xref:System.Double?displayProperty=fullName>                 *y* <xref:System.Double?displayProperty=fullName>矩形上方的 y 座標位置。</xref:System.Double?displayProperty=fullName>           *寬度*<xref:System.Double?displayProperty=fullName>非負數的值，表示<xref:System.Windows.Rect.Width%2A>的矩形。</xref:System.Windows.Rect.Width%2A> </xref:System.Double?displayProperty=fullName>           *高度*<xref:System.Double?displayProperty=fullName>非負數的值，表示<xref:System.Windows.Rect.Height%2A>的矩形。</xref:System.Windows.Rect.Height%2A> </xref:System.Double?displayProperty=fullName>    "
  example:
  - "The following example shows how to use a Rect structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: >-
      [System.ComponentModel.TypeConverter(typeof(System.Windows.RectConverter))]

      [System.Windows.Markup.ValueSerializer(typeof(System.Windows.Converters.RectValueSerializer))]

      public struct Rect : IFormattable
  inheritance:
  - System.ValueType
  implements:
  - System.IFormattable
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Windows.Size)
  id: '#ctor(System.Windows.Size)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Size)
  nameWithType: Rect.Rect(Size)
  fullName: System.Windows.Rect.Rect(Size)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.Rect&quot;></xref>結構指定的大小，而且位於 (0，0)。"
  remarks: ''
  example:
  - "The following example shows how to create a new <xref:System.Windows.Rect> structure by using the Rect constructor.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample2_csharp)]"
  syntax:
    content: public Rect (System.Windows.Size size);
    parameters:
    - id: size
      type: System.Windows.Size
      description: "A <xref href=&quot;System.Windows.Size&quot;> </xref>結構，指定矩形的高度與寬度。"
  overload: System.Windows.Rect.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Point)
  id: '#ctor(System.Windows.Point,System.Windows.Point)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Point,Point)
  nameWithType: Rect.Rect(Point,Point)
  fullName: System.Windows.Rect.Rect(Point,Point)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.Rect&quot;></xref>剛好包含兩個指定的點的結構。"
  remarks: ''
  example:
  - "The following example shows how to create a new <xref:System.Windows.Rect> structure by using the Rect constructor.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample3_csharp)]"
  syntax:
    content: public Rect (System.Windows.Point point1, System.Windows.Point point2);
    parameters:
    - id: point1
      type: System.Windows.Point
      description: "新的矩形必須包含第一個點。"
    - id: point2
      type: System.Windows.Point
      description: "新的矩形必須包含第二個點。"
  overload: System.Windows.Rect.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Size)
  id: '#ctor(System.Windows.Point,System.Windows.Size)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Point,Size)
  nameWithType: Rect.Rect(Point,Size)
  fullName: System.Windows.Rect.Rect(Point,Size)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.Rect&quot;></xref>結構具有指定的左上角位置的指定的寬度和高度。"
  remarks: ''
  example:
  - "The following example shows how to create a new <xref:System.Windows.Rect> structure by using the Rect constructor.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample4_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample4_csharp)]"
  syntax:
    content: public Rect (System.Windows.Point location, System.Windows.Size size);
    parameters:
    - id: location
      type: System.Windows.Point
      description: "指定矩形左上角的位置點。"
    - id: size
      type: System.Windows.Size
      description: "A <xref href=&quot;System.Windows.Size&quot;> </xref>結構，指定矩形的高度與寬度。"
  overload: System.Windows.Rect.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Vector)
  id: '#ctor(System.Windows.Point,System.Windows.Vector)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Point,Vector)
  nameWithType: Rect.Rect(Point,Vector)
  fullName: System.Windows.Rect.Rect(Point,Vector)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.Rect&quot;></xref>結構，這是剛好可以包含指定的點和指定的點與指定的向量的總和。"
  remarks: ''
  example:
  - "The following example shows how to create a new <xref:System.Windows.Rect> structure by using the Rect constructor.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample5_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample5_csharp)]"
  syntax:
    content: public Rect (System.Windows.Point point, System.Windows.Vector vector);
    parameters:
    - id: point
      type: System.Windows.Point
      description: "必須包含矩形的第一個點。"
    - id: vector
      type: System.Windows.Vector
      description: "要位移的指定的點的數量。 產生的矩形會剛好包含兩個點。"
  overload: System.Windows.Rect.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.#ctor(System.Double,System.Double,System.Double,System.Double)
  id: '#ctor(System.Double,System.Double,System.Double,System.Double)'
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Rect(Double,Double,Double,Double)
  nameWithType: Rect.Rect(Double,Double,Double,Double)
  fullName: System.Windows.Rect.Rect(Double,Double,Double,Double)
  type: Constructor
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "初始化的新執行個體<xref href=&quot;System.Windows.Rect&quot;></xref>結構具有指定的 x 座標，y 座標、 寬度和高度。"
  remarks: "下列範例示範如何建立新<xref:System.Windows.Rect>使用 Rect 建構函式的結構。</xref:System.Windows.Rect>       [!code-cs[RectExamples_snip # CreateRectExample6_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample6_csharp)]"
  syntax:
    content: public Rect (double x, double y, double width, double height);
    parameters:
    - id: x
      type: System.Double
      description: "矩形左上角 x 座標。"
    - id: y
      type: System.Double
      description: "矩形左上角 y 座標。"
    - id: width
      type: System.Double
      description: "矩形的寬度。"
    - id: height
      type: System.Double
      description: "矩形的高度。"
  overload: System.Windows.Rect.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>width</code>是一個負數值。       -或-<code>height</code>是負數值。"
  platform:
  - net462
- uid: System.Windows.Rect.Bottom
  id: Bottom
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Bottom
  nameWithType: Rect.Bottom
  fullName: System.Windows.Rect.Bottom
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得矩形的底部的 y 軸值。"
  remarks: "將矩形的底部的 y 軸值的總和等於<xref:System.Windows.Rect.Y%2A>和<xref:System.Windows.Rect.Height%2A>屬性。</xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Y%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Bottom { get; }
    return:
      type: System.Double
      description: "將矩形的底部 y 軸值。 如果是空的矩形，這個值會是<xref:System.Double>.</xref:System.Double>"
  overload: System.Windows.Rect.Bottom*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.BottomLeft
  id: BottomLeft
  parent: System.Windows.Rect
  langs:
  - csharp
  name: BottomLeft
  nameWithType: Rect.BottomLeft
  fullName: System.Windows.Rect.BottomLeft
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得矩形的左下角的位置"
  remarks: "矩形的左下角的位置會等於 (<xref:System.Windows.Rect.X%2A>， <xref:System.Windows.Rect.Y%2A>+ <xref:System.Windows.Rect.Height%2A>)。</xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point BottomLeft { get; }
    return:
      type: System.Windows.Point
      description: "矩形的左下角的位置。"
  overload: System.Windows.Rect.BottomLeft*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.BottomRight
  id: BottomRight
  parent: System.Windows.Rect
  langs:
  - csharp
  name: BottomRight
  nameWithType: Rect.BottomRight
  fullName: System.Windows.Rect.BottomRight
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得矩形的右下角的位置。"
  remarks: "矩形右下角的位置會等於 (<xref:System.Windows.Rect.X%2A> + <xref:System.Windows.Rect.Width%2A>， <xref:System.Windows.Rect.Y%2A>+ <xref:System.Windows.Rect.Height%2A>)。</xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.Width%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point BottomRight { get; }
    return:
      type: System.Windows.Point
      description: "矩形的右下角的位置。"
  overload: System.Windows.Rect.BottomRight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Contains(System.Windows.Point)
  id: Contains(System.Windows.Point)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Contains(Point)
  nameWithType: Rect.Contains(Point)
  fullName: System.Windows.Rect.Contains(Point)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指出矩形是否包含指定的點。"
  remarks: ''
  example:
  - "The following example shows how to use the Contains method to determine if the rectangle contains the specified <xref:System.Windows.Point>.  \n  \n [!code-cs[RectExamples_snip#ContainsExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#containsexample1_csharp)]"
  syntax:
    content: public bool Contains (System.Windows.Point point);
    parameters:
    - id: point
      type: System.Windows.Point
      description: "若要檢查點。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果矩形包含指定的點。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Rect.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Contains(System.Windows.Rect)
  id: Contains(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Contains(Rect)
  nameWithType: Rect.Contains(Rect)
  fullName: System.Windows.Rect.Contains(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指出矩形是否包含指定的矩形。"
  remarks: ''
  example:
  - "The following example shows how to use the Contains method to determine if one rectangle is contained by another rectangle.  \n  \n [!code-cs[RectExamples_snip#ContainsExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#containsexample2_csharp)]"
  syntax:
    content: public bool Contains (System.Windows.Rect rect);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "要檢查的矩形。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<code> rect </code>完全包含矩形中，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Rect.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Contains(System.Double,System.Double)
  id: Contains(System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Contains(Double,Double)
  nameWithType: Rect.Contains(Double,Double)
  fullName: System.Windows.Rect.Contains(Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指出矩形是否包含指定的 x 座標和 y 座標。"
  remarks: ''
  example:
  - "The following example shows how to use the Contains method to determine if the rectangle contains the point specified by the given x-coordinate and y-coordinate.  \n  \n [!code-cs[RectExamples_snip#ContainsExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#containsexample3_csharp)]"
  syntax:
    content: public bool Contains (double x, double y);
    parameters:
    - id: x
      type: System.Double
      description: "若要檢查點的 x 座標。"
    - id: y
      type: System.Double
      description: "若要檢查點的 y 座標。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果 (<code>x</code>， <code> y </code>) 包含由矩形中，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Rect.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Empty
  id: Empty
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Empty
  nameWithType: Rect.Empty
  fullName: System.Windows.Rect.Empty
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得表示沒有位置或區域的矩形的特殊值。"
  remarks: "避免空白矩形的算術運算。 因為同時<xref:System.Windows.Rect.X%2A>和<xref:System.Windows.Rect.Y%2A>是無限值，作業會造成嚴重受損這些作業的處理器。</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> 包含這些值的比較不會影響應用程式的效能。"
  syntax:
    content: public static System.Windows.Rect Empty { get; }
    return:
      type: System.Windows.Rect
      description: "空的矩形中，有<> *> 和<> *> 屬性值<xref:System.Double.PositiveInfinity>，且具有<> *> 和<> *> 屬性值的<xref:System.Double.NegativeInfinity>。</xref:System.Double.NegativeInfinity> </xref:System.Double.PositiveInfinity>"
  overload: System.Windows.Rect.Empty*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Equals(System.Object)
  id: Equals(System.Object)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Equals(Object)
  nameWithType: Rect.Equals(Object)
  fullName: System.Windows.Rect.Equals(Object)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指出指定的物件是否等於目前的矩形。"
  remarks: "這項作業會測試物件相等。       這項比較，兩個執行個體<xref:System.Double.NaN?displayProperty=fullName>會被視為相等。</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > 所描述矩形的位置和維度<xref:System.Double>值。</xref:System.Double> 因為<xref:System.Double>值可能會遺失有效位數時操作時，邏輯上相等的兩個值之間的比較可能會失敗。</xref:System.Double>"
  example:
  - "The following example shows how to use the Equals method to determine if a rectangle is equal to a specified object.  \n  \n [!code-cs[RectExamples_snip#EqualsExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#equalsexample1_csharp)]"
  syntax:
    content: public override bool Equals (object o);
    parameters:
    - id: o
      type: System.Object
      description: "要與目前的矩形相比較的物件。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果<code> o </code>是<xref href=&quot;System.Windows.Rect&quot;></xref>和具有相同的<> *> 和<> *> 值為目前的矩形中; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Rect.Equals*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Equals(System.Windows.Rect)
  id: Equals(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Equals(Rect)
  nameWithType: Rect.Equals(Rect)
  fullName: System.Windows.Rect.Equals(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指出指定的矩形是否等於目前的矩形。"
  remarks: "這項作業會測試物件相等。       這項比較，兩個執行個體<xref:System.Double.NaN?displayProperty=fullName>會被視為相等。</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > 所描述矩形的位置和維度<xref:System.Double>值。</xref:System.Double> 因為<xref:System.Double>值可能會遺失有效位數時操作時，邏輯上相等的兩個值之間的比較可能會失敗。</xref:System.Double>"
  example:
  - "The following example shows how to use the Equals method to determine if a rectangle is equal to a specified rectangle.  \n  \n [!code-cs[RectExamples_snip#EqualsExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#equalsexample1_csharp)]"
  syntax:
    content: public bool Equals (System.Windows.Rect value);
    parameters:
    - id: value
      type: System.Windows.Rect
      description: "要比較目前的矩形的矩形。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果指定的矩形具有相同的<> *> 和<> *> 值為目前的矩形中; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Rect.Equals*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Equals(System.Windows.Rect,System.Windows.Rect)
  id: Equals(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Equals(Rect,Rect)
  nameWithType: Rect.Equals(Rect,Rect)
  fullName: System.Windows.Rect.Equals(Rect,Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指出指定的矩形是否相等。"
  remarks: "這項作業會測試物件相等。       這項比較，兩個執行個體<xref:System.Double.NaN?displayProperty=fullName>會被視為相等。</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > 所描述矩形的位置和維度<xref:System.Double>值。</xref:System.Double> 因為<xref:System.Double>值可能會遺失有效位數時操作時，邏輯上相等的兩個值之間的比較可能會失敗。</xref:System.Double>"
  example:
  - "The following example shows how to use the Equals method to determine if one rectangle is equal to another.  \n  \n [!code-cs[RectExamples_snip#EqualsExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#equalsexample2_csharp)]"
  syntax:
    content: public static bool Equals (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "要比較的第一個矩形。"
    - id: rect2
      type: System.Windows.Rect
      description: "要比較的第二個矩形。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果有相同的矩形<> *> 和<> *> 值; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Rect.Equals*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.GetHashCode
  id: GetHashCode
  parent: System.Windows.Rect
  langs:
  - csharp
  name: GetHashCode()
  nameWithType: Rect.GetHashCode()
  fullName: System.Windows.Rect.GetHashCode()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "建立矩形的雜湊碼。"
  remarks: "這個方法會藉由建立雜湊程式碼<xref:System.Windows.Rect.X%2A>， <xref:System.Windows.Rect.Y%2A>， <xref:System.Windows.Rect.Width%2A>，和<xref:System.Windows.Rect.Height%2A>屬性值。</xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Width%2A> </xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use the GetHashCode method to get the hash code of a <xref:System.Windows.Rect>.  \n  \n [!code-cs[RectExamples_snip#GetHashCodeExample_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#gethashcodeexample_csharp)]"
  syntax:
    content: public override int GetHashCode ();
    parameters: []
    return:
      type: System.Int32
      description: "目前的雜湊碼<xref href=&quot;System.Windows.Rect&quot;></xref>結構。"
  overload: System.Windows.Rect.GetHashCode*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Height
  id: Height
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Height
  nameWithType: Rect.Height
  fullName: System.Windows.Rect.Height
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得或設定矩形的高度。"
  remarks: "<xref:System.Windows.Rect.Empty%2A>矩形的高度是<xref:System.Double.NegativeInfinity>.</xref:System.Double.NegativeInfinity> </xref:System.Windows.Rect.Empty%2A> <xref:System.Windows.Rect.Empty%2A>矩形是唯讀，則為不變更其高度。</xref:System.Windows.Rect.Empty%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Height { get; set; }
    return:
      type: System.Double
      description: "正數，代表矩形的高度。 預設值為 0。"
  overload: System.Windows.Rect.Height*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "高度會設定為負數值。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "在設定高度<xref:System.Windows.Rect.Empty*>矩形。</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.Inflate(System.Windows.Size)
  id: Inflate(System.Windows.Size)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Inflate(Size)
  nameWithType: Rect.Inflate(Size)
  fullName: System.Windows.Rect.Inflate(Size)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "使用指定的展開矩形<xref href=&quot;System.Windows.Size&quot;> </xref>，所有的方向。"
  remarks: "<xref:System.Windows.Rect.Width%2A>產生的矩形的增加了兩次<xref:System.Windows.Size.Width%2A>指定<xref:System.Windows.Size>結構，因為左邊和右邊的矩形會膨脹。</xref:System.Windows.Size> </xref:System.Windows.Size.Width%2A> </xref:System.Windows.Rect.Width%2A> 同樣地，<xref:System.Windows.Rect.Height%2A>產生的矩形的增加了兩次<xref:System.Windows.Size.Height%2A>指定<xref:System.Windows.Size>結構。</xref:System.Windows.Size> </xref:System.Windows.Size.Height%2A> </xref:System.Windows.Rect.Height%2A>"
  example:
  - "The following example shows how to use the Inflate method to increase the size of a rectangle.  \n  \n [!code-cs[RectExamples_snip#InflateExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#inflateexample1_csharp)]"
  syntax:
    content: public void Inflate (System.Windows.Size size);
    parameters:
    - id: size
      type: System.Windows.Size
      description: "指定要展開矩形的數量。 <xref href=&quot;System.Windows.Size&quot;> </xref>結構的<> *> 屬性會指定要增加的矩形數量<> *> 和<> *> 屬性。<xref href=&quot;System.Windows.Size&quot;> </xref>結構的<> *> 屬性會指定要增加的矩形數量<> *> 和<> *> 屬性。"
  overload: System.Windows.Rect.Inflate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "這個方法會在呼叫&lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt;矩形。"
  platform:
  - net462
- uid: System.Windows.Rect.Inflate(System.Double,System.Double)
  id: Inflate(System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Inflate(Double,Double)
  nameWithType: Rect.Inflate(Double,Double)
  fullName: System.Windows.Rect.Inflate(Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "展開或壓縮矩形，使用指定的寬度和高度數量，所有的方向。"
  remarks: "<xref:System.Windows.Rect.Width%2A>的產生的矩形會增加或減少指定的寬度位移的兩倍，因為它會套用至左邊和右邊的矩形。</xref:System.Windows.Rect.Width%2A> 同樣地，<xref:System.Windows.Rect.Height%2A>的產生的矩形會增加或減少兩次指定的高度。</xref:System.Windows.Rect.Height%2A>       如果指定的寬度或高度壓縮矩形大於其目前<xref:System.Windows.Rect.Width%2A>或<xref:System.Windows.Rect.Height%2A>— 負的區域中，提供矩形，矩形會變成<xref:System.Windows.Rect.Empty%2A>矩形。</xref:System.Windows.Rect.Empty%2A> </xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Width%2A>"
  example:
  - "The following example shows how to use the Inflate method to change the size of a rectangle.  \n  \n [!code-cs[RectExamples_snip#InflateExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#inflateexample2_csharp)]"
  syntax:
    content: public void Inflate (double width, double height);
    parameters:
    - id: width
      type: System.Double
      description: "用來展開或壓縮的左邊和右邊的矩形的數量。"
    - id: height
      type: System.Double
      description: "用來展開或壓縮頂端和底部的側邊的矩形的數量。"
  overload: System.Windows.Rect.Inflate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "這個方法會在呼叫&lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt;矩形。"
  platform:
  - net462
- uid: System.Windows.Rect.Inflate(System.Windows.Rect,System.Windows.Size)
  id: Inflate(System.Windows.Rect,System.Windows.Size)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Inflate(Rect,Size)
  nameWithType: Rect.Inflate(Rect,Size)
  fullName: System.Windows.Rect.Inflate(Rect,Size)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "傳回所產生自展開指定的矩形所指定的矩形<xref href=&quot;System.Windows.Size&quot;> </xref>，所有的方向。"
  remarks: "<xref:System.Windows.Rect.Width%2A>產生的矩形的增加了兩次<xref:System.Windows.Size.Width%2A>指定<xref:System.Windows.Size>結構，因為左邊和右邊的矩形會膨脹。</xref:System.Windows.Size> </xref:System.Windows.Size.Width%2A> </xref:System.Windows.Rect.Width%2A> 同樣地，<xref:System.Windows.Rect.Height%2A>產生的矩形的增加了兩次<xref:System.Windows.Size.Height%2A>指定<xref:System.Windows.Size>結構。</xref:System.Windows.Size> </xref:System.Windows.Size.Height%2A> </xref:System.Windows.Rect.Height%2A>"
  example:
  - "The following example shows how to use the Inflate method to change the size of a rectangle.  \n  \n [!code-cs[RectExamples_snip#InflateExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#inflateexample3_csharp)]"
  syntax:
    content: public static System.Windows.Rect Inflate (System.Windows.Rect rect, System.Windows.Size size);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "<xref href=&quot;System.Windows.Rect&quot;> </xref>結構修改。"
    - id: size
      type: System.Windows.Size
      description: "指定要展開矩形的數量。 <xref href=&quot;System.Windows.Size&quot;> </xref>結構的<> *> 屬性會指定要增加的矩形數量<> *> 和<> *> 屬性。<xref href=&quot;System.Windows.Size&quot;> </xref>結構的<> *> 屬性會指定要增加的矩形數量<> *> 和<> *> 屬性。"
    return:
      type: System.Windows.Rect
      description: "產生的矩形。"
  overload: System.Windows.Rect.Inflate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>rect</code>是&lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt;矩形。"
  platform:
  - net462
- uid: System.Windows.Rect.Inflate(System.Windows.Rect,System.Double,System.Double)
  id: Inflate(System.Windows.Rect,System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Inflate(Rect,Double,Double)
  nameWithType: Rect.Inflate(Rect,Double,Double)
  fullName: System.Windows.Rect.Inflate(Rect,Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "建立展開或壓縮以指定寬度和高度的數量，在所有方向指定之矩形所產生的矩形。"
  remarks: "<xref:System.Windows.Rect.Width%2A>的產生的矩形會增加或減少指定的寬度位移的兩倍，因為它會套用至左邊和右邊的矩形。</xref:System.Windows.Rect.Width%2A> 同樣地，<xref:System.Windows.Rect.Height%2A>的產生的矩形會增加或減少兩次指定的高度。</xref:System.Windows.Rect.Height%2A>       如果指定的寬度或高度修飾詞壓縮矩形大於其目前<xref:System.Windows.Rect.Width%2A>或<xref:System.Windows.Rect.Height%2A>— 負的區域中，提供矩形，這個方法會傳回<xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>.</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName> </xref:System.Windows.Rect.Height%2A> </xref:System.Windows.Rect.Width%2A>"
  example:
  - "The following example shows how to use the Inflate method to change the size of a rectangle.  \n  \n [!code-cs[RectExamples_snip#InflateExample4_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#inflateexample4_csharp)]"
  syntax:
    content: public static System.Windows.Rect Inflate (System.Windows.Rect rect, double width, double height);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "<xref href=&quot;System.Windows.Rect&quot;> </xref>結構修改。"
    - id: width
      type: System.Double
      description: "用來展開或壓縮的左邊和右邊的矩形的數量。"
    - id: height
      type: System.Double
      description: "用來展開或壓縮頂端和底部的側邊的矩形的數量。"
    return:
      type: System.Windows.Rect
      description: "產生的矩形。"
  overload: System.Windows.Rect.Inflate*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>rect</code>是&lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt;矩形。"
  platform:
  - net462
- uid: System.Windows.Rect.Intersect(System.Windows.Rect)
  id: Intersect(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Intersect(Rect)
  nameWithType: Rect.Intersect(Rect)
  fullName: System.Windows.Rect.Intersect(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "尋找目前的矩形和指定的矩形的交集，並將結果儲存為目前的矩形。"
  remarks: "如果沒有交集，目前的矩形會變成<xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>.</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>"
  example:
  - "The following example shows how to use the Intersect method to find the intersection of two rectangles and store the result as a rectangle.  \n  \n [!code-cs[RectExamples_snip#IntersectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#intersectexample1_csharp)]"
  syntax:
    content: public void Intersect (System.Windows.Rect rect);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "要與目前的矩形交集的矩形。"
  overload: System.Windows.Rect.Intersect*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Intersect(System.Windows.Rect,System.Windows.Rect)
  id: Intersect(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Intersect(Rect,Rect)
  nameWithType: Rect.Intersect(Rect,Rect)
  fullName: System.Windows.Rect.Intersect(Rect,Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "傳回指定的矩形的交集。"
  remarks: "下列範例會示範如何使用 Intersect 方法來尋找兩個矩形的交集。       [!code-cs[RectExamples_snip # IntersectExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#intersectexample2_csharp)]"
  syntax:
    content: public static System.Windows.Rect Intersect (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "要比較的第一個矩形。"
    - id: rect2
      type: System.Windows.Rect
      description: "要比較的第二個矩形。"
    return:
      type: System.Windows.Rect
      description: "兩個矩形的交集或&lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt;有沒有交集。"
  overload: System.Windows.Rect.Intersect*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.IntersectsWith(System.Windows.Rect)
  id: IntersectsWith(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: IntersectsWith(Rect)
  nameWithType: Rect.IntersectsWith(Rect)
  fullName: System.Windows.Rect.IntersectsWith(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "指出指定的矩形是否與目前矩形的交集。"
  remarks: ''
  example:
  - "The following example shows how to use the IntersectsWith method to determine if two rectangles intersect.  \n  \n [!code-cs[RectExamples_snip#IntersectsWithExample_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#intersectswithexample_csharp)]"
  syntax:
    content: public bool IntersectsWith (System.Windows.Rect rect);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "要檢查的矩形。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果指定的矩形相交與目前的矩形。否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Rect.IntersectsWith*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.IsEmpty
  id: IsEmpty
  parent: System.Windows.Rect
  langs:
  - csharp
  name: IsEmpty
  nameWithType: Rect.IsEmpty
  fullName: System.Windows.Rect.IsEmpty
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得值，指出矩形是否<xref:System.Windows.Rect.Empty*>矩形。</xref:System.Windows.Rect.Empty*>"
  remarks: "請勿使用這個屬性來測試為零的區域。具有零個區域的矩形不一定是<xref:System.Windows.Rect.Empty%2A>矩形。</xref:System.Windows.Rect.Empty%2A> 如需詳細資訊，請參閱<xref:System.Windows.Rect.Empty%2A>屬性。</xref:System.Windows.Rect.Empty%2A>"
  syntax:
    content: public bool IsEmpty { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果矩形<xref:System.Windows.Rect.Empty*>矩形，否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Windows.Rect.Empty*>"
  overload: System.Windows.Rect.IsEmpty*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Left
  id: Left
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Left
  nameWithType: Rect.Left
  fullName: System.Windows.Rect.Left
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得矩形的左半部的 x 軸值。"
  remarks: "取得這個屬性相當於取得<xref:System.Windows.Rect.X%2A>屬性。</xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Left { get; }
    return:
      type: System.Double
      description: "左側的矩形的 x 軸值。"
  overload: System.Windows.Rect.Left*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Location
  id: Location
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Location
  nameWithType: Rect.Location
  fullName: System.Windows.Rect.Location
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得或設定矩形左上角的位置。"
  remarks: "矩形左上角的位置會等於 (<xref:System.Windows.Rect.X%2A>， <xref:System.Windows.Rect.Y%2A>)。</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point Location { get; set; }
    return:
      type: System.Windows.Point
      description: "矩形左上角的位置。 預設值是 （0，0）。"
  overload: System.Windows.Rect.Location*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "在 設定位置<xref:System.Windows.Rect.Empty*>矩形。</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.Offset(System.Windows.Vector)
  id: Offset(System.Windows.Vector)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Offset(Vector)
  nameWithType: Rect.Offset(Vector)
  fullName: System.Windows.Rect.Offset(Vector)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "移動矩形所指定的向量。"
  remarks: "為空的矩形上呼叫這個方法 (<xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>) 不允許。</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>       請注意，呼叫位移方法只會影響如果您可以變更<xref:System.Windows.Rect.X%2A>和<xref:System.Windows.Rect.Y%2A>直接內容。</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> 因為<xref:System.Windows.Rect>是實值類型，如果您參考<xref:System.Windows.Rect>物件使用屬性或索引子，您會取得一份物件，而不是物件的參考。</xref:System.Windows.Rect> </xref:System.Windows.Rect> 如果您嘗試變更<xref:System.Windows.Rect.X%2A>或<xref:System.Windows.Rect.Y%2A>對屬性或索引子參考，則編譯器會發生錯誤。</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> 同樣地，在屬性或索引子呼叫位移時，不會變更基礎物件。  如果您想要變更的值<xref:System.Windows.Rect>參照為屬性或索引子，會建立新<xref:System.Windows.Rect>修改它的欄位，然後指派<xref:System.Windows.Rect>回屬性或索引子。</xref:System.Windows.Rect> </xref:System.Windows.Rect> </xref:System.Windows.Rect>"
  example:
  - "The following example shows how to use the Offset method to change the position of a rectangle.  \n  \n [!code-cs[RectExamples_snip#OffsetExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#offsetexample1_csharp)]"
  syntax:
    content: public void Offset (System.Windows.Vector offsetVector);
    parameters:
    - id: offsetVector
      type: System.Windows.Vector
      description: "指定要移動矩形的水平和垂直數量的向量。"
  overload: System.Windows.Rect.Offset*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "這個方法會在呼叫&lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt;矩形。"
  platform:
  - net462
- uid: System.Windows.Rect.Offset(System.Double,System.Double)
  id: Offset(System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Offset(Double,Double)
  nameWithType: Rect.Offset(Double,Double)
  fullName: System.Windows.Rect.Offset(Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "移動矩形所指定的水平和垂直量。"
  remarks: "為空的矩形上呼叫這個方法 (<xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>) 不允許。</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>       請注意，呼叫位移方法只會影響如果您可以變更<xref:System.Windows.Rect.X%2A>和<xref:System.Windows.Rect.Y%2A>直接內容。</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> 因為<xref:System.Windows.Rect>是實值類型，如果您參考<xref:System.Windows.Rect>物件使用屬性或索引子，您會取得一份物件，而不是物件的參考。</xref:System.Windows.Rect> </xref:System.Windows.Rect> 如果您嘗試變更<xref:System.Windows.Rect.X%2A>或<xref:System.Windows.Rect.Y%2A>對屬性或索引子參考，則編譯器會發生錯誤。</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A> 同樣地，在屬性或索引子呼叫位移時，不會變更基礎物件。  如果您想要變更的值<xref:System.Windows.Rect>參照為屬性或索引子，會建立新<xref:System.Windows.Rect>修改它的欄位，然後指派<xref:System.Windows.Rect>回屬性或索引子。</xref:System.Windows.Rect> </xref:System.Windows.Rect> </xref:System.Windows.Rect>"
  example:
  - "The following example shows how to use the Offset method to change the position of a rectangle.  \n  \n [!code-cs[RectExamples_snip#OffsetExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#offsetexample2_csharp)]"
  syntax:
    content: public void Offset (double offsetX, double offsetY);
    parameters:
    - id: offsetX
      type: System.Double
      description: "要水平移動矩形的數量。"
    - id: offsetY
      type: System.Double
      description: "要垂直移動矩形的數量。"
  overload: System.Windows.Rect.Offset*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "這個方法會在呼叫&lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt;矩形。"
  platform:
  - net462
- uid: System.Windows.Rect.Offset(System.Windows.Rect,System.Windows.Vector)
  id: Offset(System.Windows.Rect,System.Windows.Vector)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Offset(Rect,Vector)
  nameWithType: Rect.Offset(Rect,Vector)
  fullName: System.Windows.Rect.Offset(Rect,Vector)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "傳回從指定的矩形的矩形的位移，使用指定的向量。"
  remarks: "呼叫此方法時為空的矩形 (<xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>) 不允許。</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>"
  example:
  - "The following example shows how to use the Offset method to change the position of a rectangle.  \n  \n [!code-cs[RectExamples_snip#OffsetExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#offsetexample3_csharp)]"
  syntax:
    content: public static System.Windows.Rect Offset (System.Windows.Rect rect, System.Windows.Vector offsetVector);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "原始的矩形。"
    - id: offsetVector
      type: System.Windows.Vector
      description: "指定新的矩形的水平和垂直位移的向量。"
    return:
      type: System.Windows.Rect
      description: "產生的矩形。"
  overload: System.Windows.Rect.Offset*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>rect</code>是&lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt;。"
  platform:
  - net462
- uid: System.Windows.Rect.Offset(System.Windows.Rect,System.Double,System.Double)
  id: Offset(System.Windows.Rect,System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Offset(Rect,Double,Double)
  nameWithType: Rect.Offset(Rect,Double,Double)
  fullName: System.Windows.Rect.Offset(Rect,Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "使用指定的水平和垂直量，矩形的位移傳回從指定的矩形。"
  remarks: "呼叫此方法時為空的矩形 (<xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>) 不允許。</xref:System.Windows.Rect.Empty%2A?displayProperty=fullName>"
  example:
  - "The following example shows how to use the Offset method to change the position of a rectangle.  \n  \n [!code-cs[RectExamples_snip#OffsetExample4_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#offsetexample4_csharp)]"
  syntax:
    content: public static System.Windows.Rect Offset (System.Windows.Rect rect, double offsetX, double offsetY);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "要移動的矩形。"
    - id: offsetX
      type: System.Double
      description: "新的矩形的水平位移。"
    - id: offsetY
      type: System.Double
      description: "新的矩形的垂直位移。"
    return:
      type: System.Windows.Rect
      description: "產生的矩形。"
  overload: System.Windows.Rect.Offset*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<code>rect</code>是&lt;xref:System.Windows.Rect.Empty%2A?displayProperty=fullName&gt;。"
  platform:
  - net462
- uid: System.Windows.Rect.op_Equality(System.Windows.Rect,System.Windows.Rect)
  id: op_Equality(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: op_Equality(Rect,Rect)
  nameWithType: Rect.op_Equality(Rect,Rect)
  fullName: System.Windows.Rect.op_Equality(Rect,Rect)
  type: Operator
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "比較兩個矩形完全相等。"
  remarks: "這項作業會測試物件相等。       這項比較，兩個執行個體<xref:System.Double.NaN?displayProperty=fullName>會被視為相等。</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > 所描述矩形的位置和維度<xref:System.Double>值。</xref:System.Double> 因為<xref:System.Double>值可能會遺失有效位數時操作時，邏輯上相等的兩個值之間的比較可能會失敗。</xref:System.Double>"
  example:
  - "The following example shows how to use the Equality operator to determine if two rectangles are exactly equal.  \n  \n [!code-cs[RectExamples_snip#OverloadedEqualityOperatorExample](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#overloadedequalityoperatorexample)]\n [!code-vb[RectExamples_snip#OverloadedEqualityOperatorExample](~/add/codesnippet/visualbasic/rectexamples_snip/rectexample.vb#overloadedequalityoperatorexample)]"
  syntax:
    content: public static bool op_Equality (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "要比較的第一個矩形。"
    - id: rect2
      type: System.Windows.Rect
      description: "要比較的第二個矩形。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果有相同的矩形<> *> 和<> *> 值; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Rect.op_Equality*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.op_Inequality(System.Windows.Rect,System.Windows.Rect)
  id: op_Inequality(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: op_Inequality(Rect,Rect)
  nameWithType: Rect.op_Inequality(Rect,Rect)
  fullName: System.Windows.Rect.op_Inequality(Rect,Rect)
  type: Operator
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "比較兩個矩形不相等。"
  remarks: "這項作業會測試物件不相等。       這項比較，兩個執行個體<xref:System.Double.NaN?displayProperty=fullName>會被視為相等。</xref:System.Double.NaN?displayProperty=fullName>      > [!NOTE] > 所描述矩形的位置和維度<xref:System.Double>值。</xref:System.Double> 因為<xref:System.Double>值可能會遺失有效位數時操作時，邏輯上相等的兩個值之間的比較可能會失敗。</xref:System.Double>"
  example:
  - "The following example shows how to use the Inequality operator to determine if two rectangles are not exactly equal.  \n  \n [!code-cs[RectExamples_snip#OverloadedInequalityOperatorExample](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#overloadedinequalityoperatorexample)]\n [!code-vb[RectExamples_snip#OverloadedInequalityOperatorExample](~/add/codesnippet/visualbasic/rectexamples_snip/rectexample.vb#overloadedinequalityoperatorexample)]"
  syntax:
    content: public static bool op_Inequality (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "要比較的第一個矩形。"
    - id: rect2
      type: System.Windows.Rect
      description: "要比較的第二個矩形。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果矩形不會有相同<> *> 和<> *> 值; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Windows.Rect.op_Inequality*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Parse(System.String)
  id: Parse(System.String)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Parse(String)
  nameWithType: Rect.Parse(String)
  fullName: System.Windows.Rect.Parse(String)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "從指定的字串表示法建立新的矩形。"
  remarks: ''
  example:
  - "The following example shows how to use the Parse method to convert a string representation of a rectangle into a <xref:System.Windows.Rect> structure.  \n  \n [!code-cs[RectExamples_snip#ParseExample](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#parseexample)]\n [!code-vb[RectExamples_snip#ParseExample](~/add/codesnippet/visualbasic/rectexamples_snip/rectexample.vb#parseexample)]"
  syntax:
    content: public static System.Windows.Rect Parse (string source);
    parameters:
    - id: source
      type: System.String
      description: "在矩形中，在表單中的字串表示 「 x、 y、 寬度、 高度&quot;。"
    return:
      type: System.Windows.Rect
      description: "產生的矩形。"
  overload: System.Windows.Rect.Parse*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Right
  id: Right
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Right
  nameWithType: Rect.Right
  fullName: System.Windows.Rect.Right
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得矩形右邊的 x 軸值。"
  remarks: "矩形右邊的 x 軸值的總和等於<xref:System.Windows.Rect.X%2A>和<xref:System.Windows.Rect.Width%2A>屬性。</xref:System.Windows.Rect.Width%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Right { get; }
    return:
      type: System.Double
      description: "矩形右邊的 x 軸值。"
  overload: System.Windows.Rect.Right*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Scale(System.Double,System.Double)
  id: Scale(System.Double,System.Double)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Scale(Double,Double)
  nameWithType: Rect.Scale(Double,Double)
  fullName: System.Windows.Rect.Scale(Double,Double)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "目前的矩形的大小乘以指定的 x 和 y 值。"
  remarks: ''
  example:
  - "The following example shows how to use the Scale method to multiply the width and height of a rectangle by the specified amount.  \n  \n [!code-cs[RectExamples_snip#ScaleExample_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#scaleexample_csharp)]"
  syntax:
    content: public void Scale (double scaleX, double scaleY);
    parameters:
    - id: scaleX
      type: System.Double
      description: "X 方向的縮放比例。"
    - id: scaleY
      type: System.Double
      description: "Y 方向的縮放比例。"
  overload: System.Windows.Rect.Scale*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Size
  id: Size
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Size
  nameWithType: Rect.Size
  fullName: System.Windows.Rect.Size
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得或設定矩形的高度與寬度。"
  remarks: ''
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Size Size { get; set; }
    return:
      type: System.Windows.Size
      description: "A <xref href=&quot;System.Windows.Size&quot;> </xref>結構，指定矩形的高度與寬度。"
  overload: System.Windows.Rect.Size*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "在設定大小<xref:System.Windows.Rect.Empty*>矩形。</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.System#IFormattable#ToString(System.String,System.IFormatProvider)
  id: System#IFormattable#ToString(System.String,System.IFormatProvider)
  isEii: true
  parent: System.Windows.Rect
  langs:
  - csharp
  name: System.IFormattable.ToString(String,IFormatProvider)
  nameWithType: Rect.System.IFormattable.ToString(String,IFormatProvider)
  fullName: System.Windows.Rect.System.IFormattable.ToString(String,IFormatProvider)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "目前的執行個體使用指定的格式將值格式化。"
  remarks: "這個成員是明確介面成員實作。 它可用時，才<xref:System.Windows.Rect>執行個體轉換成<xref:System.IFormattable>介面。</xref:System.IFormattable> </xref:System.Windows.Rect>"
  syntax:
    content: string IFormattable.ToString (string format, IFormatProvider provider);
    parameters:
    - id: format
      type: System.String
      description: "要使用的格式。       -null 參考 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>在 Visual Basic 中) 若要使用的類型所定義的預設格式<xref:System.IFormattable>實作。</xref:System.IFormattable>"
    - id: provider
      type: System.IFormatProvider
      description: "要用來格式化值提供者。       -null 參考 (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>在 Visual Basic 中) 從目前的地區設定的作業系統取得的數值格式資訊。"
    return:
      type: System.String
      description: "矩形的字串表示。"
  overload: System.Windows.Rect.System#IFormattable#ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Top
  id: Top
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Top
  nameWithType: Rect.Top
  fullName: System.Windows.Rect.Top
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得 y 軸位置上方的矩形。"
  remarks: "取得這個屬性相當於取得<xref:System.Windows.Rect.Y%2A>屬性。</xref:System.Windows.Rect.Y%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Top { get; }
    return:
      type: System.Double
      description: "Y 軸上方的矩形位置。"
  overload: System.Windows.Rect.Top*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.TopLeft
  id: TopLeft
  parent: System.Windows.Rect
  langs:
  - csharp
  name: TopLeft
  nameWithType: Rect.TopLeft
  fullName: System.Windows.Rect.TopLeft
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得矩形的左上角的位置。"
  remarks: "矩形左上角的位置會等於 (<xref:System.Windows.Rect.X%2A>， <xref:System.Windows.Rect.Y%2A>)。</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point TopLeft { get; }
    return:
      type: System.Windows.Point
      description: "矩形左上角的位置。"
  overload: System.Windows.Rect.TopLeft*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.TopRight
  id: TopRight
  parent: System.Windows.Rect
  langs:
  - csharp
  name: TopRight
  nameWithType: Rect.TopRight
  fullName: System.Windows.Rect.TopRight
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得矩形右上角的位置。"
  remarks: "矩形右上角的位置會等於 (<xref:System.Windows.Rect.X%2A> + <xref:System.Windows.Rect.Width%2A>， <xref:System.Windows.Rect.Y%2A>)。</xref:System.Windows.Rect.Y%2A> </xref:System.Windows.Rect.Width%2A> </xref:System.Windows.Rect.X%2A>"
  example:
  - "The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public System.Windows.Point TopRight { get; }
    return:
      type: System.Windows.Point
      description: "矩形右上角的位置。"
  overload: System.Windows.Rect.TopRight*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.ToString
  id: ToString
  parent: System.Windows.Rect
  langs:
  - csharp
  name: ToString()
  nameWithType: Rect.ToString()
  fullName: System.Windows.Rect.ToString()
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "傳回的字串表示的矩形。"
  remarks: ''
  example:
  - "The following example shows how to use the ToString method to get a string representation of a <xref:System.Windows.Rect> structure.  \n  \n [!code-cs[RectExamples_snip#ToStringExample_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#tostringexample_csharp)]"
  syntax:
    content: public override string ToString ();
    parameters: []
    return:
      type: System.String
      description: '目前的矩形的字串表示。 The string has the following form: &quot;<>*>,<>*>,<>*>,<>*>&quot;.'
  overload: System.Windows.Rect.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.ToString(System.IFormatProvider)
  id: ToString(System.IFormatProvider)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: ToString(IFormatProvider)
  nameWithType: Rect.ToString(IFormatProvider)
  fullName: System.Windows.Rect.ToString(IFormatProvider)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "使用指定的格式提供者傳回的字串表示的矩形。"
  syntax:
    content: public string ToString (IFormatProvider provider);
    parameters:
    - id: provider
      type: System.IFormatProvider
      description: "特定文化特性格式資訊。"
    return:
      type: System.String
      description: "目前的矩形，取決於指定的格式提供者的字串表示。"
  overload: System.Windows.Rect.ToString*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Transform(System.Windows.Media.Matrix)
  id: Transform(System.Windows.Media.Matrix)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Transform(Matrix)
  nameWithType: Rect.Transform(Matrix)
  fullName: System.Windows.Rect.Transform(Matrix)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "套用指定的矩陣轉換的矩形。"
  remarks: ''
  example:
  - "The following example shows how to use the Transform method to transform a <xref:System.Windows.Rect> structure by using a <xref:System.Windows.Media.Matrix>.  \n  \n [!code-cs[RectExamples_snip#TransformExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#transformexample1_csharp)]"
  syntax:
    content: public void Transform (System.Windows.Media.Matrix matrix);
    parameters:
    - id: matrix
      type: System.Windows.Media.Matrix
      description: "指定要套用的轉換矩陣。"
  overload: System.Windows.Rect.Transform*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Transform(System.Windows.Rect,System.Windows.Media.Matrix)
  id: Transform(System.Windows.Rect,System.Windows.Media.Matrix)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Transform(Rect,Matrix)
  nameWithType: Rect.Transform(Rect,Matrix)
  fullName: System.Windows.Rect.Transform(Rect,Matrix)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "傳回指定的矩形來套用指定的矩陣所產生的矩形。"
  remarks: ''
  example:
  - "The following example shows how to use the Transform method to create a new <xref:System.Windows.Rect> structure that results from applying a <xref:System.Windows.Media.Matrix> to an existing rectangle.  \n  \n [!code-cs[RectExamples_snip#TransformExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#transformexample2_csharp)]"
  syntax:
    content: public static System.Windows.Rect Transform (System.Windows.Rect rect, System.Windows.Media.Matrix matrix);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "是轉換為基礎的矩形。"
    - id: matrix
      type: System.Windows.Media.Matrix
      description: "指定要套用的轉換矩陣。"
    return:
      type: System.Windows.Rect
      description: "作業所產生的矩形。"
  overload: System.Windows.Rect.Transform*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Union(System.Windows.Point)
  id: Union(System.Windows.Point)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Union(Point)
  nameWithType: Rect.Union(Point)
  fullName: System.Windows.Rect.Union(Point)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "包含指定的點剛好展開目前的矩形。"
  remarks: ''
  example:
  - "The following example shows how to use the Union method to expand the current rectangle exactly enough to contain a given <xref:System.Windows.Point>.  \n  \n [!code-cs[RectExamples_snip#UnionExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#unionexample1_csharp)]"
  syntax:
    content: public void Union (System.Windows.Point point);
    parameters:
    - id: point
      type: System.Windows.Point
      description: "要加入的點。"
  overload: System.Windows.Rect.Union*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Union(System.Windows.Rect)
  id: Union(System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Union(Rect)
  nameWithType: Rect.Union(Rect)
  fullName: System.Windows.Rect.Union(Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "展開目前的矩形剛好以包含指定的矩形。"
  remarks: ''
  example:
  - "The following example shows how to use the Union method to expand the current rectangle exactly enough to contain the specified rectangle.  \n  \n [!code-cs[RectExamples_snip#UnionExample2_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#unionexample2_csharp)]"
  syntax:
    content: public void Union (System.Windows.Rect rect);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "要加入的矩形。"
  overload: System.Windows.Rect.Union*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Point)
  id: Union(System.Windows.Rect,System.Windows.Point)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Union(Rect,Point)
  nameWithType: Rect.Union(Rect,Point)
  fullName: System.Windows.Rect.Union(Rect,Point)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "建立剛好足夠包含指定的矩形和指定的點的矩形。"
  remarks: ''
  example:
  - "The following example shows how to use the Union method to create a rectangle that is exactly large enough to contain a given rectangle and a given <xref:System.Windows.Point>.  \n  \n [!code-cs[RectExamples_snip#UnionExample3_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#unionexample3_csharp)]"
  syntax:
    content: public static System.Windows.Rect Union (System.Windows.Rect rect, System.Windows.Point point);
    parameters:
    - id: rect
      type: System.Windows.Rect
      description: "要加入的矩形。"
    - id: point
      type: System.Windows.Point
      description: "要加入的點。"
    return:
      type: System.Windows.Rect
      description: "矩形，剛好足夠包含指定的矩形和指定的點。"
  overload: System.Windows.Rect.Union*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Rect)
  id: Union(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Union(Rect,Rect)
  nameWithType: Rect.Union(Rect,Rect)
  fullName: System.Windows.Rect.Union(Rect,Rect)
  type: Method
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "建立剛好包含兩個指定的矩形的矩形。"
  remarks: ''
  example:
  - "The following example shows how to use the Union method to create a rectangle that is exactly large enough to contain two given rectangles.  \n  \n [!code-cs[RectExamples_snip#UnionExample4_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#unionexample4_csharp)]"
  syntax:
    content: public static System.Windows.Rect Union (System.Windows.Rect rect1, System.Windows.Rect rect2);
    parameters:
    - id: rect1
      type: System.Windows.Rect
      description: "要包含的第一個矩形。"
    - id: rect2
      type: System.Windows.Rect
      description: "要包含的第二個矩形。"
    return:
      type: System.Windows.Rect
      description: "產生的矩形。"
  overload: System.Windows.Rect.Union*
  exceptions: []
  platform:
  - net462
- uid: System.Windows.Rect.Width
  id: Width
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Width
  nameWithType: Rect.Width
  fullName: System.Windows.Rect.Width
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得或設定矩形的寬度。"
  remarks: "<xref:System.Windows.Rect.Empty%2A>矩形的寬度為<xref:System.Double.NegativeInfinity>.</xref:System.Double.NegativeInfinity> </xref:System.Windows.Rect.Empty%2A> <xref:System.Windows.Rect.Empty%2A>矩形是唯讀，則為不變更其寬度。</xref:System.Windows.Rect.Empty%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Width { get; set; }
    return:
      type: System.Double
      description: "正數，代表矩形的寬度。 預設值為 0。"
  overload: System.Windows.Rect.Width*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "寬度設定為負數值。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "在設定寬度<xref:System.Windows.Rect.Empty*>矩形。</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.X
  id: X
  parent: System.Windows.Rect
  langs:
  - csharp
  name: X
  nameWithType: Rect.X
  fullName: System.Windows.Rect.X
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得或設定矩形的左半部的 x 軸值。"
  remarks: "取得這個屬性相當於取得<xref:System.Windows.Rect.Left%2A>屬性。</xref:System.Windows.Rect.Left%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double X { get; set; }
    return:
      type: System.Double
      description: "左側的矩形的 x 軸值。"
  overload: System.Windows.Rect.X*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "X 上設定<xref:System.Windows.Rect.Empty*>矩形。</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
- uid: System.Windows.Rect.Y
  id: Y
  parent: System.Windows.Rect
  langs:
  - csharp
  name: Y
  nameWithType: Rect.Y
  fullName: System.Windows.Rect.Y
  type: Property
  assemblies:
  - WindowsBase
  namespace: System.Windows
  summary: "取得或設定矩形的頂端的 y 軸值。"
  remarks: "取得這個屬性相當於取得<xref:System.Windows.Rect.Top%2A>屬性。</xref:System.Windows.Rect.Top%2A>"
  example:
  - "The following example shows how to use a <xref:System.Windows.Rect> structure to specify the dimensions and location of a rectangle using XAML.  \n  \n [!code-cs[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/csharp/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.cs#rectexamplewholepage)]\n [!code-vb[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/visualbasic/geometriesmiscsnippets/rectexample.vb#rectexamplewholepage)]\n [!code-xml[GeometriesMiscSnippets_snip#RectExampleWholePage](~/add/codesnippet/xaml/GeometriesMiscSnippets_snip.GeometriesMiscSnippets/RectExample.xaml#rectexamplewholepage)]  \n  \n The following example shows how to use code to create a rectangle and add it to the page. The example also illustrates how to find size and coordinate information about the new rectangle and render the information in a <xref:System.Windows.Controls.TextBox> below the rectangle.  \n  \n [!code-cs[RectExamples_snip#CreateRectExample1_csharp](~/add/codesnippet/csharp/RectExamples_snip/RectExample.cs#createrectexample1_csharp)]"
  syntax:
    content: public double Y { get; set; }
    return:
      type: System.Double
      description: "矩形的頂端 y 軸值。"
  overload: System.Windows.Rect.Y*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "設定 Y<xref:System.Windows.Rect.Empty*>矩形。</xref:System.Windows.Rect.Empty*>"
  platform:
  - net462
references:
- uid: System.ValueType
  isExternal: false
  name: System.ValueType
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.Windows.Rect.#ctor(System.Windows.Size)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Size)
  nameWithType: Rect.Rect(Size)
  fullName: System.Windows.Rect.Rect(Size)
- uid: System.Windows.Size
  parent: System.Windows
  isExternal: false
  name: Size
  nameWithType: Size
  fullName: System.Windows.Size
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Point)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Point,Point)
  nameWithType: Rect.Rect(Point,Point)
  fullName: System.Windows.Rect.Rect(Point,Point)
- uid: System.Windows.Point
  parent: System.Windows
  isExternal: false
  name: Point
  nameWithType: Point
  fullName: System.Windows.Point
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Size)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Point,Size)
  nameWithType: Rect.Rect(Point,Size)
  fullName: System.Windows.Rect.Rect(Point,Size)
- uid: System.Windows.Rect.#ctor(System.Windows.Point,System.Windows.Vector)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Point,Vector)
  nameWithType: Rect.Rect(Point,Vector)
  fullName: System.Windows.Rect.Rect(Point,Vector)
- uid: System.Windows.Vector
  parent: System.Windows
  isExternal: false
  name: Vector
  nameWithType: Vector
  fullName: System.Windows.Vector
- uid: System.Windows.Rect.#ctor(System.Double,System.Double,System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Rect(Double,Double,Double,Double)
  nameWithType: Rect.Rect(Double,Double,Double,Double)
  fullName: System.Windows.Rect.Rect(Double,Double,Double,Double)
- uid: System.Double
  parent: System
  isExternal: true
  name: Double
  nameWithType: Double
  fullName: System.Double
- uid: System.Windows.Rect.Bottom
  parent: System.Windows.Rect
  isExternal: false
  name: Bottom
  nameWithType: Rect.Bottom
  fullName: System.Windows.Rect.Bottom
- uid: System.Windows.Rect.BottomLeft
  parent: System.Windows.Rect
  isExternal: false
  name: BottomLeft
  nameWithType: Rect.BottomLeft
  fullName: System.Windows.Rect.BottomLeft
- uid: System.Windows.Rect.BottomRight
  parent: System.Windows.Rect
  isExternal: false
  name: BottomRight
  nameWithType: Rect.BottomRight
  fullName: System.Windows.Rect.BottomRight
- uid: System.Windows.Rect.Contains(System.Windows.Point)
  parent: System.Windows.Rect
  isExternal: false
  name: Contains(Point)
  nameWithType: Rect.Contains(Point)
  fullName: System.Windows.Rect.Contains(Point)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Windows.Rect.Contains(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Contains(Rect)
  nameWithType: Rect.Contains(Rect)
  fullName: System.Windows.Rect.Contains(Rect)
- uid: System.Windows.Rect
  parent: System.Windows
  isExternal: false
  name: Rect
  nameWithType: Rect
  fullName: System.Windows.Rect
- uid: System.Windows.Rect.Contains(System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Contains(Double,Double)
  nameWithType: Rect.Contains(Double,Double)
  fullName: System.Windows.Rect.Contains(Double,Double)
- uid: System.Windows.Rect.Empty
  parent: System.Windows.Rect
  isExternal: false
  name: Empty
  nameWithType: Rect.Empty
  fullName: System.Windows.Rect.Empty
- uid: System.Windows.Rect.Equals(System.Object)
  parent: System.Windows.Rect
  isExternal: false
  name: Equals(Object)
  nameWithType: Rect.Equals(Object)
  fullName: System.Windows.Rect.Equals(Object)
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Windows.Rect.Equals(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Equals(Rect)
  nameWithType: Rect.Equals(Rect)
  fullName: System.Windows.Rect.Equals(Rect)
- uid: System.Windows.Rect.Equals(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Equals(Rect,Rect)
  nameWithType: Rect.Equals(Rect,Rect)
  fullName: System.Windows.Rect.Equals(Rect,Rect)
- uid: System.Windows.Rect.GetHashCode
  parent: System.Windows.Rect
  isExternal: false
  name: GetHashCode()
  nameWithType: Rect.GetHashCode()
  fullName: System.Windows.Rect.GetHashCode()
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Windows.Rect.Height
  parent: System.Windows.Rect
  isExternal: false
  name: Height
  nameWithType: Rect.Height
  fullName: System.Windows.Rect.Height
- uid: System.Windows.Rect.Inflate(System.Windows.Size)
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate(Size)
  nameWithType: Rect.Inflate(Size)
  fullName: System.Windows.Rect.Inflate(Size)
- uid: System.Windows.Rect.Inflate(System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate(Double,Double)
  nameWithType: Rect.Inflate(Double,Double)
  fullName: System.Windows.Rect.Inflate(Double,Double)
- uid: System.Windows.Rect.Inflate(System.Windows.Rect,System.Windows.Size)
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate(Rect,Size)
  nameWithType: Rect.Inflate(Rect,Size)
  fullName: System.Windows.Rect.Inflate(Rect,Size)
- uid: System.Windows.Rect.Inflate(System.Windows.Rect,System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate(Rect,Double,Double)
  nameWithType: Rect.Inflate(Rect,Double,Double)
  fullName: System.Windows.Rect.Inflate(Rect,Double,Double)
- uid: System.Windows.Rect.Intersect(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Intersect(Rect)
  nameWithType: Rect.Intersect(Rect)
  fullName: System.Windows.Rect.Intersect(Rect)
- uid: System.Windows.Rect.Intersect(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Intersect(Rect,Rect)
  nameWithType: Rect.Intersect(Rect,Rect)
  fullName: System.Windows.Rect.Intersect(Rect,Rect)
- uid: System.Windows.Rect.IntersectsWith(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: IntersectsWith(Rect)
  nameWithType: Rect.IntersectsWith(Rect)
  fullName: System.Windows.Rect.IntersectsWith(Rect)
- uid: System.Windows.Rect.IsEmpty
  parent: System.Windows.Rect
  isExternal: false
  name: IsEmpty
  nameWithType: Rect.IsEmpty
  fullName: System.Windows.Rect.IsEmpty
- uid: System.Windows.Rect.Left
  parent: System.Windows.Rect
  isExternal: false
  name: Left
  nameWithType: Rect.Left
  fullName: System.Windows.Rect.Left
- uid: System.Windows.Rect.Location
  parent: System.Windows.Rect
  isExternal: false
  name: Location
  nameWithType: Rect.Location
  fullName: System.Windows.Rect.Location
- uid: System.Windows.Rect.Offset(System.Windows.Vector)
  parent: System.Windows.Rect
  isExternal: false
  name: Offset(Vector)
  nameWithType: Rect.Offset(Vector)
  fullName: System.Windows.Rect.Offset(Vector)
- uid: System.Windows.Rect.Offset(System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Offset(Double,Double)
  nameWithType: Rect.Offset(Double,Double)
  fullName: System.Windows.Rect.Offset(Double,Double)
- uid: System.Windows.Rect.Offset(System.Windows.Rect,System.Windows.Vector)
  parent: System.Windows.Rect
  isExternal: false
  name: Offset(Rect,Vector)
  nameWithType: Rect.Offset(Rect,Vector)
  fullName: System.Windows.Rect.Offset(Rect,Vector)
- uid: System.Windows.Rect.Offset(System.Windows.Rect,System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Offset(Rect,Double,Double)
  nameWithType: Rect.Offset(Rect,Double,Double)
  fullName: System.Windows.Rect.Offset(Rect,Double,Double)
- uid: System.Windows.Rect.op_Equality(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: op_Equality(Rect,Rect)
  nameWithType: Rect.op_Equality(Rect,Rect)
  fullName: System.Windows.Rect.op_Equality(Rect,Rect)
- uid: System.Windows.Rect.op_Inequality(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: op_Inequality(Rect,Rect)
  nameWithType: Rect.op_Inequality(Rect,Rect)
  fullName: System.Windows.Rect.op_Inequality(Rect,Rect)
- uid: System.Windows.Rect.Parse(System.String)
  parent: System.Windows.Rect
  isExternal: false
  name: Parse(String)
  nameWithType: Rect.Parse(String)
  fullName: System.Windows.Rect.Parse(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Windows.Rect.Right
  parent: System.Windows.Rect
  isExternal: false
  name: Right
  nameWithType: Rect.Right
  fullName: System.Windows.Rect.Right
- uid: System.Windows.Rect.Scale(System.Double,System.Double)
  parent: System.Windows.Rect
  isExternal: false
  name: Scale(Double,Double)
  nameWithType: Rect.Scale(Double,Double)
  fullName: System.Windows.Rect.Scale(Double,Double)
- uid: System.Windows.Rect.Size
  parent: System.Windows.Rect
  isExternal: false
  name: Size
  nameWithType: Rect.Size
  fullName: System.Windows.Rect.Size
- uid: System.Windows.Rect.System#IFormattable#ToString(System.String,System.IFormatProvider)
  parent: System.Windows.Rect
  isExternal: false
  name: System.IFormattable.ToString(String,IFormatProvider)
  nameWithType: Rect.System.IFormattable.ToString(String,IFormatProvider)
  fullName: System.Windows.Rect.System.IFormattable.ToString(String,IFormatProvider)
- uid: System.IFormatProvider
  parent: System
  isExternal: true
  name: IFormatProvider
  nameWithType: IFormatProvider
  fullName: System.IFormatProvider
- uid: System.Windows.Rect.Top
  parent: System.Windows.Rect
  isExternal: false
  name: Top
  nameWithType: Rect.Top
  fullName: System.Windows.Rect.Top
- uid: System.Windows.Rect.TopLeft
  parent: System.Windows.Rect
  isExternal: false
  name: TopLeft
  nameWithType: Rect.TopLeft
  fullName: System.Windows.Rect.TopLeft
- uid: System.Windows.Rect.TopRight
  parent: System.Windows.Rect
  isExternal: false
  name: TopRight
  nameWithType: Rect.TopRight
  fullName: System.Windows.Rect.TopRight
- uid: System.Windows.Rect.ToString
  parent: System.Windows.Rect
  isExternal: false
  name: ToString()
  nameWithType: Rect.ToString()
  fullName: System.Windows.Rect.ToString()
- uid: System.Windows.Rect.ToString(System.IFormatProvider)
  parent: System.Windows.Rect
  isExternal: false
  name: ToString(IFormatProvider)
  nameWithType: Rect.ToString(IFormatProvider)
  fullName: System.Windows.Rect.ToString(IFormatProvider)
- uid: System.Windows.Rect.Transform(System.Windows.Media.Matrix)
  parent: System.Windows.Rect
  isExternal: false
  name: Transform(Matrix)
  nameWithType: Rect.Transform(Matrix)
  fullName: System.Windows.Rect.Transform(Matrix)
- uid: System.Windows.Media.Matrix
  parent: System.Windows.Media
  isExternal: false
  name: Matrix
  nameWithType: Matrix
  fullName: System.Windows.Media.Matrix
- uid: System.Windows.Rect.Transform(System.Windows.Rect,System.Windows.Media.Matrix)
  parent: System.Windows.Rect
  isExternal: false
  name: Transform(Rect,Matrix)
  nameWithType: Rect.Transform(Rect,Matrix)
  fullName: System.Windows.Rect.Transform(Rect,Matrix)
- uid: System.Windows.Rect.Union(System.Windows.Point)
  parent: System.Windows.Rect
  isExternal: false
  name: Union(Point)
  nameWithType: Rect.Union(Point)
  fullName: System.Windows.Rect.Union(Point)
- uid: System.Windows.Rect.Union(System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Union(Rect)
  nameWithType: Rect.Union(Rect)
  fullName: System.Windows.Rect.Union(Rect)
- uid: System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Point)
  parent: System.Windows.Rect
  isExternal: false
  name: Union(Rect,Point)
  nameWithType: Rect.Union(Rect,Point)
  fullName: System.Windows.Rect.Union(Rect,Point)
- uid: System.Windows.Rect.Union(System.Windows.Rect,System.Windows.Rect)
  parent: System.Windows.Rect
  isExternal: false
  name: Union(Rect,Rect)
  nameWithType: Rect.Union(Rect,Rect)
  fullName: System.Windows.Rect.Union(Rect,Rect)
- uid: System.Windows.Rect.Width
  parent: System.Windows.Rect
  isExternal: false
  name: Width
  nameWithType: Rect.Width
  fullName: System.Windows.Rect.Width
- uid: System.Windows.Rect.X
  parent: System.Windows.Rect
  isExternal: false
  name: X
  nameWithType: Rect.X
  fullName: System.Windows.Rect.X
- uid: System.Windows.Rect.Y
  parent: System.Windows.Rect
  isExternal: false
  name: Y
  nameWithType: Rect.Y
  fullName: System.Windows.Rect.Y
- uid: System.Windows.Rect.#ctor*
  parent: System.Windows.Rect
  isExternal: false
  name: Rect
  nameWithType: Rect.Rect
- uid: System.Windows.Rect.Bottom*
  parent: System.Windows.Rect
  isExternal: false
  name: Bottom
  nameWithType: Rect.Bottom
- uid: System.Windows.Rect.BottomLeft*
  parent: System.Windows.Rect
  isExternal: false
  name: BottomLeft
  nameWithType: Rect.BottomLeft
- uid: System.Windows.Rect.BottomRight*
  parent: System.Windows.Rect
  isExternal: false
  name: BottomRight
  nameWithType: Rect.BottomRight
- uid: System.Windows.Rect.Contains*
  parent: System.Windows.Rect
  isExternal: false
  name: Contains
  nameWithType: Rect.Contains
- uid: System.Windows.Rect.Empty*
  parent: System.Windows.Rect
  isExternal: false
  name: Empty
  nameWithType: Rect.Empty
- uid: System.Windows.Rect.Equals*
  parent: System.Windows.Rect
  isExternal: false
  name: Equals
  nameWithType: Rect.Equals
- uid: System.Windows.Rect.GetHashCode*
  parent: System.Windows.Rect
  isExternal: false
  name: GetHashCode
  nameWithType: Rect.GetHashCode
- uid: System.Windows.Rect.Height*
  parent: System.Windows.Rect
  isExternal: false
  name: Height
  nameWithType: Rect.Height
- uid: System.Windows.Rect.Inflate*
  parent: System.Windows.Rect
  isExternal: false
  name: Inflate
  nameWithType: Rect.Inflate
- uid: System.Windows.Rect.Intersect*
  parent: System.Windows.Rect
  isExternal: false
  name: Intersect
  nameWithType: Rect.Intersect
- uid: System.Windows.Rect.IntersectsWith*
  parent: System.Windows.Rect
  isExternal: false
  name: IntersectsWith
  nameWithType: Rect.IntersectsWith
- uid: System.Windows.Rect.IsEmpty*
  parent: System.Windows.Rect
  isExternal: false
  name: IsEmpty
  nameWithType: Rect.IsEmpty
- uid: System.Windows.Rect.Left*
  parent: System.Windows.Rect
  isExternal: false
  name: Left
  nameWithType: Rect.Left
- uid: System.Windows.Rect.Location*
  parent: System.Windows.Rect
  isExternal: false
  name: Location
  nameWithType: Rect.Location
- uid: System.Windows.Rect.Offset*
  parent: System.Windows.Rect
  isExternal: false
  name: Offset
  nameWithType: Rect.Offset
- uid: System.Windows.Rect.op_Equality*
  parent: System.Windows.Rect
  isExternal: false
  name: op_Equality
  nameWithType: Rect.op_Equality
- uid: System.Windows.Rect.op_Inequality*
  parent: System.Windows.Rect
  isExternal: false
  name: op_Inequality
  nameWithType: Rect.op_Inequality
- uid: System.Windows.Rect.Parse*
  parent: System.Windows.Rect
  isExternal: false
  name: Parse
  nameWithType: Rect.Parse
- uid: System.Windows.Rect.Right*
  parent: System.Windows.Rect
  isExternal: false
  name: Right
  nameWithType: Rect.Right
- uid: System.Windows.Rect.Scale*
  parent: System.Windows.Rect
  isExternal: false
  name: Scale
  nameWithType: Rect.Scale
- uid: System.Windows.Rect.Size*
  parent: System.Windows.Rect
  isExternal: false
  name: Size
  nameWithType: Rect.Size
- uid: System.Windows.Rect.System#IFormattable#ToString*
  parent: System.Windows.Rect
  isExternal: false
  name: System.IFormattable.ToString
  nameWithType: Rect.System.IFormattable.ToString
- uid: System.Windows.Rect.Top*
  parent: System.Windows.Rect
  isExternal: false
  name: Top
  nameWithType: Rect.Top
- uid: System.Windows.Rect.TopLeft*
  parent: System.Windows.Rect
  isExternal: false
  name: TopLeft
  nameWithType: Rect.TopLeft
- uid: System.Windows.Rect.TopRight*
  parent: System.Windows.Rect
  isExternal: false
  name: TopRight
  nameWithType: Rect.TopRight
- uid: System.Windows.Rect.ToString*
  parent: System.Windows.Rect
  isExternal: false
  name: ToString
  nameWithType: Rect.ToString
- uid: System.Windows.Rect.Transform*
  parent: System.Windows.Rect
  isExternal: false
  name: Transform
  nameWithType: Rect.Transform
- uid: System.Windows.Rect.Union*
  parent: System.Windows.Rect
  isExternal: false
  name: Union
  nameWithType: Rect.Union
- uid: System.Windows.Rect.Width*
  parent: System.Windows.Rect
  isExternal: false
  name: Width
  nameWithType: Rect.Width
- uid: System.Windows.Rect.X*
  parent: System.Windows.Rect
  isExternal: false
  name: X
  nameWithType: Rect.X
- uid: System.Windows.Rect.Y*
  parent: System.Windows.Rect
  isExternal: false
  name: Y
  nameWithType: Rect.Y
