### YamlMime:ManagedReference
items:
- uid: System.Web.Routing.PageRouteHandler
  id: PageRouteHandler
  children:
  - System.Web.Routing.PageRouteHandler.#ctor(System.String)
  - System.Web.Routing.PageRouteHandler.#ctor(System.String,System.Boolean)
  - System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess
  - System.Web.Routing.PageRouteHandler.GetHttpHandler(System.Web.Routing.RequestContext)
  - System.Web.Routing.PageRouteHandler.GetSubstitutedVirtualPath(System.Web.Routing.RequestContext)
  - System.Web.Routing.PageRouteHandler.VirtualPath
  langs:
  - csharp
  name: PageRouteHandler
  nameWithType: PageRouteHandler
  fullName: System.Web.Routing.PageRouteHandler
  type: Class
  summary: "提供屬性和方法定義如何將 URL 對應至實體檔案。"
  remarks: "傳遞至 PageRouteHandler 的執行個體<xref:System.Web.Routing.Route>建構函式對應的實體檔案的 URL。</xref:System.Web.Routing.Route> PageRouteHandler 物件指定的虛擬路徑的實體檔案，並判斷是否要檢查授權規則的實體的 URL。"
  syntax:
    content: 'public class PageRouteHandler : System.Web.Routing.IRouteHandler'
  inheritance:
  - System.Object
  implements:
  - System.Web.Routing.IRouteHandler
  inheritedMembers: []
  platform:
  - net462
- uid: System.Web.Routing.PageRouteHandler.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Web.Routing.PageRouteHandler
  langs:
  - csharp
  name: PageRouteHandler(String)
  nameWithType: PageRouteHandler.PageRouteHandler(String)
  fullName: System.Web.Routing.PageRouteHandler.PageRouteHandler(String)
  type: Constructor
  assemblies:
  - System.Web
  namespace: System.Web.Routing
  summary: "初始化的新執行個體<xref href=&quot;System.Web.Routing.PageRouteHandler&quot;></xref>類別。"
  remarks: "當您使用這個建構函式，<xref:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess%2A>屬性設定為`true`。</xref:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess%2A>"
  syntax:
    content: public PageRouteHandler (string virtualPath);
    parameters:
    - id: virtualPath
      type: System.String
      description: "這個實體檔案的虛擬路徑<xref:System.Web.Routing.RouteData.Route*>物件。</xref:System.Web.Routing.RouteData.Route*> 此檔案必須位於目前的應用程式。 因此，路徑必須以波狀符號 （~） 開頭。"
  overload: System.Web.Routing.PageRouteHandler.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> virtualPath </code>參數是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>或為空字串，或未啟動與&quot;~ /&quot;。"
  platform:
  - net462
- uid: System.Web.Routing.PageRouteHandler.#ctor(System.String,System.Boolean)
  id: '#ctor(System.String,System.Boolean)'
  parent: System.Web.Routing.PageRouteHandler
  langs:
  - csharp
  name: PageRouteHandler(String,Boolean)
  nameWithType: PageRouteHandler.PageRouteHandler(String,Boolean)
  fullName: System.Web.Routing.PageRouteHandler.PageRouteHandler(String,Boolean)
  type: Constructor
  assemblies:
  - System.Web
  namespace: System.Web.Routing
  summary: "初始化的新執行個體<xref href=&quot;System.Web.Routing.PageRouteHandler&quot;></xref>類別。"
  remarks: "根據預設，<xref:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess%2A>屬性是`true`。</xref:System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess%2A> 因此，如果您想要套用至實體頁面的 URL 和路由 URL 授權規則，您可以使用<xref:System.Web.Routing.PageRouteHandler.%23ctor%28System.String%29>建構函式，而不是這個建構函式。</xref:System.Web.Routing.PageRouteHandler.%23ctor%28System.String%29>"
  syntax:
    content: public PageRouteHandler (string virtualPath, bool checkPhysicalUrlAccess);
    parameters:
    - id: virtualPath
      type: System.String
      description: "這個實體檔案的虛擬路徑<xref:System.Web.Routing.RouteData.Route*>物件。</xref:System.Web.Routing.RouteData.Route*> 此檔案必須位於目前的應用程式。 因此，路徑必須以波狀符號 （~） 開頭。"
    - id: checkPhysicalUrlAccess
      type: System.Boolean
      description: "如果這個屬性設定為<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>，授權規則會套用至要求的 URL，而不在實體頁面的 URL。 如果這個屬性設定為<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>，要求 URL，並在實體頁面的 URL 授權規則會套用。"
  overload: System.Web.Routing.PageRouteHandler.#ctor*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> virtualPath </code>參數是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>或為空字串，或未啟動與&quot;~ /&quot;。"
  platform:
  - net462
- uid: System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess
  id: CheckPhysicalUrlAccess
  parent: System.Web.Routing.PageRouteHandler
  langs:
  - csharp
  name: CheckPhysicalUrlAccess
  nameWithType: PageRouteHandler.CheckPhysicalUrlAccess
  fullName: System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.Routing
  summary: "取得值，決定是否要將授權規則套用至實體檔案的 URL。"
  remarks: "當您使用時，您可以設定 CheckPhysicalUrlAccess 屬性<xref:System.Web.Routing.PageRouteHandler.%23ctor%28System.String%2CSystem.Boolean%29>建構函式。</xref:System.Web.Routing.PageRouteHandler.%23ctor%28System.String%2CSystem.Boolean%29>       CheckPhysicalUrlAccess 屬性的值會決定是否<xref:System.Web.Routing.PageRouteHandler>物件會檢查安全性權限僅適用於路由 URL，或在實體頁面及路由 URL。</xref:System.Web.Routing.PageRouteHandler>       當 CheckPhysicalUrlAccess 屬性設定為`true`（此為其預設值），使用者必須擁有存取的路由 URL 及實體的 URL 的權限。 當 CheckPhysicalUrlAccess 屬性設定為`false`使用者需要存取的路由 URL 的權限，不檢查權限的實體的 URL。       權限定義在 Web.config 檔案中，如下列範例所示︰```   <configuration>     <location path=&quot;categoriespage.aspx&quot;>       <system.web>         <authorization>           <allow roles=&quot;admin&quot;/>           <deny users=&quot;*&quot;/>         </authorization>       </system.web>     </location>     <location path=&quot;category&quot;>       <system.web>         <authorization>           <allow users=&quot;*&quot;/>         </authorization>       </system.web>     </location>   </configuration>   ```要求 Url，其中包含`Category/food/show`網域名稱之後，該路由的 URL 模式`Category/{action}/{categoryName}`Categoriespage.aspx，在實體頁面且[!INCLUDE[vstecasp](~/add/includes/vstecasp-md.md)]適用於下列方式之一，在上述範例中定義的權限:-如果 CheckPhysicalUrlAccess 屬性為`false`會授與所有使用者存取，因為所有的使用者授都與存取權開頭的 URL 模式`category`。      -如果 CheckPhysicalUrlAccess 屬性是`true`，則只`admin`會授與使用者存取。 所有使用者都有權存取開頭的 URL 模式`category`，但只`admin`使用者都有權存取 Categoriespage.aspx 在實體頁面。"
  syntax:
    content: public bool CheckPhysicalUrlAccess { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果會檢查與路由; 相關聯的實體檔案的 URL 授權否則， <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;> </xref>。"
  overload: System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess*
  exceptions: []
  platform:
  - net462
- uid: System.Web.Routing.PageRouteHandler.GetHttpHandler(System.Web.Routing.RequestContext)
  id: GetHttpHandler(System.Web.Routing.RequestContext)
  parent: System.Web.Routing.PageRouteHandler
  langs:
  - csharp
  name: GetHttpHandler(RequestContext)
  nameWithType: PageRouteHandler.GetHttpHandler(RequestContext)
  fullName: System.Web.Routing.PageRouteHandler.GetHttpHandler(RequestContext)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.Routing
  summary: "傳回處理要求的物件。"
  syntax:
    content: public virtual System.Web.IHttpHandler GetHttpHandler (System.Web.Routing.RequestContext requestContext);
    parameters:
    - id: requestContext
      type: System.Web.Routing.RequestContext
      description: "封裝要求的相關資訊的物件。"
    return:
      type: System.Web.IHttpHandler
      description: "處理要求的物件。"
  overload: System.Web.Routing.PageRouteHandler.GetHttpHandler*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>requestContext</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Web.Routing.PageRouteHandler.GetSubstitutedVirtualPath(System.Web.Routing.RequestContext)
  id: GetSubstitutedVirtualPath(System.Web.Routing.RequestContext)
  parent: System.Web.Routing.PageRouteHandler
  langs:
  - csharp
  name: GetSubstitutedVirtualPath(RequestContext)
  nameWithType: PageRouteHandler.GetSubstitutedVirtualPath(RequestContext)
  fullName: System.Web.Routing.PageRouteHandler.GetSubstitutedVirtualPath(RequestContext)
  type: Method
  assemblies:
  - System.Web
  namespace: System.Web.Routing
  summary: "替代項目套用至任何取代參數之後，傳回實體檔案路徑的虛擬的路徑。"
  remarks: "如果<xref:System.Web.Routing.PageRouteHandler.VirtualPath%2A>值不包含任何取代參數，則 GetSubstitutedVirtualPath 方法會傳回相同的值<xref:System.Web.Routing.PageRouteHandler.VirtualPath%2A>屬性。</xref:System.Web.Routing.PageRouteHandler.VirtualPath%2A> </xref:System.Web.Routing.PageRouteHandler.VirtualPath%2A>"
  syntax:
    content: public string GetSubstitutedVirtualPath (System.Web.Routing.RequestContext requestContext);
    parameters:
    - id: requestContext
      type: System.Web.Routing.RequestContext
      description: "封裝要求的相關資訊的物件。"
    return:
      type: System.String
      description: "從路由產生的實體檔案的 URL。"
  overload: System.Web.Routing.PageRouteHandler.GetSubstitutedVirtualPath*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>requestContext</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Web.Routing.PageRouteHandler.VirtualPath
  id: VirtualPath
  parent: System.Web.Routing.PageRouteHandler
  langs:
  - csharp
  name: VirtualPath
  nameWithType: PageRouteHandler.VirtualPath
  fullName: System.Web.Routing.PageRouteHandler.VirtualPath
  type: Property
  assemblies:
  - System.Web
  namespace: System.Web.Routing
  summary: "取得與此路由相關聯之網頁的虛擬路徑。"
  remarks: "在中設定 VirtualPath 屬性<xref:System.Web.Routing.PageRouteHandler.%23ctor%2A?displayProperty=fullName>建構函式或在<xref:System.Web.Routing.PageRouteHandler.%23ctor%2A?displayProperty=fullName>建構函式。</xref:System.Web.Routing.PageRouteHandler.%23ctor%2A?displayProperty=fullName> </xref:System.Web.Routing.PageRouteHandler.%23ctor%2A?displayProperty=fullName>"
  syntax:
    content: public string VirtualPath { get; }
    return:
      type: System.String
      description: "網頁上之前的任何取代參數已套用的替代, URL。"
  overload: System.Web.Routing.PageRouteHandler.VirtualPath*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Web.Routing.PageRouteHandler.#ctor(System.String)
  parent: System.Web.Routing.PageRouteHandler
  isExternal: false
  name: PageRouteHandler(String)
  nameWithType: PageRouteHandler.PageRouteHandler(String)
  fullName: System.Web.Routing.PageRouteHandler.PageRouteHandler(String)
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Web.Routing.PageRouteHandler.#ctor(System.String,System.Boolean)
  parent: System.Web.Routing.PageRouteHandler
  isExternal: false
  name: PageRouteHandler(String,Boolean)
  nameWithType: PageRouteHandler.PageRouteHandler(String,Boolean)
  fullName: System.Web.Routing.PageRouteHandler.PageRouteHandler(String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess
  parent: System.Web.Routing.PageRouteHandler
  isExternal: false
  name: CheckPhysicalUrlAccess
  nameWithType: PageRouteHandler.CheckPhysicalUrlAccess
  fullName: System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess
- uid: System.Web.Routing.PageRouteHandler.GetHttpHandler(System.Web.Routing.RequestContext)
  parent: System.Web.Routing.PageRouteHandler
  isExternal: false
  name: GetHttpHandler(RequestContext)
  nameWithType: PageRouteHandler.GetHttpHandler(RequestContext)
  fullName: System.Web.Routing.PageRouteHandler.GetHttpHandler(RequestContext)
- uid: System.Web.IHttpHandler
  parent: System.Web
  isExternal: false
  name: IHttpHandler
  nameWithType: IHttpHandler
  fullName: System.Web.IHttpHandler
- uid: System.Web.Routing.RequestContext
  parent: System.Web.Routing
  isExternal: true
  name: RequestContext
  nameWithType: RequestContext
  fullName: System.Web.Routing.RequestContext
- uid: System.Web.Routing.PageRouteHandler.GetSubstitutedVirtualPath(System.Web.Routing.RequestContext)
  parent: System.Web.Routing.PageRouteHandler
  isExternal: false
  name: GetSubstitutedVirtualPath(RequestContext)
  nameWithType: PageRouteHandler.GetSubstitutedVirtualPath(RequestContext)
  fullName: System.Web.Routing.PageRouteHandler.GetSubstitutedVirtualPath(RequestContext)
- uid: System.Web.Routing.PageRouteHandler.VirtualPath
  parent: System.Web.Routing.PageRouteHandler
  isExternal: false
  name: VirtualPath
  nameWithType: PageRouteHandler.VirtualPath
  fullName: System.Web.Routing.PageRouteHandler.VirtualPath
- uid: System.Web.Routing.PageRouteHandler.#ctor*
  parent: System.Web.Routing.PageRouteHandler
  isExternal: false
  name: PageRouteHandler
  nameWithType: PageRouteHandler.PageRouteHandler
- uid: System.Web.Routing.PageRouteHandler.CheckPhysicalUrlAccess*
  parent: System.Web.Routing.PageRouteHandler
  isExternal: false
  name: CheckPhysicalUrlAccess
  nameWithType: PageRouteHandler.CheckPhysicalUrlAccess
- uid: System.Web.Routing.PageRouteHandler.GetHttpHandler*
  parent: System.Web.Routing.PageRouteHandler
  isExternal: false
  name: GetHttpHandler
  nameWithType: PageRouteHandler.GetHttpHandler
- uid: System.Web.Routing.PageRouteHandler.GetSubstitutedVirtualPath*
  parent: System.Web.Routing.PageRouteHandler
  isExternal: false
  name: GetSubstitutedVirtualPath
  nameWithType: PageRouteHandler.GetSubstitutedVirtualPath
- uid: System.Web.Routing.PageRouteHandler.VirtualPath*
  parent: System.Web.Routing.PageRouteHandler
  isExternal: false
  name: VirtualPath
  nameWithType: PageRouteHandler.VirtualPath
