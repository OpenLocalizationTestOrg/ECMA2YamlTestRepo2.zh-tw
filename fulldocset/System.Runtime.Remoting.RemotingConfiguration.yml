### YamlMime:ManagedReference
items:
- uid: System.Runtime.Remoting.RemotingConfiguration
  id: RemotingConfiguration
  children:
  - System.Runtime.Remoting.RemotingConfiguration.ApplicationId
  - System.Runtime.Remoting.RemotingConfiguration.ApplicationName
  - System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)
  - System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)
  - System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(System.Boolean)
  - System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode
  - System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes
  - System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes
  - System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes
  - System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes
  - System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(System.Type)
  - System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.Type)
  - System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.String,System.String)
  - System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.Type)
  - System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.String,System.String)
  - System.Runtime.Remoting.RemotingConfiguration.ProcessId
  - System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry)
  - System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)
  - System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry)
  - System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)
  - System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry)
  - System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)
  - System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry)
  - System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)
  langs:
  - csharp
  name: RemotingConfiguration
  nameWithType: RemotingConfiguration
  fullName: System.Runtime.Remoting.RemotingConfiguration
  type: Class
  summary: "提供各種設定的遠端執行功能基礎結構的靜態方法。"
  syntax:
    content: >-
      [System.Runtime.InteropServices.ComVisible(true)]

      public static class RemotingConfiguration
  inheritance:
  - System.Object
  implements: []
  inheritedMembers: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.ApplicationId
  id: ApplicationId
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: ApplicationId
  nameWithType: RemotingConfiguration.ApplicationId
  fullName: System.Runtime.Remoting.RemotingConfiguration.ApplicationId
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "取得目前執行的應用程式的識別碼。"
  remarks: "應用程式識別碼是前面加上目前正在執行的應用程式所建立之物件的 URI。"
  syntax:
    content: public static string ApplicationId { get; }
    return:
      type: System.String
      description: "A <xref:System.String>，其中包含目前正在執行的應用程式的識別碼。</xref:System.String>"
  overload: System.Runtime.Remoting.RemotingConfiguration.ApplicationId*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "立即呼叫者沒有基礎結構的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.ApplicationName
  id: ApplicationName
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: ApplicationName
  nameWithType: RemotingConfiguration.ApplicationName
  fullName: System.Runtime.Remoting.RemotingConfiguration.ApplicationName
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "取得或設定遠端處理應用程式的名稱。"
  remarks: "一次，可以設定應用程式名稱，透過目前的屬性，或是透過組態檔。 如果應用程式正在執行內託管環境，例如網際網路資訊服務 (IIS) 中，這個值可能已經設定 （通常是為了的虛擬目錄）。 目前的屬性會傳回`null`如果尚未設定應用程式名稱。"
  example:
  - "The following code example demonstrates the use of the ApplicationName property to indicate the name of the remoting application. For the full example code, see examples for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> and <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A> methods.  \n  \n [!code-cs[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/csharp/p-system.runtime.remotin_94_1.cs)]\n [!code-cpp[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/cpp/p-system.runtime.remotin_94_1.cpp)]\n [!code-vb[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/visualbasic/p-system.runtime.remotin_94_1.vb)]  \n  \n The following code example demonstrates how to access an object remoted from a named application.  \n  \n [!code-cpp[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/cpp/p-system.runtime.remotin_94_2.cpp)]\n [!code-cs[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/csharp/p-system.runtime.remotin_94_2.cs)]\n [!code-vb[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/visualbasic/p-system.runtime.remotin_94_2.vb)]"
  syntax:
    content: public static string ApplicationName { get; set; }
    return:
      type: System.String
      description: "遠端處理應用程式的名稱。"
  overload: System.Runtime.Remoting.RemotingConfiguration.ApplicationName*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。 只有當設定的屬性值，則會擲回這個例外狀況。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)
  id: Configure(System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: Configure(String)
  nameWithType: RemotingConfiguration.Configure(String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.Configure(String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "讀取組態檔，並設定遠端功能基礎結構。 設定已過時。 請使用&lt;xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29&gt;改為。"
  remarks: "> [!NOTE]> 設定已過時。 請使用<xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29>改用。</xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29>       傳遞`null`為`filename`參數會導致預設遠端初始設定，而不需要設定檔案是否存在。       如需組態檔的語法，請參閱[遠端設定結構描述](http://msdn.microsoft.com/en-us/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e)。      > [!NOTE] > 傳址方式封送處理物件 (Mbr) 永遠不會位於記憶體。 相反地，除非類型覆寫<xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=fullName>來控制其本身的存留期原則，每個 MBR 具有有限的存留期.NET Framework 遠端處理系統開始刪除和回收記憶體的程序之前。</xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=fullName> 如需詳細資訊，請參閱[存留期租約](http://msdn.microsoft.com/en-us/c72d561c-1266-4c8b-b258-2c168c08da9a)。"
  example:
  - >-
    [!code-cs[RemotingConfiguration_Configure_Client#1](~/add/codesnippet/csharp/m-system.runtime.remotin_8_1.cs)]
     [!code-vb[RemotingConfiguration_Configure_Client#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_8_1.vb)]
     [!code-cpp[RemotingConfiguration_Configure_Client#1](~/add/codesnippet/cpp/m-system.runtime.remotin_8_1.cpp)]
  syntax:
    content: public static void Configure (string filename);
    parameters:
    - id: filename
      type: System.String
      description: "遠端組態檔的名稱。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  overload: System.Runtime.Remoting.RemotingConfiguration.Configure*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)
  id: Configure(System.String,System.Boolean)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: Configure(String,Boolean)
  nameWithType: RemotingConfiguration.Configure(String,Boolean)
  fullName: System.Runtime.Remoting.RemotingConfiguration.Configure(String,Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "讀取組態檔，並設定遠端功能基礎結構。"
  remarks: "傳遞`null`為`filename`參數會導致預設遠端初始設定，而不需要設定檔案是否存在。 如需遠端處理和安全性詳細資訊，請參閱[遠端處理中的安全性。](http://msdn.microsoft.com/en-us/9574262c-d4b1-41c5-8600-24ff147c0add)       如需組態檔的語法，請參閱[遠端設定結構描述](http://msdn.microsoft.com/en-us/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e)。      > [!NOTE] > 傳址方式封送處理物件 (Mbr) 永遠不會位於記憶體。 相反地，除非類型覆寫<xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=fullName>來控制其本身的存留期原則，每個 MBR 具有有限的存留期.NET Framework 遠端處理系統開始刪除和回收記憶體的程序之前。</xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=fullName> 如需詳細資訊，請參閱[存留期租約](http://msdn.microsoft.com/en-us/c72d561c-1266-4c8b-b258-2c168c08da9a)。"
  syntax:
    content: public static void Configure (string filename, bool ensureSecurity);
    parameters:
    - id: filename
      type: System.String
      description: "遠端組態檔的名稱。 Can be <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
    - id: ensureSecurity
      type: System.Boolean
      description: "如果設定為<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>安全性是必要的。 如果設定為<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>，就不需要安全性，但仍可使用。"
  overload: System.Runtime.Remoting.RemotingConfiguration.Configure*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(System.Boolean)
  id: CustomErrorsEnabled(System.Boolean)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: CustomErrorsEnabled(Boolean)
  nameWithType: RemotingConfiguration.CustomErrorsEnabled(Boolean)
  fullName: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(Boolean)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "指出是否在這個應用程式定義域中的伺服器通道篩選過或完整的例外狀況資訊傳回至本機或遠端呼叫端。"
  remarks: "Complete exception information includes the exact server exception and the server stack trace. Filtered information includes a standard remoting exception but no server stack trace.  \n  \n The `CustomErrorsEnabled` method reflects configuration settings that were specified in the `mode` attribute of the `<customErrors>` element of the application configuration file. For more information about configuration options, see [&#91;\\<topic://cpconconfiguration>&#93;](http://msdn.microsoft.com/en-us/92c0c097-d984-4315-835b-7490ecdf1097).  \n  \n The following table shows the three server channel property values that specify which callers receive exception information and what type of information they receive.  \n  \n|Value|Description|  \n|-----------|-----------------|  \n|`off`|All callers receive complete exception information.|  \n|`on`|All callers receive filtered exception information.|  \n|`remoteOnly`|Local callers receive complete exception information; remote callers receive filtered exception information.|  \n  \n The following table shows the interaction of the `isLocalRequest` parameter and the server channel property.  \n  \n|Value|isLocalRequest|Return value|Description|  \n|-----------|--------------------|------------------|-----------------|  \n|`on`|`true`|`true`|Local callers receive filtered exception information.|  \n|`on`|`false`|`true`|Remote callers receive filtered exception information.|  \n|`off`|`true`|`false`|Local callers receive complete exception information.|  \n|`off`|`false`|`false`|Remote callers receive complete exception information.|  \n|`remoteOnly`|`true`|`false`|Local callers receive complete exception information.|  \n|`remoteOnly`|`false`|`true`|Remote callers receive filtered exception information.|  \n  \n For information about using application configuration files to control the return of exception information to callers, see the `<customErrors>` element."
  syntax:
    content: public static bool CustomErrorsEnabled (bool isLocalRequest);
    parameters:
    - id: isLocalRequest
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>若要指定本機呼叫端;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>來指定遠端呼叫端。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果只篩選例外狀況資訊傳回至本機或遠端呼叫端，所指定<code> isLocalRequest </code>參數;<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>如果完成就會傳回例外狀況資訊。"
  overload: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode
  id: CustomErrorsMode
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: CustomErrorsMode
  nameWithType: RemotingConfiguration.CustomErrorsMode
  fullName: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "取得或設定值，指出如何自訂錯誤處理。"
  syntax:
    content: public static System.Runtime.Remoting.CustomErrorsModes CustomErrorsMode { get; set; }
    return:
      type: System.Runtime.Remoting.CustomErrorsModes
      description: "成員<xref href=&quot;System.Runtime.Remoting.CustomErrorsModes&quot;></xref>列舉，指出如何自訂錯誤處理。"
  overload: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode*
  exceptions: []
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes
  id: GetRegisteredActivatedClientTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: GetRegisteredActivatedClientTypes()
  nameWithType: RemotingConfiguration.GetRegisteredActivatedClientTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "擷取註冊用戶端上做為型別會從遠端啟用的物件類型的陣列。"
  remarks: "用戶端啟用物件的詳細說明，請參閱[[\\<topic://cpconClientActivation >]](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)。"
  syntax:
    content: public static System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes ();
    parameters: []
    return:
      type: System.Runtime.Remoting.ActivatedClientTypeEntry[]
      description: "登錄用戶端上做為型別會從遠端啟用之物件類型的陣列。"
  overload: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes
  id: GetRegisteredActivatedServiceTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: GetRegisteredActivatedServiceTypes()
  nameWithType: RemotingConfiguration.GetRegisteredActivatedServiceTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "擷取可啟動的用戶端要求的服務端上註冊的物件類型的陣列。"
  remarks: "用戶端啟用物件的詳細說明，請參閱[[\\<topic://cpconClientActivation >]](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)。"
  example:
  - >-
    [!code-cs[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/add/codesnippet/csharp/131c20b0-ea6b-424e-a05f-_1.cs)]
     [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/add/codesnippet/visualbasic/131c20b0-ea6b-424e-a05f-_1.vb)]
     [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/add/codesnippet/cpp/131c20b0-ea6b-424e-a05f-_1.cpp)]
  syntax:
    content: public static System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes ();
    parameters: []
    return:
      type: System.Runtime.Remoting.ActivatedServiceTypeEntry[]
      description: "在服務端可以要求從用戶端上啟用的登錄之物件類型的陣列。"
  overload: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes
  id: GetRegisteredWellKnownClientTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: GetRegisteredWellKnownClientTypes()
  nameWithType: RemotingConfiguration.GetRegisteredWellKnownClientTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "擷取做為已知的型別將用戶端上註冊的物件類型的陣列。"
  remarks: "Well-known object types can be either single call or singleton. If an object type is single call, then a new instance of it is created each time a call from the client comes in. All calls to a singleton object are handled by one instance of that object.  \n  \n For a more detailed description of well-known objects, see [&#91;\\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396)."
  example:
  - >-
    [!code-vb[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/add/codesnippet/visualbasic/90e2868e-717f-4977-8f71-_1.vb)]
     [!code-cs[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/add/codesnippet/csharp/90e2868e-717f-4977-8f71-_1.cs)]
     [!code-cpp[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/add/codesnippet/cpp/90e2868e-717f-4977-8f71-_1.cpp)]
  syntax:
    content: public static System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes ();
    parameters: []
    return:
      type: System.Runtime.Remoting.WellKnownClientTypeEntry[]
      description: "做為已知的型別將用戶端上登錄之物件類型的陣列。"
  overload: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes
  id: GetRegisteredWellKnownServiceTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: GetRegisteredWellKnownServiceTypes()
  nameWithType: RemotingConfiguration.GetRegisteredWellKnownServiceTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "擷取註冊服務端上做為已知類型的物件類型的陣列。"
  remarks: "Well-known object types can be either single call or singleton. If an object type is single call, then a new instance of it is created each time a call from the client comes in. All calls to a singleton object are handled by one instance of that object.  \n  \n For a more detailed description of well-known objects, see [&#91;\\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396)."
  example:
  - >-
    [!code-cs[RemotingConfiguration_Configure_Client#2](~/add/codesnippet/csharp/86dd75a5-23bc-425c-9a34-_1.cs)]
     [!code-vb[RemotingConfiguration_Configure_Client#2](~/add/codesnippet/visualbasic/86dd75a5-23bc-425c-9a34-_1.vb)]
     [!code-cpp[RemotingConfiguration_Configure_Client#2](~/add/codesnippet/cpp/86dd75a5-23bc-425c-9a34-_1.cpp)]
  syntax:
    content: public static System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes ();
    parameters: []
    return:
      type: System.Runtime.Remoting.WellKnownServiceTypeEntry[]
      description: "在服務端登錄做為已知的型別之物件類型的陣列。"
  overload: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(System.Type)
  id: IsActivationAllowed(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: IsActivationAllowed(Type)
  nameWithType: RemotingConfiguration.IsActivationAllowed(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "傳回布林值，指出是否指定<xref:System.Type>允許為已啟動用戶端。</xref:System.Type>"
  remarks: "目前的方法在伺服器端用來判斷是否啟用物件的<xref:System.Type>伺服器明確地允許。</xref:System.Type>"
  example:
  - >-
    [!code-cs[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/add/codesnippet/csharp/m-system.runtime.remotin_30_1.cs)]
     [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/add/codesnippet/visualbasic/m-system.runtime.remotin_30_1.vb)]
     [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/add/codesnippet/cpp/m-system.runtime.remotin_30_1.cpp)]
  syntax:
    content: public static bool IsActivationAllowed (Type svrType);
    parameters:
    - id: svrType
      type: System.Type
      description: "物件<xref:System.Type>檢查。</xref:System.Type>"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果指定<xref:System.Type>允許用戶端啟動; 否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。</xref:System.Type>"
  overload: System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.Type)
  id: IsRemotelyActivatedClientType(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: IsRemotelyActivatedClientType(Type)
  nameWithType: RemotingConfiguration.IsRemotelyActivatedClientType(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "檢查是否指定的物件<xref:System.Type>註冊為遠端啟動用戶端類型。</xref:System.Type>"
  remarks: ''
  example:
  - >-
    [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/add/codesnippet/cpp/3c46e8e7-ec3a-4a5f-8592-_1.cpp)]
     [!code-cs[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/add/codesnippet/csharp/3c46e8e7-ec3a-4a5f-8592-_1.cs)]
     [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/add/codesnippet/visualbasic/3c46e8e7-ec3a-4a5f-8592-_1.vb)]
  syntax:
    content: public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (Type svrType);
    parameters:
    - id: svrType
      type: System.Type
      description: "要檢查的物件類型。"
    return:
      type: System.Runtime.Remoting.ActivatedClientTypeEntry
      description: "<xref href=&quot;System.Runtime.Remoting.ActivatedClientTypeEntry&quot;> </xref>對應於指定的物件類型。"
  overload: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.String,System.String)
  id: IsRemotelyActivatedClientType(System.String,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: IsRemotelyActivatedClientType(String,String)
  nameWithType: RemotingConfiguration.IsRemotelyActivatedClientType(String,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "檢查是否為從遠端啟動的用戶端類型登錄其型別名稱和組件名稱所指定的物件。"
  remarks: ''
  example:
  - >-
    [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/add/codesnippet/cpp/12883156-dae9-4c9d-b176-_1.cpp)]
     [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/add/codesnippet/visualbasic/12883156-dae9-4c9d-b176-_1.vb)]
     [!code-cs[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/add/codesnippet/csharp/12883156-dae9-4c9d-b176-_1.cs)]
  syntax:
    content: public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (string typeName, string assemblyName);
    parameters:
    - id: typeName
      type: System.String
      description: "要檢查的物件型別名稱。"
    - id: assemblyName
      type: System.String
      description: "若要檢查物件的組件名稱。"
    return:
      type: System.Runtime.Remoting.ActivatedClientTypeEntry
      description: "<xref href=&quot;System.Runtime.Remoting.ActivatedClientTypeEntry&quot;> </xref>對應於指定的物件類型。"
  overload: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.Type)
  id: IsWellKnownClientType(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: IsWellKnownClientType(Type)
  nameWithType: RemotingConfiguration.IsWellKnownClientType(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "檢查是否指定的物件<xref:System.Type>註冊為已知的用戶端類型。</xref:System.Type>"
  remarks: ''
  example:
  - >-
    [!code-cs[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/add/codesnippet/csharp/e5a3d3ea-9352-4b35-bf3c-_1.cs)]
     [!code-cpp[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/add/codesnippet/cpp/e5a3d3ea-9352-4b35-bf3c-_1.cpp)]
     [!code-vb[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/add/codesnippet/visualbasic/e5a3d3ea-9352-4b35-bf3c-_1.vb)]
  syntax:
    content: public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (Type svrType);
    parameters:
    - id: svrType
      type: System.Type
      description: "物件<xref:System.Type>檢查。</xref:System.Type>"
    return:
      type: System.Runtime.Remoting.WellKnownClientTypeEntry
      description: "<xref href=&quot;System.Runtime.Remoting.WellKnownClientTypeEntry&quot;> </xref>對應於指定的物件類型。"
  overload: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.String,System.String)
  id: IsWellKnownClientType(System.String,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: IsWellKnownClientType(String,String)
  nameWithType: RemotingConfiguration.IsWellKnownClientType(String,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(String,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "檢查是否為已知的用戶端類型登錄其型別名稱和組件名稱所指定的物件。"
  remarks: ''
  example:
  - >-
    [!code-cpp[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/add/codesnippet/cpp/2bdef175-1df9-4504-8b1f-_1.cpp)]
     [!code-cs[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/add/codesnippet/csharp/2bdef175-1df9-4504-8b1f-_1.cs)]
     [!code-vb[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/add/codesnippet/visualbasic/2bdef175-1df9-4504-8b1f-_1.vb)]
  syntax:
    content: public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (string typeName, string assemblyName);
    parameters:
    - id: typeName
      type: System.String
      description: "要檢查的物件型別名稱。"
    - id: assemblyName
      type: System.String
      description: "若要檢查物件的組件名稱。"
    return:
      type: System.Runtime.Remoting.WellKnownClientTypeEntry
      description: "<xref href=&quot;System.Runtime.Remoting.WellKnownClientTypeEntry&quot;> </xref>對應於指定的物件類型。"
  overload: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.ProcessId
  id: ProcessId
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: ProcessId
  nameWithType: RemotingConfiguration.ProcessId
  fullName: System.Runtime.Remoting.RemotingConfiguration.ProcessId
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "取得目前執行的處理序的識別碼。"
  syntax:
    content: public static string ProcessId { get; }
    return:
      type: System.String
      description: "A <xref:System.String>，其中包含目前正在執行的處理序的識別碼。</xref:System.String>"
  overload: System.Runtime.Remoting.RemotingConfiguration.ProcessId*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "立即呼叫者沒有基礎結構的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry)
  id: RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterActivatedClientType(ActivatedClientTypeEntry)
  nameWithType: RemotingConfiguration.RegisterActivatedClientType(ActivatedClientTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(ActivatedClientTypeEntry)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "註冊物件<xref:System.Type>記錄在提供<xref href=&quot;System.Runtime.Remoting.ActivatedClientTypeEntry&quot;></xref>為可以在伺服器啟動的型別將用戶端上。</xref:System.Type>"
  remarks: "To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method. To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new`.  \n  \n To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method gives the remoting infrastructure the location of the remote application where `new` attempts to create it. If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary. To supply the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.  \n  \n For a detailed description of client-activated objects, see [&#91;\\<topic://cpconClientActivation>&#93;](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)."
  syntax:
    content: public static void RegisterActivatedClientType (System.Runtime.Remoting.ActivatedClientTypeEntry entry);
    parameters:
    - id: entry
      type: System.Runtime.Remoting.ActivatedClientTypeEntry
      description: "組態設定的用戶端啟動型別。"
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)
  id: RegisterActivatedClientType(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterActivatedClientType(Type,String)
  nameWithType: RemotingConfiguration.RegisterActivatedClientType(Type,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(Type,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "註冊物件<xref:System.Type>將用戶端上做為可啟動的伺服器類型，使用指定的參數來初始化的新執行個體<xref href=&quot;System.Runtime.Remoting.ActivatedClientTypeEntry&quot;></xref>類別</xref:System.Type>"
  remarks: "To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method. To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new`.  \n  \n To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the RegisterActivatedClientType method. Calling the RegisterActivatedClientType method gives the remoting infrastructure the location of the remote application where `new` attempts to create it. If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary. To supply the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.  \n  \n For a detailed description of client-activated objects, see [&#91;\\<topic://cpconClientActivation>&#93;](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)"
  example:
  - "The following code example demonstrates registration of an object type on the client end as a type that can be activated on the server. For the server code that corresponds to the presented client code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method.  \n  \n [!code-cs[RemotingConfiguration.ClientActivation#1](~/add/codesnippet/csharp/c2dd353b-ad06-48e7-888a-_1.cs)]\n [!code-cpp[RemotingConfiguration.ClientActivation#1](~/add/codesnippet/cpp/c2dd353b-ad06-48e7-888a-_1.cpp)]\n [!code-vb[RemotingConfiguration.ClientActivation#1](~/add/codesnippet/visualbasic/c2dd353b-ad06-48e7-888a-_1.vb)]"
  syntax:
    content: public static void RegisterActivatedClientType (Type type, string appUrl);
    parameters:
    - id: type
      type: System.Type
      description: "物件<xref:System.Type>。</xref:System.Type>"
    - id: appUrl
      type: System.String
      description: "啟用此類型的程式應用程式的 URL。"
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "The <code>typeName</code> or <code>URI</code> parameter is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry)
  id: RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterActivatedServiceType(ActivatedServiceTypeEntry)
  nameWithType: RemotingConfiguration.RegisterActivatedServiceType(ActivatedServiceTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(ActivatedServiceTypeEntry)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "記錄在提供的物件類型的暫存器<xref href=&quot;System.Runtime.Remoting.ActivatedServiceTypeEntry&quot;></xref>在服務端的可啟動的用戶端要求。"
  remarks: "To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A> method. To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new` or <xref:System.Activator.CreateInstance%2A?displayProperty=fullName>.  \n  \n To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method gives the remoting infrastructure the location of the remote application, where `new` attempts to create it. If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary. To supply the <xref:System.Activator.CreateInstance%2A> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.  \n  \n For a detailed description of client-activated objects, see [&#91;\\<topic://cpconClientActivation>&#93;](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)."
  syntax:
    content: public static void RegisterActivatedServiceType (System.Runtime.Remoting.ActivatedServiceTypeEntry entry);
    parameters:
    - id: entry
      type: System.Runtime.Remoting.ActivatedServiceTypeEntry
      description: "組態設定的用戶端啟動型別。"
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)
  id: RegisterActivatedServiceType(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterActivatedServiceType(Type)
  nameWithType: RemotingConfiguration.RegisterActivatedServiceType(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(Type)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "在服務端指定的物件類型註冊為可啟動的用戶端要求的型別。"
  remarks: "To create an instance of a client-activated object on the server, you must know its <xref:System.Type> and it must be registered on the server end by using the RegisterActivatedServiceType method. To obtain a proxy for a new instance of the client-activated object, the client must first register a channel with <xref:System.Runtime.Remoting.Channels.ChannelServices> and then activate the object by calling `new` or <xref:System.Activator.CreateInstance%2A?displayProperty=fullName>.  \n  \n To activate a client-activated object type with the `new` keyword, you must first register the object type on the client end using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method gives the remoting infrastructure the location of the remote application, where `new` attempts to create it. If, on the other hand, you use the <xref:System.Activator.CreateInstance%2A> method to create a new instance of the client-activated object, you must supply the remote application's URL as a parameter, so no prior registration on the client end is necessary. To supply the <xref:System.Activator.CreateInstance%2A> method with the URL of the server where you want to create the object, you must encapsulate the URL in an instance of the <xref:System.Runtime.Remoting.Activation.UrlAttribute> class.  \n  \n For a detailed description of client-activated objects, see [&#91;\\<topic://cpconClientActivation>&#93;](http://msdn.microsoft.com/en-us/4a791494-c18a-4711-a5c1-4ab0e49a8f1a)."
  example:
  - "The following code example demonstrates registration of an object type on the server as a type that can be activated by the client. For the client code that corresponds to the presented server code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> method.  \n  \n [!code-cpp[RemotingConfiguration.ClientActivation#2](~/add/codesnippet/cpp/47d0882a-e55a-42b9-abb6-_1.cpp)]\n [!code-vb[RemotingConfiguration.ClientActivation#2](~/add/codesnippet/visualbasic/47d0882a-e55a-42b9-abb6-_1.vb)]\n [!code-cs[RemotingConfiguration.ClientActivation#2](~/add/codesnippet/csharp/47d0882a-e55a-42b9-abb6-_1.cs)]  \n  \n The following code example shows the service object registered in the sample code above.  \n  \n [!code-cpp[RemotingConfiguration.ClientActivation#3](~/add/codesnippet/cpp/47d0882a-e55a-42b9-abb6-_2.cpp)]\n [!code-vb[RemotingConfiguration.ClientActivation#3](~/add/codesnippet/visualbasic/47d0882a-e55a-42b9-abb6-_2.vb)]\n [!code-cs[RemotingConfiguration.ClientActivation#3](~/add/codesnippet/csharp/47d0882a-e55a-42b9-abb6-_2.cs)]"
  syntax:
    content: public static void RegisterActivatedServiceType (Type type);
    parameters:
    - id: type
      type: System.Type
      description: "<xref:System.Type>要註冊的物件。</xref:System.Type>"
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry)
  id: RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterWellKnownClientType(WellKnownClientTypeEntry)
  nameWithType: RemotingConfiguration.RegisterWellKnownClientType(WellKnownClientTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(WellKnownClientTypeEntry)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "註冊物件<xref:System.Type>記錄在提供<xref href=&quot;System.Runtime.Remoting.WellKnownClientTypeEntry&quot;></xref>為已知的型別，可以啟用在伺服器上的用戶端上。</xref:System.Type>"
  remarks: "Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or <xref:System.Activator.GetObject%2A?displayProperty=fullName>. To activate a well-known object with `new`, you must first register the well-known object type on the client using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it. If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.  \n  \n For a detailed description of well-known objects, see [&#91;\\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396)."
  syntax:
    content: public static void RegisterWellKnownClientType (System.Runtime.Remoting.WellKnownClientTypeEntry entry);
    parameters:
    - id: entry
      type: System.Runtime.Remoting.WellKnownClientTypeEntry
      description: "已知類型的組態設定。"
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)
  id: RegisterWellKnownClientType(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterWellKnownClientType(Type,String)
  nameWithType: RemotingConfiguration.RegisterWellKnownClientType(Type,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(Type,String)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "註冊物件<xref:System.Type>上為已知的型別，可以啟用在伺服器上的用戶端結束時，使用指定的參數來初始化的新執行個體<xref href=&quot;System.Runtime.Remoting.WellKnownClientTypeEntry&quot;></xref>類別</xref:System.Type>"
  remarks: "Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or <xref:System.Activator.GetObject%2A?displayProperty=fullName>. To activate a well-known object with `new`, you must first register the well-known object type on the client using the RegisterWellKnownClientType method. Calling the RegisterWellKnownClientType method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it. If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.  \n  \n For a detailed description of well-known objects, see [&#91;\\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396)."
  example:
  - "The following code example demonstrates registration of an object type on the client end as a well-known type. For the server code that corresponds to the presented client code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A> method.  \n  \n [!code-cpp[RemotingConfiguration.ServerActivation1#5](~/add/codesnippet/cpp/a1a284a9-559a-423c-b0e1-_1.cpp)]\n [!code-cs[RemotingConfiguration.ServerActivation1#5](~/add/codesnippet/csharp/a1a284a9-559a-423c-b0e1-_1.cs)]\n [!code-vb[RemotingConfiguration.ServerActivation1#5](~/add/codesnippet/visualbasic/a1a284a9-559a-423c-b0e1-_1.vb)]  \n[!code-cpp[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/cpp/a1a284a9-559a-423c-b0e1-_2.cpp)]\n[!code-cs[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/csharp/a1a284a9-559a-423c-b0e1-_2.cs)]\n[!code-vb[RemotingConfiguration.ServerActivation1#6](~/add/codesnippet/visualbasic/a1a284a9-559a-423c-b0e1-_2.vb)]  \n[!code-cpp[RemotingConfiguration.ServerActivation1#7](~/add/codesnippet/cpp/a1a284a9-559a-423c-b0e1-_3.cpp)]\n[!code-cs[RemotingConfiguration.ServerActivation1#7](~/add/codesnippet/csharp/a1a284a9-559a-423c-b0e1-_3.cs)]\n[!code-vb[RemotingConfiguration.ServerActivation1#7](~/add/codesnippet/visualbasic/a1a284a9-559a-423c-b0e1-_3.vb)]"
  syntax:
    content: public static void RegisterWellKnownClientType (Type type, string objectUrl);
    parameters:
    - id: type
      type: System.Type
      description: "物件<xref:System.Type>。</xref:System.Type>"
    - id: objectUrl
      type: System.String
      description: "已知的用戶端物件的 URL。"
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry)
  id: RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterWellKnownServiceType(WellKnownServiceTypeEntry)
  nameWithType: RemotingConfiguration.RegisterWellKnownServiceType(WellKnownServiceTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(WellKnownServiceTypeEntry)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "註冊物件<xref:System.Type>記錄在提供<xref href=&quot;System.Runtime.Remoting.WellKnownServiceTypeEntry&quot;></xref>在服務端為已知型別。</xref:System.Type>"
  remarks: "Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method. To activate a well-known object with `new`, you must first register the well-known object type on the client using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it. If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.  \n  \n When the call arrives at the server, the .NET Framework extracts the URI from the message, examines the remoting tables to locate the reference for the object that matches the URI, and then instantiates the object if necessary, forwarding the method call to the object. If the object is registered as <xref:System.Runtime.Remoting.WellKnownObjectMode>, it is destroyed after the method call is completed. A new instance of the object is created for each method called. The only difference between <xref:System.Activator.GetObject%2A?displayProperty=fullName> and `new` is that the former allows you to specify a URL as a parameter, and the latter obtains the URL from the configuration.  \n  \n The remote object itself is not instantiated by the registration process. This only happens when a client attempts to call a method on the object or activates the object from the client side.  \n  \n For a detailed description of well-known objects, see [&#91;\\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396)."
  example:
  - >-
    [!code-cs[CreateObjRef2#2](~/add/codesnippet/csharp/5b43d3ef-403f-408d-a561-_1.cs)]
     [!code-vb[CreateObjRef2#2](~/add/codesnippet/visualbasic/5b43d3ef-403f-408d-a561-_1.vb)]
     [!code-cpp[CreateObjRef2#2](~/add/codesnippet/cpp/5b43d3ef-403f-408d-a561-_1.cpp)]
  syntax:
    content: public static void RegisterWellKnownServiceType (System.Runtime.Remoting.WellKnownServiceTypeEntry entry);
    parameters:
    - id: entry
      type: System.Runtime.Remoting.WellKnownServiceTypeEntry
      description: "已知類型的組態設定。"
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)
  id: RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)
  parent: System.Runtime.Remoting.RemotingConfiguration
  langs:
  - csharp
  name: RegisterWellKnownServiceType(Type,String,WellKnownObjectMode)
  nameWithType: RemotingConfiguration.RegisterWellKnownServiceType(Type,String,WellKnownObjectMode)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(Type,String,WellKnownObjectMode)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Runtime.Remoting
  summary: "註冊物件<xref:System.Type>為已知型別在服務端，使用指定的參數來初始化的新執行個體<xref href=&quot;System.Runtime.Remoting.WellKnownServiceTypeEntry&quot;> </xref>。</xref:System.Type>"
  remarks: "Any client that knows the URI of a registered well-known object can obtain a proxy for the object by registering the channel it prefers with <xref:System.Runtime.Remoting.Channels.ChannelServices>, and activating the object by calling `new` or the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method. To activate a well-known object with `new`, you must first register the well-known object type on the client using the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method. Calling the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method gives the remoting infrastructure the location of the remote object, which allows the `new` keyword to create it. If, on the other hand, you use the <xref:System.Activator.GetObject%2A?displayProperty=fullName> method to activate the well-known object, you must supply it with the object's URL as an argument, so no prior registration on the client end is necessary.  \n  \n When the call arrives at the server, the .NET Framework extracts the URI from the message, examines the remoting tables to locate the reference for the object that matches the URI, and then instantiates the object if necessary, forwarding the method call to the object. If the object is registered as <xref:System.Runtime.Remoting.WellKnownObjectMode>, it is destroyed after the method call is completed. A new instance of the object is created for each method called. The only difference between <xref:System.Activator.GetObject%2A?displayProperty=fullName> and `new` is that the former allows you to specify a URL as a parameter, and the latter obtains the URL from the configuration.  \n  \n The remote object itself is not instantiated by the registration process. This only happens when a client attempts to call a method on the object or activates the object from the client side.  \n  \n For a detailed description of well-known objects, see [&#91;\\<topic://cpconServerActivation>&#93;](http://msdn.microsoft.com/en-us/77ded6e2-4ca8-448b-acf2-562d27fd4396)."
  example:
  - "The following code example demonstrates registration of an object type on the server as a well-known object type. For the client code that corresponds to the presented server code, see the example for the <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> method.  \n  \n [!code-cs[RemotingConfiguration.ServerActivation1#1](~/add/codesnippet/csharp/fe293b93-5873-439c-96b8-_1.cs)]\n [!code-cpp[RemotingConfiguration.ServerActivation1#1](~/add/codesnippet/cpp/fe293b93-5873-439c-96b8-_1.cpp)]\n [!code-vb[RemotingConfiguration.ServerActivation1#1](~/add/codesnippet/visualbasic/fe293b93-5873-439c-96b8-_1.vb)]  \n[!code-cs[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/csharp/fe293b93-5873-439c-96b8-_2.cs)]\n[!code-cpp[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/cpp/fe293b93-5873-439c-96b8-_2.cpp)]\n[!code-vb[RemotingConfiguration.ServerActivation1#2](~/add/codesnippet/visualbasic/fe293b93-5873-439c-96b8-_2.vb)]  \n[!code-cs[RemotingConfiguration.ServerActivation1#3](~/add/codesnippet/csharp/fe293b93-5873-439c-96b8-_3.cs)]\n[!code-cpp[RemotingConfiguration.ServerActivation1#3](~/add/codesnippet/cpp/fe293b93-5873-439c-96b8-_3.cpp)]\n[!code-vb[RemotingConfiguration.ServerActivation1#3](~/add/codesnippet/visualbasic/fe293b93-5873-439c-96b8-_3.vb)]  \n  \n The following code example shows the service object registered in the sample code above.  \n  \n [!code-cpp[RemotingConfiguration.ServerActivation1#4](~/add/codesnippet/cpp/fe293b93-5873-439c-96b8-_4.cpp)]\n [!code-cs[RemotingConfiguration.ServerActivation1#4](~/add/codesnippet/csharp/fe293b93-5873-439c-96b8-_4.cs)]\n [!code-vb[RemotingConfiguration.ServerActivation1#4](~/add/codesnippet/visualbasic/fe293b93-5873-439c-96b8-_4.vb)]"
  syntax:
    content: public static void RegisterWellKnownServiceType (Type type, string objectUri, System.Runtime.Remoting.WellKnownObjectMode mode);
    parameters:
    - id: type
      type: System.Type
      description: "物件<xref:System.Type>。</xref:System.Type>"
    - id: objectUri
      type: System.String
      description: "物件的 URI。"
    - id: mode
      type: System.Runtime.Remoting.WellKnownObjectMode
      description: "正在註冊之已知的物件類型的啟動模式。 (See <xref href=&quot;System.Runtime.Remoting.WellKnownObjectMode&quot;></xref>.)"
  overload: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType*
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "至少一個呼叫堆疊中較高層的呼叫端沒有設定遠端類型和通道的權限。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.Security.SecurityException
  isExternal: true
  name: System.Security.SecurityException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Runtime.Remoting.RemotingConfiguration.ApplicationId
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: ApplicationId
  nameWithType: RemotingConfiguration.ApplicationId
  fullName: System.Runtime.Remoting.RemotingConfiguration.ApplicationId
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Runtime.Remoting.RemotingConfiguration.ApplicationName
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: ApplicationName
  nameWithType: RemotingConfiguration.ApplicationName
  fullName: System.Runtime.Remoting.RemotingConfiguration.ApplicationName
- uid: System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: Configure(String)
  nameWithType: RemotingConfiguration.Configure(String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.Configure(String)
- uid: System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: Configure(String,Boolean)
  nameWithType: RemotingConfiguration.Configure(String,Boolean)
  fullName: System.Runtime.Remoting.RemotingConfiguration.Configure(String,Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(System.Boolean)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: CustomErrorsEnabled(Boolean)
  nameWithType: RemotingConfiguration.CustomErrorsEnabled(Boolean)
  fullName: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(Boolean)
- uid: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: CustomErrorsMode
  nameWithType: RemotingConfiguration.CustomErrorsMode
  fullName: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode
- uid: System.Runtime.Remoting.CustomErrorsModes
  parent: System.Runtime.Remoting
  isExternal: false
  name: CustomErrorsModes
  nameWithType: CustomErrorsModes
  fullName: System.Runtime.Remoting.CustomErrorsModes
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredActivatedClientTypes()
  nameWithType: RemotingConfiguration.GetRegisteredActivatedClientTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes()
- uid: System.Runtime.Remoting.ActivatedClientTypeEntry[]
  parent: System.Runtime.Remoting
  isExternal: false
  name: ActivatedClientTypeEntry
  nameWithType: ActivatedClientTypeEntry
  fullName: System.Runtime.Remoting.ActivatedClientTypeEntry[]
  spec.csharp:
  - uid: System.Runtime.Remoting.ActivatedClientTypeEntry
    name: ActivatedClientTypeEntry
    nameWithType: ActivatedClientTypeEntry
    fullName: ActivatedClientTypeEntry[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredActivatedServiceTypes()
  nameWithType: RemotingConfiguration.GetRegisteredActivatedServiceTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes()
- uid: System.Runtime.Remoting.ActivatedServiceTypeEntry[]
  parent: System.Runtime.Remoting
  isExternal: false
  name: ActivatedServiceTypeEntry
  nameWithType: ActivatedServiceTypeEntry
  fullName: System.Runtime.Remoting.ActivatedServiceTypeEntry[]
  spec.csharp:
  - uid: System.Runtime.Remoting.ActivatedServiceTypeEntry
    name: ActivatedServiceTypeEntry
    nameWithType: ActivatedServiceTypeEntry
    fullName: ActivatedServiceTypeEntry[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredWellKnownClientTypes()
  nameWithType: RemotingConfiguration.GetRegisteredWellKnownClientTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes()
- uid: System.Runtime.Remoting.WellKnownClientTypeEntry[]
  parent: System.Runtime.Remoting
  isExternal: false
  name: WellKnownClientTypeEntry
  nameWithType: WellKnownClientTypeEntry
  fullName: System.Runtime.Remoting.WellKnownClientTypeEntry[]
  spec.csharp:
  - uid: System.Runtime.Remoting.WellKnownClientTypeEntry
    name: WellKnownClientTypeEntry
    nameWithType: WellKnownClientTypeEntry
    fullName: WellKnownClientTypeEntry[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredWellKnownServiceTypes()
  nameWithType: RemotingConfiguration.GetRegisteredWellKnownServiceTypes()
  fullName: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes()
- uid: System.Runtime.Remoting.WellKnownServiceTypeEntry[]
  parent: System.Runtime.Remoting
  isExternal: false
  name: WellKnownServiceTypeEntry
  nameWithType: WellKnownServiceTypeEntry
  fullName: System.Runtime.Remoting.WellKnownServiceTypeEntry[]
  spec.csharp:
  - uid: System.Runtime.Remoting.WellKnownServiceTypeEntry
    name: WellKnownServiceTypeEntry
    nameWithType: WellKnownServiceTypeEntry
    fullName: WellKnownServiceTypeEntry[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsActivationAllowed(Type)
  nameWithType: RemotingConfiguration.IsActivationAllowed(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(Type)
- uid: System.Type
  parent: System
  isExternal: true
  name: Type
  nameWithType: Type
  fullName: System.Type
- uid: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsRemotelyActivatedClientType(Type)
  nameWithType: RemotingConfiguration.IsRemotelyActivatedClientType(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(Type)
- uid: System.Runtime.Remoting.ActivatedClientTypeEntry
  parent: System.Runtime.Remoting
  isExternal: false
  name: ActivatedClientTypeEntry
  nameWithType: ActivatedClientTypeEntry
  fullName: System.Runtime.Remoting.ActivatedClientTypeEntry
- uid: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.String,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsRemotelyActivatedClientType(String,String)
  nameWithType: RemotingConfiguration.IsRemotelyActivatedClientType(String,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(String,String)
- uid: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsWellKnownClientType(Type)
  nameWithType: RemotingConfiguration.IsWellKnownClientType(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(Type)
- uid: System.Runtime.Remoting.WellKnownClientTypeEntry
  parent: System.Runtime.Remoting
  isExternal: false
  name: WellKnownClientTypeEntry
  nameWithType: WellKnownClientTypeEntry
  fullName: System.Runtime.Remoting.WellKnownClientTypeEntry
- uid: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.String,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsWellKnownClientType(String,String)
  nameWithType: RemotingConfiguration.IsWellKnownClientType(String,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(String,String)
- uid: System.Runtime.Remoting.RemotingConfiguration.ProcessId
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: ProcessId
  nameWithType: RemotingConfiguration.ProcessId
  fullName: System.Runtime.Remoting.RemotingConfiguration.ProcessId
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterActivatedClientType(ActivatedClientTypeEntry)
  nameWithType: RemotingConfiguration.RegisterActivatedClientType(ActivatedClientTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(ActivatedClientTypeEntry)
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterActivatedClientType(Type,String)
  nameWithType: RemotingConfiguration.RegisterActivatedClientType(Type,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(Type,String)
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterActivatedServiceType(ActivatedServiceTypeEntry)
  nameWithType: RemotingConfiguration.RegisterActivatedServiceType(ActivatedServiceTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(ActivatedServiceTypeEntry)
- uid: System.Runtime.Remoting.ActivatedServiceTypeEntry
  parent: System.Runtime.Remoting
  isExternal: false
  name: ActivatedServiceTypeEntry
  nameWithType: ActivatedServiceTypeEntry
  fullName: System.Runtime.Remoting.ActivatedServiceTypeEntry
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterActivatedServiceType(Type)
  nameWithType: RemotingConfiguration.RegisterActivatedServiceType(Type)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(Type)
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterWellKnownClientType(WellKnownClientTypeEntry)
  nameWithType: RemotingConfiguration.RegisterWellKnownClientType(WellKnownClientTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(WellKnownClientTypeEntry)
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterWellKnownClientType(Type,String)
  nameWithType: RemotingConfiguration.RegisterWellKnownClientType(Type,String)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(Type,String)
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterWellKnownServiceType(WellKnownServiceTypeEntry)
  nameWithType: RemotingConfiguration.RegisterWellKnownServiceType(WellKnownServiceTypeEntry)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(WellKnownServiceTypeEntry)
- uid: System.Runtime.Remoting.WellKnownServiceTypeEntry
  parent: System.Runtime.Remoting
  isExternal: false
  name: WellKnownServiceTypeEntry
  nameWithType: WellKnownServiceTypeEntry
  fullName: System.Runtime.Remoting.WellKnownServiceTypeEntry
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterWellKnownServiceType(Type,String,WellKnownObjectMode)
  nameWithType: RemotingConfiguration.RegisterWellKnownServiceType(Type,String,WellKnownObjectMode)
  fullName: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(Type,String,WellKnownObjectMode)
- uid: System.Runtime.Remoting.WellKnownObjectMode
  parent: System.Runtime.Remoting
  isExternal: false
  name: WellKnownObjectMode
  nameWithType: WellKnownObjectMode
  fullName: System.Runtime.Remoting.WellKnownObjectMode
- uid: System.Runtime.Remoting.RemotingConfiguration.ApplicationId*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: ApplicationId
  nameWithType: RemotingConfiguration.ApplicationId
- uid: System.Runtime.Remoting.RemotingConfiguration.ApplicationName*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: ApplicationName
  nameWithType: RemotingConfiguration.ApplicationName
- uid: System.Runtime.Remoting.RemotingConfiguration.Configure*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: Configure
  nameWithType: RemotingConfiguration.Configure
- uid: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: CustomErrorsEnabled
  nameWithType: RemotingConfiguration.CustomErrorsEnabled
- uid: System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: CustomErrorsMode
  nameWithType: RemotingConfiguration.CustomErrorsMode
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredActivatedClientTypes
  nameWithType: RemotingConfiguration.GetRegisteredActivatedClientTypes
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredActivatedServiceTypes
  nameWithType: RemotingConfiguration.GetRegisteredActivatedServiceTypes
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredWellKnownClientTypes
  nameWithType: RemotingConfiguration.GetRegisteredWellKnownClientTypes
- uid: System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: GetRegisteredWellKnownServiceTypes
  nameWithType: RemotingConfiguration.GetRegisteredWellKnownServiceTypes
- uid: System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsActivationAllowed
  nameWithType: RemotingConfiguration.IsActivationAllowed
- uid: System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsRemotelyActivatedClientType
  nameWithType: RemotingConfiguration.IsRemotelyActivatedClientType
- uid: System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: IsWellKnownClientType
  nameWithType: RemotingConfiguration.IsWellKnownClientType
- uid: System.Runtime.Remoting.RemotingConfiguration.ProcessId*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: ProcessId
  nameWithType: RemotingConfiguration.ProcessId
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterActivatedClientType
  nameWithType: RemotingConfiguration.RegisterActivatedClientType
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterActivatedServiceType
  nameWithType: RemotingConfiguration.RegisterActivatedServiceType
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterWellKnownClientType
  nameWithType: RemotingConfiguration.RegisterWellKnownClientType
- uid: System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType*
  parent: System.Runtime.Remoting.RemotingConfiguration
  isExternal: false
  name: RegisterWellKnownServiceType
  nameWithType: RemotingConfiguration.RegisterWellKnownServiceType
