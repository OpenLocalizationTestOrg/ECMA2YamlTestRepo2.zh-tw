### YamlMime:ManagedReference
items:
- uid: System.Data.Common.DbDataAdapter
  id: DbDataAdapter
  children:
  - System.Data.Common.DbDataAdapter.#ctor
  - System.Data.Common.DbDataAdapter.#ctor(System.Data.Common.DbDataAdapter)
  - System.Data.Common.DbDataAdapter.AddToBatch(System.Data.IDbCommand)
  - System.Data.Common.DbDataAdapter.ClearBatch
  - System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  - System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  - System.Data.Common.DbDataAdapter.DefaultSourceTableName
  - System.Data.Common.DbDataAdapter.DeleteCommand
  - System.Data.Common.DbDataAdapter.Dispose(System.Boolean)
  - System.Data.Common.DbDataAdapter.ExecuteBatch
  - System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)
  - System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable)
  - System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.String)
  - System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable,System.Data.IDbCommand,System.Data.CommandBehavior)
  - System.Data.Common.DbDataAdapter.Fill(System.Int32,System.Int32,System.Data.DataTable[])
  - System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String)
  - System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)
  - System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)
  - System.Data.Common.DbDataAdapter.FillCommandBehavior
  - System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)
  - System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType)
  - System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String)
  - System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)
  - System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)
  - System.Data.Common.DbDataAdapter.GetBatchedParameter(System.Int32,System.Int32)
  - System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(System.Int32,System.Int32@,System.Exception@)
  - System.Data.Common.DbDataAdapter.GetFillParameters
  - System.Data.Common.DbDataAdapter.InitializeBatching
  - System.Data.Common.DbDataAdapter.InsertCommand
  - System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)
  - System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)
  - System.Data.Common.DbDataAdapter.SelectCommand
  - System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand
  - System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand
  - System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand
  - System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand
  - System.Data.Common.DbDataAdapter.System#ICloneable#Clone
  - System.Data.Common.DbDataAdapter.TerminateBatching
  - System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[])
  - System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)
  - System.Data.Common.DbDataAdapter.Update(System.Data.DataTable)
  - System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)
  - System.Data.Common.DbDataAdapter.Update(System.Data.DataSet,System.String)
  - System.Data.Common.DbDataAdapter.UpdateBatchSize
  - System.Data.Common.DbDataAdapter.UpdateCommand
  langs:
  - csharp
  name: DbDataAdapter
  nameWithType: DbDataAdapter
  fullName: System.Data.Common.DbDataAdapter
  type: Class
  summary: "可協助實作<xref href=&quot;System.Data.IDbDataAdapter&quot;></xref>介面。 DbDataAdapter 繼承者實作一組功能，以提供強型別，但繼承大多數完整實作所需的功能**DataAdapter**。"
  remarks: "DbDataAdapter 類別繼承自<xref:System.Data.Common.DataAdapter>類別，並可協助實作類別**DataAdapter**設計用於關聯式資料庫。</xref:System.Data.Common.DataAdapter>       應用程式不會直接建立 DbDataAdapter 介面的執行個體，但是會建立繼承的類別的執行個體<xref:System.Data.IDbDataAdapter>和 DbDataAdapter。</xref:System.Data.IDbDataAdapter>       類別繼承 DbDataAdapter 必須實作繼承的成員，並且通常會定義要加入提供者特有的功能的其他成員。 例如，DbDataAdapter 類別定義<xref:System.Data.IDbDataAdapter.SelectCommand%2A>屬性和 DbDataAdapter 介面定義的八個多載<xref:System.Data.IDataAdapter.Fill%2A>方法。</xref:System.Data.IDataAdapter.Fill%2A> </xref:System.Data.IDbDataAdapter.SelectCommand%2A> 接著，<xref:System.Data.OleDb.OleDbDataAdapter>類別會繼承<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法，而且也會定義兩個其他多載<xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A>可接受的 ADO 資料錄集物件做為參數。</xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A> </xref:System.Data.Common.DbDataAdapter.Fill%2A> </xref:System.Data.OleDb.OleDbDataAdapter>"
  syntax:
    content: 'public abstract class DbDataAdapter : System.Data.Common.DataAdapter, ICloneable, System.Data.IDbDataAdapter'
  inheritance:
  - System.Object
  - System.MarshalByRefObject
  - System.ComponentModel.Component
  - System.Data.Common.DataAdapter
  implements:
  - System.Data.IDbDataAdapter
  - System.ICloneable
  inheritedMembers:
  - System.ComponentModel.Component.CanRaiseEvents
  - System.ComponentModel.Component.Container
  - System.ComponentModel.Component.DesignMode
  - System.ComponentModel.Component.Dispose
  - System.ComponentModel.Component.Disposed
  - System.ComponentModel.Component.Events
  - System.ComponentModel.Component.GetService(System.Type)
  - System.ComponentModel.Component.Site
  - System.ComponentModel.Component.ToString
  - System.Data.Common.DataAdapter.AcceptChangesDuringFill
  - System.Data.Common.DataAdapter.AcceptChangesDuringUpdate
  - System.Data.Common.DataAdapter.CloneInternals
  - System.Data.Common.DataAdapter.ContinueUpdateOnError
  - System.Data.Common.DataAdapter.CreateTableMappings
  - System.Data.Common.DataAdapter.Fill(System.Data.DataSet,System.String,System.Data.IDataReader,System.Int32,System.Int32)
  - System.Data.Common.DataAdapter.Fill(System.Data.DataTable,System.Data.IDataReader)
  - System.Data.Common.DataAdapter.Fill(System.Data.DataTable[],System.Data.IDataReader,System.Int32,System.Int32)
  - System.Data.Common.DataAdapter.FillError
  - System.Data.Common.DataAdapter.FillLoadOption
  - System.Data.Common.DataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String,System.Data.IDataReader)
  - System.Data.Common.DataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDataReader)
  - System.Data.Common.DataAdapter.HasTableMappings
  - System.Data.Common.DataAdapter.MissingMappingAction
  - System.Data.Common.DataAdapter.MissingSchemaAction
  - System.Data.Common.DataAdapter.OnFillError(System.Data.FillErrorEventArgs)
  - System.Data.Common.DataAdapter.ResetFillLoadOption
  - System.Data.Common.DataAdapter.ReturnProviderSpecificTypes
  - System.Data.Common.DataAdapter.ShouldSerializeAcceptChangesDuringFill
  - System.Data.Common.DataAdapter.ShouldSerializeFillLoadOption
  - System.Data.Common.DataAdapter.ShouldSerializeTableMappings
  - System.Data.Common.DataAdapter.System#Data#IDataAdapter#TableMappings
  - System.Data.Common.DataAdapter.TableMappings
  - System.MarshalByRefObject.CreateObjRef(System.Type)
  - System.MarshalByRefObject.GetLifetimeService
  - System.MarshalByRefObject.InitializeLifetimeService
  - System.MarshalByRefObject.MemberwiseClone(System.Boolean)
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.#ctor
  id: '#ctor'
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: DbDataAdapter()
  nameWithType: DbDataAdapter.DbDataAdapter()
  fullName: System.Data.Common.DbDataAdapter.DbDataAdapter()
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "初始化的新執行個體**DataAdapter**類別。"
  remarks: "當您建立的執行個體<xref:System.Data.Common.DbDataAdapter>，下列的讀取/寫入屬性設定為下列的初始值。</xref:System.Data.Common.DbDataAdapter>      |屬性 |初始值 |  |----------------|-------------------|  |<xref:System.Data.IDbDataAdapter.SelectCommand%2A>|新<xref:System.Data.IDbCommand>。 |  |<xref:System.Data.IDbDataAdapter.InsertCommand%2A>|新<xref:System.Data.IDbCommand>。 |  |<xref:System.Data.IDbDataAdapter.DeleteCommand%2A>|新<xref:System.Data.IDbCommand>。 |  |<xref:System.Data.IDbDataAdapter.UpdateCommand%2A>|新<xref:System.Data.IDbCommand>。 |  |<xref:System.Data.Common.DataAdapter.MissingMappingAction%2A>|`MissingMappingAction.Passthrough`|  |<xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>|`MissingSchemaAction.Add`|      您可以變更任何這些屬性，透過呼叫另一個屬性的值。</xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> </xref:System.Data.Common.DataAdapter.MissingMappingAction%2A> </xref:System.Data.IDbCommand> </xref:System.Data.IDbDataAdapter.UpdateCommand%2A> </xref:System.Data.IDbCommand> </xref:System.Data.IDbDataAdapter.DeleteCommand%2A> </xref:System.Data.IDbCommand> </xref:System.Data.IDbDataAdapter.InsertCommand%2A> </xref:System.Data.IDbCommand> </xref:System.Data.IDbDataAdapter.SelectCommand%2A>"
  syntax:
    content: protected DbDataAdapter ();
    parameters: []
  overload: System.Data.Common.DbDataAdapter.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.#ctor(System.Data.Common.DbDataAdapter)
  id: '#ctor(System.Data.Common.DbDataAdapter)'
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: DbDataAdapter(DbDataAdapter)
  nameWithType: DbDataAdapter.DbDataAdapter(DbDataAdapter)
  fullName: System.Data.Common.DbDataAdapter.DbDataAdapter(DbDataAdapter)
  type: Constructor
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "初始化的新執行個體<xref uid=&quot;langword_csharp_DataAdapter&quot; name=&quot;DataAdapter&quot; href=&quot;&quot;></xref>從現有的物件相同類型的類別。"
  remarks: "這個多載<xref:System.Data.Common.DbDataAdapter>建構函式針對使用.NET Framework 資料提供者 clone 實作中實作類似的建構函式使用時。</xref:System.Data.Common.DbDataAdapter>"
  syntax:
    content: protected DbDataAdapter (System.Data.Common.DbDataAdapter adapter);
    parameters:
    - id: adapter
      type: System.Data.Common.DbDataAdapter
      description: "A <xref uid=&quot;langword_csharp_DataAdapter&quot; name=&quot;DataAdapter&quot; href=&quot;&quot;> </xref>用來建立新物件<xref uid=&quot;langword_csharp_DataAdapter&quot; name=&quot;DataAdapter&quot; href=&quot;&quot;> </xref>。"
  overload: System.Data.Common.DbDataAdapter.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.AddToBatch(System.Data.IDbCommand)
  id: AddToBatch(System.Data.IDbCommand)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: AddToBatch(IDbCommand)
  nameWithType: DbDataAdapter.AddToBatch(IDbCommand)
  fullName: System.Data.Common.DbDataAdapter.AddToBatch(IDbCommand)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "新增<xref href=&quot;System.Data.IDbCommand&quot;></xref>至目前的批次。"
  remarks: "在中<xref:System.Data.Common.DbDataAdapter>，這個方法會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.Common.DbDataAdapter> 類別繼承自<xref:System.Data.Common.DbDataAdapter>覆寫這個方法以提供支援批次。</xref:System.Data.Common.DbDataAdapter>"
  syntax:
    content: protected virtual int AddToBatch (System.Data.IDbCommand command);
    parameters:
    - id: command
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref>將新增至批次。"
    return:
      type: System.Int32
      description: "然後再加入批次中的命令數目<xref href=&quot;System.Data.IDbCommand&quot;> </xref>。"
  overload: System.Data.Common.DbDataAdapter.AddToBatch*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "配接器不支援批次。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.ClearBatch
  id: ClearBatch
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: ClearBatch()
  nameWithType: DbDataAdapter.ClearBatch()
  fullName: System.Data.Common.DbDataAdapter.ClearBatch()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "移除所有<xref href=&quot;System.Data.IDbCommand&quot;></xref>批次中的物件。"
  remarks: "在中<xref:System.Data.Common.DbDataAdapter>，這個方法會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.Common.DbDataAdapter> 類別繼承自<xref:System.Data.Common.DbDataAdapter>覆寫這個方法以提供支援批次。</xref:System.Data.Common.DbDataAdapter>"
  syntax:
    content: protected virtual void ClearBatch ();
    parameters: []
  overload: System.Data.Common.DbDataAdapter.ClearBatch*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "配接器不支援批次。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  id: CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: CreateRowUpdatedEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  nameWithType: DbDataAdapter.CreateRowUpdatedEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  fullName: System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "初始化的新執行個體<xref href=&quot;System.Data.Common.RowUpdatedEventArgs&quot;></xref>類別。"
  syntax:
    content: protected virtual System.Data.Common.RowUpdatedEventArgs CreateRowUpdatedEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);
    parameters:
    - id: dataRow
      type: System.Data.DataRow
      description: "<xref href=&quot;System.Data.DataRow&quot;> </xref>用來更新資料來源。"
    - id: command
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref> <xref:System.Data.IDataAdapter.Update*>.</xref:System.Data.IDataAdapter.Update*>期間執行"
    - id: statementType
      type: System.Data.StatementType
      description: "是否此命令為 UPDATE、 INSERT、 DELETE 或 SELECT 陳述式。"
    - id: tableMapping
      type: System.Data.Common.DataTableMapping
      description: "A <xref href=&quot;System.Data.Common.DataTableMapping&quot;></xref> object."
    return:
      type: System.Data.Common.RowUpdatedEventArgs
      description: "新執行個體<xref href=&quot;System.Data.Common.RowUpdatedEventArgs&quot;></xref>類別。"
  overload: System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  id: CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: CreateRowUpdatingEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  nameWithType: DbDataAdapter.CreateRowUpdatingEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  fullName: System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "初始化的新執行個體<xref href=&quot;System.Data.Common.RowUpdatingEventArgs&quot;></xref>類別。"
  syntax:
    content: protected virtual System.Data.Common.RowUpdatingEventArgs CreateRowUpdatingEvent (System.Data.DataRow dataRow, System.Data.IDbCommand command, System.Data.StatementType statementType, System.Data.Common.DataTableMapping tableMapping);
    parameters:
    - id: dataRow
      type: System.Data.DataRow
      description: "<xref href=&quot;System.Data.DataRow&quot;> </xref> ，來更新資料來源。"
    - id: command
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref> <xref:System.Data.IDataAdapter.Update*>.</xref:System.Data.IDataAdapter.Update*>期間執行"
    - id: statementType
      type: System.Data.StatementType
      description: "是否此命令為 UPDATE、 INSERT、 DELETE 或 SELECT 陳述式。"
    - id: tableMapping
      type: System.Data.Common.DataTableMapping
      description: "A <xref href=&quot;System.Data.Common.DataTableMapping&quot;></xref> object."
    return:
      type: System.Data.Common.RowUpdatingEventArgs
      description: "新執行個體<xref href=&quot;System.Data.Common.RowUpdatingEventArgs&quot;></xref>類別。"
  overload: System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.DefaultSourceTableName
  id: DefaultSourceTableName
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: DefaultSourceTableName
  nameWithType: DbDataAdapter.DefaultSourceTableName
  fullName: System.Data.Common.DbDataAdapter.DefaultSourceTableName
  type: Field
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "所使用的預設名稱<xref href=&quot;System.Data.Common.DataAdapter&quot;></xref>資料表對應的物件。"
  remarks: "「 資料表 」 是所使用的預設名稱<xref:System.Data.Common.DataAdapter>資料表對應的物件。</xref:System.Data.Common.DataAdapter>       應用程式加入資料表對應搭配使用時，DefaultSourceTableName <xref:System.Data.Common.DbDataAdapter.Fill%2A>，但未指定<xref:System.Data.DataTable>名稱。</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  syntax:
    content: public const string DefaultSourceTableName;
    return:
      type: System.String
      description: "即將加入。"
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.DeleteCommand
  id: DeleteCommand
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: DeleteCommand
  nameWithType: DbDataAdapter.DeleteCommand
  fullName: System.Data.Common.DbDataAdapter.DeleteCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "取得或設定從資料集中刪除記錄的命令。"
  remarks: "期間<xref:System.Data.Common.DbDataAdapter.Update%2A>，如果沒有設定這個屬性，並且出現在主索引鍵資訊<xref:System.Data.DataSet>、<xref:System.Data.IDbDataAdapter.DeleteCommand%2A>自動產生。</xref:System.Data.IDbDataAdapter.DeleteCommand%2A> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Update%2A>"
  example:
  - "The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.  \n  \n [!code-cs[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/add/codesnippet/csharp/p-system.data.common.dbd_3_1.cs)]\n [!code-vb[Classic WebData DbDataAdapter.DeleteCommand Example#1](~/add/codesnippet/visualbasic/p-system.data.common.dbd_3_1.vb)]"
  syntax:
    content: public System.Data.Common.DbCommand DeleteCommand { get; set; }
    return:
      type: System.Data.Common.DbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref>期間使用<xref:System.Data.IDataAdapter.Update*>資料集中刪除的資料列的資料來源中刪除記錄。</xref:System.Data.IDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.DeleteCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Dispose(Boolean)
  nameWithType: DbDataAdapter.Dispose(Boolean)
  fullName: System.Data.Common.DbDataAdapter.Dispose(Boolean)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "所使用的 unmanaged 的資源釋出<xref href=&quot;System.Data.Common.DbDataAdapter&quot;></xref>並選擇性釋放 managed 的資源。"
  syntax:
    content: protected override void Dispose (bool disposing);
    parameters:
    - id: disposing
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>表示釋放 managed 和 unmanaged 資源，<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>表示只釋放 unmanaged 的資源。"
  overload: System.Data.Common.DbDataAdapter.Dispose*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.ExecuteBatch
  id: ExecuteBatch
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: ExecuteBatch()
  nameWithType: DbDataAdapter.ExecuteBatch()
  fullName: System.Data.Common.DbDataAdapter.ExecuteBatch()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "執行目前的批次。"
  remarks: "在中<xref:System.Data.Common.DbDataAdapter>，這個方法會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.Common.DbDataAdapter> 類別繼承自<xref:System.Data.Common.DbDataAdapter>覆寫這個方法以提供支援批次。</xref:System.Data.Common.DbDataAdapter>"
  syntax:
    content: protected virtual int ExecuteBatch ();
    parameters: []
    return:
      type: System.Int32
      description: "從批次中的最後一個命令傳回的值。"
  overload: System.Data.Common.DbDataAdapter.ExecuteBatch*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)
  id: Fill(System.Data.DataSet)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(DataSet)
  nameWithType: DbDataAdapter.Fill(DataSet)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "加入或重新整理中的資料列<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "Fill 方法會從使用 SELECT 陳述式的資料來源擷取資料。 <xref:System.Data.IDbConnection>Select 命令相關聯的物件必須有效，但它不需要開啟。</xref:System.Data.IDbConnection> 如果<xref:System.Data.IDbConnection>是關閉呼叫填滿之前，它是開啟擷取資料並關閉。</xref:System.Data.IDbConnection> 如果連接為開啟，會在呼叫填滿之前，它會保持開啟。       如果錯誤或例外狀況時發生填入資料的資料表，在發生錯誤之前所加入的資料列會保留在資料的資料表。 已中止運算的餘數。       如果命令未傳回任何資料列，將資料表加入至<xref:System.Data.DataSet>，並會引發任何例外狀況。</xref:System.Data.DataSet>       如果<xref:System.Data.Common.DbDataAdapter>物件遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續使用模式的資料行的名稱&quot;*columnname*1&quot;，&quot;*columnname*2&quot;，&quot;*columnname*3&quot;，依此類推。</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式&quot;Column1&quot;、&quot;Column2&quot;，等等。</xref:System.Data.DataSet>       當指定的查詢傳回多個結果時，結果集傳回查詢的每個資料列位於個別的資料表。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，&quot;Table&quot;、&quot;Table1&quot;、&quot;Table2&quot;等等） 的整數值。 不會建立資料表查詢不會傳回資料列，如果您在處理 insert 查詢後面的 select 查詢，因為資料表建立選取查詢的名稱為&quot;Table&quot;因為它是建立的第一個資料表。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。       當 SELECT 陳述式用來填入的<xref:System.Data.DataSet>多個結果，例如批次 SQL 陳述式，如果其中一個結果包含錯誤，會傳回所有後續的結果會略過並不會加入至<xref:System.Data.DataSet>。</xref:System.Data.DataSet> </xref:System.Data.DataSet>       當使用後續填滿對更新的內容呼叫<xref:System.Data.DataSet>，必須符合兩個條件︰ 1。</xref:System.Data.DataSet>  SQL 陳述式應該符合最初用來填入<xref:System.Data.DataSet>.</xref:System.Data.DataSet>      2.  **金鑰**必須存在的資料行資訊。       如果存在主索引鍵資訊，任何重複的資料列和一致，而且只能出現一次在<xref:System.Data.DataTable>對應至<xref:System.Data.DataSet>。</xref:System.Data.DataSet> </xref:System.Data.DataTable> 主索引鍵資訊可能會設定透過<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>，藉由指定<xref:System.Data.DataTable.PrimaryKey%2A>屬性<xref:System.Data.DataTable>，或藉由設定<xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>屬性`AddWithKey`。</xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       如果`SelectCommand`傳回結果的 OUTER JOIN，`DataAdapter`未設定<xref:System.Data.DataTable.PrimaryKey%2A>值，產生<xref:System.Data.DataTable>。</xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> 您必須明確定義主索引鍵，以確保正確解析重複的資料列。 如需詳細資訊，請參閱[定義主索引鍵](~/add/includes/ajax-current-ext-md.md)。      > [!NOTE] > 時處理批次 SQL 陳述式會傳回多個結果，實作<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取結構描述資訊，只有第一個結果。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 若要擷取多個結果的結構描述資訊，請使用 以填滿<xref:System.Data.MissingSchemaAction>設`AddWithKey`。</xref:System.Data.MissingSchemaAction>"
  syntax:
    content: public override int Fill (System.Data.DataSet dataSet);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "A <xref href=&quot;System.Data.DataSet&quot;> </xref>填滿記錄，如有必要，結構描述。"
    return:
      type: System.Int32
      description: "資料列數目已成功加入，或在中重新整理<xref href=&quot;System.Data.DataSet&quot;> </xref>。 這不包括不傳回資料列的陳述式所影響的資料列。"
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable)
  id: Fill(System.Data.DataTable)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(DataTable)
  nameWithType: DbDataAdapter.Fill(DataTable)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataTable)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "加入或重新整理指定範圍中的資料列<xref href=&quot;System.Data.DataSet&quot;></xref>以符合資料來源使用<xref href=&quot;System.Data.DataTable&quot;></xref>名稱。"
  remarks: "<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法會從使用 SELECT 陳述式指定由相關聯的資料來源擷取資料列<xref:System.Data.IDbDataAdapter.SelectCommand%2A>屬性。</xref:System.Data.IDbDataAdapter.SelectCommand%2A> </xref:System.Data.Common.DbDataAdapter.Fill%2A> SELECT 陳述式相關聯的連接物件必須有效，但它不需要開啟。 如果連接已關閉之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會開啟擷取資料，然後關閉。</xref:System.Data.Common.DbDataAdapter.Fill%2A> 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。</xref:System.Data.Common.DbDataAdapter.Fill%2A>       <xref:System.Data.Common.DbDataAdapter.Fill%2A>作業接著會將資料列加入到目的地<xref:System.Data.DataTable>中的物件<xref:System.Data.DataSet>、 建立<xref:System.Data.DataTable>如果它們尚不存在的物件。</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Fill%2A> 建立時<xref:System.Data.DataTable>物件<xref:System.Data.Common.DbDataAdapter.Fill%2A>作業通常會建立只有資料行名稱中繼資料。</xref:System.Data.Common.DbDataAdapter.Fill%2A> </xref:System.Data.DataTable> 不過，如果<xref:System.Data.IDataAdapter.MissingSchemaAction%2A>屬性設定為`AddWithKey`，也會建立適當的主索引鍵和條件約束。</xref:System.Data.IDataAdapter.MissingSchemaAction%2A>       如果<xref:System.Data.Common.DbDataAdapter>遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱&quot;*columnname*1&quot;，&quot;*columnname*2&quot;，&quot;*columnname*3 」，依此類推。</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式&quot;Column1&quot;、&quot;Column2&quot;，等等。</xref:System.Data.DataSet> 當多個結果集加入至<xref:System.Data.DataSet>放置於個別的資料表中每個結果集。</xref:System.Data.DataSet>       多載<xref:System.Data.Common.DbDataAdapter.Fill%2A>採用`DataTable`如參數只會取得第一個結果。</xref:System.Data.Common.DbDataAdapter.Fill%2A> 使用的多載<xref:System.Data.Common.DbDataAdapter.Fill%2A>採用`DataSet`做為參數來取得多個結果。</xref:System.Data.Common.DbDataAdapter.Fill%2A>       <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> 在這種情況下，<xref:System.Data.Common.DbDataAdapter.Fill%2A>執行區分大小寫的比較，來尋找對應的資料表，並建立新的資料表，如果沒有完全相符項目存在。</xref:System.Data.Common.DbDataAdapter.Fill%2A> 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();    dataset.Tables.Add(&quot;aaa&quot;);    dataset.Tables.Add(&quot;AAA&quot;);    adapter.Fill(dataset, &quot;aaa&quot;); // Fills &quot;aaa&quot;, which already exists in the DataSet.       adapter.Fill(dataset, &quot;Aaa&quot;); // Adds a new table called &quot;Aaa&quot;.   ```如果<xref:System.Data.Common.DbDataAdapter.Fill%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();    dataset.Tables.Add(&quot;aaa&quot;);       adapter.Fill(dataset, &quot;AAA&quot;); // Fills table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```您可以使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>多次於相同<xref:System.Data.DataTable>。</xref:System.Data.DataTable>方法</xref:System.Data.Common.DbDataAdapter.Fill%2A> 如果主索引鍵存在，內送資料列會合併具有相符的資料列已經存在。 如果沒有主索引鍵存在，內送資料列會附加至<xref:System.Data.DataTable>。</xref:System.Data.DataTable>       如果`SelectCommand`傳回結果的 OUTER JOIN，`DataAdapter`未設定<xref:System.Data.DataTable.PrimaryKey%2A>值，產生<xref:System.Data.DataTable>。</xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> 您必須明確定義主索引鍵，以確保正確解析重複的資料列。 如需詳細資訊，請參閱[定義主索引鍵](~/add/includes/ajax-current-ext-md.md)。      > [!NOTE] > 時處理批次 SQL 陳述式會傳回多個結果，實作<xref:System.Data.Common.DbDataAdapter.Fill%2A>和<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>對於.NET Framework 資料提供者擷取結構描述資訊，只有第一個結果。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  syntax:
    content: public int Fill (System.Data.DataTable dataTable);
    parameters:
    - id: dataTable
      type: System.Data.DataTable
      description: "名稱<xref href=&quot;System.Data.DataTable&quot;></xref>用於資料表對應。"
    return:
      type: System.Int32
      description: "資料列數目已成功加入，或在中重新整理<xref href=&quot;System.Data.DataSet&quot;> </xref>。 這不包括不傳回資料列的陳述式所影響的資料列。"
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無效的來源資料表。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.String)
  id: Fill(System.Data.DataSet,System.String)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(DataSet,String)
  nameWithType: DbDataAdapter.Fill(DataSet,String)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet,String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "加入或重新整理中的資料列<xref href=&quot;System.Data.DataSet&quot;></xref>以符合資料來源使用<xref href=&quot;System.Data.DataSet&quot;></xref>和<xref href=&quot;System.Data.DataTable&quot;></xref>名稱。"
  remarks: "<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法會從使用 SELECT 陳述式的資料來源擷取資料。</xref:System.Data.Common.DbDataAdapter.Fill%2A> <xref:System.Data.IDbConnection>Select 命令相關聯的物件必須有效，但它不需要開啟。</xref:System.Data.IDbConnection> 如果<xref:System.Data.IDbConnection>前已關閉<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會開啟擷取資料，然後關閉。</xref:System.Data.Common.DbDataAdapter.Fill%2A> </xref:System.Data.IDbConnection> 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。</xref:System.Data.Common.DbDataAdapter.Fill%2A>       如果命令未傳回任何資料列，將資料表加入至<xref:System.Data.DataSet>，並會引發任何例外狀況。</xref:System.Data.DataSet>       如果<xref:System.Data.Common.DbDataAdapter>物件遇到重複的資料行在填入<xref:System.Data.DataTable>，它將會產生名稱為後續的資料行，並使用模式 」 columnname1&quot;、&quot;columnname2&quot;、&quot;columnname3&quot;，等等。</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式&quot;Column1&quot;、&quot;Column2&quot;，等等。</xref:System.Data.DataSet>       當指定的查詢傳回多個結果時，每個結果集被放在個別的資料表。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，&quot;Table&quot;、&quot;Table1&quot;、&quot;Table2&quot;等等） 的整數值。 不會建立資料表查詢不會傳回資料列，如果您要處理插入查詢後面的 select 查詢，因為建立選取查詢的資料表就會命名為&quot;Table&quot;，因為它是建立的第一個資料表。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。       <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> 在這種情況下，<xref:System.Data.Common.DbDataAdapter.Fill%2A>執行區分大小寫的比較，來尋找對應的資料表，並建立新的資料表，如果沒有完全相符項目存在。</xref:System.Data.Common.DbDataAdapter.Fill%2A> 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   dataset.Tables.Add(&quot;AAA&quot;);   adapter.Fill(dataset, &quot;aaa&quot;); // Fills &quot;aaa&quot;, which already exists in the DataSet.   adapter.Fill(dataset, &quot;Aaa&quot;); // Adds a new table called &quot;Aaa&quot;.   ```如果<xref:System.Data.Common.DbDataAdapter.Fill%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   adapter.Fill(dataset, &quot;AAA&quot;); // Fills table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```如果錯誤或例外狀況時發生填入資料的資料表，在發生錯誤之前所加入的資料列會保留在資料的資料表。 已中止運算的餘數。       當 SELECT 陳述式用來填入<xref:System.Data.DataSet>會傳回多個結果，例如批次 SQL 陳述式，可注意下列事項:-如果其中一個結果包含錯誤時，所有後續的結果會略過，且未新增到<xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataSet>       當使用後續<xref:System.Data.Common.DbDataAdapter.Fill%2A>對更新的內容呼叫<xref:System.Data.DataSet>，必須符合兩個條件︰ 1。</xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A>  SQL 陳述式應該符合最初用來填入<xref:System.Data.DataSet>.</xref:System.Data.DataSet>      2.  **金鑰**必須存在的資料行資訊。 如果存在主索引鍵資訊，任何重複的資料列和一致，而且只能出現一次在<xref:System.Data.DataTable>對應至<xref:System.Data.DataSet>。</xref:System.Data.DataSet> </xref:System.Data.DataTable> 主索引鍵資訊可能會設定透過<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>，藉由指定<xref:System.Data.DataTable.PrimaryKey%2A>屬性<xref:System.Data.DataTable>，或藉由設定<xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>屬性`AddWithKey`。</xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       如果`SelectCommand`傳回結果的 OUTER JOIN，`DataAdapter`未設定<xref:System.Data.DataTable.PrimaryKey%2A>值，產生<xref:System.Data.DataTable>。</xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> 您必須明確定義主索引鍵，以確保正確解析重複的資料列。 如需詳細資訊，請參閱[定義主索引鍵](~/add/includes/ajax-current-ext-md.md)。      > [!NOTE] > 時處理批次 SQL 陳述式會傳回多個結果，實作<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取結構描述資訊，只有第一個結果。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  example:
  - "The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to fill a <xref:System.Data.DataSet> with rows from the categories table. This example assumes that you have created an <xref:System.Data.OleDb.OleDbDataAdapter> and a <xref:System.Data.DataSet>.  \n  \n [!code-vb[Classic WebData DbDataAdapter.Fill2 Example#1](~/add/codesnippet/visualbasic/m-system.data.common.dbd_3_1.vb)]\n [!code-cs[Classic WebData DbDataAdapter.Fill2 Example#1](~/add/codesnippet/csharp/m-system.data.common.dbd_3_1.cs)]"
  syntax:
    content: public int Fill (System.Data.DataSet dataSet, string srcTable);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "A <xref href=&quot;System.Data.DataSet&quot;> </xref>填滿記錄，如有必要，結構描述。"
    - id: srcTable
      type: System.String
      description: "要用於資料表對應的來源資料表的名稱。"
    return:
      type: System.Int32
      description: "資料列數目已成功加入，或在中重新整理<xref href=&quot;System.Data.DataSet&quot;> </xref>。 這不包括不傳回資料列的陳述式所影響的資料列。"
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "無效的來源資料表。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable,System.Data.IDbCommand,System.Data.CommandBehavior)
  id: Fill(System.Data.DataTable,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(DataTable,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.Fill(DataTable,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataTable,IDbCommand,CommandBehavior)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "加入或重新整理中的資料列<xref href=&quot;System.Data.DataTable&quot;></xref>以符合使用指定的資料來源<xref href=&quot;System.Data.DataTable&quot;> </xref>， <xref href=&quot;System.Data.IDbCommand&quot;> </xref>和<xref href=&quot;System.Data.CommandBehavior&quot;> </xref>。"
  remarks: "<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法會從使用 SELECT 陳述式指定由相關聯的資料來源擷取資料列<xref:System.Data.IDbDataAdapter.SelectCommand%2A>屬性。</xref:System.Data.IDbDataAdapter.SelectCommand%2A> </xref:System.Data.Common.DbDataAdapter.Fill%2A> SELECT 陳述式相關聯的連接物件必須有效，但它不需要開啟。 如果連接已關閉之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會開啟擷取資料並關閉。</xref:System.Data.Common.DbDataAdapter.Fill%2A> 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。</xref:System.Data.Common.DbDataAdapter.Fill%2A>       <xref:System.Data.Common.DbDataAdapter.Fill%2A>作業接著會將資料列加入到指定的目的地<xref:System.Data.DataTable>物件存放至<xref:System.Data.DataSet>、 建立<xref:System.Data.DataTable>如果它不存在的物件。</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Fill%2A> 建立時<xref:System.Data.DataTable>物件<xref:System.Data.Common.DbDataAdapter.Fill%2A>作業通常會建立只有資料行名稱中繼資料。</xref:System.Data.Common.DbDataAdapter.Fill%2A> </xref:System.Data.DataTable> 不過，如果<xref:System.Data.IDataAdapter.MissingSchemaAction%2A>屬性設定為`AddWithKey`，也會建立適當的主索引鍵和條件約束。</xref:System.Data.IDataAdapter.MissingSchemaAction%2A>       如果<xref:System.Data.Common.DbDataAdapter>物件遇到重複的資料行在填入<xref:System.Data.DataTable>，它將會產生後續的資料行，並使用模式的名稱&quot;*columnname*1&quot;，&quot;*columnname*2&quot;，&quot;*columnname*3&quot;，依此類推。</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式&quot;Column1&quot;、&quot;Column2&quot;，等等。</xref:System.Data.DataSet>       多載<xref:System.Data.Common.DbDataAdapter.Fill%2A>採用`DataTable`如參數只會取得第一個結果。</xref:System.Data.Common.DbDataAdapter.Fill%2A> 使用的多載<xref:System.Data.Common.DbDataAdapter.Fill%2A>採用`DataSet`做為參數來取得多個結果。</xref:System.Data.Common.DbDataAdapter.Fill%2A>       您可以使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>多次於相同<xref:System.Data.DataTable>。</xref:System.Data.DataTable>方法</xref:System.Data.Common.DbDataAdapter.Fill%2A> 如果主索引鍵存在，內送資料列會合併具有相符的資料列已經存在。 如果沒有主索引鍵存在，內送資料列會附加至<xref:System.Data.DataTable>。</xref:System.Data.DataTable>       如果`SelectCommand`傳回結果的 OUTER JOIN，`DataAdapter`未設定<xref:System.Data.DataTable.PrimaryKey%2A>值，產生<xref:System.Data.DataTable>。</xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> 您必須明確定義主索引鍵，以確保正確解析重複的資料列。 如需詳細資訊，請參閱[定義主索引鍵](~/add/includes/ajax-current-ext-md.md)。      > [!NOTE] > 時處理批次 SQL 陳述式會傳回多個結果，實作<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取結構描述資訊，只有第一個結果。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  syntax:
    content: protected virtual int Fill (System.Data.DataTable dataTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);
    parameters:
    - id: dataTable
      type: System.Data.DataTable
      description: "A <xref href=&quot;System.Data.DataTable&quot;> </xref>填滿記錄，如有必要，結構描述。"
    - id: command
      type: System.Data.IDbCommand
      description: "SQL SELECT 陳述式用於從資料來源擷取資料列。"
    - id: behavior
      type: System.Data.CommandBehavior
      description: "其中一個<xref href=&quot;System.Data.CommandBehavior&quot;></xref>值。"
    return:
      type: System.Int32
      description: "資料列數目已成功加入，或在中重新整理<xref href=&quot;System.Data.DataTable&quot;> </xref>。 這不包括不傳回資料列的陳述式所影響的資料列。"
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Int32,System.Int32,System.Data.DataTable[])
  id: Fill(System.Int32,System.Int32,System.Data.DataTable[])
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(Int32,Int32,DataTable[])
  nameWithType: DbDataAdapter.Fill(Int32,Int32,DataTable[])
  fullName: System.Data.Common.DbDataAdapter.Fill(Int32,Int32,DataTable[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "加入或重新整理中的資料列<xref href=&quot;System.Data.DataTable&quot;></xref>以符合資料來源，起點在指定的記錄，擷取至指定的最大記錄數目。"
  remarks: "<xref:System.Data.Common.DataAdapter.Fill%2A>方法會從使用 SELECT 陳述式指定由相關聯的資料來源擷取資料列<xref:System.Data.IDbDataAdapter.SelectCommand%2A>屬性。</xref:System.Data.IDbDataAdapter.SelectCommand%2A> </xref:System.Data.Common.DataAdapter.Fill%2A> SELECT 陳述式相關聯的連接物件必須有效，但它不需要開啟。 如果連接已關閉之前<xref:System.Data.Common.DataAdapter.Fill%2A>是呼叫，來擷取資料，開啟和關閉然後。</xref:System.Data.Common.DataAdapter.Fill%2A> 如果連接為開啟之前<xref:System.Data.Common.DataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。</xref:System.Data.Common.DataAdapter.Fill%2A>       <xref:System.Data.Common.DataAdapter.Fill%2A>作業接著會將資料列加入到目的地<xref:System.Data.DataTable>中的物件<xref:System.Data.DataSet>、 建立<xref:System.Data.DataTable>如果它們尚不存在的物件。</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DataAdapter.Fill%2A> 建立時<xref:System.Data.DataTable>物件<xref:System.Data.Common.DataAdapter.Fill%2A>作業通常會建立只有資料行名稱中繼資料。</xref:System.Data.Common.DataAdapter.Fill%2A> </xref:System.Data.DataTable> 不過，如果<xref:System.Data.IDataAdapter.MissingSchemaAction%2A>屬性設定為`AddWithKey`，也會建立適當的主索引鍵和條件約束。</xref:System.Data.IDataAdapter.MissingSchemaAction%2A>       如果`SelectCommand`傳回結果的 OUTER JOIN，`DataAdapter`未設定<xref:System.Data.DataTable.PrimaryKey%2A>值，產生<xref:System.Data.DataTable>。</xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> 您必須明確定義主索引鍵，以確保正確解析重複的資料列。 如需詳細資訊，請參閱[定義主索引鍵](~/add/includes/ajax-current-ext-md.md)。       如果資料配接器遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生名稱，後續的資料行，並使用模式 」 columnname1&quot;、&quot;columnname2&quot;、&quot;columnname3&quot;，等等。</xref:System.Data.DataTable> 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式&quot;Column1&quot;、&quot;Column2&quot;，等等。</xref:System.Data.DataSet> 當多個結果集加入至<xref:System.Data.DataSet>，放置於個別的資料表中每個結果集。</xref:System.Data.DataSet> 其他結果集的命名方式是附加至指定的資料表名稱 （例如，&quot;Table&quot;、&quot;Table1&quot;、&quot;Table2&quot;等等） 的整數值。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。       當 SELECT 陳述式用來填入<xref:System.Data.DataSet>傳回多個結果，例如批次 SQL 陳述式中，如果其中一個結果包含錯誤，所有後續的結果會略過，不會加入至<xref:System.Data.DataSet>。</xref:System.Data.DataSet> </xref:System.Data.DataSet>       您可以使用<xref:System.Data.Common.DataAdapter.Fill%2A>多次於相同<xref:System.Data.DataTable>。</xref:System.Data.DataTable>方法</xref:System.Data.Common.DataAdapter.Fill%2A> 如果主索引鍵存在，內送資料列會合併具有相符的資料列已經存在。 如果沒有主索引鍵存在，內送資料列會附加至<xref:System.Data.DataTable>。</xref:System.Data.DataTable>      > [!NOTE] > 時處理批次 SQL 陳述式會傳回多個結果，實作<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取結構描述資訊，只有第一個結果。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  syntax:
    content: public int Fill (int startRecord, int maxRecords, System.Data.DataTable[] dataTables);
    parameters:
    - id: startRecord
      type: System.Int32
      description: "若要開始使用以零為起始的記錄號碼。"
    - id: maxRecords
      type: System.Int32
      description: "要擷取的記錄數目上限。"
    - id: dataTables
      type: System.Data.DataTable[]
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref>填入來自資料來源的物件。"
    return:
      type: System.Int32
      description: "資料列數目已成功加入，或在中重新整理<xref href=&quot;System.Data.DataTable&quot;> </xref>。 此值不包含不傳回資料列的陳述式所影響的資料列。"
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String)
  id: Fill(System.Data.DataSet,System.Int32,System.Int32,System.String)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(DataSet,Int32,Int32,String)
  nameWithType: DbDataAdapter.Fill(DataSet,Int32,Int32,String)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet,Int32,Int32,String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "加入或重新整理指定範圍中的資料列<xref href=&quot;System.Data.DataSet&quot;></xref>以符合資料來源使用<xref href=&quot;System.Data.DataSet&quot;></xref>和<xref href=&quot;System.Data.DataTable&quot;></xref>名稱。"
  remarks: "A `maxRecords` 0 的值取得開始記錄後，仍找到的所有記錄。 如果`maxRecords`大於剩餘的資料列數目只會傳回其餘的資料列，並不會發出錯誤。       如果對應的 select 命令的陳述式傳回多個結果，<xref:System.Data.Common.DbDataAdapter.Fill%2A>只適用於`maxRecords`至第一個結果。</xref:System.Data.Common.DbDataAdapter.Fill%2A>       <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法會從使用 SELECT 陳述式的資料來源擷取資料。</xref:System.Data.Common.DbDataAdapter.Fill%2A> <xref:System.Data.IDbConnection>SELECT 陳述式相關聯的物件必須有效，但它不需要開啟。</xref:System.Data.IDbConnection> 如果<xref:System.Data.IDbConnection>前已關閉<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會開啟擷取資料並關閉。</xref:System.Data.Common.DbDataAdapter.Fill%2A> </xref:System.Data.IDbConnection> 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。</xref:System.Data.Common.DbDataAdapter.Fill%2A>       如果命令未傳回任何資料列，將資料表加入至<xref:System.Data.DataSet>，但會引發任何例外狀況。</xref:System.Data.DataSet>       如果<xref:System.Data.Common.DbDataAdapter>物件遇到重複的資料行在填入<xref:System.Data.DataTable>，它將會產生後續的資料行，並使用模式的名稱&quot;*columnname*1&quot;，&quot;*columnname*2&quot;，&quot;*columnname*3&quot;，依此類推。</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式&quot;Column1&quot;、&quot;Column2&quot;，等等。</xref:System.Data.DataSet>       當指定的查詢傳回多個結果時，每個結果集被放在個別的資料表。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，&quot;Table&quot;、&quot;Table1&quot;、&quot;Table2&quot;等等） 的整數值。 因為不會建立資料表查詢不會傳回資料列，如果您在處理 insert 查詢後面的 select 查詢，針對 select 查詢所建立的資料表是名為&quot;Table&quot;，因為它是建立的第一個資料表。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。       <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> 在這種情況下，<xref:System.Data.Common.DbDataAdapter.Fill%2A>執行區分大小寫的比較，來尋找對應的資料表，並建立新的資料表，如果沒有完全相符項目存在。</xref:System.Data.Common.DbDataAdapter.Fill%2A> 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   dataset.Tables.Add(&quot;AAA&quot;);   adapter.Fill(dataset, &quot;aaa&quot;); // Fills &quot;aaa&quot;, which already exists in the DataSet.   adapter.Fill(dataset, &quot;Aaa&quot;); // Adds a new table called &quot;Aaa&quot;.   ```如果<xref:System.Data.Common.DbDataAdapter.Fill%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   adapter.Fill(dataset, &quot;AAA&quot;); // Fills table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```如果錯誤或例外狀況時發生填入資料的資料表，在發生錯誤之前所加入的資料列會保留在資料的資料表。 已中止運算的餘數。       當 SELECT 陳述式用來填入<xref:System.Data.DataSet>傳回多個結果，例如批次 SQL 陳述式，可注意下列事項:-時處理批次 SQL 陳述式，從多個結果`maxRecords`只適用於第一個結果。</xref:System.Data.DataSet> 也適用於包含章節化的結果 (.NET Framework Data Provider for OLE DB 只) 的資料列。 最上層結果會受到`maxRecords`，但是所有的子資料列會加入。      -如果其中一個結果包含錯誤時，所有後續的結果會略過，且未新增到<xref:System.Data.DataSet>.</xref:System.Data.DataSet>       當使用後續<xref:System.Data.Common.DbDataAdapter.Fill%2A>對更新的內容呼叫<xref:System.Data.DataSet>，必須符合兩個條件︰ 1。</xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A>  SQL 陳述式應該符合最初用來填入<xref:System.Data.DataSet>.</xref:System.Data.DataSet>      2.  **金鑰**必須存在的資料行資訊。       如果存在主索引鍵資訊，任何重複的資料列會調解並只在<xref:System.Data.DataTable>對應至<xref:System.Data.DataSet>。</xref:System.Data.DataSet></xref:System.Data.DataTable>出現一次 主索引鍵資訊可能會設定透過<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>，藉由指定<xref:System.Data.DataTable.PrimaryKey%2A>屬性<xref:System.Data.DataTable>，或藉由設定<xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A>屬性`AddWithKey`。</xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> </xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       如果`SelectCommand`傳回結果的 OUTER JOIN，`DataAdapter`未設定<xref:System.Data.DataTable.PrimaryKey%2A>值，產生<xref:System.Data.DataTable>。</xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> 您必須明確定義主索引鍵，以確保正確解析重複的資料列。 如需詳細資訊，請參閱[定義主索引鍵](~/add/includes/ajax-current-ext-md.md)。      > [!NOTE] > 時處理批次 SQL 陳述式會傳回多個結果，實作<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取結構描述資訊，只有第一個結果。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>      > [!NOTE] >`DataSet`不會包含在所指定的記錄數目超過`maxRecords`。 不過，從伺服器仍會傳回查詢所產生的整個結果集。"
  example:
  - "The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to fill a <xref:System.Data.DataSet> with 15 rows, beginning at row 10, from the **Categories** table. This example assumes that you have created an <xref:System.Data.OleDb.OleDbDataAdapter> and a <xref:System.Data.DataSet>.  \n  \n [!code-vb[Classic WebData DbDataAdapter.Fill3 Example#1](~/add/codesnippet/visualbasic/db016a7d-8591-46f9-abcc-_1.vb)]\n [!code-cs[Classic WebData DbDataAdapter.Fill3 Example#1](~/add/codesnippet/csharp/db016a7d-8591-46f9-abcc-_1.cs)]"
  syntax:
    content: public int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "A <xref href=&quot;System.Data.DataSet&quot;> </xref>填滿記錄，如有必要，結構描述。"
    - id: startRecord
      type: System.Int32
      description: "若要開始使用以零為起始的記錄號碼。"
    - id: maxRecords
      type: System.Int32
      description: "要擷取的記錄數目上限。"
    - id: srcTable
      type: System.String
      description: "要用於資料表對應的來源資料表的名稱。"
    return:
      type: System.Int32
      description: "資料列數目已成功加入，或在中重新整理<xref href=&quot;System.Data.DataSet&quot;> </xref>。 這不包括不傳回資料列的陳述式所影響的資料列。"
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "<xref href=&quot;System.Data.DataSet&quot;> </xref>無效。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無效的來源資料表。       -或者-連接無效。"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "找不到連接。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> startRecord </code>參數小於 0。       -或- <code> maxRecords </code>參數小於 0。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)
  id: Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(DataTable[],Int32,Int32,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.Fill(DataTable[],Int32,Int32,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataTable[],Int32,Int32,IDbCommand,CommandBehavior)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "加入或重新整理指定範圍中的資料列<xref href=&quot;System.Data.DataSet&quot;></xref>以符合資料來源使用<xref href=&quot;System.Data.DataSet&quot;></xref>和<xref href=&quot;System.Data.DataTable&quot;></xref>名稱。"
  remarks: "A `maxRecords` 0 的值取得開始記錄後，仍找到的所有記錄。 如果`maxRecords`大於剩餘的資料列數目只會傳回其餘的資料列，不會發出錯誤。       Fill 方法會從使用 SELECT 陳述式的資料來源擷取資料。 <xref:System.Data.IDbConnection>SELECT 陳述式相關聯的物件必須有效，但它不需要開啟。</xref:System.Data.IDbConnection> 如果<xref:System.Data.IDbConnection>前已關閉<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會開啟擷取資料，然後關閉。</xref:System.Data.Common.DbDataAdapter.Fill%2A> </xref:System.Data.IDbConnection> 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。</xref:System.Data.Common.DbDataAdapter.Fill%2A>       如果命令未傳回任何資料列，將資料表加入至<xref:System.Data.DataSet>，但會引發任何例外狀況。</xref:System.Data.DataSet>       如果<xref:System.Data.Common.DbDataAdapter>物件遇到重複的資料行在填入<xref:System.Data.DataTable>，它將會產生後續的資料行，並使用模式的名稱&quot;*columnname*1&quot;，&quot;*columnname*2&quot;，&quot;*columnname*3&quot;，依此類推。</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式&quot;Column1&quot;、&quot;Column2&quot;，等等。</xref:System.Data.DataSet>       當指定的查詢傳回多個結果時，每個結果集被放在個別的資料表。 其他結果集的命名方式是附加至指定的資料表名稱 （例如，&quot;Table&quot;、&quot;Table1&quot;、&quot;Table2&quot;等等） 的整數值。 不會建立資料表查詢不會傳回資料列，如果您要處理插入查詢後面的 select 查詢，因為建立選取查詢的資料表就會命名為&quot;Table&quot;，因為它是建立的第一個資料表。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。       Fill 方法的支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。</xref:System.Data.DataTable> </xref:System.Data.DataSet> 在這種情況下，<xref:System.Data.Common.DbDataAdapter.Fill%2A>執行區分大小寫的比較，來尋找對應的資料表，並建立新的資料表，如果沒有完全相符項目存在。</xref:System.Data.Common.DbDataAdapter.Fill%2A> 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   dataset.Tables.Add(&quot;AAA&quot;);   adapter.Fill(dataset, &quot;aaa&quot;); // Fills &quot;aaa&quot;, which already exists in the DataSet.   adapter.Fill(dataset, &quot;Aaa&quot;); // Adds a new table called &quot;Aaa&quot;.   ```如果<xref:System.Data.Common.DbDataAdapter.Fill%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   adapter.Fill(dataset, &quot;AAA&quot;); // Fills table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```如果錯誤或例外狀況時發生填入資料的資料表，在發生錯誤之前所加入的資料列會保留在資料的資料表。 已中止運算的餘數。       當 SELECT 陳述式用來填入<xref:System.Data.DataTable>物件會傳回多個結果，例如批次 SQL 陳述式，可注意下列事項:-時處理批次 SQL 陳述式，從多個結果`maxRecords`只適用於第一個結果。</xref:System.Data.DataTable> 也適用於包含章節化的結果 (.NET Framework Data Provider for OLE DB 只) 的資料列。 最上層結果會受到`maxRecords`，但是所有的子資料列會加入。      -如果其中一個結果包含錯誤時，會略過所有後續的結果。      > [!NOTE] >`DataSet`不會包含在所指定的記錄數目超過`maxRecords`。 不過，從伺服器仍會傳回整個查詢所產生的結果集。"
  syntax:
    content: protected virtual int Fill (System.Data.DataTable[] dataTables, int startRecord, int maxRecords, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);
    parameters:
    - id: dataTables
      type: System.Data.DataTable[]
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref>填入來自資料來源的物件。"
    - id: startRecord
      type: System.Int32
      description: "若要開始使用以零為起始的記錄號碼。"
    - id: maxRecords
      type: System.Int32
      description: "要擷取的記錄數目上限。"
    - id: command
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref>執行，以填滿<xref href=&quot;System.Data.DataTable&quot;></xref>物件。"
    - id: behavior
      type: System.Data.CommandBehavior
      description: "其中一個<xref href=&quot;System.Data.CommandBehavior&quot;></xref>值。"
    return:
      type: System.Int32
      description: "加入至或在資料表中重新整理的資料列數目。"
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "<xref href=&quot;System.Data.DataSet&quot;> </xref>無效。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無效的來源資料表。       -或者-連接無效。"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "找不到連接。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> startRecord </code>參數小於 0。       -或- <code> maxRecords </code>參數小於 0。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)
  id: Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Fill(DataSet,Int32,Int32,String,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.Fill(DataSet,Int32,Int32,String,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet,Int32,Int32,String,IDbCommand,CommandBehavior)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "加入或重新整理指定範圍中的資料列<xref href=&quot;System.Data.DataSet&quot;></xref>以符合資料來源使用<xref href=&quot;System.Data.DataSet&quot;></xref>和來源資料表名稱、 命令字串和命令行為。"
  remarks: "<xref:System.Data.Common.DbDataAdapter.Fill%2A>方法會從使用 SELECT 陳述式指定由相關聯的資料來源擷取資料列<xref:System.Data.IDbDataAdapter.SelectCommand%2A>屬性。</xref:System.Data.IDbDataAdapter.SelectCommand%2A> </xref:System.Data.Common.DbDataAdapter.Fill%2A> SELECT 陳述式相關聯的連接物件必須有效，但它不需要開啟。 如果連接已關閉之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會開啟擷取資料，然後關閉。</xref:System.Data.Common.DbDataAdapter.Fill%2A> 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.Fill%2A>是呼叫，它會保持開啟狀態。</xref:System.Data.Common.DbDataAdapter.Fill%2A>       <xref:System.Data.Common.DbDataAdapter.Fill%2A>作業接著會將資料列加入到目的地<xref:System.Data.DataTable>中的物件<xref:System.Data.DataSet>、 建立<xref:System.Data.DataTable>如果它們尚不存在的物件。</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.Fill%2A> 建立時<xref:System.Data.DataTable>物件<xref:System.Data.Common.DbDataAdapter.Fill%2A>作業通常會建立只有資料行名稱中繼資料。</xref:System.Data.Common.DbDataAdapter.Fill%2A> </xref:System.Data.DataTable> 不過，如果<xref:System.Data.IDataAdapter.MissingSchemaAction%2A>屬性設定為`AddWithKey`，也會建立適當的主索引鍵和條件約束。</xref:System.Data.IDataAdapter.MissingSchemaAction%2A>       如果<xref:System.Data.Common.DbDataAdapter>遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱&quot;*columnname*1&quot;，&quot;*columnname*2&quot;，&quot;*columnname*3 」，依此類推。</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式&quot;Column1&quot;、&quot;Column2&quot;，等等。</xref:System.Data.DataSet> 當多個結果集加入至<xref:System.Data.DataSet>放置於個別的資料表中每個結果集。</xref:System.Data.DataSet> 其他結果集的命名方式是附加至指定的資料表名稱 （例如，&quot;Table&quot;、&quot;Table1&quot;、&quot;Table2&quot;等等） 的整數值。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。       <xref:System.Data.Common.DbDataAdapter.Fill%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> 在這種情況下，<xref:System.Data.Common.DbDataAdapter.Fill%2A>執行區分大小寫的比較，來尋找對應的資料表，並建立新的資料表，如果沒有完全相符項目存在。</xref:System.Data.Common.DbDataAdapter.Fill%2A> 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   dataset.Tables.Add(&quot;AAA&quot;);   adapter.Fill(dataset, &quot;aaa&quot;); // Fills &quot;aaa&quot;, which already exists in the DataSet.   adapter.Fill(dataset, &quot;Aaa&quot;); // Adds a new table called &quot;Aaa&quot;.   ```如果<xref:System.Data.Common.DbDataAdapter.Fill%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Fill%2A> 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   adapter.Fill(dataset, &quot;AAA&quot;); // Fills table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```您可以使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>多次於相同<xref:System.Data.DataTable>。</xref:System.Data.DataTable>方法</xref:System.Data.Common.DbDataAdapter.Fill%2A> 如果主索引鍵存在，內送資料列會合併具有相符的資料列已經存在。 如果沒有主索引鍵存在，內送資料列會附加至<xref:System.Data.DataTable>。</xref:System.Data.DataTable>       如果`SelectCommand`傳回結果的 OUTER JOIN，`DataAdapter`未設定<xref:System.Data.DataTable.PrimaryKey%2A>值，產生<xref:System.Data.DataTable>。</xref:System.Data.DataTable> </xref:System.Data.DataTable.PrimaryKey%2A> 您必須明確定義主索引鍵，以確保正確解析重複的資料列。 如需詳細資訊，請參閱[定義主索引鍵](~/add/includes/ajax-current-ext-md.md)。      > [!NOTE] > 時處理批次 SQL 陳述式會傳回多個結果，實作<xref:System.Data.Common.DbDataAdapter.Fill%2A>和<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>對於.NET Framework 資料提供者擷取結構描述資訊，只有第一個結果。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> </xref:System.Data.Common.DbDataAdapter.Fill%2A>"
  syntax:
    content: protected virtual int Fill (System.Data.DataSet dataSet, int startRecord, int maxRecords, string srcTable, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "A <xref href=&quot;System.Data.DataSet&quot;> </xref>填滿記錄，如有必要，結構描述。"
    - id: startRecord
      type: System.Int32
      description: "若要開始使用以零為起始的記錄號碼。"
    - id: maxRecords
      type: System.Int32
      description: "要擷取的記錄數目上限。"
    - id: srcTable
      type: System.String
      description: "要用於資料表對應的來源資料表的名稱。"
    - id: command
      type: System.Data.IDbCommand
      description: "SQL SELECT 陳述式用於從資料來源擷取資料列。"
    - id: behavior
      type: System.Data.CommandBehavior
      description: "其中一個<xref href=&quot;System.Data.CommandBehavior&quot;></xref>值。"
    return:
      type: System.Int32
      description: "資料列數目已成功加入，或在中重新整理<xref href=&quot;System.Data.DataSet&quot;> </xref>。 這不包括不傳回資料列的陳述式所影響的資料列。"
  overload: System.Data.Common.DbDataAdapter.Fill*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無效的來源資料表。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code> startRecord </code>參數小於 0。       -或- <code> maxRecords </code>參數小於 0。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.FillCommandBehavior
  id: FillCommandBehavior
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: FillCommandBehavior
  nameWithType: DbDataAdapter.FillCommandBehavior
  fullName: System.Data.Common.DbDataAdapter.FillCommandBehavior
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "取得或設定用來填滿資料配接器的命令的行為。"
  syntax:
    content: protected System.Data.CommandBehavior FillCommandBehavior { get; set; }
    return:
      type: System.Data.CommandBehavior
      description: "<xref href=&quot;System.Data.CommandBehavior&quot;> </xref>用來填滿資料配接器的命令。"
  overload: System.Data.Common.DbDataAdapter.FillCommandBehavior*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)
  id: FillSchema(System.Data.DataSet,System.Data.SchemaType)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: FillSchema(DataSet,SchemaType)
  nameWithType: DbDataAdapter.FillSchema(DataSet,SchemaType)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataSet,SchemaType)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "新增<xref href=&quot;System.Data.DataTable&quot;></xref>指定名為&quot;Table&quot; <xref href=&quot;System.Data.DataSet&quot;> </xref>並設定基礎結構描述要比對資料來源中指定<xref href=&quot;System.Data.SchemaType&quot;> </xref>。"
  remarks: "這個方法會從使用<xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</xref:System.Data.IDbDataAdapter.SelectCommand%2A>的資料來源擷取的結構描述資訊       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>作業會將加入<xref:System.Data.DataTable>到目的地<xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 接著它會加入至資料行<xref:System.Data.DataColumnCollection>的<xref:System.Data.DataTable>，並設定下列<xref:System.Data.DataColumn>屬性如果存在於資料來源:- <xref:System.Data.DataColumn.AllowDBNull%2A>- <xref:System.Data.DataColumn.AutoIncrement%2A>.</xref:System.Data.DataColumn.AutoIncrement%2A> </xref:System.Data.DataColumn.AllowDBNull%2A> </xref:System.Data.DataColumn> </xref:System.Data.DataTable> </xref:System.Data.DataColumnCollection> 您必須設定<xref:System.Data.DataColumn.AutoIncrementStep%2A>和<xref:System.Data.DataColumn.AutoIncrementSeed%2A>個別。</xref:System.Data.DataColumn.AutoIncrementSeed%2A> </xref:System.Data.DataColumn.AutoIncrementStep%2A>      - <xref:System.Data.DataColumn.MaxLength%2A>- <xref:System.Data.DataColumn.ReadOnly%2A>-<xref:System.Data.DataColumn.Unique%2A><xref:System.Data.Common.DbDataAdapter.FillSchema%2A>也會設定<xref:System.Data.DataTable.PrimaryKey%2A>和<xref:System.Data.DataTable.Constraints%2A>屬性根據下列規則:-如果一或多個主索引鍵資料行所傳回的<xref:System.Data.IDbDataAdapter.SelectCommand%2A>，它們會當做<xref:System.Data.DataTable>.</xref:System.Data.DataTable>的主索引鍵資料行</xref:System.Data.IDbDataAdapter.SelectCommand%2A></xref:System.Data.DataTable.Constraints%2A></xref:System.Data.DataTable.PrimaryKey%2A></xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       </xref:System.Data.DataColumn.Unique%2A></xref:System.Data.DataColumn.ReadOnly%2A></xref:System.Data.DataColumn.MaxLength%2A>      -如果傳回沒有主索引鍵資料行，但是唯一的資料行，唯一的資料行可用的主索引鍵，如果且只有唯一的資料行都不可為 null。 如果任何資料行可為 null，<xref:System.Data.UniqueConstraint>加入至<xref:System.Data.ConstraintCollection>，但<xref:System.Data.DataTable.PrimaryKey%2A>屬性未設定。</xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.ConstraintCollection> </xref:System.Data.UniqueConstraint>      -如果傳回主要索引鍵資料行，唯一的資料行，主索引鍵資料行作為主索引鍵資料行<xref:System.Data.DataTable>.</xref:System.Data.DataTable>       請注意，會將主索引鍵和唯一條件約束加入至<xref:System.Data.ConstraintCollection>根據前述規則，但其他條件約束類型不會加入。</xref:System.Data.ConstraintCollection>       如果唯一叢集索引上的資料行或 SQL Server 資料表中的資料行定義和叢集索引中的資料行的名稱將會傳回一組個別的資料行上定義主索引鍵條件約束。 若要傳回的主索引鍵資料行的名稱，使用指定名稱的主索引鍵的 SELECT 陳述式中的查詢提示。 如需有關指定查詢提示的詳細資訊，請參閱[查詢提示 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)。       主索引鍵資訊會使用於<xref:System.Data.Common.DbDataAdapter.Fill%2A>來尋找和取代其索引鍵資料行符合任何資料列。</xref:System.Data.Common.DbDataAdapter.Fill%2A> 如果這不是所要的行為，使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>但未要求結構描述資訊。</xref:System.Data.Common.DbDataAdapter.Fill%2A>       如果<xref:System.Data.IDataAdapter>遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱&quot;*columnname*1&quot;，&quot;*columnname*2&quot;，&quot;*columnname*3 」，依此類推。</xref:System.Data.DataTable> </xref:System.Data.IDataAdapter> 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式&quot;Column1&quot;、&quot;Column2&quot;，等等。</xref:System.Data.DataSet> 當多個結果集加入至<xref:System.Data.DataSet>放置於個別的資料表中每個結果集。</xref:System.Data.DataSet> 其他結果集的命名方式是附加至指定的資料表名稱 （例如，&quot;Table&quot;、&quot;Table1&quot;、&quot;Table2&quot;等。） 的整數值。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。       <xref:System.Data.IDbConnection>Select 命令相關聯的物件必須有效，但不需要開啟。</xref:System.Data.IDbConnection> 如果<xref:System.Data.IDbConnection>前已關閉<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它會開啟擷取資料，然後關閉。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> </xref:System.Data.IDbConnection> 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它仍然為開啟狀態。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A>      > [!NOTE] > 時處理批次 SQL 陳述式會傳回多個結果，實作<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取結構描述資訊，只有第一個結果。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>       當使用<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>，.NET Framework Data Provider for SQL Server 會將 FOR BROWSE 子句附加至正在執行的陳述式。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 使用者應該注意潛在的副作用，例如使用 SET FMTONLY ON 陳述式的干擾。 如需詳細資訊，請參閱 SQL Server 線上叢書 》。"
  example:
  - "The following example uses the derived class, <xref:System.Data.SqlClient.SqlDataAdapter>, to fill a <xref:System.Data.DataSet> with the schema, and returns a <xref:System.Data.DataSet>.  \n  \n [!code-vb[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/add/codesnippet/visualbasic/5283d285-2680-48b0-856a-_1.vb)]\n [!code-cs[Classic WebData DbDataAdapter.FillSchema1 Example#1](~/add/codesnippet/csharp/5283d285-2680-48b0-856a-_1.cs)]"
  syntax:
    content: public override System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "A <xref href=&quot;System.Data.DataSet&quot;> </xref>插入結構描述中的。"
    - id: schemaType
      type: System.Data.SchemaType
      description: "其中一個<xref href=&quot;System.Data.SchemaType&quot;></xref>指定如何插入結構描述的值。"
    return:
      type: System.Data.DataTable[]
      description: "集合的參考<xref href=&quot;System.Data.DataTable&quot;></xref>物件新增至<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.Common.DbDataAdapter.FillSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType)
  id: FillSchema(System.Data.DataTable,System.Data.SchemaType)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: FillSchema(DataTable,SchemaType)
  nameWithType: DbDataAdapter.FillSchema(DataTable,SchemaType)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataTable,SchemaType)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "設定指定的結構描述<xref href=&quot;System.Data.DataTable&quot;></xref>根據指定<xref href=&quot;System.Data.SchemaType&quot;> </xref>。"
  remarks: "FillSchema 方法從資料來源使用<xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</xref:System.Data.IDbDataAdapter.SelectCommand%2A>擷取結構描述 連接物件相關聯<xref:System.Data.IDbDataAdapter.SelectCommand%2A>必須有效，但它不需要開啟。</xref:System.Data.IDbDataAdapter.SelectCommand%2A> 如果連接已關閉 FillSchema 呼叫之前，它會開啟擷取資料，然後關閉。 如果連接為開啟，會在呼叫 FillSchema 之前，它會保持開啟。       FillSchema 作業會傳回<xref:System.Data.DataTable>.</xref:System.Data.DataTable> 接著它會加入至資料行<xref:System.Data.DataColumnCollection>的<xref:System.Data.DataTable>，並設定下列<xref:System.Data.DataColumn>屬性如果存在於資料來源:- <xref:System.Data.DataColumn.AllowDBNull%2A>- <xref:System.Data.DataColumn.AutoIncrement%2A>.</xref:System.Data.DataColumn.AutoIncrement%2A> </xref:System.Data.DataColumn.AllowDBNull%2A> </xref:System.Data.DataColumn> </xref:System.Data.DataTable> </xref:System.Data.DataColumnCollection> 您必須設定<xref:System.Data.DataColumn.AutoIncrementStep%2A>和<xref:System.Data.DataColumn.AutoIncrementSeed%2A>個別。</xref:System.Data.DataColumn.AutoIncrementSeed%2A> </xref:System.Data.DataColumn.AutoIncrementStep%2A>      - <xref:System.Data.DataColumn.MaxLength%2A>- <xref:System.Data.DataColumn.ReadOnly%2A>- <xref:System.Data.DataColumn.Unique%2A>FillSchema 也會設定<xref:System.Data.DataTable.PrimaryKey%2A>和<xref:System.Data.DataTable.Constraints%2A>屬性根據下列規則:-如果<xref:System.Data.DataTable.PrimaryKey%2A>已經定義為`DataTable`，或`DataTable`包含資料，`PrimaryKey`未設定屬性。</xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.DataTable.Constraints%2A> </xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.DataColumn.Unique%2A> </xref:System.Data.DataColumn.ReadOnly%2A> </xref:System.Data.DataColumn.MaxLength%2A>      -如果一或多個主索引鍵資料行所傳回<xref:System.Data.IDbDataAdapter.SelectCommand%2A>，它們會做為主要索引鍵資料行`DataTable`。</xref:System.Data.IDbDataAdapter.SelectCommand%2A>      -如果傳回沒有主索引鍵資料行，但是唯一的資料行，唯一的資料行可用的主索引鍵，如果且只有唯一的資料行都不可為 null。 如果任何資料行可為 null，<xref:System.Data.UniqueConstraint>加入至<xref:System.Data.ConstraintCollection>，但`PrimaryKey`屬性未設定。</xref:System.Data.ConstraintCollection> </xref:System.Data.UniqueConstraint>      -如果傳回主要索引鍵資料行，唯一的資料行，主索引鍵資料行做為主要索引鍵資料行`DataTable`。       請注意，會將主索引鍵和唯一條件約束加入至<xref:System.Data.ConstraintCollection>根據前述規則，但其他條件約束類型不會加入。</xref:System.Data.ConstraintCollection> 此程序可能需要數個往返到伺服器。       如果唯一叢集索引上的資料行或 SQL Server 資料表中的資料行定義和叢集索引中的資料行的名稱將會傳回一組個別的資料行上定義主索引鍵條件約束。 若要傳回的主索引鍵資料行的名稱，使用指定名稱的主索引鍵的 SELECT 陳述式中的查詢提示。 如需有關指定查詢提示的詳細資訊，請參閱[查詢提示 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)。       如果<xref:System.Data.Common.DbDataAdapter>遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱&quot;*columnname*1&quot;，&quot;*columnname*2&quot;，&quot;*columnname*3 」，依此類推。</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式&quot;Column1&quot;、&quot;Column2&quot;，等等。</xref:System.Data.DataSet> 當多個結果集加入至<xref:System.Data.DataSet>放置於個別的資料表中每個結果集。</xref:System.Data.DataSet> 其他結果集的命名方式是附加至指定的資料表名稱 （例如，&quot;Table&quot;、&quot;Table1&quot;、&quot;Table2&quot;等。） 的整數值。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。       FillSchema 不傳回任何資料列。 使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>要加入資料列至<xref:System.Data.DataTable>。</xref:System.Data.DataTable>方法</xref:System.Data.Common.DbDataAdapter.Fill%2A>      > [!NOTE] > 的實作 FillSchema 的.NET Framework Data Provider for OLE DB 時處理批次傳回多個結果的 SQL 陳述式，擷取結構描述資訊，只有第一個結果。 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>       當使用 FillSchema 時，.NET Framework Data Provider for SQL Server 會將 FOR BROWSE 子句附加至正在執行的陳述式中。 使用者應該注意潛在的副作用，例如使用 SET FMTONLY ON 陳述式的干擾。 如需詳細資訊，請參閱 SQL Server 線上叢書 》。"
  example:
  - "The following example uses the derived class, <xref:System.Data.SqlClient.SqlDataAdapter>, to fill a <xref:System.Data.DataSet> with the schema, and returns a <xref:System.Data.DataTable>.  \n  \n [!code-vb[Classic WebData DbDataAdapter.FillSchema3#1](~/add/codesnippet/visualbasic/658ac10a-3a87-4693-8b37-_1.vb)]\n [!code-cs[Classic WebData DbDataAdapter.FillSchema3#1](~/add/codesnippet/csharp/658ac10a-3a87-4693-8b37-_1.cs)]"
  syntax:
    content: public System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType);
    parameters:
    - id: dataTable
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref>来填入資料來源的結構描述。"
    - id: schemaType
      type: System.Data.SchemaType
      description: "其中一個<xref href=&quot;System.Data.SchemaType&quot;></xref>值。"
    return:
      type: System.Data.DataTable
      description: "A <xref href=&quot;System.Data.DataTable&quot;> </xref> ，其中包含從資料來源傳回結構描述資訊。"
  overload: System.Data.Common.DbDataAdapter.FillSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String)
  id: FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: FillSchema(DataSet,SchemaType,String)
  nameWithType: DbDataAdapter.FillSchema(DataSet,SchemaType,String)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataSet,SchemaType,String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "新增<xref href=&quot;System.Data.DataTable&quot;></xref>指定<xref href=&quot;System.Data.DataSet&quot;></xref>及設定的結構描述要比對資料來源中根據指定<xref href=&quot;System.Data.SchemaType&quot;></xref>和<xref href=&quot;System.Data.DataTable&quot;> </xref>。"
  remarks: "這個方法會從使用<xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</xref:System.Data.IDbDataAdapter.SelectCommand%2A>的資料來源擷取的結構描述資訊       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>作業會將加入<xref:System.Data.DataTable>到目的地<xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 接著它會加入至資料行<xref:System.Data.DataColumnCollection>的<xref:System.Data.DataTable>，並設定下列<xref:System.Data.DataColumn>屬性如果存在於資料來源:- <xref:System.Data.DataColumn.AllowDBNull%2A>- <xref:System.Data.DataColumn.AutoIncrement%2A>.</xref:System.Data.DataColumn.AutoIncrement%2A> </xref:System.Data.DataColumn.AllowDBNull%2A> </xref:System.Data.DataColumn> </xref:System.Data.DataTable> </xref:System.Data.DataColumnCollection> 您必須設定<xref:System.Data.DataColumn.AutoIncrementStep%2A>和<xref:System.Data.DataColumn.AutoIncrementSeed%2A>個別。</xref:System.Data.DataColumn.AutoIncrementSeed%2A> </xref:System.Data.DataColumn.AutoIncrementStep%2A>      - <xref:System.Data.DataColumn.MaxLength%2A>- <xref:System.Data.DataColumn.ReadOnly%2A>-<xref:System.Data.DataColumn.Unique%2A><xref:System.Data.Common.DbDataAdapter.FillSchema%2A>也會設定<xref:System.Data.DataTable.PrimaryKey%2A>和<xref:System.Data.DataTable.Constraints%2A>屬性根據下列規則:-如果一或多個主索引鍵資料行所傳回的<xref:System.Data.IDbDataAdapter.SelectCommand%2A>，它們會當做<xref:System.Data.DataTable>.</xref:System.Data.DataTable>的主索引鍵資料行</xref:System.Data.IDbDataAdapter.SelectCommand%2A></xref:System.Data.DataTable.Constraints%2A></xref:System.Data.DataTable.PrimaryKey%2A></xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       </xref:System.Data.DataColumn.Unique%2A></xref:System.Data.DataColumn.ReadOnly%2A></xref:System.Data.DataColumn.MaxLength%2A>      -如果傳回沒有主索引鍵資料行，但是唯一的資料行，唯一的資料行可用的主索引鍵，如果且只有唯一的資料行都不可為 null。 如果任何資料行可為 null，<xref:System.Data.UniqueConstraint>加入至<xref:System.Data.ConstraintCollection>，但<xref:System.Data.DataTable.PrimaryKey%2A>屬性未設定。</xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.ConstraintCollection> </xref:System.Data.UniqueConstraint>      -如果傳回主要索引鍵資料行，唯一的資料行，主索引鍵資料行作為主索引鍵資料行<xref:System.Data.DataTable>.</xref:System.Data.DataTable>       請注意，會將主索引鍵和唯一條件約束加入至<xref:System.Data.ConstraintCollection>根據前述規則，但其他條件約束類型不會加入。</xref:System.Data.ConstraintCollection>       如果唯一叢集索引上的資料行或 SQL Server 資料表中的資料行定義和叢集索引中的資料行的名稱將會傳回一組個別的資料行上定義主索引鍵條件約束。 若要傳回的主索引鍵資料行的名稱，使用指定名稱的主索引鍵的 SELECT 陳述式中的查詢提示。 如需有關指定查詢提示的詳細資訊，請參閱[查詢提示 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)。       主索引鍵資訊會使用於<xref:System.Data.Common.DbDataAdapter.Fill%2A>來尋找和取代其索引鍵資料行符合任何資料列。</xref:System.Data.Common.DbDataAdapter.Fill%2A> 如果這不是所要的行為，使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>但未要求結構描述資訊。</xref:System.Data.Common.DbDataAdapter.Fill%2A>       如果<xref:System.Data.Common.DbDataAdapter>遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱&quot;*columnname*1&quot;，&quot;*columnname*2&quot;，&quot;*columnname*3 」，依此類推。</xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter> 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式&quot;Column1&quot;、&quot;Column2&quot;，等等。</xref:System.Data.DataSet> 當多個結果集加入至<xref:System.Data.DataSet>放置於個別的資料表中每個結果集。</xref:System.Data.DataSet> 其他結果集的命名方式是附加至指定的資料表名稱 （例如，&quot;Table&quot;、&quot;Table1&quot;、&quot;Table2&quot;等。） 的整數值。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 在這種情況下，<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>執行區分大小寫的比較，來尋找對應的資料表，並建立新的資料表，如果沒有完全相符項目存在。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   dataset.Tables.Add(&quot;AAA&quot;);   adapter.FillSchema(dataset, &quot;aaa&quot;); // Fills the schema of &quot;aaa&quot;, which already exists in the DataSet.   adapter.FillSchema(dataset, &quot;Aaa&quot;); // Adds a new table called &quot;Aaa&quot;.   ```如果<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   adapter.FillSchema(dataset, &quot;AAA&quot;); // Fills the schema of table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```<xref:System.Data.IDbConnection>Select 命令相關聯的物件必須有效，但不需要開啟。</xref:System.Data.IDbConnection> 如果<xref:System.Data.IDbConnection>前已關閉<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它會開啟擷取資料，然後關閉。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> </xref:System.Data.IDbConnection> 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它仍然為開啟狀態。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A>      > [!NOTE] > 時處理批次 SQL 陳述式會傳回多個結果，實作<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取結構描述資訊，只有第一個結果。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>       當使用<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>，.NET Framework Data Provider for SQL Server 會將 FOR BROWSE 子句附加至正在執行的陳述式。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 使用者應該注意潛在的副作用，例如使用 SET FMTONLY ON 陳述式的干擾。 如需詳細資訊，請參閱 SQL Server 線上叢書 》。"
  example:
  - "The following example uses the derived class, <xref:System.Data.SqlClient.SqlDataAdapter>, to fill a <xref:System.Data.DataSet> with the schema, and returns a <xref:System.Data.DataSet>.  \n  \n [!code-vb[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/add/codesnippet/visualbasic/c7e2b899-0a44-4d9d-9e8d-_1.vb)]\n [!code-cs[Classic WebData DbDataAdapter.FillSchema2 Example#1](~/add/codesnippet/csharp/c7e2b899-0a44-4d9d-9e8d-_1.cs)]"
  syntax:
    content: public System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, string srcTable);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "A <xref href=&quot;System.Data.DataSet&quot;> </xref>插入結構描述中的。"
    - id: schemaType
      type: System.Data.SchemaType
      description: "其中一個<xref href=&quot;System.Data.SchemaType&quot;></xref>指定如何插入結構描述的值。"
    - id: srcTable
      type: System.String
      description: "要用於資料表對應的來源資料表的名稱。"
    return:
      type: System.Data.DataTable[]
      description: "集合的參考<xref href=&quot;System.Data.DataTable&quot;></xref>物件新增至<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.Common.DbDataAdapter.FillSchema*
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "找不到要從中取得結構描述的來源資料表。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)
  id: FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: FillSchema(DataTable,SchemaType,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.FillSchema(DataTable,SchemaType,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataTable,SchemaType,IDbCommand,CommandBehavior)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "設定指定的結構描述<xref href=&quot;System.Data.DataTable&quot;></xref>根據指定<xref href=&quot;System.Data.SchemaType&quot;> </xref>，命令字串，並<xref href=&quot;System.Data.CommandBehavior&quot;></xref>值。"
  remarks: "<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>方法會擷取使用<xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</xref:System.Data.IDbDataAdapter.SelectCommand%2A>資料來源的結構描述</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 連接物件相關聯<xref:System.Data.IDbDataAdapter.SelectCommand%2A>必須有效，但它不需要開啟。</xref:System.Data.IDbDataAdapter.SelectCommand%2A> 如果連接已關閉之前<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它會開啟擷取資料，然後關閉。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它會保持開啟狀態。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>作業會將加入<xref:System.Data.DataTable>到目的地<xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 接著它會加入至資料行<xref:System.Data.DataColumnCollection>的<xref:System.Data.DataTable>，並設定下列<xref:System.Data.DataColumn>屬性如果存在於資料來源:- <xref:System.Data.DataColumn.AllowDBNull%2A>- <xref:System.Data.DataColumn.AutoIncrement%2A>.</xref:System.Data.DataColumn.AutoIncrement%2A> </xref:System.Data.DataColumn.AllowDBNull%2A> </xref:System.Data.DataColumn> </xref:System.Data.DataTable> </xref:System.Data.DataColumnCollection> 您必須設定<xref:System.Data.DataColumn.AutoIncrementStep%2A>和<xref:System.Data.DataColumn.AutoIncrementSeed%2A>個別。</xref:System.Data.DataColumn.AutoIncrementSeed%2A> </xref:System.Data.DataColumn.AutoIncrementStep%2A>      - <xref:System.Data.DataColumn.MaxLength%2A>- <xref:System.Data.DataColumn.ReadOnly%2A>-<xref:System.Data.DataColumn.Unique%2A><xref:System.Data.Common.DbDataAdapter.FillSchema%2A>也會設定<xref:System.Data.DataTable.PrimaryKey%2A>和<xref:System.Data.DataTable.Constraints%2A>屬性根據下列規則:-如果一或多個主索引鍵資料行所傳回的<xref:System.Data.IDbDataAdapter.SelectCommand%2A>，它們會當做<xref:System.Data.DataTable>.</xref:System.Data.DataTable>的主索引鍵資料行</xref:System.Data.IDbDataAdapter.SelectCommand%2A></xref:System.Data.DataTable.Constraints%2A></xref:System.Data.DataTable.PrimaryKey%2A></xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       </xref:System.Data.DataColumn.Unique%2A></xref:System.Data.DataColumn.ReadOnly%2A></xref:System.Data.DataColumn.MaxLength%2A>      -如果傳回沒有主索引鍵資料行，但是唯一的資料行，唯一的資料行可用的主索引鍵，如果且只有唯一的資料行都不可為 null。 如果任何資料行可為 null，<xref:System.Data.UniqueConstraint>加入至<xref:System.Data.ConstraintCollection>，但<xref:System.Data.DataTable.PrimaryKey%2A>屬性未設定。</xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.ConstraintCollection> </xref:System.Data.UniqueConstraint>      -如果傳回主要索引鍵資料行，唯一的資料行，主索引鍵資料行作為主索引鍵資料行<xref:System.Data.DataTable>.</xref:System.Data.DataTable>       請注意，會將主索引鍵和唯一條件約束加入至<xref:System.Data.ConstraintCollection>根據前述規則，但其他條件約束類型不會加入。</xref:System.Data.ConstraintCollection>       如果唯一叢集索引上的資料行或 SQL Server 資料表中的資料行定義和叢集索引中的資料行的名稱將會傳回一組個別的資料行上定義主索引鍵條件約束。 若要傳回的主索引鍵資料行的名稱，使用指定名稱的主索引鍵的 SELECT 陳述式中的查詢提示。 如需有關指定查詢提示的詳細資訊，請參閱[查詢提示 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)。       如果<xref:System.Data.IDataAdapter>遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱&quot;*columnname*1&quot;，&quot;*columnname*2&quot;，&quot;*columnname*3 」，依此類推。</xref:System.Data.DataTable> </xref:System.Data.IDataAdapter> 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式&quot;Column1&quot;、&quot;Column2&quot;，等等。</xref:System.Data.DataSet> 當多個結果集加入至<xref:System.Data.DataSet>放置於個別的資料表中每個結果集。</xref:System.Data.DataSet> 其他結果集的命名方式是附加至指定的資料表名稱 （例如，&quot;Table&quot;、&quot;Table1&quot;、&quot;Table2&quot;等。） 的整數值。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>不會傳回任何資料列。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>要加入資料列至<xref:System.Data.DataTable>。</xref:System.Data.DataTable>方法</xref:System.Data.Common.DbDataAdapter.Fill%2A>      > [!NOTE] > 時處理批次 SQL 陳述式會傳回多個結果，實作<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取結構描述資訊，只有第一個結果。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>       當使用<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>，.NET Framework Data Provider for SQL Server 會將 FOR BROWSE 子句附加至正在執行的陳述式。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 使用者應該注意潛在的副作用，例如使用 SET FMTONLY ON 陳述式的干擾。 如需詳細資訊，請參閱 SQL Server 線上叢書 》。"
  syntax:
    content: protected virtual System.Data.DataTable FillSchema (System.Data.DataTable dataTable, System.Data.SchemaType schemaType, System.Data.IDbCommand command, System.Data.CommandBehavior behavior);
    parameters:
    - id: dataTable
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref>来填入資料來源的結構描述。"
    - id: schemaType
      type: System.Data.SchemaType
      description: "其中一個<xref href=&quot;System.Data.SchemaType&quot;></xref>值。"
    - id: command
      type: System.Data.IDbCommand
      description: "SQL SELECT 陳述式用於從資料來源擷取資料列。"
    - id: behavior
      type: System.Data.CommandBehavior
      description: "其中一個<xref href=&quot;System.Data.CommandBehavior&quot;></xref>值。"
    return:
      type: System.Data.DataTable
      description: "A 的<xref href=&quot;System.Data.DataTable&quot;></xref>從資料來源傳回的物件，其中包含結構描述資訊。"
  overload: System.Data.Common.DbDataAdapter.FillSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)
  id: FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: FillSchema(DataSet,SchemaType,IDbCommand,String,CommandBehavior)
  nameWithType: DbDataAdapter.FillSchema(DataSet,SchemaType,IDbCommand,String,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataSet,SchemaType,IDbCommand,String,CommandBehavior)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "新增<xref href=&quot;System.Data.DataTable&quot;></xref>指定<xref href=&quot;System.Data.DataSet&quot;></xref>並設定基礎結構描述要比對資料來源中指定<xref href=&quot;System.Data.SchemaType&quot;> </xref>。"
  remarks: "<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>方法會擷取使用<xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</xref:System.Data.IDbDataAdapter.SelectCommand%2A>資料來源的結構描述</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 連接物件相關聯<xref:System.Data.IDbDataAdapter.SelectCommand%2A>必須有效，但它不需要開啟。</xref:System.Data.IDbDataAdapter.SelectCommand%2A> 如果連接已關閉之前<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它會開啟擷取資料，然後關閉。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 如果連接為開啟之前<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>是呼叫，它會保持開啟狀態。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>作業會將加入<xref:System.Data.DataTable>到目的地<xref:System.Data.DataSet>.</xref:System.Data.DataSet> </xref:System.Data.DataTable> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 接著它會加入至資料行<xref:System.Data.DataColumnCollection>的<xref:System.Data.DataTable>，並設定下列<xref:System.Data.DataColumn>屬性如果存在於資料來源:- <xref:System.Data.DataColumn.AllowDBNull%2A>- <xref:System.Data.DataColumn.AutoIncrement%2A>.</xref:System.Data.DataColumn.AutoIncrement%2A> </xref:System.Data.DataColumn.AllowDBNull%2A> </xref:System.Data.DataColumn> </xref:System.Data.DataTable> </xref:System.Data.DataColumnCollection> 您必須設定<xref:System.Data.DataColumn.AutoIncrementStep%2A>和<xref:System.Data.DataColumn.AutoIncrementSeed%2A>個別。</xref:System.Data.DataColumn.AutoIncrementSeed%2A> </xref:System.Data.DataColumn.AutoIncrementStep%2A>      - <xref:System.Data.DataColumn.MaxLength%2A>- <xref:System.Data.DataColumn.ReadOnly%2A>-<xref:System.Data.DataColumn.Unique%2A><xref:System.Data.Common.DbDataAdapter.FillSchema%2A>也會設定<xref:System.Data.DataTable.PrimaryKey%2A>和<xref:System.Data.DataTable.Constraints%2A>屬性根據下列規則:-如果一或多個主索引鍵資料行所傳回的<xref:System.Data.IDbDataAdapter.SelectCommand%2A>，它們會當做<xref:System.Data.DataTable>.</xref:System.Data.DataTable>的主索引鍵資料行</xref:System.Data.IDbDataAdapter.SelectCommand%2A></xref:System.Data.DataTable.Constraints%2A></xref:System.Data.DataTable.PrimaryKey%2A></xref:System.Data.Common.DbDataAdapter.FillSchema%2A>       </xref:System.Data.DataColumn.Unique%2A></xref:System.Data.DataColumn.ReadOnly%2A></xref:System.Data.DataColumn.MaxLength%2A>      -如果傳回沒有主索引鍵資料行，但是唯一的資料行，唯一的資料行可用的主索引鍵，如果且只有唯一的資料行都不可為 null。 如果任何資料行可為 null，<xref:System.Data.UniqueConstraint>加入至<xref:System.Data.ConstraintCollection>，但<xref:System.Data.DataTable.PrimaryKey%2A>屬性未設定。</xref:System.Data.DataTable.PrimaryKey%2A> </xref:System.Data.ConstraintCollection> </xref:System.Data.UniqueConstraint>      -如果傳回主要索引鍵資料行，唯一的資料行，主索引鍵資料行作為主索引鍵資料行<xref:System.Data.DataTable>.</xref:System.Data.DataTable>       請注意，會將主索引鍵和唯一條件約束加入至<xref:System.Data.ConstraintCollection>根據前述規則，但其他條件約束類型不會加入。</xref:System.Data.ConstraintCollection>       如果唯一叢集索引上的資料行或 SQL Server 資料表中的資料行定義和叢集索引中的資料行的名稱將會傳回一組個別的資料行上定義主索引鍵條件約束。 若要傳回的主索引鍵資料行的名稱，使用指定名稱的主索引鍵的 SELECT 陳述式中的查詢提示。 如需有關指定查詢提示的詳細資訊，請參閱[查詢提示 (TRANSACT-SQL)](http://msdn.microsoft.com/library/ms181714.aspx)。       如果<xref:System.Data.IDataAdapter>遇到重複的資料行在填入<xref:System.Data.DataTable>，它會產生後續的資料行，並使用模式的名稱&quot;*columnname*1&quot;，&quot;*columnname*2&quot;，&quot;*columnname*3 」，依此類推。</xref:System.Data.DataTable> </xref:System.Data.IDataAdapter> 如果內送資料中包含未命名資料行，它們會放置於<xref:System.Data.DataSet>根據模式&quot;Column1&quot;、&quot;Column2&quot;，等等。</xref:System.Data.DataSet> 當多個結果集加入至<xref:System.Data.DataSet>放置於個別的資料表中每個結果集。</xref:System.Data.DataSet> 其他結果集的命名方式是附加至指定的資料表名稱 （例如，&quot;Table&quot;、&quot;Table1&quot;、&quot;Table2&quot;等。） 的整數值。 使用資料行和資料表名稱的應用程式應確保這些命名模式衝突不會發生。       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 在這種情況下，<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>執行區分大小寫的比較，來尋找對應的資料表，並建立新的資料表，如果沒有完全相符項目存在。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   dataset.Tables.Add(&quot;AAA&quot;);   adapter.FillSchema(dataset, &quot;aaa&quot;); // Fills the schema of &quot;aaa&quot;, which already exists in the DataSet.   adapter.FillSchema(dataset, &quot;Aaa&quot;); // Adds a new table called &quot;Aaa&quot;.   ```如果<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();   dataset.Tables.Add(&quot;aaa&quot;);   adapter.FillSchema(dataset, &quot;AAA&quot;); // Fills the schema of table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```       <xref:System.Data.Common.DbDataAdapter.FillSchema%2A>不會傳回任何資料列。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>要加入資料列至<xref:System.Data.DataTable>。</xref:System.Data.DataTable>方法</xref:System.Data.Common.DbDataAdapter.Fill%2A>      > [!NOTE] > 時處理批次 SQL 陳述式會傳回多個結果，實作<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>的.NET Framework Data Provider for OLE DB 擷取結構描述資訊，只有第一個結果。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 若要擷取多個結果的結構描述資訊，請使用<xref:System.Data.Common.DbDataAdapter.Fill%2A>與<xref:System.Data.MissingSchemaAction>設`AddWithKey`。</xref:System.Data.MissingSchemaAction> </xref:System.Data.Common.DbDataAdapter.Fill%2A>       當使用<xref:System.Data.Common.DbDataAdapter.FillSchema%2A>，.NET Framework Data Provider for SQL Server 會將 FOR BROWSE 子句附加至正在執行的陳述式。</xref:System.Data.Common.DbDataAdapter.FillSchema%2A> 使用者應該注意潛在的副作用，例如使用 SET FMTONLY ON 陳述式的干擾。 如需詳細資訊，請參閱 SQL Server 線上叢書 》。"
  syntax:
    content: protected virtual System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType, System.Data.IDbCommand command, string srcTable, System.Data.CommandBehavior behavior);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref href=&quot;System.Data.DataSet&quot;> </xref>来填入資料來源的結構描述。"
    - id: schemaType
      type: System.Data.SchemaType
      description: "其中一個<xref href=&quot;System.Data.SchemaType&quot;></xref>值。"
    - id: command
      type: System.Data.IDbCommand
      description: "SQL SELECT 陳述式用於從資料來源擷取資料列。"
    - id: srcTable
      type: System.String
      description: "要用於資料表對應的來源資料表的名稱。"
    - id: behavior
      type: System.Data.CommandBehavior
      description: "其中一個<xref href=&quot;System.Data.CommandBehavior&quot;></xref>值。"
    return:
      type: System.Data.DataTable[]
      description: "陣列<xref href=&quot;System.Data.DataTable&quot;></xref>從資料來源傳回的物件，其中包含結構描述資訊。"
  overload: System.Data.Common.DbDataAdapter.FillSchema*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.GetBatchedParameter(System.Int32,System.Int32)
  id: GetBatchedParameter(System.Int32,System.Int32)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: GetBatchedParameter(Int32,Int32)
  nameWithType: DbDataAdapter.GetBatchedParameter(Int32,Int32)
  fullName: System.Data.Common.DbDataAdapter.GetBatchedParameter(Int32,Int32)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "傳回<xref href=&quot;System.Data.IDataParameter&quot;></xref>個目前的批次中的命令數。"
  remarks: "在中<xref:System.Data.Common.DbDataAdapter>，這個方法會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.Common.DbDataAdapter> 類別繼承自<xref:System.Data.Common.DbDataAdapter>覆寫這個方法以提供支援批次。</xref:System.Data.Common.DbDataAdapter>"
  syntax:
    content: protected virtual System.Data.IDataParameter GetBatchedParameter (int commandIdentifier, int parameterIndex);
    parameters:
    - id: commandIdentifier
      type: System.Int32
      description: "要從其中擷取參數命令的索引。"
    - id: parameterIndex
      type: System.Int32
      description: "命令參數的索引。"
    return:
      type: System.Data.IDataParameter
      description: "<xref href=&quot;System.Data.IDataParameter&quot;> </xref>指定。"
  overload: System.Data.Common.DbDataAdapter.GetBatchedParameter*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "配接器不支援批次。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(System.Int32,System.Int32@,System.Exception@)
  id: GetBatchedRecordsAffected(System.Int32,System.Int32@,System.Exception@)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: GetBatchedRecordsAffected(Int32,Int32,Exception)
  nameWithType: DbDataAdapter.GetBatchedRecordsAffected(Int32,Int32,Exception)
  fullName: System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(Int32,Int32,Exception)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "傳回在較大的批次更新內嘗試個別更新的相關資訊。"
  remarks: "支援批次更新邏輯的資料提供者必須覆寫一系列的<xref:System.Data.Common.DbDataAdapter>類別</xref:System.Data.Common.DbDataAdapter>上的虛擬方法 `GetBatchedRecordsAffected`代表其中一個這些虛擬方法。 `DbDataAdapter`類別會倚賴`GetBatchedRecordsAffected`來判斷成功或失敗的批次內的個別更新嘗試，因此它可以將標記各有一個對應<xref:System.Data.DataRow>據以。</xref:System.Data.DataRow>"
  syntax:
    content: protected virtual bool GetBatchedRecordsAffected (int commandIdentifier, out int recordsAffected, out Exception error);
    parameters:
    - id: commandIdentifier
      type: System.Int32
      description: "個別命令批次內之以零為起始的資料行序數。"
    - id: recordsAffected
      type: System.Int32
      description: "受影響的資料存放區中所指定的命令批次內的資料列數目。"
    - id: error
      type: System.Exception
      description: "<xref:System.Exception>指定命令執行期間擲回。</xref:System.Exception> 傳回<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref> (<xref uid=&quot;langword_csharp_Nothing&quot; name=&quot;Nothing&quot; href=&quot;&quot;> </xref>在 Visual Basic 中) 如果擲不回任何例外狀況。"
    return:
      type: System.Boolean
      description: "在較大的批次更新內嘗試個別更新的相關資訊。"
  overload: System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.GetFillParameters
  id: GetFillParameters
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: GetFillParameters()
  nameWithType: DbDataAdapter.GetFillParameters()
  fullName: System.Data.Common.DbDataAdapter.GetFillParameters()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "取得執行的 SQL SELECT 陳述式時，使用者所設定的參數。"
  syntax:
    content: public override System.Data.IDataParameter[] GetFillParameters ();
    parameters: []
    return:
      type: System.Data.IDataParameter[]
      description: "陣列<xref href=&quot;System.Data.IDataParameter&quot;></xref>使用者設定物件，包含的參數。"
  overload: System.Data.Common.DbDataAdapter.GetFillParameters*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.InitializeBatching
  id: InitializeBatching
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: InitializeBatching()
  nameWithType: DbDataAdapter.InitializeBatching()
  fullName: System.Data.Common.DbDataAdapter.InitializeBatching()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "初始化的批次<xref href=&quot;System.Data.Common.DbDataAdapter&quot;> </xref>。"
  remarks: "在中<xref:System.Data.Common.DbDataAdapter>，這個方法會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.Common.DbDataAdapter> 類別繼承自<xref:System.Data.Common.DbDataAdapter>覆寫這個方法以提供支援批次。</xref:System.Data.Common.DbDataAdapter>"
  syntax:
    content: protected virtual void InitializeBatching ();
    parameters: []
  overload: System.Data.Common.DbDataAdapter.InitializeBatching*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "配接器不支援批次。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.InsertCommand
  id: InsertCommand
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: InsertCommand
  nameWithType: DbDataAdapter.InsertCommand
  fullName: System.Data.Common.DbDataAdapter.InsertCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "取得或設定用來將新記錄插入至資料來源的命令。"
  remarks: "期間<xref:System.Data.Common.DbDataAdapter.Update%2A>，如果沒有設定這個屬性，並且出現在主索引鍵資訊<xref:System.Data.DataSet>、<xref:System.Data.IDbDataAdapter.InsertCommand%2A>就會自動產生。</xref:System.Data.IDbDataAdapter.InsertCommand%2A> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Update%2A>"
  example:
  - "The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.  \n  \n [!code-cs[Classic WebData DbDataAdapter.InsertCommand Example#1](~/add/codesnippet/csharp/p-system.data.common.dbd_0_1.cs)]\n [!code-vb[Classic WebData DbDataAdapter.InsertCommand Example#1](~/add/codesnippet/visualbasic/p-system.data.common.dbd_0_1.vb)]"
  syntax:
    content: public System.Data.Common.DbCommand InsertCommand { get; set; }
    return:
      type: System.Data.Common.DbCommand
      description: "A <xref href=&quot;System.Data.IDbCommand&quot;> </xref>期間使用<xref:System.Data.IDataAdapter.Update*>插入新資料列的資料集的資料來源中的記錄。</xref:System.Data.IDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.InsertCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)
  id: OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: OnRowUpdated(RowUpdatedEventArgs)
  nameWithType: DbDataAdapter.OnRowUpdated(RowUpdatedEventArgs)
  fullName: System.Data.Common.DbDataAdapter.OnRowUpdated(RowUpdatedEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "引發<xref uid=&quot;langword_csharp_RowUpdated&quot; name=&quot;RowUpdated&quot; href=&quot;&quot;> </xref> .NET Framework 資料提供者的事件。"
  remarks: '引發事件會透過委派事件處理常式叫用。 如需概觀，請參閱[NIB︰ 引發事件](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)。'
  syntax:
    content: protected virtual void OnRowUpdated (System.Data.Common.RowUpdatedEventArgs value);
    parameters:
    - id: value
      type: System.Data.Common.RowUpdatedEventArgs
      description: "A <xref href=&quot;System.Data.Common.RowUpdatedEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Data.Common.DbDataAdapter.OnRowUpdated*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)
  id: OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: OnRowUpdating(RowUpdatingEventArgs)
  nameWithType: DbDataAdapter.OnRowUpdating(RowUpdatingEventArgs)
  fullName: System.Data.Common.DbDataAdapter.OnRowUpdating(RowUpdatingEventArgs)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "引發<xref uid=&quot;langword_csharp_RowUpdating&quot; name=&quot;RowUpdating&quot; href=&quot;&quot;> </xref> .NET Framework 資料提供者的事件。"
  remarks: '引發事件會透過委派事件處理常式叫用。 如需概觀，請參閱[NIB︰ 引發事件](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2)。'
  syntax:
    content: protected virtual void OnRowUpdating (System.Data.Common.RowUpdatingEventArgs value);
    parameters:
    - id: value
      type: System.Data.Common.RowUpdatingEventArgs
      description: "<xref href=&quot;System.Data.Common.RowUpdatingEventArgs&quot;> </xref>包含事件資料。"
  overload: System.Data.Common.DbDataAdapter.OnRowUpdating*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.SelectCommand
  id: SelectCommand
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: SelectCommand
  nameWithType: DbDataAdapter.SelectCommand
  fullName: System.Data.Common.DbDataAdapter.SelectCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "取得或設定用來選取資料來源中的記錄的命令。"
  remarks: ''
  example:
  - "The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.  \n  \n [!code-cs[Classic WebData DbDataAdapter.SelectCommand Example#1](~/add/codesnippet/csharp/p-system.data.common.dbd_1_1.cs)]\n [!code-vb[Classic WebData DbDataAdapter.SelectCommand Example#1](~/add/codesnippet/visualbasic/p-system.data.common.dbd_1_1.vb)]"
  syntax:
    content: public System.Data.Common.DbCommand SelectCommand { get; set; }
    return:
      type: System.Data.Common.DbCommand
      description: "A <xref href=&quot;System.Data.IDbCommand&quot;> </xref>期間所使用<xref:System.Data.IDataAdapter.Update*>放置在資料集中的資料來源中選取記錄。</xref:System.Data.IDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.SelectCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand
  id: System#Data#IDbDataAdapter#DeleteCommand
  isEii: true
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: System.Data.IDbDataAdapter.DeleteCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.DeleteCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.DeleteCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "取得或設定從資料集中刪除記錄的 SQL 陳述式。"
  remarks: "這個成員是明確介面成員實作。 它可用時，才<xref:System.Data.Common.DbDataAdapter>執行個體轉換成<xref:System.Data.IDbDataAdapter>介面。</xref:System.Data.IDbDataAdapter> </xref:System.Data.Common.DbDataAdapter>       如需詳細資訊，請參閱<xref:System.Data.IDbDataAdapter.DeleteCommand%2A>.</xref:System.Data.IDbDataAdapter.DeleteCommand%2A>"
  syntax:
    content: System.Data.IDbCommand System.Data.IDbDataAdapter.DeleteCommand { get; set; }
    return:
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref>期間使用<xref:System.Data.Common.DbDataAdapter.Update*>資料集中刪除的資料列的資料來源中刪除記錄。</xref:System.Data.Common.DbDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand
  id: System#Data#IDbDataAdapter#InsertCommand
  isEii: true
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: System.Data.IDbDataAdapter.InsertCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.InsertCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.InsertCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "取得或設定用來將新記錄插入至資料來源的 SQL 陳述式。"
  remarks: "這個成員是明確介面成員實作。 它可用時，才<xref:System.Data.Common.DbDataAdapter>執行個體轉換成<xref:System.Data.IDbDataAdapter>介面。</xref:System.Data.IDbDataAdapter> </xref:System.Data.Common.DbDataAdapter>       如需詳細資訊，請參閱<xref:System.Data.IDbDataAdapter.InsertCommand%2A>.</xref:System.Data.IDbDataAdapter.InsertCommand%2A>"
  syntax:
    content: System.Data.IDbCommand System.Data.IDbDataAdapter.InsertCommand { get; set; }
    return:
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref>期間使用<xref:System.Data.Common.DbDataAdapter.Update*>插入新資料列的資料集的資料來源中的記錄。</xref:System.Data.Common.DbDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand
  id: System#Data#IDbDataAdapter#SelectCommand
  isEii: true
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: System.Data.IDbDataAdapter.SelectCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.SelectCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.SelectCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "取得或設定用來選取記錄的資料來源中的 SQL 陳述式。"
  remarks: "這個成員是明確介面成員實作。 它可用時，才<xref:System.Data.Common.DbDataAdapter>執行個體轉換成<xref:System.Data.IDbDataAdapter>介面。</xref:System.Data.IDbDataAdapter> </xref:System.Data.Common.DbDataAdapter>       如需詳細資訊，請參閱<xref:System.Data.IDbDataAdapter.SelectCommand%2A>.</xref:System.Data.IDbDataAdapter.SelectCommand%2A>"
  syntax:
    content: System.Data.IDbCommand System.Data.IDbDataAdapter.SelectCommand { get; set; }
    return:
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref>期間所使用<xref:System.Data.Common.DbDataAdapter.Update*>放置在資料集中的資料來源中選取記錄。</xref:System.Data.Common.DbDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand
  id: System#Data#IDbDataAdapter#UpdateCommand
  isEii: true
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: System.Data.IDbDataAdapter.UpdateCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.UpdateCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.UpdateCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "取得或設定用來更新資料來源中的之記錄的 SQL 陳述式。"
  remarks: "這個成員是明確介面成員實作。 它可用時，才<xref:System.Data.Common.DbDataAdapter>執行個體轉換成<xref:System.Data.IDbDataAdapter>介面。</xref:System.Data.IDbDataAdapter> </xref:System.Data.Common.DbDataAdapter>       如需詳細資訊，請參閱<xref:System.Data.IDbDataAdapter.UpdateCommand%2A>.</xref:System.Data.IDbDataAdapter.UpdateCommand%2A>"
  syntax:
    content: System.Data.IDbCommand System.Data.IDbDataAdapter.UpdateCommand { get; set; }
    return:
      type: System.Data.IDbCommand
      description: "<xref href=&quot;System.Data.IDbCommand&quot;> </xref>期間使用<xref:System.Data.Common.DbDataAdapter.Update*>修改資料集中的資料列的資料來源中更新記錄。</xref:System.Data.Common.DbDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.System#ICloneable#Clone
  id: System#ICloneable#Clone
  isEii: true
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: System.ICloneable.Clone()
  nameWithType: DbDataAdapter.System.ICloneable.Clone()
  fullName: System.Data.Common.DbDataAdapter.System.ICloneable.Clone()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "建立新的物件目前的執行個體的複本。"
  remarks: "這個成員是明確介面成員實作。 它可用時，才<xref:System.Data.Common.DbDataAdapter>執行個體轉換成<xref:System.ICloneable>介面。</xref:System.ICloneable> </xref:System.Data.Common.DbDataAdapter>       如需詳細資訊，請參閱<xref:System.ICloneable.Clone%2A?displayProperty=fullName>.</xref:System.ICloneable.Clone%2A?displayProperty=fullName>"
  syntax:
    content: object ICloneable.Clone ();
    parameters: []
    return:
      type: System.Object
      description: "新的物件，為這個執行個體的複本。"
  overload: System.Data.Common.DbDataAdapter.System#ICloneable#Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.TerminateBatching
  id: TerminateBatching
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: TerminateBatching()
  nameWithType: DbDataAdapter.TerminateBatching()
  fullName: System.Data.Common.DbDataAdapter.TerminateBatching()
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "結束的批次<xref href=&quot;System.Data.Common.DbDataAdapter&quot;> </xref>。"
  remarks: "在中<xref:System.Data.Common.DbDataAdapter>，這個方法會擲回<xref:System.NotSupportedException>.</xref:System.NotSupportedException> </xref:System.Data.Common.DbDataAdapter> 類別繼承自<xref:System.Data.Common.DbDataAdapter>覆寫這個方法以提供支援批次。</xref:System.Data.Common.DbDataAdapter>"
  syntax:
    content: protected virtual void TerminateBatching ();
    parameters: []
  overload: System.Data.Common.DbDataAdapter.TerminateBatching*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "配接器不支援批次。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[])
  id: Update(System.Data.DataRow[])
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Update(DataRow[])
  nameWithType: DbDataAdapter.Update(DataRow[])
  fullName: System.Data.Common.DbDataAdapter.Update(DataRow[])
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "執行個別的 INSERT、 UPDATE 或 DELETE 陳述式，針對每個插入、 更新或刪除資料列中指定的陣列中以更新資料庫中的值<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "當應用程式呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>方法，<xref:System.Data.Common.DbDataAdapter>檢查<xref:System.Data.DataRow.RowState%2A>屬性，並執行必要的 INSERT、 UPDATE 或 DELETE 陳述式，反覆地針對每個資料列，並根據<xref:System.Data.DataSet>.</xref:System.Data.DataSet>中設定的索引順序</xref:System.Data.DataRow.RowState%2A></xref:System.Data.Common.DbDataAdapter></xref:System.Data.Common.DbDataAdapter.Update%2A> 例如，<xref:System.Data.Common.DbDataAdapter.Update%2A>可能會執行 DELETE 陳述式，後面接著 INSERT 陳述式和另一個的 DELETE 陳述式，因為<xref:System.Data.DataTable>.</xref:System.Data.DataTable>中的資料列的順序</xref:System.Data.Common.DbDataAdapter.Update%2A>       請注意這些陳述式不會執行以批次的處理程序。個別更新每個資料列。 應用程式可以呼叫<xref:System.Data.DataSet.GetChanges%2A>情況下，您必須在其中控制陳述式型別 （例如，在更新之前插入） 順序的方法。</xref:System.Data.DataSet.GetChanges%2A> 如需詳細資訊，請參閱[以 Dataadapter 更新資料來源](~/add/includes/ajax-current-ext-md.md)。       如果尚未指定 INSERT、 UPDATE 或 DELETE 陳述式，<xref:System.Data.Common.DbDataAdapter.Update%2A>方法會產生例外狀況。</xref:System.Data.Common.DbDataAdapter.Update%2A> 不過，您可以建立<xref:System.Data.SqlClient.SqlCommandBuilder>或<xref:System.Data.OleDb.OleDbCommandBuilder>物件來自動產生的單一資料表更新 SQL 陳述式，如果您設定`SelectCommand`.NET Framework 資料提供者的屬性。</xref:System.Data.OleDb.OleDbCommandBuilder> </xref:System.Data.SqlClient.SqlCommandBuilder> 然後，您未設定任何其他 SQL 陳述式由產生**CommandBuilder**。 此產生邏輯需要存在於<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的索引鍵資料行資訊 如需詳細資訊，請參閱[Commandbuilder 產生命令](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Data.Common.DbDataAdapter.Update%2A>方法會從執行更新前的第一個對應中所列的資料表擷取資料列。</xref:System.Data.Common.DbDataAdapter.Update%2A> <xref:System.Data.Common.DbDataAdapter.Update%2A>然後重新整理使用的值的資料列<xref:System.Data.IDbCommand.UpdatedRowSource%2A>屬性。</xref:System.Data.IDbCommand.UpdatedRowSource%2A> </xref:System.Data.Common.DbDataAdapter.Update%2A> 傳回的任何其他資料列都會被忽略。       任何資料會載入回後<xref:System.Data.DataSet>、<xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>引發事件，讓使用者檢查調解<xref:System.Data.DataSet>資料列和任何輸出命令所傳回的參數。</xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> </xref:System.Data.DataSet> 已成功更新資料列之後，會接受該資料列所做的變更。       當使用<xref:System.Data.Common.DbDataAdapter.Update%2A>，執行的順序如下︰ 1。</xref:System.Data.Common.DbDataAdapter.Update%2A>  中的值<xref:System.Data.DataRow>移到參數值。</xref:System.Data.DataRow>      2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>就會引發事件。</xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>      3.  執行命令。      4.  如果命令設定為`FirstReturnedRecord`，第一個傳回的結果會放在<xref:System.Data.DataRow>.</xref:System.Data.DataRow>      5.  如果沒有輸出參數，它們會放置於<xref:System.Data.DataRow>.</xref:System.Data.DataRow>      6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>就會引發事件。</xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>      7.  <xref:System.Data.DataRow.AcceptChanges%2A>會呼叫。</xref:System.Data.DataRow.AcceptChanges%2A>       關聯<xref:System.Data.Common.DbDataAdapter>通常會有與其相關聯的參數集合</xref:System.Data.Common.DbDataAdapter>的每個命令 參數對應到目前的資料列，透過`SourceColumn`和`SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別。 `SourceColumn`是指<xref:System.Data.DataTable>資料行，<xref:System.Data.Common.DbDataAdapter>以取得目前資料列的參數值的參考。</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.DataTable>       `SourceColumn`在套用任何資料表對應之前，是指未對應的資料行名稱。 如果`SourceColumn`參考到不存在的資料行中，所採取的動作取決於下列其中一種<xref:System.Data.MissingMappingAction>值。</xref:System.Data.MissingMappingAction>      |列舉值 |採取動作 |  |-----------------------|------------------|  |`MissingMappingAction.Passthrough`|來源資料行名稱和資料表名稱使用<xref:System.Data.DataSet>中，如果不不存在任何對應。 |  |`MissingMappingAction.Ignore`|A<xref:System.SystemException>產生。</xref:System.SystemException> </xref:System.Data.DataSet> 對應會明確設定時，遺失對應的輸入的參數通常錯誤的結果。 |  |`MissingMappingAction.Error`|產生<xref:System.SystemException>。 |      `SourceColumn`屬性也用來對應輸出的值，或輸入/輸出參數回`DataSet`。</xref:System.SystemException> 如果它是指不存在的資料行，會產生例外狀況。       `SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別會決定是否要使用的資料行值的原始、 Current 或 Proposed 版本。 這項功能通常用於在 UPDATE 陳述式來檢查有開放式同步存取違規的 WHERE 子句中包含原始值。      > [!NOTE] > 如果更新的資料列時發生錯誤，擲回例外狀況和已停止執行更新。 若要繼續更新作業，而不會產生例外狀況，當發生錯誤時，設定<xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>屬性`true`之前呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>.</xref:System.Data.Common.DbDataAdapter.Update%2A> </xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 您可能也會回應內的每個資料列基礎上的錯誤`RowUpdated`DataAdapter 的事件。 若要繼續更新作業，而不會產生例外狀況中的`RowUpdated`事件時，設定<xref:System.Data.Common.RowUpdatedEventArgs.Status%2A><xref:System.Data.Common.RowUpdatedEventArgs>至<xref:System.Data.UpdateStatus>。</xref:System.Data.UpdateStatus></xref:System.Data.Common.RowUpdatedEventArgs>屬性</xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>"
  example:
  - "The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.  \n  \n [!code-cs[Classic WebData DbDataAdapter.Update1 Example#1](~/add/codesnippet/csharp/m-system.data.common.dbd_0_1.cs)]\n [!code-vb[Classic WebData DbDataAdapter.Update1 Example#1](~/add/codesnippet/visualbasic/m-system.data.common.dbd_0_1.vb)]"
  syntax:
    content: public int Update (System.Data.DataRow[] dataRows);
    parameters:
    - id: dataRows
      type: System.Data.DataRow[]
      description: "陣列<xref href=&quot;System.Data.DataRow&quot;></xref>用來更新資料來源的物件。"
    return:
      type: System.Int32
      description: "已成功從更新的資料列數目<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.Common.DbDataAdapter.Update*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref href=&quot;System.Data.DataSet&quot;> </xref>無效。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無效的來源資料表。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "否<xref href=&quot;System.Data.DataRow&quot;></xref>有更新。       -或-否<xref href=&quot;System.Data.DataTable&quot;></xref>有更新。       -或-否<xref href=&quot;System.Data.DataSet&quot;></xref>存在要當做來源使用。"
  - type: System.Data.DBConcurrencyException
    commentId: T:System.Data.DBConcurrencyException
    description: "嘗試執行的 INSERT、 UPDATE 或 DELETE 陳述式產生零個受影響的記錄。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)
  id: Update(System.Data.DataSet)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Update(DataSet)
  nameWithType: DbDataAdapter.Update(DataSet)
  fullName: System.Data.Common.DbDataAdapter.Update(DataSet)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "更新資料庫中的值，藉由執行個別的 INSERT、 UPDATE 或 DELETE 陳述式，針對每個插入、 更新或刪除資料列中指定<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  remarks: "當應用程式呼叫更新方法時，<xref:System.Data.Common.DbDataAdapter>檢查<xref:System.Data.DataRow.RowState%2A>屬性，並執行必要的 INSERT、 UPDATE 或 DELETE 陳述式，反覆地針對每個資料列，並根據<xref:System.Data.DataSet>.</xref:System.Data.DataSet>中設定的索引順序</xref:System.Data.DataRow.RowState%2A></xref:System.Data.Common.DbDataAdapter> 比方說，更新可能會執行 DELETE 陳述式，後面接著 INSERT 陳述式和另一個的 DELETE 陳述式，因為<xref:System.Data.DataTable>.</xref:System.Data.DataTable>中的資料列的順序       請注意這些陳述式不會執行以批次的處理程序。個別更新每個資料列。 應用程式可以呼叫<xref:System.Data.DataSet.GetChanges%2A>情況下，您必須在其中控制陳述式型別 （例如，在更新之前插入） 順序的方法。</xref:System.Data.DataSet.GetChanges%2A> 如需詳細資訊，請參閱[以 Dataadapter 更新資料來源](~/add/includes/ajax-current-ext-md.md)。       如果 INSERT、 UPDATE 或 DELETE 陳述式未指定，更新方法會產生例外狀況。 不過，您可以建立<xref:System.Data.SqlClient.SqlCommandBuilder>或<xref:System.Data.OleDb.OleDbCommandBuilder>物件來自動產生的單一資料表更新 SQL 陳述式，如果您設定`SelectCommand`.NET Framework 資料提供者的屬性。</xref:System.Data.OleDb.OleDbCommandBuilder> </xref:System.Data.SqlClient.SqlCommandBuilder> 然後，您未設定任何其他 SQL 陳述式由產生**CommandBuilder**。 此產生邏輯需要存在於<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的索引鍵資料行資訊 如需詳細資訊，請參閱[Commandbuilder 產生命令](~/add/includes/ajax-current-ext-md.md)。       Update 方法之前執行更新的第一個對應中所列的資料表中擷取資料列。 更新會再重新整理使用的值的資料列<xref:System.Data.IDbCommand.UpdatedRowSource%2A>屬性。</xref:System.Data.IDbCommand.UpdatedRowSource%2A> 傳回的任何其他資料列都會被忽略。       任何資料會載入回後<xref:System.Data.DataSet>、<xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>引發事件，讓使用者檢查調解<xref:System.Data.DataSet>資料列和任何輸出命令所傳回的參數。</xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> </xref:System.Data.DataSet> 已成功更新資料列之後，會接受該資料列所做的變更。       使用 Update，執行的順序時，如下所示︰ 1。  中的值<xref:System.Data.DataRow>移到參數值。</xref:System.Data.DataRow>      2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>就會引發事件。</xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>      3.  執行命令。      4.  如果命令設定為`FirstReturnedRecord`，則第一個傳回結果會放在<xref:System.Data.DataRow>.</xref:System.Data.DataRow>      5.  如果沒有輸出參數，它們會放置於<xref:System.Data.DataRow>.</xref:System.Data.DataRow>      6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>就會引發事件。</xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>      7.  <xref:System.Data.DataRow.AcceptChanges%2A>會呼叫。</xref:System.Data.DataRow.AcceptChanges%2A>       關聯<xref:System.Data.Common.DbDataAdapter>通常會有與其相關聯的參數集合</xref:System.Data.Common.DbDataAdapter>的每個命令 參數對應到目前的資料列，透過`SourceColumn`和`SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別。 `SourceColumn`是指<xref:System.Data.DataTable>資料行，<xref:System.Data.Common.DbDataAdapter>以取得目前資料列的參數值的參考。</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.DataTable>       `SourceColumn`在套用任何資料表對應之前，是指未對應的資料行名稱。 如果`SourceColumn`參考到不存在的資料行中，所採取的動作取決於下列其中一種<xref:System.Data.MissingMappingAction>值。</xref:System.Data.MissingMappingAction>      |列舉值 |採取動作 |  |-----------------------|------------------|  |`MissingMappingAction.Passthrough`|來源資料行名稱和資料表名稱使用<xref:System.Data.DataSet>中，如果不不存在任何對應。 |  |`MissingMappingAction.Ignore`|A<xref:System.SystemException>產生。</xref:System.SystemException> </xref:System.Data.DataSet> 對應會明確設定時，遺失對應的輸入的參數通常錯誤的結果。 |  |`MissingMappingAction.Error`|產生<xref:System.SystemException>。 |      `SourceColumn`屬性也用來對應輸出的值，或輸入/輸出參數回`DataSet`。</xref:System.SystemException> 如果它是指不存在的資料行，會產生例外狀況。       `SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別會決定是否要使用的資料行值的原始、 Current 或 Proposed 版本。 這項功能通常用於在 UPDATE 陳述式來檢查有開放式同步存取違規的 WHERE 子句中包含原始值。      > [!NOTE] > 如果更新的資料列時發生錯誤，擲回例外狀況和已停止執行更新。 若要繼續更新作業，而不會產生例外狀況，當發生錯誤時，設定<xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>屬性`true`呼叫之前更新。</xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 您可能也會回應內的每個資料列基礎上的錯誤`RowUpdated`DataAdapter 的事件。 若要繼續更新作業，而不會產生例外狀況中的`RowUpdated`事件時，設定<xref:System.Data.Common.RowUpdatedEventArgs.Status%2A><xref:System.Data.Common.RowUpdatedEventArgs>至<xref:System.Data.UpdateStatus>。</xref:System.Data.UpdateStatus></xref:System.Data.Common.RowUpdatedEventArgs>屬性</xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>"
  example:
  - "The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.  \n  \n [!code-vb[Classic WebData DbDataAdapter.Update Example#1](~/add/codesnippet/visualbasic/m-system.data.common.dbd_4_1.vb)]\n [!code-cs[Classic WebData DbDataAdapter.Update Example#1](~/add/codesnippet/csharp/m-system.data.common.dbd_4_1.cs)]"
  syntax:
    content: public override int Update (System.Data.DataSet dataSet);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref href=&quot;System.Data.DataSet&quot;> </xref>用來更新資料來源。"
    return:
      type: System.Int32
      description: "已成功從更新的資料列數目<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.Common.DbDataAdapter.Update*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無效的來源資料表。"
  - type: System.Data.DBConcurrencyException
    commentId: T:System.Data.DBConcurrencyException
    description: "嘗試執行的 INSERT、 UPDATE 或 DELETE 陳述式產生零個受影響的記錄。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataTable)
  id: Update(System.Data.DataTable)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Update(DataTable)
  nameWithType: DbDataAdapter.Update(DataTable)
  fullName: System.Data.Common.DbDataAdapter.Update(DataTable)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "更新資料庫中的值，藉由執行個別的 INSERT、 UPDATE 或 DELETE 陳述式，針對每個插入、 更新或刪除資料列中指定<xref href=&quot;System.Data.DataTable&quot;> </xref>。"
  remarks: "當應用程式呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>方法，<xref:System.Data.Common.DbDataAdapter>檢查<xref:System.Data.DataRow.RowState%2A>屬性，並執行必要的 INSERT、 UPDATE 或 DELETE 陳述式，反覆地針對每個資料列，並根據<xref:System.Data.DataSet>.</xref:System.Data.DataSet>中設定的索引順序</xref:System.Data.DataRow.RowState%2A></xref:System.Data.Common.DbDataAdapter></xref:System.Data.Common.DbDataAdapter.Update%2A> 例如，<xref:System.Data.Common.DbDataAdapter.Update%2A>可能會執行 DELETE 陳述式，後面接著 INSERT 陳述式和另一個的 DELETE 陳述式，因為<xref:System.Data.DataTable>.</xref:System.Data.DataTable>中的資料列的順序</xref:System.Data.Common.DbDataAdapter.Update%2A>       請注意這些陳述式不會執行以批次的處理程序。個別更新每個資料列。 應用程式可以呼叫<xref:System.Data.DataSet.GetChanges%2A>情況下，您必須在其中控制陳述式型別 （例如，在更新之前插入） 順序的方法。</xref:System.Data.DataSet.GetChanges%2A> 如需詳細資訊，請參閱[以 Dataadapter 更新資料來源](~/add/includes/ajax-current-ext-md.md)。       如果尚未指定 INSERT、 UPDATE 或 DELETE 陳述式，<xref:System.Data.Common.DbDataAdapter.Update%2A>方法會產生例外狀況。</xref:System.Data.Common.DbDataAdapter.Update%2A> 不過，您可以建立<xref:System.Data.SqlClient.SqlCommandBuilder>或<xref:System.Data.OleDb.OleDbCommandBuilder>物件來自動產生的單一資料表更新 SQL 陳述式，如果您設定`SelectCommand`.NET Framework 資料提供者的屬性。</xref:System.Data.OleDb.OleDbCommandBuilder> </xref:System.Data.SqlClient.SqlCommandBuilder> 然後，您未設定任何其他 SQL 陳述式由產生**CommandBuilder**。 此產生邏輯需要存在於<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的索引鍵資料行資訊 如需詳細資訊，請參閱[Commandbuilder 產生命令](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Data.Common.DbDataAdapter.Update%2A>方法會從執行更新前的第一個對應中所列的資料表擷取資料列。</xref:System.Data.Common.DbDataAdapter.Update%2A> <xref:System.Data.Common.DbDataAdapter.Update%2A>然後重新整理使用的值的資料列<xref:System.Data.IDbCommand.UpdatedRowSource%2A>屬性。</xref:System.Data.IDbCommand.UpdatedRowSource%2A> </xref:System.Data.Common.DbDataAdapter.Update%2A> 傳回的任何其他資料列都會被忽略。       任何資料會載入回後<xref:System.Data.DataSet>、<xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>引發事件，讓使用者檢查調解<xref:System.Data.DataSet>資料列和任何輸出命令所傳回的參數。</xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> </xref:System.Data.DataSet> 已成功更新資料列之後，會接受該資料列所做的變更。       當使用<xref:System.Data.Common.DbDataAdapter.Update%2A>，執行的順序如下︰ 1。</xref:System.Data.Common.DbDataAdapter.Update%2A>  中的值<xref:System.Data.DataRow>移到參數值。</xref:System.Data.DataRow>      2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>就會引發事件。</xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>      3.  執行命令。      4.  如果命令設定為`FirstReturnedRecord`，則第一個傳回結果會放在<xref:System.Data.DataRow>.</xref:System.Data.DataRow>      5.  如果沒有輸出參數，它們會放置於<xref:System.Data.DataRow>.</xref:System.Data.DataRow>      6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>就會引發事件。</xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>      7.  <xref:System.Data.DataRow.AcceptChanges%2A>會呼叫。</xref:System.Data.DataRow.AcceptChanges%2A>       關聯<xref:System.Data.Common.DbDataAdapter>通常會有與其相關聯的參數集合</xref:System.Data.Common.DbDataAdapter>的每個命令 參數對應到目前的資料列，透過`SourceColumn`和`SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別。 `SourceColumn`是指<xref:System.Data.DataTable>資料行，<xref:System.Data.Common.DbDataAdapter>以取得目前資料列的參數值的參考。</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.DataTable>       `SourceColumn`在套用任何資料表對應之前，是指未對應的資料行名稱。 如果`SourceColumn`參考到不存在的資料行中，所採取的動作取決於下列其中一種<xref:System.Data.MissingMappingAction>值。</xref:System.Data.MissingMappingAction>      |列舉值 |採取動作 |  |-----------------------|------------------|  |`MissingMappingAction.Passthrough`|來源資料行名稱和資料表名稱使用<xref:System.Data.DataSet>中，如果不不存在任何對應。 |  |`MissingMappingAction.Ignore`|A<xref:System.SystemException>產生。</xref:System.SystemException> </xref:System.Data.DataSet> 對應會明確設定時，遺失對應的輸入的參數通常錯誤的結果。 |  |`MissingMappingAction.Error`|產生<xref:System.SystemException>。 |      `SourceColumn`屬性也用來對應輸出的值，或輸入/輸出參數回`DataSet`。</xref:System.SystemException> 如果它是指不存在的資料行，會產生例外狀況。       `SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別會決定是否要使用的資料行值的原始、 Current 或 Proposed 版本。 這項功能通常用於在 UPDATE 陳述式來檢查有開放式同步存取違規的 WHERE 子句中包含原始值。      > [!NOTE] > 如果更新的資料列時發生錯誤，擲回例外狀況和已停止執行更新。 若要繼續更新作業，而不會產生例外狀況，當發生錯誤時，設定<xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>屬性`true`之前呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>.</xref:System.Data.Common.DbDataAdapter.Update%2A> </xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 您可能也會回應內的每個資料列基礎上的錯誤`RowUpdated`DataAdapter 的事件。 若要繼續更新作業，而不會產生例外狀況中的`RowUpdated`事件時，設定<xref:System.Data.Common.RowUpdatedEventArgs.Status%2A><xref:System.Data.Common.RowUpdatedEventArgs>至<xref:System.Data.UpdateStatus>。</xref:System.Data.UpdateStatus></xref:System.Data.Common.RowUpdatedEventArgs>屬性</xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>"
  example:
  - "The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.  \n  \n [!code-vb[Classic WebData DbDataAdapter.Update2 Example#1](~/add/codesnippet/visualbasic/m-system.data.common.dbd_1_1.vb)]\n [!code-cs[Classic WebData DbDataAdapter.Update2 Example#1](~/add/codesnippet/csharp/m-system.data.common.dbd_1_1.cs)]"
  syntax:
    content: public int Update (System.Data.DataTable dataTable);
    parameters:
    - id: dataTable
      type: System.Data.DataTable
      description: "<xref href=&quot;System.Data.DataTable&quot;> </xref>用來更新資料來源。"
    return:
      type: System.Int32
      description: "已成功從更新的資料列數目<xref href=&quot;System.Data.DataTable&quot;> </xref>。"
  overload: System.Data.Common.DbDataAdapter.Update*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref href=&quot;System.Data.DataSet&quot;> </xref>無效。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無效的來源資料表。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "否<xref href=&quot;System.Data.DataRow&quot;></xref>有更新。       -或-否<xref href=&quot;System.Data.DataTable&quot;></xref>有更新。       -或-否<xref href=&quot;System.Data.DataSet&quot;></xref>存在要當做來源使用。"
  - type: System.Data.DBConcurrencyException
    commentId: T:System.Data.DBConcurrencyException
    description: "嘗試執行的 INSERT、 UPDATE 或 DELETE 陳述式產生零個受影響的記錄。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)
  id: Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Update(DataRow[],DataTableMapping)
  nameWithType: DbDataAdapter.Update(DataRow[],DataTableMapping)
  fullName: System.Data.Common.DbDataAdapter.Update(DataRow[],DataTableMapping)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "更新資料庫中的值，藉由執行個別的 INSERT、 UPDATE 或 DELETE 陳述式，針對每個插入、 更新或刪除資料列中指定的陣列<xref href=&quot;System.Data.DataSet&quot;></xref>物件。"
  remarks: "當應用程式呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>方法，<xref:System.Data.Common.DbDataAdapter>檢查<xref:System.Data.DataRow.RowState%2A>屬性，並執行必要的 INSERT、 UPDATE 或 DELETE 陳述式，反覆地針對每個資料列，並根據<xref:System.Data.DataSet>.</xref:System.Data.DataSet>中設定的索引順序</xref:System.Data.DataRow.RowState%2A></xref:System.Data.Common.DbDataAdapter></xref:System.Data.Common.DbDataAdapter.Update%2A> 例如，<xref:System.Data.Common.DbDataAdapter.Update%2A>可能會執行 DELETE 陳述式，後面接著 INSERT 陳述式和另一個的 DELETE 陳述式，因為<xref:System.Data.DataTable>.</xref:System.Data.DataTable>中的資料列的順序</xref:System.Data.Common.DbDataAdapter.Update%2A>       請注意這些陳述式不會執行以批次的處理程序。個別更新每個資料列。 應用程式可以呼叫<xref:System.Data.DataSet.GetChanges%2A>情況下，您必須在其中控制陳述式型別 （例如，在更新之前插入） 順序的方法。</xref:System.Data.DataSet.GetChanges%2A> 如需詳細資訊，請參閱[以 Dataadapter 更新資料來源](~/add/includes/ajax-current-ext-md.md)。       如果尚未指定 INSERT、 UPDATE 或 DELETE 陳述式，<xref:System.Data.Common.DbDataAdapter.Update%2A>方法會產生例外狀況。</xref:System.Data.Common.DbDataAdapter.Update%2A> 不過，您可以建立<xref:System.Data.SqlClient.SqlCommandBuilder>或<xref:System.Data.OleDb.OleDbCommandBuilder>物件來自動產生的單一資料表更新 SQL 陳述式，如果您設定`SelectCommand`.NET Framework 資料提供者的屬性。</xref:System.Data.OleDb.OleDbCommandBuilder> </xref:System.Data.SqlClient.SqlCommandBuilder> 然後，您未設定任何其他 SQL 陳述式由產生**CommandBuilder**。 此產生邏輯需要存在於<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的索引鍵資料行資訊 如需詳細資訊，請參閱[Commandbuilder 產生命令](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Data.Common.DbDataAdapter.Update%2A>方法會從執行更新前的第一個對應中所列的資料表擷取資料列。</xref:System.Data.Common.DbDataAdapter.Update%2A> <xref:System.Data.Common.DbDataAdapter.Update%2A>然後重新整理使用的值的資料列<xref:System.Data.IDbCommand.UpdatedRowSource%2A>屬性。</xref:System.Data.IDbCommand.UpdatedRowSource%2A> </xref:System.Data.Common.DbDataAdapter.Update%2A> 傳回的任何其他資料列都會被忽略。       任何資料會載入回後<xref:System.Data.DataSet>、<xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>引發事件，讓使用者檢查調解<xref:System.Data.DataSet>資料列和任何輸出命令所傳回的參數。</xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> </xref:System.Data.DataSet> 已成功更新資料列之後，會接受該資料列所做的變更。       當使用<xref:System.Data.Common.DbDataAdapter.Update%2A>，執行的順序如下︰ 1。</xref:System.Data.Common.DbDataAdapter.Update%2A>  中的值<xref:System.Data.DataRow>移到參數值。</xref:System.Data.DataRow>      2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>就會引發事件。</xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>      3.  執行命令。      4.  如果命令設定為`FirstReturnedRecord`，則第一個傳回結果會放在<xref:System.Data.DataRow>.</xref:System.Data.DataRow>      5.  如果沒有輸出參數，它們會放置於<xref:System.Data.DataRow>.</xref:System.Data.DataRow>      6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>就會引發事件。</xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>      7.  <xref:System.Data.DataRow.AcceptChanges%2A>會呼叫。</xref:System.Data.DataRow.AcceptChanges%2A>       關聯<xref:System.Data.Common.DbDataAdapter>通常會有與其相關聯的參數集合</xref:System.Data.Common.DbDataAdapter>的每個命令 參數對應到目前的資料列，透過`SourceColumn`和`SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別。 `SourceColumn`是指<xref:System.Data.DataTable>資料行，<xref:System.Data.Common.DbDataAdapter>以取得目前資料列的參數值的參考。</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.DataTable>       `SourceColumn`在套用任何資料表對應之前，是指未對應的資料行名稱。 如果`SourceColumn`參考到不存在的資料行中，所採取的動作取決於下列其中一種<xref:System.Data.MissingMappingAction>值。</xref:System.Data.MissingMappingAction>      |列舉值 |採取動作 |  |-----------------------|------------------|  |`MissingMappingAction.Passthrough`|來源資料行名稱和資料表名稱使用<xref:System.Data.DataSet>中，如果不不存在任何對應。 |  |`MissingMappingAction.Ignore`|A<xref:System.SystemException>產生。</xref:System.SystemException> </xref:System.Data.DataSet> 對應會明確設定時，遺失對應的輸入的參數通常錯誤的結果。 |  |`MissingMappingAction.Error`|產生<xref:System.SystemException>。 |      `SourceColumn`屬性也用來對應輸出的值，或輸入/輸出參數回`DataSet`。</xref:System.SystemException> 如果它是指不存在的資料行，會產生例外狀況。       `SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別會決定是否要使用的資料行值的原始、 Current 或 Proposed 版本。 這項功能通常用於在 UPDATE 陳述式來檢查有開放式同步存取違規的 WHERE 子句中包含原始值。      > [!NOTE] > 如果更新的資料列時發生錯誤，擲回例外狀況和已停止執行更新。 若要繼續更新作業，而不會產生例外狀況，當發生錯誤時，設定<xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>屬性`true`之前呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>.</xref:System.Data.Common.DbDataAdapter.Update%2A> </xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 您可能也會回應內的每個資料列基礎上的錯誤`RowUpdated`DataAdapter 的事件。 若要繼續更新作業，而不會產生例外狀況中的`RowUpdated`事件時，設定<xref:System.Data.Common.RowUpdatedEventArgs.Status%2A><xref:System.Data.Common.RowUpdatedEventArgs>至<xref:System.Data.UpdateStatus>。</xref:System.Data.UpdateStatus></xref:System.Data.Common.RowUpdatedEventArgs>屬性</xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>"
  syntax:
    content: protected virtual int Update (System.Data.DataRow[] dataRows, System.Data.Common.DataTableMapping tableMapping);
    parameters:
    - id: dataRows
      type: System.Data.DataRow[]
      description: "陣列<xref href=&quot;System.Data.DataRow&quot;></xref>用來更新資料來源的物件。"
    - id: tableMapping
      type: System.Data.Common.DataTableMapping
      description: "<xref:System.Data.IDataAdapter.TableMappings*>要使用的集合。</xref:System.Data.IDataAdapter.TableMappings*>"
    return:
      type: System.Int32
      description: "已成功從更新的資料列數目<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.Common.DbDataAdapter.Update*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref href=&quot;System.Data.DataSet&quot;> </xref>無效。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無效的來源資料表。"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "否<xref href=&quot;System.Data.DataRow&quot;></xref>有更新。       -或-否<xref href=&quot;System.Data.DataTable&quot;></xref>有更新。       -或-否<xref href=&quot;System.Data.DataSet&quot;></xref>存在要當做來源使用。"
  - type: System.Data.DBConcurrencyException
    commentId: T:System.Data.DBConcurrencyException
    description: "嘗試執行的 INSERT、 UPDATE 或 DELETE 陳述式產生零個受影響的記錄。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataSet,System.String)
  id: Update(System.Data.DataSet,System.String)
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: Update(DataSet,String)
  nameWithType: DbDataAdapter.Update(DataSet,String)
  fullName: System.Data.Common.DbDataAdapter.Update(DataSet,String)
  type: Method
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "執行個別的 INSERT、 UPDATE 或 DELETE 陳述式，針對每個插入、 更新或刪除資料列中的，以更新資料庫中的值<xref href=&quot;System.Data.DataSet&quot;></xref>具有指定<xref href=&quot;System.Data.DataTable&quot;></xref>名稱。"
  remarks: "當應用程式呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>方法，<xref:System.Data.Common.DbDataAdapter>檢查<xref:System.Data.DataRow.RowState%2A>屬性，並執行必要的 INSERT、 UPDATE 或 DELETE 陳述式，反覆地針對每個資料列，並根據<xref:System.Data.DataSet>.</xref:System.Data.DataSet>中設定的索引順序</xref:System.Data.DataRow.RowState%2A></xref:System.Data.Common.DbDataAdapter></xref:System.Data.Common.DbDataAdapter.Update%2A> 例如，<xref:System.Data.Common.DbDataAdapter.Update%2A>可能會執行 DELETE 陳述式，後面接著 INSERT 陳述式和另一個的 DELETE 陳述式，因為<xref:System.Data.DataTable>.</xref:System.Data.DataTable>中的資料列的順序</xref:System.Data.Common.DbDataAdapter.Update%2A>       請注意這些陳述式不會執行以批次的處理程序。個別更新每個資料列。 應用程式可以呼叫<xref:System.Data.DataSet.GetChanges%2A>情況下，您必須在其中控制陳述式型別序列中的方法 （例如，更新之前插入）。</xref:System.Data.DataSet.GetChanges%2A> 如需詳細資訊，請參閱[以 Dataadapter 更新資料來源](~/add/includes/ajax-current-ext-md.md)。       如果尚未指定 INSERT、 UPDATE 或 DELETE 陳述式，<xref:System.Data.Common.DbDataAdapter.Update%2A>方法會產生例外狀況。</xref:System.Data.Common.DbDataAdapter.Update%2A> 不過，您可以建立<xref:System.Data.SqlClient.SqlCommandBuilder>或<xref:System.Data.OleDb.OleDbCommandBuilder>物件來自動產生的單一資料表更新 SQL 陳述式，如果您設定`SelectCommand`.NET Framework 資料提供者的屬性。</xref:System.Data.OleDb.OleDbCommandBuilder> </xref:System.Data.SqlClient.SqlCommandBuilder> 然後，您未設定任何其他 SQL 陳述式由產生**CommandBuilder**。 此產生邏輯需要存在於<xref:System.Data.DataSet>.</xref:System.Data.DataSet>的索引鍵資料行資訊 如需詳細資訊，請參閱[Commandbuilder 產生命令](~/add/includes/ajax-current-ext-md.md)。       <xref:System.Data.Common.DbDataAdapter.Update%2A>方法支援案例其中<xref:System.Data.DataSet>包含多個<xref:System.Data.DataTable>名稱只有大小寫不同的物件。</xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Update%2A> 當多個資料表具有名稱相同但大小寫不同，存在於`DataSet`，<xref:System.Data.Common.DbDataAdapter.Update%2A>執行區分大小寫的比較，來尋找對應的資料表，並產生例外狀況，如果沒有完全相符項目存在。</xref:System.Data.Common.DbDataAdapter.Update%2A> 下列 C# 程式碼說明這個行為。      ```   DataSet ds = new DataSet();    ds.Tables.Add(&quot;aaa&quot;);    ds.Tables.Add(&quot;AAA&quot;);    adapter.Update(ds, &quot;aaa&quot;); // Updates &quot;aaa&quot;, which already exists in the DataSet.    adapter.Update(ds, &quot;AAA&quot;); // Updates &quot;AAA&quot;, which already exists in the DataSet.       adapter.Update(ds, &quot;Aaa&quot;); // Results in an exception.   ```如果<xref:System.Data.Common.DbDataAdapter.Update%2A>稱為和<xref:System.Data.DataSet>只包含<xref:System.Data.DataTable>名稱只有大小寫不同的<xref:System.Data.DataTable>會更新。</xref:System.Data.DataTable> </xref:System.Data.DataTable> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Update%2A> 在此案例中，這個比較是不區分大小寫。 下列 C# 程式碼說明這個行為。      ```   DataSet dataset = new DataSet();    dataset.Tables.Add(&quot;aaa&quot;);       adapter.Update(dataset, &quot;AAA&quot;); // Updates table &quot;aaa&quot; because only one similarly named table is in the DataSet.   ```<xref:System.Data.Common.DbDataAdapter.Update%2A>方法會從執行更新前的第一個對應中所列的資料表擷取資料列。</xref:System.Data.Common.DbDataAdapter.Update%2A> <xref:System.Data.Common.DbDataAdapter.Update%2A>然後重新整理使用的值的資料列<xref:System.Data.IDbCommand.UpdatedRowSource%2A>屬性。</xref:System.Data.IDbCommand.UpdatedRowSource%2A> </xref:System.Data.Common.DbDataAdapter.Update%2A> 傳回的任何其他資料列都會被忽略。       任何資料會載入回後<xref:System.Data.DataSet>、<xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>引發事件，讓使用者檢查調解<xref:System.Data.DataSet>資料列和任何輸出命令所傳回的參數。</xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> </xref:System.Data.DataSet> 已成功更新資料列之後，會接受該資料列所做的變更。       當使用<xref:System.Data.Common.DbDataAdapter.Update%2A>，執行的順序如下︰ 1。</xref:System.Data.Common.DbDataAdapter.Update%2A>  中的值<xref:System.Data.DataRow>移到參數值。</xref:System.Data.DataRow>      2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>就會引發事件。</xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>      3.  執行命令。      4.  如果命令設定為`FirstReturnedRecord`，則第一個傳回結果會放在<xref:System.Data.DataRow>.</xref:System.Data.DataRow>      5.  如果沒有輸出參數，它們會放置於<xref:System.Data.DataRow>.</xref:System.Data.DataRow>      6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>就會引發事件。</xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>      7.  <xref:System.Data.DataRow.AcceptChanges%2A>會呼叫。</xref:System.Data.DataRow.AcceptChanges%2A>       關聯<xref:System.Data.Common.DbDataAdapter>通常會有與其相關聯的參數集合</xref:System.Data.Common.DbDataAdapter>的每個命令 參數對應到目前的資料列，透過`SourceColumn`和`SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別。 `SourceColumn`是指<xref:System.Data.DataTable>資料行，<xref:System.Data.Common.DbDataAdapter>以取得目前資料列的參數值的參考。</xref:System.Data.Common.DbDataAdapter> </xref:System.Data.DataTable>       `SourceColumn`在套用任何資料表對應之前，是指未對應的資料行名稱。 如果`SourceColumn`參考到不存在的資料行中，所採取的動作取決於下列其中一種<xref:System.Data.MissingMappingAction>值。</xref:System.Data.MissingMappingAction>      |列舉值 |採取動作 |  |-----------------------|------------------|  |`MissingMappingAction.Passthrough`|來源資料行名稱和資料表名稱使用<xref:System.Data.DataSet>中，如果不不存在任何對應。 |  |`MissingMappingAction.Ignore`|A<xref:System.SystemException>產生。</xref:System.SystemException> </xref:System.Data.DataSet> 對應會明確設定時，遺失對應的輸入的參數通常錯誤的結果。 |  |`MissingMappingAction.Error`|產生<xref:System.SystemException>。 |      `SourceColumn`屬性也用來對應輸出的值，或輸入/輸出參數回`DataSet`。</xref:System.SystemException> 如果它是指不存在的資料行，會產生例外狀況。       `SourceVersion`的.NET Framework 資料提供者的屬性`Parameter`類別會決定是否要使用的資料行值的原始、 Current 或 Proposed 版本。 這項功能通常用於在 UPDATE 陳述式來檢查有開放式同步存取違規的 WHERE 子句中包含原始值。      > [!NOTE] > 如果更新的資料列時發生錯誤，擲回例外狀況和已停止執行更新。 若要繼續更新作業，而不會產生例外狀況，當發生錯誤時，設定<xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A>屬性`true`之前呼叫<xref:System.Data.Common.DbDataAdapter.Update%2A>.</xref:System.Data.Common.DbDataAdapter.Update%2A> </xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> 您可能也會回應內的每個資料列基礎上的錯誤`RowUpdated`DataAdapter 的事件。 若要繼續更新作業，而不會產生例外狀況中的`RowUpdated`事件時，設定<xref:System.Data.Common.RowUpdatedEventArgs.Status%2A><xref:System.Data.Common.RowUpdatedEventArgs>至<xref:System.Data.UpdateStatus>。</xref:System.Data.UpdateStatus></xref:System.Data.Common.RowUpdatedEventArgs>屬性</xref:System.Data.Common.RowUpdatedEventArgs.Status%2A>"
  example:
  - "The following example uses the derived class, <xref:System.Data.OleDb.OleDbDataAdapter>, to update the data source.  \n  \n [!code-cs[Classic WebData DbDataAdapter.Update3#1](~/add/codesnippet/csharp/m-system.data.common.dbd_2_1.cs)]\n [!code-vb[Classic WebData DbDataAdapter.Update3#1](~/add/codesnippet/visualbasic/m-system.data.common.dbd_2_1.vb)]"
  syntax:
    content: public int Update (System.Data.DataSet dataSet, string srcTable);
    parameters:
    - id: dataSet
      type: System.Data.DataSet
      description: "<xref href=&quot;System.Data.DataSet&quot;> </xref>用來更新資料來源。"
    - id: srcTable
      type: System.String
      description: "要用於資料表對應的來源資料表的名稱。"
    return:
      type: System.Int32
      description: "已成功從更新的資料列數目<xref href=&quot;System.Data.DataSet&quot;> </xref>。"
  overload: System.Data.Common.DbDataAdapter.Update*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<xref href=&quot;System.Data.DataSet&quot;> </xref>無效。"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "無效的來源資料表。"
  - type: System.Data.DBConcurrencyException
    commentId: T:System.Data.DBConcurrencyException
    description: "嘗試執行的 INSERT、 UPDATE 或 DELETE 陳述式產生零個受影響的記錄。"
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.UpdateBatchSize
  id: UpdateBatchSize
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: UpdateBatchSize
  nameWithType: DbDataAdapter.UpdateBatchSize
  fullName: System.Data.Common.DbDataAdapter.UpdateBatchSize
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "取得或設定值，這個值會啟用或停用批次處理支援，並指定可以在批次中執行的命令數目。"
  remarks: "使用 UpdateBatchSize 屬性以變更從<xref:System.Data.DataSet>.</xref:System.Data.DataSet>更新資料來源 如果資料提供者支援批次處理，這可藉由減少伺服器的來回次數來增加應用程式的效能。 在 ADO.NET 2.0 中，這個屬性可支援.NET 資料提供者的 SQL Server (SqlClient) 和 Oracle (OracleClient)。       執行極大的批次可能會降低效能。 因此，您應該先測試理想的批次大小設定，再實作應用程式。       <xref:System.ArgumentOutOfRangeException>會擲回此值設為號碼小於零。</xref:System.ArgumentOutOfRangeException>"
  syntax:
    content: public virtual int UpdateBatchSize { get; set; }
    return:
      type: System.Int32
      description: "處理每個批次的資料列數目。       <table><thead><tr><th> 值是       </th><th> 效果       </th></tr></thead><tbody><tr><td> 0       </td><td> 批次大小沒有任何限制。       </td></tr><tr><td> 1       </td><td> 停用批次更新。       </td></tr><tr><td> &gt; 1       </td><td> 變更會傳送一次使用 UpdateBatchSize 作業的批次。       </td></tr></tbody></table>       當設定為 1 以外的值，與相關聯的所有命令<xref href=&quot;System.Data.Common.DbDataAdapter&quot;></xref>必須要有其<> *> 屬性設定為**無**或**輸出參數**。 否則會擲回例外狀況。"
  overload: System.Data.Common.DbDataAdapter.UpdateBatchSize*
  exceptions: []
  platform:
  - net462
- uid: System.Data.Common.DbDataAdapter.UpdateCommand
  id: UpdateCommand
  parent: System.Data.Common.DbDataAdapter
  langs:
  - csharp
  name: UpdateCommand
  nameWithType: DbDataAdapter.UpdateCommand
  fullName: System.Data.Common.DbDataAdapter.UpdateCommand
  type: Property
  assemblies:
  - System.Data
  namespace: System.Data.Common
  summary: "取得或設定用來更新資料來源中的之記錄的命令。"
  remarks: "期間<xref:System.Data.Common.DbDataAdapter.Update%2A>，如果沒有設定這個屬性，並且出現在主索引鍵資訊<xref:System.Data.DataSet>、<xref:System.Data.IDbDataAdapter.UpdateCommand%2A>就會自動產生。</xref:System.Data.IDbDataAdapter.UpdateCommand%2A> </xref:System.Data.DataSet> </xref:System.Data.Common.DbDataAdapter.Update%2A>"
  example:
  - "The following example creates the derived class <xref:System.Data.OleDb.OleDbDataAdapter> and sets some of its properties.  \n  \n [!code-cs[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/add/codesnippet/csharp/p-system.data.common.dbd_2_1.cs)]\n [!code-vb[Classic WebData DbDataAdapter.UpdateCommand Example#1](~/add/codesnippet/visualbasic/p-system.data.common.dbd_2_1.vb)]"
  syntax:
    content: public System.Data.Common.DbCommand UpdateCommand { get; set; }
    return:
      type: System.Data.Common.DbCommand
      description: "A <xref href=&quot;System.Data.IDbCommand&quot;> </xref>期間使用<xref:System.Data.IDataAdapter.Update*>資料集中修改的資料列的資料來源中更新記錄。</xref:System.Data.IDataAdapter.Update*>"
  overload: System.Data.Common.DbDataAdapter.UpdateCommand*
  exceptions: []
  platform:
  - net462
references:
- uid: System.Data.Common.DataAdapter
  isExternal: false
  name: System.Data.Common.DataAdapter
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.SystemException
  parent: System
  isExternal: false
  name: SystemException
  nameWithType: SystemException
  fullName: System.SystemException
- uid: System.InvalidCastException
  isExternal: true
  name: System.InvalidCastException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.Data.DBConcurrencyException
  parent: System.Data
  isExternal: false
  name: DBConcurrencyException
  nameWithType: DBConcurrencyException
  fullName: System.Data.DBConcurrencyException
- uid: System.Data.Common.DbDataAdapter.#ctor
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: DbDataAdapter()
  nameWithType: DbDataAdapter.DbDataAdapter()
  fullName: System.Data.Common.DbDataAdapter.DbDataAdapter()
- uid: System.Data.Common.DbDataAdapter.#ctor(System.Data.Common.DbDataAdapter)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: DbDataAdapter(DbDataAdapter)
  nameWithType: DbDataAdapter.DbDataAdapter(DbDataAdapter)
  fullName: System.Data.Common.DbDataAdapter.DbDataAdapter(DbDataAdapter)
- uid: System.Data.Common.DbDataAdapter
  parent: System.Data.Common
  isExternal: false
  name: DbDataAdapter
  nameWithType: DbDataAdapter
  fullName: System.Data.Common.DbDataAdapter
- uid: System.Data.Common.DbDataAdapter.AddToBatch(System.Data.IDbCommand)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: AddToBatch(IDbCommand)
  nameWithType: DbDataAdapter.AddToBatch(IDbCommand)
  fullName: System.Data.Common.DbDataAdapter.AddToBatch(IDbCommand)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Data.IDbCommand
  parent: System.Data
  isExternal: false
  name: IDbCommand
  nameWithType: IDbCommand
  fullName: System.Data.IDbCommand
- uid: System.Data.Common.DbDataAdapter.ClearBatch
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: ClearBatch()
  nameWithType: DbDataAdapter.ClearBatch()
  fullName: System.Data.Common.DbDataAdapter.ClearBatch()
- uid: System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: CreateRowUpdatedEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  nameWithType: DbDataAdapter.CreateRowUpdatedEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  fullName: System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
- uid: System.Data.Common.RowUpdatedEventArgs
  parent: System.Data.Common
  isExternal: false
  name: RowUpdatedEventArgs
  nameWithType: RowUpdatedEventArgs
  fullName: System.Data.Common.RowUpdatedEventArgs
- uid: System.Data.DataRow
  parent: System.Data
  isExternal: false
  name: DataRow
  nameWithType: DataRow
  fullName: System.Data.DataRow
- uid: System.Data.StatementType
  parent: System.Data
  isExternal: false
  name: StatementType
  nameWithType: StatementType
  fullName: System.Data.StatementType
- uid: System.Data.Common.DataTableMapping
  parent: System.Data.Common
  isExternal: false
  name: DataTableMapping
  nameWithType: DataTableMapping
  fullName: System.Data.Common.DataTableMapping
- uid: System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(System.Data.DataRow,System.Data.IDbCommand,System.Data.StatementType,System.Data.Common.DataTableMapping)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: CreateRowUpdatingEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  nameWithType: DbDataAdapter.CreateRowUpdatingEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
  fullName: System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent(DataRow,IDbCommand,StatementType,DataTableMapping)
- uid: System.Data.Common.RowUpdatingEventArgs
  parent: System.Data.Common
  isExternal: false
  name: RowUpdatingEventArgs
  nameWithType: RowUpdatingEventArgs
  fullName: System.Data.Common.RowUpdatingEventArgs
- uid: System.Data.Common.DbDataAdapter.DefaultSourceTableName
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: DefaultSourceTableName
  nameWithType: DbDataAdapter.DefaultSourceTableName
  fullName: System.Data.Common.DbDataAdapter.DefaultSourceTableName
- uid: System.String
  parent: System
  isExternal: true
  name: String
  nameWithType: String
  fullName: System.String
- uid: System.Data.Common.DbDataAdapter.DeleteCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: DeleteCommand
  nameWithType: DbDataAdapter.DeleteCommand
  fullName: System.Data.Common.DbDataAdapter.DeleteCommand
- uid: System.Data.Common.DbCommand
  parent: System.Data.Common
  isExternal: false
  name: DbCommand
  nameWithType: DbCommand
  fullName: System.Data.Common.DbCommand
- uid: System.Data.Common.DbDataAdapter.Dispose(System.Boolean)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Dispose(Boolean)
  nameWithType: DbDataAdapter.Dispose(Boolean)
  fullName: System.Data.Common.DbDataAdapter.Dispose(Boolean)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Data.Common.DbDataAdapter.ExecuteBatch
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: ExecuteBatch()
  nameWithType: DbDataAdapter.ExecuteBatch()
  fullName: System.Data.Common.DbDataAdapter.ExecuteBatch()
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(DataSet)
  nameWithType: DbDataAdapter.Fill(DataSet)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet)
- uid: System.Data.DataSet
  parent: System.Data
  isExternal: false
  name: DataSet
  nameWithType: DataSet
  fullName: System.Data.DataSet
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(DataTable)
  nameWithType: DbDataAdapter.Fill(DataTable)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataTable)
- uid: System.Data.DataTable
  parent: System.Data
  isExternal: false
  name: DataTable
  nameWithType: DataTable
  fullName: System.Data.DataTable
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.String)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(DataSet,String)
  nameWithType: DbDataAdapter.Fill(DataSet,String)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet,String)
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(DataTable,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.Fill(DataTable,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataTable,IDbCommand,CommandBehavior)
- uid: System.Data.CommandBehavior
  parent: System.Data
  isExternal: false
  name: CommandBehavior
  nameWithType: CommandBehavior
  fullName: System.Data.CommandBehavior
- uid: System.Data.Common.DbDataAdapter.Fill(System.Int32,System.Int32,System.Data.DataTable[])
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(Int32,Int32,DataTable[])
  nameWithType: DbDataAdapter.Fill(Int32,Int32,DataTable[])
  fullName: System.Data.Common.DbDataAdapter.Fill(Int32,Int32,DataTable[])
- uid: System.Data.DataTable[]
  parent: System.Data
  isExternal: false
  name: DataTable
  nameWithType: DataTable
  fullName: System.Data.DataTable[]
  spec.csharp:
  - uid: System.Data.DataTable
    name: DataTable
    nameWithType: DataTable
    fullName: DataTable[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(DataSet,Int32,Int32,String)
  nameWithType: DbDataAdapter.Fill(DataSet,Int32,Int32,String)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet,Int32,Int32,String)
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataTable[],System.Int32,System.Int32,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(DataTable[],Int32,Int32,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.Fill(DataTable[],Int32,Int32,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataTable[],Int32,Int32,IDbCommand,CommandBehavior)
- uid: System.Data.Common.DbDataAdapter.Fill(System.Data.DataSet,System.Int32,System.Int32,System.String,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill(DataSet,Int32,Int32,String,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.Fill(DataSet,Int32,Int32,String,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.Fill(DataSet,Int32,Int32,String,IDbCommand,CommandBehavior)
- uid: System.Data.Common.DbDataAdapter.FillCommandBehavior
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillCommandBehavior
  nameWithType: DbDataAdapter.FillCommandBehavior
  fullName: System.Data.Common.DbDataAdapter.FillCommandBehavior
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillSchema(DataSet,SchemaType)
  nameWithType: DbDataAdapter.FillSchema(DataSet,SchemaType)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataSet,SchemaType)
- uid: System.Data.SchemaType
  parent: System.Data
  isExternal: false
  name: SchemaType
  nameWithType: SchemaType
  fullName: System.Data.SchemaType
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillSchema(DataTable,SchemaType)
  nameWithType: DbDataAdapter.FillSchema(DataTable,SchemaType)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataTable,SchemaType)
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.String)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillSchema(DataSet,SchemaType,String)
  nameWithType: DbDataAdapter.FillSchema(DataSet,SchemaType,String)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataSet,SchemaType,String)
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataTable,System.Data.SchemaType,System.Data.IDbCommand,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillSchema(DataTable,SchemaType,IDbCommand,CommandBehavior)
  nameWithType: DbDataAdapter.FillSchema(DataTable,SchemaType,IDbCommand,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataTable,SchemaType,IDbCommand,CommandBehavior)
- uid: System.Data.Common.DbDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType,System.Data.IDbCommand,System.String,System.Data.CommandBehavior)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillSchema(DataSet,SchemaType,IDbCommand,String,CommandBehavior)
  nameWithType: DbDataAdapter.FillSchema(DataSet,SchemaType,IDbCommand,String,CommandBehavior)
  fullName: System.Data.Common.DbDataAdapter.FillSchema(DataSet,SchemaType,IDbCommand,String,CommandBehavior)
- uid: System.Data.Common.DbDataAdapter.GetBatchedParameter(System.Int32,System.Int32)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: GetBatchedParameter(Int32,Int32)
  nameWithType: DbDataAdapter.GetBatchedParameter(Int32,Int32)
  fullName: System.Data.Common.DbDataAdapter.GetBatchedParameter(Int32,Int32)
- uid: System.Data.IDataParameter
  parent: System.Data
  isExternal: false
  name: IDataParameter
  nameWithType: IDataParameter
  fullName: System.Data.IDataParameter
- uid: System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(System.Int32,System.Int32@,System.Exception@)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: GetBatchedRecordsAffected(Int32,Int32,Exception)
  nameWithType: DbDataAdapter.GetBatchedRecordsAffected(Int32,Int32,Exception)
  fullName: System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected(Int32,Int32,Exception)
- uid: System.Exception
  parent: System
  isExternal: true
  name: Exception
  nameWithType: Exception
  fullName: System.Exception
- uid: System.Data.Common.DbDataAdapter.GetFillParameters
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: GetFillParameters()
  nameWithType: DbDataAdapter.GetFillParameters()
  fullName: System.Data.Common.DbDataAdapter.GetFillParameters()
- uid: System.Data.IDataParameter[]
  parent: System.Data
  isExternal: false
  name: IDataParameter
  nameWithType: IDataParameter
  fullName: System.Data.IDataParameter[]
  spec.csharp:
  - uid: System.Data.IDataParameter
    name: IDataParameter
    nameWithType: IDataParameter
    fullName: IDataParameter[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.Common.DbDataAdapter.InitializeBatching
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: InitializeBatching()
  nameWithType: DbDataAdapter.InitializeBatching()
  fullName: System.Data.Common.DbDataAdapter.InitializeBatching()
- uid: System.Data.Common.DbDataAdapter.InsertCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: InsertCommand
  nameWithType: DbDataAdapter.InsertCommand
  fullName: System.Data.Common.DbDataAdapter.InsertCommand
- uid: System.Data.Common.DbDataAdapter.OnRowUpdated(System.Data.Common.RowUpdatedEventArgs)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: OnRowUpdated(RowUpdatedEventArgs)
  nameWithType: DbDataAdapter.OnRowUpdated(RowUpdatedEventArgs)
  fullName: System.Data.Common.DbDataAdapter.OnRowUpdated(RowUpdatedEventArgs)
- uid: System.Data.Common.DbDataAdapter.OnRowUpdating(System.Data.Common.RowUpdatingEventArgs)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: OnRowUpdating(RowUpdatingEventArgs)
  nameWithType: DbDataAdapter.OnRowUpdating(RowUpdatingEventArgs)
  fullName: System.Data.Common.DbDataAdapter.OnRowUpdating(RowUpdatingEventArgs)
- uid: System.Data.Common.DbDataAdapter.SelectCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: SelectCommand
  nameWithType: DbDataAdapter.SelectCommand
  fullName: System.Data.Common.DbDataAdapter.SelectCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.DeleteCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.DeleteCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.DeleteCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.InsertCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.InsertCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.InsertCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.SelectCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.SelectCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.SelectCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.UpdateCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.UpdateCommand
  fullName: System.Data.Common.DbDataAdapter.System.Data.IDbDataAdapter.UpdateCommand
- uid: System.Data.Common.DbDataAdapter.System#ICloneable#Clone
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.ICloneable.Clone()
  nameWithType: DbDataAdapter.System.ICloneable.Clone()
  fullName: System.Data.Common.DbDataAdapter.System.ICloneable.Clone()
- uid: System.Object
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object
- uid: System.Data.Common.DbDataAdapter.TerminateBatching
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: TerminateBatching()
  nameWithType: DbDataAdapter.TerminateBatching()
  fullName: System.Data.Common.DbDataAdapter.TerminateBatching()
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[])
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Update(DataRow[])
  nameWithType: DbDataAdapter.Update(DataRow[])
  fullName: System.Data.Common.DbDataAdapter.Update(DataRow[])
- uid: System.Data.DataRow[]
  parent: System.Data
  isExternal: false
  name: DataRow
  nameWithType: DataRow
  fullName: System.Data.DataRow[]
  spec.csharp:
  - uid: System.Data.DataRow
    name: DataRow
    nameWithType: DataRow
    fullName: DataRow[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataSet)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Update(DataSet)
  nameWithType: DbDataAdapter.Update(DataSet)
  fullName: System.Data.Common.DbDataAdapter.Update(DataSet)
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataTable)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Update(DataTable)
  nameWithType: DbDataAdapter.Update(DataTable)
  fullName: System.Data.Common.DbDataAdapter.Update(DataTable)
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataRow[],System.Data.Common.DataTableMapping)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Update(DataRow[],DataTableMapping)
  nameWithType: DbDataAdapter.Update(DataRow[],DataTableMapping)
  fullName: System.Data.Common.DbDataAdapter.Update(DataRow[],DataTableMapping)
- uid: System.Data.Common.DbDataAdapter.Update(System.Data.DataSet,System.String)
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Update(DataSet,String)
  nameWithType: DbDataAdapter.Update(DataSet,String)
  fullName: System.Data.Common.DbDataAdapter.Update(DataSet,String)
- uid: System.Data.Common.DbDataAdapter.UpdateBatchSize
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: UpdateBatchSize
  nameWithType: DbDataAdapter.UpdateBatchSize
  fullName: System.Data.Common.DbDataAdapter.UpdateBatchSize
- uid: System.Data.Common.DbDataAdapter.UpdateCommand
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: UpdateCommand
  nameWithType: DbDataAdapter.UpdateCommand
  fullName: System.Data.Common.DbDataAdapter.UpdateCommand
- uid: System.Data.Common.DbDataAdapter.#ctor*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: DbDataAdapter
  nameWithType: DbDataAdapter.DbDataAdapter
- uid: System.Data.Common.DbDataAdapter.AddToBatch*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: AddToBatch
  nameWithType: DbDataAdapter.AddToBatch
- uid: System.Data.Common.DbDataAdapter.ClearBatch*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: ClearBatch
  nameWithType: DbDataAdapter.ClearBatch
- uid: System.Data.Common.DbDataAdapter.CreateRowUpdatedEvent*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: CreateRowUpdatedEvent
  nameWithType: DbDataAdapter.CreateRowUpdatedEvent
- uid: System.Data.Common.DbDataAdapter.CreateRowUpdatingEvent*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: CreateRowUpdatingEvent
  nameWithType: DbDataAdapter.CreateRowUpdatingEvent
- uid: System.Data.Common.DbDataAdapter.DeleteCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: DeleteCommand
  nameWithType: DbDataAdapter.DeleteCommand
- uid: System.Data.Common.DbDataAdapter.Dispose*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Dispose
  nameWithType: DbDataAdapter.Dispose
- uid: System.Data.Common.DbDataAdapter.ExecuteBatch*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: ExecuteBatch
  nameWithType: DbDataAdapter.ExecuteBatch
- uid: System.Data.Common.DbDataAdapter.Fill*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Fill
  nameWithType: DbDataAdapter.Fill
- uid: System.Data.Common.DbDataAdapter.FillCommandBehavior*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillCommandBehavior
  nameWithType: DbDataAdapter.FillCommandBehavior
- uid: System.Data.Common.DbDataAdapter.FillSchema*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: FillSchema
  nameWithType: DbDataAdapter.FillSchema
- uid: System.Data.Common.DbDataAdapter.GetBatchedParameter*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: GetBatchedParameter
  nameWithType: DbDataAdapter.GetBatchedParameter
- uid: System.Data.Common.DbDataAdapter.GetBatchedRecordsAffected*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: GetBatchedRecordsAffected
  nameWithType: DbDataAdapter.GetBatchedRecordsAffected
- uid: System.Data.Common.DbDataAdapter.GetFillParameters*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: GetFillParameters
  nameWithType: DbDataAdapter.GetFillParameters
- uid: System.Data.Common.DbDataAdapter.InitializeBatching*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: InitializeBatching
  nameWithType: DbDataAdapter.InitializeBatching
- uid: System.Data.Common.DbDataAdapter.InsertCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: InsertCommand
  nameWithType: DbDataAdapter.InsertCommand
- uid: System.Data.Common.DbDataAdapter.OnRowUpdated*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: OnRowUpdated
  nameWithType: DbDataAdapter.OnRowUpdated
- uid: System.Data.Common.DbDataAdapter.OnRowUpdating*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: OnRowUpdating
  nameWithType: DbDataAdapter.OnRowUpdating
- uid: System.Data.Common.DbDataAdapter.SelectCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: SelectCommand
  nameWithType: DbDataAdapter.SelectCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#DeleteCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.DeleteCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.DeleteCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#InsertCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.InsertCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.InsertCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#SelectCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.SelectCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.SelectCommand
- uid: System.Data.Common.DbDataAdapter.System#Data#IDbDataAdapter#UpdateCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.Data.IDbDataAdapter.UpdateCommand
  nameWithType: DbDataAdapter.System.Data.IDbDataAdapter.UpdateCommand
- uid: System.Data.Common.DbDataAdapter.System#ICloneable#Clone*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: System.ICloneable.Clone
  nameWithType: DbDataAdapter.System.ICloneable.Clone
- uid: System.Data.Common.DbDataAdapter.TerminateBatching*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: TerminateBatching
  nameWithType: DbDataAdapter.TerminateBatching
- uid: System.Data.Common.DbDataAdapter.Update*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: Update
  nameWithType: DbDataAdapter.Update
- uid: System.Data.Common.DbDataAdapter.UpdateBatchSize*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: UpdateBatchSize
  nameWithType: DbDataAdapter.UpdateBatchSize
- uid: System.Data.Common.DbDataAdapter.UpdateCommand*
  parent: System.Data.Common.DbDataAdapter
  isExternal: false
  name: UpdateCommand
  nameWithType: DbDataAdapter.UpdateCommand
