### YamlMime:ManagedReference
items:
- uid: System.Collections.Queue
  id: Queue
  children:
  - System.Collections.Queue.#ctor
  - System.Collections.Queue.#ctor(System.Collections.ICollection)
  - System.Collections.Queue.#ctor(System.Int32)
  - System.Collections.Queue.#ctor(System.Int32,System.Single)
  - System.Collections.Queue.Clear
  - System.Collections.Queue.Clone
  - System.Collections.Queue.Contains(System.Object)
  - System.Collections.Queue.CopyTo(System.Array,System.Int32)
  - System.Collections.Queue.Count
  - System.Collections.Queue.Dequeue
  - System.Collections.Queue.Enqueue(System.Object)
  - System.Collections.Queue.GetEnumerator
  - System.Collections.Queue.IsSynchronized
  - System.Collections.Queue.Peek
  - System.Collections.Queue.Synchronized(System.Collections.Queue)
  - System.Collections.Queue.SyncRoot
  - System.Collections.Queue.ToArray
  - System.Collections.Queue.TrimToSize
  langs:
  - csharp
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
  type: Class
  summary: "表示第一個在先進先出集合的物件。"
  remarks: "這個類別會實作佇列以循環的陣列。 儲存在佇列中插入一個結尾並移除的物件不同的方式。       佇列和堆疊有用您需要進行暫存儲存位置的資訊。也就是說，您可能想要擷取其值後捨棄項目。 如果您需要存取相同的順序儲存在集合中的資訊，請使用佇列。 使用<xref:System.Collections.Stack>如果您需要以相反順序存取的資訊。</xref:System.Collections.Stack> 使用<xref:System.Collections.Concurrent.ConcurrentQueue%601>或<xref:System.Collections.Concurrent.ConcurrentStack%601>如果您需要從多個執行緒同時存取集合。</xref:System.Collections.Concurrent.ConcurrentStack%601> </xref:System.Collections.Concurrent.ConcurrentQueue%601>       三個主要的作業可對佇列和其項目:-<xref:System.Collections.Queue.Enqueue%2A>將元素加入佇列的末端。</xref:System.Collections.Queue.Enqueue%2A>      -<xref:System.Collections.Queue.Dequeue%2A>從佇列的開頭移除最舊的項目。</xref:System.Collections.Queue.Dequeue%2A>      -<xref:System.Collections.Queue.Peek%2A>傳回的最舊的項目是佇列的開頭，但不會從佇列移除。</xref:System.Collections.Queue.Peek%2A>       佇列的容量是佇列可以保存的項目數目。 當項目加入至佇列時，會自動增加容量視需要透過重新配置。  您可以藉由呼叫<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>減少容量       成長係數是需要更大的容量時，目前的容量乘的乘數目。  建構佇列時，決定成長係數。 預設成長因數為 2.0。 佇列的容量永遠會增加不論成長係數的四個至少有最小值。 比方說，1.0 的成長係數的佇列會永遠增加容量由四個需要更大的容量時。       佇列接受`null`有效的值，並允許重複的項目。       這個集合的泛型版本，請參閱<xref:System.Collections.Generic.Queue%601?displayProperty=fullName></xref:System.Collections.Generic.Queue%601?displayProperty=fullName>"
  example:
  - "The following example shows how to create and add values to a Queue and how to print out its values.  \n  \n [!code-cs[Classic Queue Example#1](~/add/codesnippet/csharp/t-system.collections.queue_1.cs)]\n [!code-cpp[Classic Queue Example#1](~/add/codesnippet/cpp/t-system.collections.queue_1.cpp)]\n [!code-vb[Classic Queue Example#1](~/add/codesnippet/visualbasic/t-system.collections.queue_1.vb)]"
  syntax:
    content: >-
      [System.Diagnostics.DebuggerDisplay("Count = {Count}")]

      [System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Queue/QueueDebugView))]

      [System.Runtime.InteropServices.ComVisible(true)]

      public class Queue : ICloneable, System.Collections.ICollection
  inheritance:
  - System.Object
  implements:
  - System.Collections.ICollection
  - System.ICloneable
  inheritedMembers: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor
  id: '#ctor'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新執行個體<xref href=&quot;System.Collections.Queue&quot;></xref>類別是空白的、 具有預設初始容量，並使用預設成長因數。"
  remarks: "容量<xref:System.Collections.Queue>是項目數目<xref:System.Collections.Queue>可以保存。</xref:System.Collections.Queue> </xref:System.Collections.Queue>  當項目加入至<xref:System.Collections.Queue>，就會自動增加容量視需要透過重新配置。</xref:System.Collections.Queue>  您可以藉由呼叫<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>減少容量       成長係數是需要更大的容量時，目前的容量乘的乘數目。  成長因數會決定當<xref:System.Collections.Queue>建構。</xref:System.Collections.Queue>       這個建構函式是 o （1） 運算。"
  syntax:
    content: public Queue ();
    parameters: []
  overload: System.Collections.Queue.#ctor*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  id: '#ctor(System.Collections.ICollection)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新執行個體<xref href=&quot;System.Collections.Queue&quot;></xref>類別，其中包含從指定之集合複製項目具有複製，項目數一樣的初始容量，並使用預設成長因數。"
  remarks: "容量<xref:System.Collections.Queue>是項目數目<xref:System.Collections.Queue>可以保存。</xref:System.Collections.Queue> </xref:System.Collections.Queue>  當項目加入至<xref:System.Collections.Queue>，就會自動增加容量視需要透過重新配置。</xref:System.Collections.Queue>  您可以藉由呼叫<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>減少容量       成長係數是需要更大的容量時，目前的容量乘的乘數目。  成長因數會決定當<xref:System.Collections.Queue>建構。</xref:System.Collections.Queue>       將元素複製到<xref:System.Collections.Queue>相同的順序讀取<xref:System.Collections.IEnumerator>的<xref:System.Collections.ICollection>。</xref:System.Collections.ICollection> </xref:System.Collections.IEnumerator> </xref:System.Collections.Queue>       這個建構函式為 O (`n`) 作業，其中`n`是中的項目數`col`。"
  syntax:
    content: public Queue (System.Collections.ICollection col);
    parameters:
    - id: col
      type: System.Collections.ICollection
      description: "<xref:System.Collections.ICollection>要複製的項目。</xref:System.Collections.ICollection>"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>col</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新執行個體<xref href=&quot;System.Collections.Queue&quot;></xref>類別是空白的、 具有指定的初始容量，並使用預設成長因數。"
  remarks: "容量<xref:System.Collections.Queue>是項目數目<xref:System.Collections.Queue>可以保存。</xref:System.Collections.Queue> </xref:System.Collections.Queue>  當項目加入至<xref:System.Collections.Queue>，就會自動增加容量視需要透過重新配置。</xref:System.Collections.Queue>  您可以藉由呼叫<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>減少容量       成長係數是需要更大的容量時，目前的容量乘的乘數目。  成長因數會決定當<xref:System.Collections.Queue>建構。</xref:System.Collections.Queue>       如果可以評估集合的大小，指定初始容量，就不需要執行數個項目加入至<xref:System.Collections.Queue>。</xref:System.Collections.Queue>時調整大小作業       這個建構函式為 O (`n`) 作業，其中`n`是`capacity`。"
  syntax:
    content: public Queue (int capacity);
    parameters:
    - id: capacity
      type: System.Int32
      description: "初始項目數， <xref href=&quot;System.Collections.Queue&quot;> </xref>可以包含。"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小於零。"
  platform:
  - net462
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  id: '#ctor(System.Int32,System.Single)'
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
  type: Constructor
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "初始化的新執行個體<xref href=&quot;System.Collections.Queue&quot;></xref>類別是空白的、 具有指定的初始容量，並使用指定的成長係數。"
  remarks: "容量<xref:System.Collections.Queue>是項目數目<xref:System.Collections.Queue>可以保存。</xref:System.Collections.Queue> </xref:System.Collections.Queue>  當項目加入至<xref:System.Collections.Queue>，就會自動增加容量視需要透過重新配置。</xref:System.Collections.Queue>  您可以藉由呼叫<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>減少容量       成長係數是需要更大的容量時，目前的容量乘的乘數目。  成長因數會決定當<xref:System.Collections.Queue>建構。</xref:System.Collections.Queue> 容量<xref:System.Collections.Queue>一定會增加的最小值，不論成長係數; 不會防止 1.0 成長因數<xref:System.Collections.Queue>從增加大小。</xref:System.Collections.Queue> </xref:System.Collections.Queue>       如果可以評估集合的大小，指定初始容量，就不需要執行數個項目加入至<xref:System.Collections.Queue>。</xref:System.Collections.Queue>時調整大小作業       這個建構函式為 O (`n`) 作業，其中`n`是`capacity`。"
  syntax:
    content: public Queue (int capacity, float growFactor);
    parameters:
    - id: capacity
      type: System.Int32
      description: "初始項目數， <xref href=&quot;System.Collections.Queue&quot;> </xref>可以包含。"
    - id: growFactor
      type: System.Single
      description: "所用的因數的容量<xref href=&quot;System.Collections.Queue&quot;></xref>會展開。"
  overload: System.Collections.Queue.#ctor*
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>capacity</code>小於零。       -或-<code>growFactor</code>小於 1.0 或大於 10.0。"
  platform:
  - net462
- uid: System.Collections.Queue.Clear
  id: Clear
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "移除所有的物件，從<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "<xref:System.Collections.Queue.Count%2A>已設為零，並從項目集合的其他物件的參考也會釋放。</xref:System.Collections.Queue.Count%2A>       容量會維持不變。 若要重設<xref:System.Collections.Queue>，請呼叫<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A></xref:System.Collections.Queue>容量 修剪空白<xref:System.Collections.Queue>設定的容量<xref:System.Collections.Queue>預設容量。</xref:System.Collections.Queue> </xref:System.Collections.Queue>       這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Queue.Count%2A>。</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to clear the values of the <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.Clear Example#1](~/add/codesnippet/cpp/m-system.collections.que_6_1.cpp)]\n [!code-cs[Classic Queue.Clear Example#1](~/add/codesnippet/csharp/m-system.collections.que_6_1.cs)]\n [!code-vb[Classic Queue.Clear Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_6_1.vb)]"
  syntax:
    content: public virtual void Clear ();
    parameters: []
  overload: System.Collections.Queue.Clear*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Clone
  id: Clone
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "建立的淺層複本<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "集合的淺層複本只會複製元素的集合，不論它們是參考類型或實值類型，但是不會複製參考所參考的物件。 新的集合中的參考都指向相同原始集合中的參考所指向的物件。       相反地，項目複製集合的深層複本，並直接或間接參考之項目，所有項目。       這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Queue.Count%2A>。</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual object Clone ();
    parameters: []
    return:
      type: System.Object
      description: "淺層複本<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  overload: System.Collections.Queue.Clone*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Contains(System.Object)
  id: Contains(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "判斷元素是否在<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "這個方法會判斷相等，藉由呼叫<xref:System.Object.Equals%2A?displayProperty=fullName>.</xref:System.Object.Equals%2A?displayProperty=fullName>       這個方法會執行線性搜尋;因此，這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Queue.Count%2A>。</xref:System.Collections.Queue.Count%2A>       從.NET Framework 2.0 開始，這個方法會使用集合的物件<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`obj`來判斷是否`item`存在。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A> 在舊版的.NET Framework 中，藉由進行這項判斷<xref:System.Object.Equals%2A>和<xref:System.IComparable.CompareTo%2A>方法`obj`上集合中物件的參數。</xref:System.IComparable.CompareTo%2A> </xref:System.Object.Equals%2A>"
  syntax:
    content: public virtual bool Contains (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "<xref:System.Object>中尋找<xref href=&quot;System.Collections.Queue&quot;> </xref>。</xref:System.Object> 這個值可以是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>if <code>obj</code> is found in the <xref href=&quot;System.Collections.Queue&quot;></xref>; otherwise, <xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;></xref>."
  overload: System.Collections.Queue.Contains*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "複製<xref href=&quot;System.Collections.Queue&quot;></xref>項目至現有一維<xref:System.Array>、 指定的陣列索引處開始。</xref:System.Array>"
  remarks: "項目複製至<xref:System.Array>列舉值逐一<xref:System.Collections.Queue>.</xref:System.Collections.Queue>所在的相同順序</xref:System.Array>       這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Queue.Count%2A>。</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_4_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_4_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_4_1.vb)]"
  syntax:
    content: public virtual void CopyTo (Array array, int index);
    parameters:
    - id: array
      type: System.Array
      description: "一維<xref:System.Array>也就是從複製之元素的目的地<xref href=&quot;System.Collections.Queue&quot;> </xref>。</xref:System.Array> <xref:System.Array>必須有以零為起始的索引。</xref:System.Array>"
    - id: index
      type: System.Int32
      description: "中以零為起始的索引`array`由此開始複製。"
  overload: System.Collections.Queue.CopyTo*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>array</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "<code>index</code>小於零。"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "<code>array</code>是多維的。       -在來源中的項目數<xref href=&quot;System.Collections.Queue&quot;></xref>大於可用空間<code>index</code>至目的地結尾<code>array</code>。"
  - type: System.ArrayTypeMismatchException
    commentId: T:System.ArrayTypeMismatchException
    description: "來源類型<xref href=&quot;System.Collections.Queue&quot;></xref>無法自動轉換成目的地類型<code> array </code>。"
  platform:
  - net462
- uid: System.Collections.Queue.Count
  id: Count
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得所包含的元素數目<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "容量<xref:System.Collections.Queue>是項目數目，<xref:System.Collections.Queue>可以儲存。</xref:System.Collections.Queue> </xref:System.Collections.Queue> 計數是實際<xref:System.Collections.Queue>.</xref:System.Collections.Queue>中的項目數目       容量<xref:System.Collections.Queue>永遠是大於或等於 Count。</xref:System.Collections.Queue> 如果計數超過容量加入項目時，容量會自動增加之前複製的舊項目並加入新項目後，重新配置內部的陣列。 新的容量取決於目前的容量乘以成長係數，也就是決定何時<xref:System.Collections.Queue>建構。</xref:System.Collections.Queue> 容量<xref:System.Collections.Queue>一定會增加的最小值，不論成長係數; 不會防止 1.0 成長因數<xref:System.Collections.Queue>從增加大小。</xref:System.Collections.Queue> </xref:System.Collections.Queue>       您可以藉由呼叫<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>減少容量       擷取這個屬性的值是一種 o （1） 運算。"
  syntax:
    content: public virtual int Count { get; }
    return:
      type: System.Int32
      description: "中包含的元素數目<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  overload: System.Collections.Queue.Count*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Dequeue
  id: Dequeue
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "移除並傳回物件的開頭<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "這個方法是類似的<xref:System.Collections.Queue.Peek%2A>方法，但<xref:System.Collections.Queue.Peek%2A>不是會修改<xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue.Peek%2A> </xref:System.Collections.Queue.Peek%2A>       `null`可以加入至<xref:System.Collections.Queue>做為值。</xref:System.Collections.Queue> Null 值和結束之間區別<xref:System.Collections.Queue>，檢查<xref:System.Collections.Queue.Count%2A>屬性或 catch <xref:System.InvalidOperationException>，這就會擲回時<xref:System.Collections.Queue>是空的。</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       這個方法是一種 o （1） 運算。"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_0_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_0_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_0_1.cpp)]"
  syntax:
    content: public virtual object Dequeue ();
    parameters: []
    return:
      type: System.Object
      description: "移除從開頭的物件<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  overload: System.Collections.Queue.Dequeue*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref>是空的。"
  platform:
  - net462
- uid: System.Collections.Queue.Enqueue(System.Object)
  id: Enqueue(System.Object)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "將物件加入至結尾<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "容量<xref:System.Collections.Queue>是項目數目<xref:System.Collections.Queue>可以保存。</xref:System.Collections.Queue> </xref:System.Collections.Queue>  當項目加入至<xref:System.Collections.Queue>，就會自動增加容量視需要透過重新配置。</xref:System.Collections.Queue>  您可以藉由呼叫<xref:System.Collections.Queue.TrimToSize%2A>.</xref:System.Collections.Queue.TrimToSize%2A>減少容量       成長係數是需要更大的容量時，目前的容量乘的乘數目。  成長因數會決定當<xref:System.Collections.Queue>建構。</xref:System.Collections.Queue> 容量<xref:System.Collections.Queue>一定會增加的最小值，不論成長係數; 不會防止 1.0 成長因數<xref:System.Collections.Queue>從增加大小。</xref:System.Collections.Queue> </xref:System.Collections.Queue>       如果<xref:System.Collections.Queue.Count%2A>小於比內部陣列的容量，這個方法是一種 o （1） 運算。</xref:System.Collections.Queue.Count%2A> 如果需要重新配置以容納新項目內部的陣列，這個方法會變成 O (`n`) 作業，其中`n`為<xref:System.Collections.Queue.Count%2A>。</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_5_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_5_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_5_1.cpp)]"
  syntax:
    content: public virtual void Enqueue (object obj);
    parameters:
    - id: obj
      type: System.Object
      description: "要加入至物件<xref href=&quot;System.Collections.Queue&quot;> </xref>。 這個值可以是<xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Queue.Enqueue*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Queue
  langs:
  - csharp
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "傳回逐一查看的列舉值<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "`foreach` C# 語言的陳述式 (`for each`在 Visual Basic 中) 會隱藏列舉值的複雜度。  因此，使用`foreach`建議，而不是直接管理 列舉值。       列舉程式可以用來讀取集合中的資料，但無法用於修改基礎集合。       一開始，列舉程式位在集合中的第一個項目之前。 <xref:System.Collections.IEnumerator.Reset%2A>也會列舉值帶回至這個位置。</xref:System.Collections.IEnumerator.Reset%2A>  此位置<xref:System.Collections.IEnumerator.Current%2A>是未定義。</xref:System.Collections.IEnumerator.Current%2A> 因此，您必須呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>前進的第一個元素之前讀取<xref:System.Collections.IEnumerator.Current%2A>.</xref:System.Collections.IEnumerator.Current%2A>值集合的列舉值</xref:System.Collections.IEnumerator.MoveNext%2A>       <xref:System.Collections.IEnumerator.Current%2A>會傳回相同的物件直到<xref:System.Collections.IEnumerator.MoveNext%2A>或<xref:System.Collections.IEnumerator.Reset%2A>稱為。</xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.MoveNext%2A></xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>設定<xref:System.Collections.IEnumerator.Current%2A>下一個項目。</xref:System.Collections.IEnumerator.Current%2A></xref:System.Collections.IEnumerator.MoveNext%2A>       如果<xref:System.Collections.IEnumerator.MoveNext%2A>超過集合的列舉值的結尾會位於集合中的最後一個元素之後和<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 列舉值位於這個位置上，後續呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>也會傳回`false`。</xref:System.Collections.IEnumerator.MoveNext%2A> 如果最後一個呼叫<xref:System.Collections.IEnumerator.MoveNext%2A>傳回`false`，<xref:System.Collections.IEnumerator.Current%2A>是未定義。</xref:System.Collections.IEnumerator.Current%2A> </xref:System.Collections.IEnumerator.MoveNext%2A> 若要設定<xref:System.Collections.IEnumerator.Current%2A>的第一個元素的集合，您可以呼叫<xref:System.Collections.IEnumerator.Reset%2A>後面加上<xref:System.Collections.IEnumerator.MoveNext%2A>.</xref:System.Collections.IEnumerator.MoveNext%2A> </xref:System.Collections.IEnumerator.Reset%2A> </xref:System.Collections.IEnumerator.Current%2A>       只要集合維持不變，列舉程式就持續有效。 如果對集合進行變更，例如加入、 修改或刪除元素，列舉程式會永久失效，且其行為未定義。       列舉程式沒有集合的獨佔存取因此，列舉集合在本質上並非安全執行緒程序。  若要保證列舉過程的執行緒安全，您可以鎖定在整個列舉過程的集合。  若要讓集合以便進行讀取和寫入的多重執行緒能夠存取，您必須實作自己的同步處理。       這個方法是一種 o （1） 運算。"
  syntax:
    content: public virtual System.Collections.IEnumerator GetEnumerator ();
    parameters: []
    return:
      type: System.Collections.IEnumerator
      description: "An <xref:System.Collections.IEnumerator> for the <xref href=&quot;System.Collections.Queue&quot;></xref>.</xref:System.Collections.IEnumerator>"
  overload: System.Collections.Queue.GetEnumerator*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.IsSynchronized
  id: IsSynchronized
  parent: System.Collections.Queue
  langs:
  - csharp
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得值，指出是否存取<xref href=&quot;System.Collections.Queue&quot;></xref>是同步 （安全執行緒）。"
  remarks: "若要保證的執行緒安全<xref:System.Collections.Queue>，所有作業都必須都透過包裝函式所傳回<xref:System.Collections.Queue.Synchronized%2A>方法。</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue>       透過集合進行列舉在本質上並不是安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。"
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_0_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_0_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_0_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized, and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/p-system.collections.que_0_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/p-system.collections.que_0_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/p-system.collections.que_0_2.vb)]"
  syntax:
    content: public virtual bool IsSynchronized { get; }
    return:
      type: System.Boolean
      description: "<xref uid=&quot;langword_csharp_true&quot; name=&quot;true&quot; href=&quot;&quot;></xref>如果存取<xref href=&quot;System.Collections.Queue&quot;></xref>是同步 （安全執行緒），否則<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。 預設值是<xref uid=&quot;langword_csharp_false&quot; name=&quot;false&quot; href=&quot;&quot;> </xref>。"
  overload: System.Collections.Queue.IsSynchronized*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.Peek
  id: Peek
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "傳回物件的開頭<xref href=&quot;System.Collections.Queue&quot;></xref>而不移除它。"
  remarks: "這個方法是類似的<xref:System.Collections.Queue.Dequeue%2A>方法，但查看不會修改<xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue.Dequeue%2A>       `null`可以加入至<xref:System.Collections.Queue>做為值。</xref:System.Collections.Queue> Null 值和結束之間區別<xref:System.Collections.Queue>，檢查<xref:System.Collections.Queue.Count%2A>屬性或 catch <xref:System.InvalidOperationException>，這就會擲回時<xref:System.Collections.Queue>是空的。</xref:System.Collections.Queue> </xref:System.InvalidOperationException> </xref:System.Collections.Queue.Count%2A> </xref:System.Collections.Queue>       這個方法是一種 o （1） 運算。"
  example:
  - "The following example shows how to add elements to the <xref:System.Collections.Queue>, remove elements from the <xref:System.Collections.Queue>, or view the element at the beginning of the <xref:System.Collections.Queue>.  \n  \n [!code-vb[Classic Queue.Enqueue Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_1_1.vb)]\n [!code-cs[Classic Queue.Enqueue Example#1](~/add/codesnippet/csharp/m-system.collections.que_1_1.cs)]\n [!code-cpp[Classic Queue.Enqueue Example#1](~/add/codesnippet/cpp/m-system.collections.que_1_1.cpp)]"
  syntax:
    content: public virtual object Peek ();
    parameters: []
    return:
      type: System.Object
      description: "物件的開頭<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  overload: System.Collections.Queue.Peek*
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref>是空的。"
  platform:
  - net462
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  id: Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  langs:
  - csharp
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "傳回新<xref href=&quot;System.Collections.Queue&quot;></xref>包裝原始的佇列，而且具備執行緒安全。"
  remarks: "這個方法所傳回的包裝函式會鎖定佇列之前，讓它安全執行緒的方式執行，執行作業。       若要保證的執行緒安全<xref:System.Collections.Queue>，所有作業必須都透過這個包裝函式只。</xref:System.Collections.Queue>       透過集合進行列舉在本質上並不是安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。"
  example:
  - "The following code example shows how to lock the collection using the <xref:System.Collections.Queue.SyncRoot%2A> during the entire enumeration. This method is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/m-system.collections.que_3_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/m-system.collections.que_3_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/m-system.collections.que_3_1.vb)]  \n  \n The following example shows how to synchronize a <xref:System.Collections.Queue>, determine if a <xref:System.Collections.Queue> is synchronized and use a synchronized <xref:System.Collections.Queue>.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/cpp/m-system.collections.que_3_2.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/csharp/m-system.collections.que_3_2.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_3_2.vb)]"
  syntax:
    content: public static System.Collections.Queue Synchronized (System.Collections.Queue queue);
    parameters:
    - id: queue
      type: System.Collections.Queue
      description: "<xref href=&quot;System.Collections.Queue&quot;> </xref>來同步處理。"
    return:
      type: System.Collections.Queue
      description: "A <xref href=&quot;System.Collections.Queue&quot;> </xref>包裝函式是同步 （安全執行緒）。"
  overload: System.Collections.Queue.Synchronized*
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "<code>queue</code>is <xref uid=&quot;langword_csharp_null&quot; name=&quot;null&quot; href=&quot;&quot;></xref>."
  platform:
  - net462
- uid: System.Collections.Queue.SyncRoot
  id: SyncRoot
  parent: System.Collections.Queue
  langs:
  - csharp
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
  type: Property
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "取得物件，可用來同步處理存取具備<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "若要建立的同步化的版本<xref:System.Collections.Queue>，使用<xref:System.Collections.Queue.Synchronized%2A>方法。</xref:System.Collections.Queue.Synchronized%2A> </xref:System.Collections.Queue> 不過，在衍生的類別可以提供自己的同步處理的版本<xref:System.Collections.Queue>使用 SyncRoot 屬性。</xref:System.Collections.Queue> 同步處理的程式碼必須在上執行作業的 SyncRoot <xref:System.Collections.Queue>，不是直接在<xref:System.Collections.Queue>.</xref:System.Collections.Queue> </xref:System.Collections.Queue> 這可確保衍生自其他物件的集合正常運作。 具體而言，保持正常的同步處理與其他可能同時修改的執行緒<xref:System.Collections.Queue>物件。</xref:System.Collections.Queue>       透過集合進行列舉在本質上並不是安全執行緒程序。 即使集合經過同步化，其他的執行緒仍可修改該集合，使列舉值擲回例外狀況。 若要保證列舉過程的執行緒安全，您可以在整個列舉過程中鎖定集合，或攔截由其他執行緒的變更所造成的例外狀況。"
  example:
  - "The following code example shows how to lock the collection using the SyncRoot during the entire enumeration. Retrieving the value of this property is an O(1) operation.  \n  \n [!code-cpp[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/cpp/p-system.collections.que_1_1.cpp)]\n [!code-cs[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/csharp/p-system.collections.que_1_1.cs)]\n [!code-vb[Classic Queue.IsSynchronized Example#2](~/add/codesnippet/visualbasic/p-system.collections.que_1_1.vb)]"
  syntax:
    content: public virtual object SyncRoot { get; }
    return:
      type: System.Object
      description: "物件，可用來同步處理存取具備<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  overload: System.Collections.Queue.SyncRoot*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.ToArray
  id: ToArray
  parent: System.Collections.Queue
  langs:
  - csharp
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "複製<xref href=&quot;System.Collections.Queue&quot;></xref>到新的陣列項目。"
  remarks: "<xref:System.Collections.Queue>則不會修改。</xref:System.Collections.Queue> 新陣列中項目的順序是從開頭項目的順序相同<xref:System.Collections.Queue>至它的結尾。</xref:System.Collections.Queue>       這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Queue.Count%2A>。</xref:System.Collections.Queue.Count%2A>"
  example:
  - "The following example shows how to copy a <xref:System.Collections.Queue> into a one-dimensional array.  \n  \n [!code-cpp[Classic Queue.CopyTo Example#1](~/add/codesnippet/cpp/m-system.collections.que_2_1.cpp)]\n [!code-cs[Classic Queue.CopyTo Example#1](~/add/codesnippet/csharp/m-system.collections.que_2_1.cs)]\n [!code-vb[Classic Queue.CopyTo Example#1](~/add/codesnippet/visualbasic/m-system.collections.que_2_1.vb)]"
  syntax:
    content: public virtual object[] ToArray ();
    parameters: []
    return:
      type: System.Object[]
      description: "新陣列，包含從複製項目<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  overload: System.Collections.Queue.ToArray*
  exceptions: []
  platform:
  - net462
- uid: System.Collections.Queue.TrimToSize
  id: TrimToSize
  parent: System.Collections.Queue
  langs:
  - csharp
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
  type: Method
  assemblies:
  - mscorlib
  namespace: System.Collections
  summary: "將容量設中的項目實際數目<xref href=&quot;System.Collections.Queue&quot;> </xref>。"
  remarks: "這個方法可用記憶體降到最低佇列的額外負荷如果沒有新的項目會加入至佇列。       若要重設<xref:System.Collections.Queue>設為初始狀態，請呼叫<xref:System.Collections.Queue.Clear%2A>方法，然後再呼叫 TrimToSize。</xref:System.Collections.Queue.Clear%2A> </xref:System.Collections.Queue> 修剪空白<xref:System.Collections.Queue>設定的容量<xref:System.Collections.Queue>預設容量。</xref:System.Collections.Queue> </xref:System.Collections.Queue>       這個方法是 O (`n`) 作業，其中`n`為<xref:System.Collections.Queue.Count%2A>。</xref:System.Collections.Queue.Count%2A>"
  syntax:
    content: public virtual void TrimToSize ();
    parameters: []
  overload: System.Collections.Queue.TrimToSize*
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "<xref href=&quot;System.Collections.Queue&quot;> </xref>處於唯讀狀態。"
  platform:
  - net462
references:
- uid: System.Object
  isExternal: false
  name: System.Object
- uid: System.ArgumentNullException
  isExternal: true
  name: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: true
  name: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  isExternal: true
  name: System.ArgumentException
- uid: System.ArrayTypeMismatchException
  isExternal: true
  name: System.ArrayTypeMismatchException
- uid: System.InvalidOperationException
  isExternal: true
  name: System.InvalidOperationException
- uid: System.NotSupportedException
  isExternal: true
  name: System.NotSupportedException
- uid: System.Collections.Queue.#ctor
  parent: System.Collections.Queue
  isExternal: false
  name: Queue()
  nameWithType: Queue.Queue()
  fullName: System.Collections.Queue.Queue()
- uid: System.Collections.Queue.#ctor(System.Collections.ICollection)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(ICollection)
  nameWithType: Queue.Queue(ICollection)
  fullName: System.Collections.Queue.Queue(ICollection)
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: true
  name: ICollection
  nameWithType: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.Queue.#ctor(System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32)
  nameWithType: Queue.Queue(Int32)
  fullName: System.Collections.Queue.Queue(Int32)
- uid: System.Int32
  parent: System
  isExternal: true
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
- uid: System.Collections.Queue.#ctor(System.Int32,System.Single)
  parent: System.Collections.Queue
  isExternal: false
  name: Queue(Int32,Single)
  nameWithType: Queue.Queue(Int32,Single)
  fullName: System.Collections.Queue.Queue(Int32,Single)
- uid: System.Single
  parent: System
  isExternal: true
  name: Single
  nameWithType: Single
  fullName: System.Single
- uid: System.Collections.Queue.Clear
  parent: System.Collections.Queue
  isExternal: false
  name: Clear()
  nameWithType: Queue.Clear()
  fullName: System.Collections.Queue.Clear()
- uid: System.Collections.Queue.Clone
  parent: System.Collections.Queue
  isExternal: false
  name: Clone()
  nameWithType: Queue.Clone()
  fullName: System.Collections.Queue.Clone()
- uid: System.Collections.Queue.Contains(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Contains(Object)
  nameWithType: Queue.Contains(Object)
  fullName: System.Collections.Queue.Contains(Object)
- uid: System.Boolean
  parent: System
  isExternal: true
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
- uid: System.Collections.Queue.CopyTo(System.Array,System.Int32)
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo(Array,Int32)
  nameWithType: Queue.CopyTo(Array,Int32)
  fullName: System.Collections.Queue.CopyTo(Array,Int32)
- uid: System.Array
  parent: System
  isExternal: true
  name: Array
  nameWithType: Array
  fullName: System.Array
- uid: System.Collections.Queue.Count
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
  fullName: System.Collections.Queue.Count
- uid: System.Collections.Queue.Dequeue
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue()
  nameWithType: Queue.Dequeue()
  fullName: System.Collections.Queue.Dequeue()
- uid: System.Collections.Queue.Enqueue(System.Object)
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue(Object)
  nameWithType: Queue.Enqueue(Object)
  fullName: System.Collections.Queue.Enqueue(Object)
- uid: System.Collections.Queue.GetEnumerator
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator()
  nameWithType: Queue.GetEnumerator()
  fullName: System.Collections.Queue.GetEnumerator()
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: true
  name: IEnumerator
  nameWithType: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Queue.IsSynchronized
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
  fullName: System.Collections.Queue.IsSynchronized
- uid: System.Collections.Queue.Peek
  parent: System.Collections.Queue
  isExternal: false
  name: Peek()
  nameWithType: Queue.Peek()
  fullName: System.Collections.Queue.Peek()
- uid: System.Collections.Queue.Synchronized(System.Collections.Queue)
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized(Queue)
  nameWithType: Queue.Synchronized(Queue)
  fullName: System.Collections.Queue.Synchronized(Queue)
- uid: System.Collections.Queue
  parent: System.Collections
  isExternal: false
  name: Queue
  nameWithType: Queue
  fullName: System.Collections.Queue
- uid: System.Collections.Queue.SyncRoot
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
  fullName: System.Collections.Queue.SyncRoot
- uid: System.Collections.Queue.ToArray
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray()
  nameWithType: Queue.ToArray()
  fullName: System.Collections.Queue.ToArray()
- uid: System.Object[]
  parent: System
  isExternal: true
  name: Object
  nameWithType: Object
  fullName: System.Object[]
  spec.csharp:
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: Object[]
  - name: '[]'
    nameWithType: '[]'
    fullName: '[]'
- uid: System.Collections.Queue.TrimToSize
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize()
  nameWithType: Queue.TrimToSize()
  fullName: System.Collections.Queue.TrimToSize()
- uid: System.Collections.Queue.#ctor*
  parent: System.Collections.Queue
  isExternal: false
  name: Queue
  nameWithType: Queue.Queue
- uid: System.Collections.Queue.Clear*
  parent: System.Collections.Queue
  isExternal: false
  name: Clear
  nameWithType: Queue.Clear
- uid: System.Collections.Queue.Clone*
  parent: System.Collections.Queue
  isExternal: false
  name: Clone
  nameWithType: Queue.Clone
- uid: System.Collections.Queue.Contains*
  parent: System.Collections.Queue
  isExternal: false
  name: Contains
  nameWithType: Queue.Contains
- uid: System.Collections.Queue.CopyTo*
  parent: System.Collections.Queue
  isExternal: false
  name: CopyTo
  nameWithType: Queue.CopyTo
- uid: System.Collections.Queue.Count*
  parent: System.Collections.Queue
  isExternal: false
  name: Count
  nameWithType: Queue.Count
- uid: System.Collections.Queue.Dequeue*
  parent: System.Collections.Queue
  isExternal: false
  name: Dequeue
  nameWithType: Queue.Dequeue
- uid: System.Collections.Queue.Enqueue*
  parent: System.Collections.Queue
  isExternal: false
  name: Enqueue
  nameWithType: Queue.Enqueue
- uid: System.Collections.Queue.GetEnumerator*
  parent: System.Collections.Queue
  isExternal: false
  name: GetEnumerator
  nameWithType: Queue.GetEnumerator
- uid: System.Collections.Queue.IsSynchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: IsSynchronized
  nameWithType: Queue.IsSynchronized
- uid: System.Collections.Queue.Peek*
  parent: System.Collections.Queue
  isExternal: false
  name: Peek
  nameWithType: Queue.Peek
- uid: System.Collections.Queue.Synchronized*
  parent: System.Collections.Queue
  isExternal: false
  name: Synchronized
  nameWithType: Queue.Synchronized
- uid: System.Collections.Queue.SyncRoot*
  parent: System.Collections.Queue
  isExternal: false
  name: SyncRoot
  nameWithType: Queue.SyncRoot
- uid: System.Collections.Queue.ToArray*
  parent: System.Collections.Queue
  isExternal: false
  name: ToArray
  nameWithType: Queue.ToArray
- uid: System.Collections.Queue.TrimToSize*
  parent: System.Collections.Queue
  isExternal: false
  name: TrimToSize
  nameWithType: Queue.TrimToSize
